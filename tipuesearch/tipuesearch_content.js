var tipuesearch = {"pages":[{"title":" uEMEP ","text":"uEMEP","tags":"home","loc":"index.html"},{"title":"open_log_file – uEMEP","text":"public  subroutine open_log_file(logfile_name, io_err) Opens a new log file for writing Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile_name integer, intent(inout), optional :: io_err Source Code subroutine open_log_file ( logfile_name , io_err ) !! Opens a new log file for writing character ( len =* ), intent ( in ) :: logfile_name integer , intent ( inout ), optional :: io_err ! Store unit and file name information in module log_name = trim ( logfile_name ) ! Open log file if ( present ( io_err )) then open ( newunit = log_unit , file = log_name , status = \"replace\" , iostat = io_err ) else open ( newunit = log_unit , file = log_name , status = \"replace\" ) end if file_opened = . true . end subroutine open_log_file","tags":"","loc":"proc/open_log_file.html"},{"title":"close_log_file – uEMEP","text":"public  subroutine close_log_file(io_err) Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: io_err Closes the log file Source Code subroutine close_log_file ( io_err ) integer , intent ( inout ), optional :: io_err !! Closes the log file if ( file_opened ) then if ( present ( io_err )) then close ( log_unit , iostat = io_err ) else close ( log_unit ) end if log_unit = - 1 end if end subroutine close_log_file","tags":"","loc":"proc/close_log_file.html"},{"title":"set_log_level – uEMEP","text":"public  subroutine set_log_level(level) Sets the log level The logger will write all message at or above this level Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Source Code subroutine set_log_level ( level ) !! Sets the log level !! !! The logger will write all message at or above this level integer , intent ( in ) :: level if ( level >= DEBUG . and . level <= ERROR ) then log_level = level else print * , \"ERROR! Invalid log level: \" , level stop 1 end if end subroutine set_log_level","tags":"","loc":"proc/set_log_level.html"},{"title":"log_header – uEMEP","text":"public  subroutine log_header(message, level, upper_space, lower_space) Send a log header message to the log file Log levels: DEBUG, INFO, WARNING and ERROR Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to log integer, intent(in) :: level Log level logical, intent(in), optional :: upper_space logical, intent(in), optional :: lower_space Source Code subroutine log_header ( message , level , upper_space , lower_space ) !! Send a log header message to the log file !! !! Log levels: DEBUG, INFO, WARNING and ERROR character ( len =* ), intent ( in ) :: message !! Message to log integer , intent ( in ) :: level !! Log level logical , intent ( in ), optional :: upper_space , lower_space ! Local variables logical :: u_space , l_space if ( present ( upper_space )) then u_space = upper_space else u_space = . true . end if if ( present ( lower_space )) then l_space = lower_space else l_space = . true . end if if ( u_space ) call log_message ( \"\" , level ) call log_message ( \"================================================================\" , level ) call log_message ( message , level ) call log_message ( \"================================================================\" , level ) if ( l_space ) call log_message ( \"\" , level ) end subroutine log_header","tags":"","loc":"proc/log_header.html"},{"title":"log_message – uEMEP","text":"public  subroutine log_message(message, level) Send a log message to the log file Log levels: DEBUG, INFO, WARNING and ERROR Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to log integer, intent(in) :: level Log level Source Code subroutine log_message ( message , level ) !! Send a log message to the log file !! !! Log levels: DEBUG, INFO, WARNING and ERROR character ( len =* ), intent ( in ) :: message !! Message to log integer , intent ( in ) :: level !! Log level ! Local variables character ( len = 18 ) :: timestamp character ( len = 8 ) :: datestr character ( len = 10 ) :: timestr ! Get current date and time call date_and_time ( date = datestr , time = timestr ) timestamp = '[' // datestr // ' ' // timestr ( 1 : 6 ) // '] ' if ( level >= log_level ) then select case ( level ) case ( DEBUG ) call write_log ( timestamp // '[DEBUG] ' // message ) case ( INFO ) call write_log ( timestamp // '[INFO]  ' // message ) case ( WARNING ) call write_log ( timestamp // '[WARN]  ' // message ) case ( ERROR ) call write_log ( timestamp // '[ERROR] ' // message ) case default print \"(a)\" , \"ERROR: Invalid log level: \" , level stop 1 end select end if end subroutine log_message","tags":"","loc":"proc/log_message.html"},{"title":"write_log – uEMEP","text":"private  subroutine write_log(message) Writes the message to the log file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to log Source Code subroutine write_log ( message ) !! Writes the message to the log file character ( len =* ), intent ( in ) :: message !! Message to log if (. not . file_opened ) then print \"(a)\" , \"ERROR: No file has been opened for writing\" stop 1 end if write ( log_unit , \"(a)\" ) trim ( adjustl ( message )) end subroutine write_log","tags":"","loc":"proc/write_log.html"},{"title":"uEMEP_subgrid_dispersion – uEMEP","text":"public  subroutine uEMEP_subgrid_dispersion(source_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer :: source_index Source Code subroutine uEMEP_subgrid_dispersion ( source_index ) use uEMEP_definitions implicit none integer i , j integer source_index integer jj , ii , tt real distance_subgrid integer i_start , i_end , j_start , j_end , t_start , t_end integer i_cross , j_cross integer i_cross_integral , j_cross_integral , i_cross_target_integral , j_cross_target_integral real cos_subgrid_loc , sin_subgrid_loc , FF_loc , FF_zc_loc integer subsource_index real ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , sig_y_00_loc , sig_z_00_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc real xpos_limit , ypos_limit real xpos_limit2 , ypos_limit2 real time_weight ( subgrid_dim ( t_dim_index ), n_pollutant_loop ), time_total ( subgrid_dim ( t_dim_index ), n_pollutant_loop ) real x_downwind , y_downwind real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real distance_subgrid_min real xpos_subgrid , ypos_subgrid real xpos_emission_subgrid , ypos_emission_subgrid real temp_subgrid_internal real distance_emission_subgrid_min real temp_sum_subgrid ( n_pollutant_loop ) real temp_sum_subgrid_from_in_region_new ( n_pollutant_loop ) integer count real , allocatable :: temp_emission_subgrid (:,:,:) real , allocatable :: temp_subgrid (:,:,:) !real, allocatable :: diagnostic_subgrid(:,:,:) real , allocatable :: temp_FF_subgrid (:,:) real , allocatable :: temp_FF_emission_subgrid (:,:) real , allocatable :: trajectory_subgrid (:,:,:,:) real , allocatable :: angle_diff (:,:) integer traj_max_index logical valid_traj real traj_step_size , x_loc , y_loc , FFgrid_loc , logz0_loc , u_star0_loc , FF10_loc , zc_loc , invL_loc real z0_temp , h_temp real , allocatable :: temp_target_subgrid (:,:,:) real , allocatable :: x_target_subgrid (:,:) real , allocatable :: y_target_subgrid (:,:) real , allocatable :: traveltime_temp_target_subgrid (:,:,:,:) integer temp_target_subgrid_dim_min ( 2 ), temp_target_subgrid_dim_max ( 2 ) integer temp_target_subgrid_dim_length ( 2 ) real temp_target_subgrid_delta ( 2 ) logical :: use_target_subgrid = . true . integer i_target_start , i_target_end , j_target_start , j_target_end logical temp_use_subgrid integer i_pollutant real temp_subgrid_internal_pollutant ( n_pollutant_loop ) integer i_cross_deposition , j_cross_deposition real temp_subgrid_rotated ( n_pollutant_loop ) real temp_subgrid_rotated_integrated ( n_pollutant_loop ) real precip_loc real deposition_subgrid_scale real plume_vertical_integral ( n_integral_subgrid_index , n_pollutant_loop ) !Fitting Kz calculation real x_loc_fit ( 2 ) real sig_z_loc_fit ( 2 ) real sig_y_loc_fit ( 2 ) real FF_zc_loc_fit ( 2 ) !Not used real az_loc_fit , bz_loc_fit real ay_loc_fit , by_loc_fit real sig_z_0_loc_fit , sig_y_0_loc_fit integer f_loop !functions !real gauss_plume_second_order_rotated_integral_func !real gauss_plume_cartesian_integral_func ! Arrays for the new way to calculate from-in-region, by matching emission region with region in each subgrid of the target grid real , allocatable :: subgrid_from_in_region_new (:,:,:) real , allocatable :: temp_target_subgrid_per_source_region (:,:,:,:) !x,y,pollutant,region integer i_region integer emission_region_index write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating dispersion of proxy (uEMEP_subgrid_dispersion)' write ( unit_logfile , '(A)' ) '================================================================' !First call the integral dispersion routine if it is needed. Only when using the concentration redistribution or the EMEP grid interpolation with proxy if ( local_subgrid_method_flag . eq . 1. or . EMEP_grid_interpolation_flag . eq . 4 ) then call uEMEP_subgrid_dispersion_integral ( source_index ) endif allocate ( temp_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) allocate ( temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_pollutant_loop )) !allocate (diagnostic_subgrid(subgrid_dim(x_dim_index),subgrid_dim(y_dim_index),n_pollutant_loop)) allocate ( temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( temp_FF_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) allocate ( angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if ( trace_emissions_from_in_region ) then allocate ( subgrid_from_in_region_new ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_pollutant_loop )) subgrid_from_in_region_new = 0. endif temp_subgrid = 0. temp_emission_subgrid = 0. temp_FF_subgrid = 0. temp_FF_emission_subgrid = 0. angle_diff = 0. !Set the x and y position limits to coincide to half the EMEP grid (refered here as lon and lat but can be also LCC projection) times the number of grids xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling xpos_limit2 = dgrid_nc ( lon_nc_index ) / 2. ypos_limit2 = dgrid_nc ( lat_nc_index ) / 2. !write(unit_logfile,'(A,2f12.2)') 'xpos_limit and ypos_limit: ',xpos_limit,ypos_limit !Minimum distance for travel time calculation set to  half of a grid diagonal weighted so the circle has the same area as the square with that diagonal distance_subgrid_min = sqrt ( subgrid_delta ( x_dim_index ) * subgrid_delta ( x_dim_index ) + subgrid_delta ( y_dim_index ) * subgrid_delta ( y_dim_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 !Minimum distance for dispersion set to  half of an emission grid diagonal weighted so the circle has the same area as the square with that diagonal distance_emission_subgrid_min = sqrt ( emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( x_dim_index , source_index ) & + emission_subgrid_delta ( y_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 do subsource_index = 1 , n_subsource ( source_index ) !Do not use target subgrid if the grid is auto selected !if (emission_subgrid_delta(x_dim_index,source_index).le.subgrid_delta(x_dim_index).or. & if ( use_emission_positions_for_auto_subgrid_flag ( source_index )) then !If auto positions using emissions for that source then do not use the interpolation target grid use_target_subgrid = . false . write ( unit_logfile , * ) 'Using auto subgrid for source ' , trim ( source_file_str ( source_index )) elseif ( emission_subgrid_delta ( x_dim_index , source_index ). le . subgrid_delta ( x_dim_index )) then !If the subgrid emissions are less than or equal to the dispersion grid then do not use the target interpolation grid !No matter what auto subgrid is used use_target_subgrid = . false . else !Use the target subgrid even when the other auto subgrids are on. Slows it down but is necessary to get the right interpolation !(use_population_positions_for_auto_subgrid_flag.or.use_receptor_positions_for_auto_subgrid_flag) use_target_subgrid = . true . endif if ( use_target_subgrid ) then write ( unit_logfile , * ) 'Using emission subgrid with interpolation for source ' , trim ( source_file_str ( source_index )) else write ( unit_logfile , * ) 'Using normal subgrid with no interpolation for source ' , trim ( source_file_str ( source_index )) endif call uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) !Set local dispersion parameters to be used only in the annual calculation, overwritten in the hourly files ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) sig_y_00_loc = sig_y_00 ( source_index , subsource_index ) sig_z_00_loc = sig_z_00 ( source_index , subsource_index ) h_emis_loc = h_emis ( source_index , subsource_index ) z_rec_loc = z_rec ( source_index , subsource_index ) write ( unit_logfile , '(a,i3)' ) 'Calculating proxy concentration data for ' // trim ( source_file_str ( source_index )) // ' with subsource index ' , subsource_index !Set up a target grid that matches the emissions grid and is just slightly bigger than it !Find the grid index it belongs to if ( use_target_subgrid ) then temp_target_subgrid_dim_min ( x_dim_index ) =- 1 + 1 + floor (( subgrid_min ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) temp_target_subgrid_dim_min ( y_dim_index ) =- 1 + 1 + floor (( subgrid_min ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) temp_target_subgrid_dim_max ( x_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) temp_target_subgrid_dim_max ( y_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) temp_target_subgrid_dim_length ( x_dim_index ) = temp_target_subgrid_dim_max ( x_dim_index ) - temp_target_subgrid_dim_min ( x_dim_index ) + 1 temp_target_subgrid_dim_length ( y_dim_index ) = temp_target_subgrid_dim_max ( y_dim_index ) - temp_target_subgrid_dim_min ( y_dim_index ) + 1 temp_target_subgrid_delta ( x_dim_index ) = emission_subgrid_delta ( x_dim_index , source_index ) temp_target_subgrid_delta ( y_dim_index ) = emission_subgrid_delta ( y_dim_index , source_index ) !Reallocate internal target arrays for each source if ( allocated ( temp_target_subgrid )) deallocate ( temp_target_subgrid ) if ( allocated ( x_target_subgrid )) deallocate ( x_target_subgrid ) if ( allocated ( y_target_subgrid )) deallocate ( y_target_subgrid ) if ( allocated ( traveltime_temp_target_subgrid )) deallocate ( traveltime_temp_target_subgrid ) if (. not . allocated ( temp_target_subgrid )) allocate ( temp_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) if (. not . allocated ( traveltime_temp_target_subgrid )) allocate ( traveltime_temp_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_pollutant_loop )) if (. not . allocated ( x_target_subgrid )) allocate ( x_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_target_subgrid )) allocate ( y_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) x_target_subgrid (:,:) = x_emission_subgrid (:,:, source_index ) y_target_subgrid (:,:) = y_emission_subgrid (:,:, source_index ) if ( trace_emissions_from_in_region ) then if ( allocated ( temp_target_subgrid_per_source_region )) deallocate ( temp_target_subgrid_per_source_region ) allocate ( temp_target_subgrid_per_source_region ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop , n_regions )) endif endif !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) !Loop through the time do tt = t_start , t_end subgrid (:,:, tt , proxy_subgrid_index , source_index ,:) = 0. if ( use_target_subgrid ) temp_target_subgrid = 0. if ( use_target_subgrid ) traveltime_temp_target_subgrid = 0. if ( trace_emissions_from_in_region ) then temp_target_subgrid_per_source_region = 0. endif !Set a temporary emission array temp_emission_subgrid = emission_subgrid (:,:, tt , source_index ,:) temp_subgrid = 0. temp_FF_subgrid = 0. !diagnostic_subgrid=0. if ( trace_emissions_from_in_region ) then subgrid_from_in_region_new = 0. endif if ( calculate_deposition_flag ) then subgrid (:,:, tt , drydepo_local_subgrid_index , source_index ,:) = 0. subgrid (:,:, tt , wetdepo_local_subgrid_index , source_index ,:) = 0. endif !Set the last meteo data subgrid in the case when the internal time loop is used if (. not . use_single_time_loop_flag ) then if ( tt . gt . t_start ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt - 1 ,:) else last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt ,:) endif endif !Precalculate information for the trajectory model !Maxium number of trajectory steps and size of steps based on the integral (meteorology) loop size if ( use_trajectory_flag ( source_index )) then traj_step_size = min ( integral_subgrid_delta ( x_dim_index ), integral_subgrid_delta ( y_dim_index )) * traj_step_scale traj_max_index = floor ( max ( integral_subgrid_loop_index ( x_dim_index ), integral_subgrid_loop_index ( y_dim_index )) / traj_step_scale ) if ( tt . eq . t_start ) write ( unit_logfile , '(a,f12.1,i)' ) 'Trajectory step (m) and dimensions: ' , traj_step_size , traj_max_index if (. not . allocated ( trajectory_subgrid )) allocate ( trajectory_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), traj_max_index , 2 )) trajectory_subgrid = NODATA_value !Loop through the emissions and create trajectories for all emissions source grids do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( sum ( temp_emission_subgrid ( i , j ,:)). ne . 0 ) then call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), tt , & traj_max_index , traj_step_size , trajectory_subgrid ( i , j ,:, x_dim_index ), trajectory_subgrid ( i , j ,:, y_dim_index )) endif enddo enddo endif !Create a temporary wind speed subgrid for each hour temp_FF_subgrid = 0. do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) z0_temp = exp ( meteo_subgrid ( i_cross , j_cross , tt , logz0_subgrid_index )) h_temp = h_emis ( source_index , subsource_index ) !if (source_index.eq.industry_index) then !    write(*,*) z0_temp,h_temp,1./meteo_subgrid(i_cross,j_cross,tt,inv_FFgrid_subgrid_index),H_meteo !    stop !endif if ( annual_calculations . and . wind_level_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( annual_calculations . and . wind_level_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( wind_level_flag . eq . 0 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag . eq . 5 ) then !Will set based on sigma z centre of mass temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag . eq . 6 ) then !Will set based on sigma z centre of mass and emission height temp_FF_subgrid ( i_cross , j_cross ) = 1. else write ( unit_logfile , '(a)' ) 'No valid wind_level_flag selected. Stopping (uEMEP_subgrid_dispersion)' stop endif !Setting a minimum value for wind for dispersion purposes (cannot be zero) temp_FF_subgrid ( i_cross , j_cross ) = sqrt ( temp_FF_subgrid ( i_cross , j_cross ) * temp_FF_subgrid ( i_cross , j_cross ) + FF_min_dispersion * FF_min_dispersion ) if ( temp_FF_subgrid ( i_cross , j_cross ). eq . 0 ) then write ( unit_logfile , '(a,2i)' ) 'Zero wind speed at integral grid (stopping): ' , i_cross , j_cross stop endif !Finds the angle difference between the current and last meteo field for dispersion and implements meandering if selected if ( hourly_calculations ) then call delta_wind_direction ( i_cross , j_cross , tt , meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ), angle_diff ( i_cross , j_cross )) else angle_diff ( i_cross , j_cross ) = 0. endif enddo enddo !If wind level flag is set to 5, use of initial plume centre of mass, then set wind speed for each non-zero emission grid if ( wind_level_flag . eq . 5 ) then temp_FF_emission_subgrid = 0. do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( sum ( temp_emission_subgrid ( ii , jj ,:)). ne . 0 ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) !Set the local variables logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) if ( annual_calculations ) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) endif !Set sig_0's at the emission position x_loc = 0. call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Use the initial plume centre of mass to determine wind advection height call z_centremass_gauss_func ( sig_z_0_loc , h_emis_loc , h_mix_loc , zc_loc ) call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) !Set a minimum wind speed based on traffic (if use_traffic_for_minFF_flag=T) !                FF_loc=sqrt(FF_loc*FF_loc+emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)*emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)) !Set the minimum wind speed FF_loc = sqrt ( FF_loc * FF_loc + FF_min_dispersion * FF_min_dispersion ) temp_FF_emission_subgrid ( ii , jj ) = FF_loc !write(*,*) FF10_loc,FF_loc,zc_loc,sig_z_0_loc endif enddo enddo endif !Loop through the target grid if ( use_target_subgrid ) then j_target_start = temp_target_subgrid_dim_min ( y_dim_index ); j_target_end = temp_target_subgrid_dim_max ( y_dim_index ) i_target_start = temp_target_subgrid_dim_min ( x_dim_index ); i_target_end = temp_target_subgrid_dim_max ( x_dim_index ) else j_target_start = 1 ; j_target_end = subgrid_dim ( y_dim_index ) i_target_start = 1 ; i_target_end = subgrid_dim ( x_dim_index ) endif !write(*,*) i_target_start,i_target_end,j_target_start,j_target_end do j = j_target_start , j_target_end do i = i_target_start , i_target_end !do j=1,subgrid_dim(y_dim_index) !do i=1,subgrid_dim(x_dim_index) !Only use those that are marked for use if ( use_target_subgrid ) then !Always use the grids because they cannot be tested temp_use_subgrid = . true . else temp_use_subgrid = use_subgrid ( i , j , source_index ) endif if ( temp_use_subgrid ) then !Set the position of the target grid in terms of the EMEP projection if ( use_target_subgrid ) then xpos_subgrid = xproj_emission_subgrid ( i , j , source_index ) ypos_subgrid = yproj_emission_subgrid ( i , j , source_index ) else xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) endif !Find the cross reference to the emission grid from the target grid if ( use_target_subgrid ) then i_cross = i j_cross = j else i_cross = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , source_index ) j_cross = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , source_index ) endif !Find the cross reference for the meteo grid at the target grid if ( use_target_subgrid ) then i_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , source_index ) j_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , source_index ) else i_cross_target_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross_target_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) endif !Set the travel time integral values to 0 time_weight ( tt ,:) = 0. time_total ( tt ,:) = 0. !Use the wind direction to move the target area downwind. To reduce the search loop if ( use_downwind_position_flag . and . hourly_calculations ) then !Set the emission grid loop region based on the downwind position x_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , cos_subgrid_index ) * sqrt ( 2. ))) y_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , sin_subgrid_index ) * sqrt ( 2. ))) i_end = min ( ceiling ( i_cross + 1 + ( 1. - x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), emission_subgrid_dim ( x_dim_index , source_index )) i_start = max ( floor ( i_cross - 1 - ( 1. + x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), 1 ) j_end = min ( ceiling ( j_cross + 1 + ( 1. - y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), emission_subgrid_dim ( y_dim_index , source_index )) j_start = max ( floor ( j_cross - 1 - ( 1. + y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), 1 ) !Set the EMEP projection limits to include the upwind source region xpos_area_max = xpos_subgrid + ( 1. - x_downwind ) * xpos_limit / 2. + emission_subgrid_dim ( x_dim_index , source_index ) xpos_area_min = xpos_subgrid - ( 1. + x_downwind ) * xpos_limit / 2. - emission_subgrid_dim ( x_dim_index , source_index ) ypos_area_max = ypos_subgrid + ( 1. - y_downwind ) * ypos_limit / 2. + emission_subgrid_dim ( y_dim_index , source_index ) ypos_area_min = ypos_subgrid - ( 1. + y_downwind ) * ypos_limit / 2. - emission_subgrid_dim ( y_dim_index , source_index ) else !Set the size of the loop region around the target cell to be up to subgrid_loop_index i_start = max ( 1 , i_cross - emission_subgrid_loop_index ( x_dim_index , source_index )) i_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), i_cross + emission_subgrid_loop_index ( x_dim_index , source_index )) j_start = max ( 1 , j_cross - emission_subgrid_loop_index ( y_dim_index , source_index )) j_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), j_cross + emission_subgrid_loop_index ( y_dim_index , source_index )) !Set the emission limits (EMEP projection ) surrounding the target grid xpos_area_max = xpos_subgrid + xpos_limit xpos_area_min = xpos_subgrid - xpos_limit ypos_area_max = ypos_subgrid + ypos_limit ypos_area_min = ypos_subgrid - ypos_limit endif !Limit the region. This will still allow a contribution from half an EMEP grid away if ( limit_emep_grid_interpolation_region_to_calculation_region ) then xpos_area_min = max ( xpos_area_min , subgrid_proj_min ( x_dim_index ) - xpos_limit2 ) xpos_area_max = min ( xpos_area_max , subgrid_proj_max ( x_dim_index ) + xpos_limit2 ) ypos_area_min = max ( ypos_area_min , subgrid_proj_min ( y_dim_index ) - ypos_limit2 ) ypos_area_max = min ( ypos_area_max , subgrid_proj_max ( y_dim_index ) + ypos_limit2 ) endif !Loop through emission sub_grids in the nearby region do jj = j_start , j_end do ii = i_start , i_end !Only non zero emissions to be calculated if ( sum ( temp_emission_subgrid ( ii , jj ,:)). ne . 0 ) then !Set the EMEP projection position of the emission grid xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , source_index ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , source_index ) !Select only emissions within the predefined region if ( xpos_emission_subgrid . ge . xpos_area_min . and . xpos_emission_subgrid . le . xpos_area_max & . and . ypos_emission_subgrid . ge . ypos_area_min . and . ypos_emission_subgrid . le . ypos_area_max ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) i_cross_integral = min ( max ( 1 , i_cross_integral ), integral_subgrid_dim ( x_dim_index )) j_cross_integral = min ( max ( 1 , j_cross_integral ), integral_subgrid_dim ( y_dim_index )) if ( hourly_calculations ) then if ( use_trajectory_flag ( source_index )) then !Calculate the minimum distance to the trajectory. Time consuming if ( use_target_subgrid ) then call uEMEP_minimum_distance_trajectory_fast ( x_target_subgrid ( i , j ), y_target_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_subgrid ( ii , jj ,:, x_dim_index ), trajectory_subgrid ( ii , jj ,:, y_dim_index ), x_loc , y_loc , valid_traj ) else call uEMEP_minimum_distance_trajectory_fast ( x_subgrid ( i , j ), y_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_subgrid ( ii , jj ,:, x_dim_index ), trajectory_subgrid ( ii , jj ,:, y_dim_index ), x_loc , y_loc , valid_traj ) endif else !Set the local wind cos and sin values cos_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , cos_subgrid_index ) sin_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , sin_subgrid_index ) !Determine the rotated position along wind values if ( use_target_subgrid ) then x_loc = ( x_target_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc + ( y_target_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc y_loc =- ( x_target_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc + ( y_target_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc else x_loc = ( x_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc + ( y_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc y_loc =- ( x_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc + ( y_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc endif !write(*,*) x_loc,x_subgrid(i,j)-x_emission_subgrid(ii,jj,source_index),y_subgrid(i,j)-y_emission_subgrid(ii,jj,source_index) !If x is downwind then it is valid if ( x_loc . ge . 0. ) then valid_traj = . true . else valid_traj = . false . endif endif !Calculate dispersion if ( valid_traj ) then !Set the mixing height at the average of the emission and target position h_mix_loc = ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) + meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , hmix_subgrid_index )) / 2. !Set the local wind speed and other parameters at emission position FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) !L_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,invL_subgrid_index) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) !u_star0_loc=max(meteo_subgrid(i_cross_integral,j_cross_integral,tt,ustar_subgrid_index),ustar_min) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) !Set ustar 0 to be consistent with FF10 and z0 call u_profile_neutral_val_func ( 1 0. , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) u_star0_loc = max ( u_star0_loc , ustar_min ) if ( wind_level_flag . eq . 5. or . wind_level_flag . eq . 6 ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) endif !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif !Make the wind level to be at emission height for emissions greater than 10 m, if meteoflag 1 or 3 is called h_temp = h_emis_loc if ( wind_level_flag . eq . 2. or .( h_temp . gt . H_meteo . and . wind_level_flag . eq . 1 )) then FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FFgrid_loc , H_meteo , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif if ( wind_level_flag . eq . 4. or .( h_temp . gt . 1 0. and . wind_level_flag . eq . 3 )) then FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 3 ) then !Need to make 10 m winds if they are not selected by the wind_level_flag.  and do not exist is not included any more if ( hourly_calculations . and .( wind_level_flag . eq . 1. or . wind_level_flag . eq . 2 )) then call u_profile_neutral_val_func ( 1 0. , meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ), H_meteo , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) endif !Set initial values for sigma. Initial sig_y is set here as well but is overridden by Kz dispersion call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !call uEMEP_set_dispersion_sigma_Kz_emulator(h_emis_loc,invL_loc,logz0_loc,h_mix_loc,sig_z_00_loc,sig_y_00_loc,emission_subgrid_delta(:,source_index),0.,x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) !write(*,*) 'H0: ',sig_z_loc call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !write(*,*) 'H1: ',sig_z_loc !Add the meandering and change in wind angle to the plume since not included in Kz calculation sig_y_loc = sig_y_loc + x_loc * angle_diff ( i_cross_integral , j_cross_integral ) !Use the average of the emision height and zc to determine wind speed. Is true if wind_level_flag=6 or if wind_level_zc_flag is true then it will do this for all other types of wind flags as well if ( wind_level_flag . eq . 6. or . wind_level_zc_flag ) then !FF_loc=FF_zc_loc !Set the minimum wind speed FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif if ( stability_scheme_flag . eq . 4 ) then call uEMEP_set_dispersion_sigma_Kz_emulator ( h_emis_loc , invL_loc , logz0_loc , h_mix_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif !Adjust the height of the wind to the average of the emission and plume centre of mass height. !This is already the case in the Kz calculation so not repeated here. if ( wind_level_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then !if (wind_level_flag.eq.6) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !Calculate the dispersion temp_subgrid_internal = gauss_plume_cartesian_sigma_func ( x_loc , y_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc ) !if (ii.eq.i_cross.and.jj.eq.j_cross) write(*,'(10es12.2)') x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,temp_subgrid_internal,temp_emission_subgrid(ii,jj,1) !if (tt.ge.18.and.tt.le.18.and.temp_subgrid_internal.gt.1.e-3) then !write(*,'(2i,12es12.2)') ii,jj,x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,temp_emission_subgrid(ii,jj,1),temp_subgrid_internal,sin_subgrid_loc,cos_subgrid_loc !endif !if (source_index.eq.traffic_index.and.x_loc.eq.0) write(*,'(16es12.2)') sigy_0_subgid_width_scale,x_loc,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_00_loc,sig_z_00_loc,sig_y_0_loc,sig_z_0_loc,sig_y_loc,sig_z_loc,h_emis_loc,FF_loc,meteo_subgrid(i_cross_integral,j_cross_integral,tt,FF10_subgrid_index) !For diagnostics only!! !diagnostic_subgrid(i,j,1)=diagnostic_subgrid(i,j,1)+temp_subgrid_internal !diagnostic_subgrid(i,j,2)=diagnostic_subgrid(i,j,2)+temp_emission_subgrid(ii,jj,1) do i_pollutant = 1 , n_pollutant_loop !Multiply by the emission factor temp_subgrid_internal_pollutant ( i_pollutant ) = temp_subgrid_internal * temp_emission_subgrid ( ii , jj , i_pollutant ) !Add to the receptor subgrid position if ( use_target_subgrid ) then temp_target_subgrid ( i , j , i_pollutant ) = temp_target_subgrid ( i , j , i_pollutant ) + temp_subgrid_internal_pollutant ( i_pollutant ) else temp_subgrid ( i , j , i_pollutant ) = temp_subgrid ( i , j , i_pollutant ) + temp_subgrid_internal_pollutant ( i_pollutant ) endif if ( trace_emissions_from_in_region ) then ! New version of in-region calculations: allowing target region to vary with the target grid ! **************** emission_region_index = emission_subgrid_region_index ( ii , jj , source_index ) if ( use_target_subgrid ) then ! one temp_target_subgrid may contain multiple regions in the finer resolution, so we must store results in a per-region array ! -> add this contribution to the region index that matches the current emission grid if ( emission_region_index > 0 ) then i_region = regionindex_loop_back_index ( emission_region_index ) if ( i_region > 0 ) then temp_target_subgrid_per_source_region ( i , j , i_pollutant , i_region ) = temp_target_subgrid_per_source_region ( i , j , i_pollutant , i_region ) + temp_subgrid_internal_pollutant ( i_pollutant ) end if end if else ! dispersion calculation is done directly on the fine-resolution target grid, so there is only one target region ! -> we can directly check if the target subgrid region ID matches the current emission grid region ID if ( emission_region_index > 0 . and . emission_region_index == subgrid_region_index ( i , j )) then subgrid_from_in_region_new ( i , j , i_pollutant ) = subgrid_from_in_region_new ( i , j , i_pollutant ) + temp_subgrid_internal_pollutant ( i_pollutant ) end if end if ! ************************ endif enddo !Determine the distance for the travel time calculation if ( use_straightline_traveltime_distance ) then distance_subgrid = x_loc else distance_subgrid = sqrt ( x_loc * x_loc + y_loc * y_loc ) endif else temp_subgrid_internal = 0. temp_subgrid_internal_pollutant = 0. endif !Calculate weighted time based on the selected temp_FF_subgrid wind level if ( temp_subgrid_internal . gt . 0 ) then distance_subgrid = max ( distance_subgrid , distance_subgrid_min ) !Alternative heavier weighting to higher concentrations (pollutant&#94;2). Not in deposition_dispersion routine if ( use_alternative_traveltime_weighting ) then time_weight ( tt ,:) = time_weight ( tt ,:) + distance_subgrid / FF_loc * temp_subgrid_internal_pollutant ** traveltime_power time_total ( tt ,:) = time_total ( tt ,:) + temp_subgrid_internal_pollutant ** traveltime_power else !Take weighted average (weighted by concentration) of the time time_weight ( tt ,:) = time_weight ( tt ,:) + distance_subgrid / FF_loc * temp_subgrid_internal_pollutant !Calculate sum of the concentration for normalisation time_total ( tt ,:) = time_total ( tt ,:) + temp_subgrid_internal_pollutant endif endif else !Annual calculations sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) u_star0_loc = max ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , ustar_subgrid_index ), ustar_min ) !FF10_loc=meteo_subgrid(i_cross_integral,j_cross_integral,tt,FF10_subgrid_index) FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) !Recalculate utar0 based on 10 m wind speed for consistency with current z0 and FF profile call u_profile_neutral_val_func ( 1 0. , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) u_star0_loc = max ( u_star0_loc , ustar_min ) !write(*,*) ii,jj,sig_y_00_loc,sig_z_00_loc !If not hourly concentration then use the annual dispersion function if ( use_target_subgrid ) then distance_subgrid = sqrt (( x_emission_subgrid ( ii , jj , source_index ) - x_target_subgrid ( i , j )) * ( x_emission_subgrid ( ii , jj , source_index ) - x_target_subgrid ( i , j )) & + ( y_emission_subgrid ( ii , jj , source_index ) - y_target_subgrid ( i , j )) * ( y_emission_subgrid ( ii , jj , source_index ) - y_target_subgrid ( i , j ))) else distance_subgrid = sqrt (( x_emission_subgrid ( ii , jj , source_index ) - x_subgrid ( i , j )) * ( x_emission_subgrid ( ii , jj , source_index ) - x_subgrid ( i , j )) & + ( y_emission_subgrid ( ii , jj , source_index ) - y_subgrid ( i , j )) * ( y_emission_subgrid ( ii , jj , source_index ) - y_subgrid ( i , j ))) endif !Set the simple as default at the receptor grid x_loc = distance_subgrid call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then !These are already set at the start as the default !call uEMEP_set_dispersion_params_simple(source_index,subsource_index) !call uEMEP_set_dispersion_sigma_simple(sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) !call uEMEP_set_dispersion_sigma_PG(invL_loc,logz0_loc,sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) endif if ( stability_scheme_flag . eq . 3 ) then !Fit the Kz curve at 100 and 2000 m to get an estimate of sigma that can be used in the calculations !Set sig z,y 00 and sig z,y 0 to 0 for the fitting x_loc_fit ( 1 ) = 10 0. x_loc_fit ( 2 ) = 200 0. do f_loop = 1 , 2 !Set initial values for sigma. Initial sig_y is set here as well but is overridden by Kz dispersion call uEMEP_set_dispersion_sigma_simple ( 0. , 0. , 0. , emission_subgrid_delta (:, source_index ) * 0. , angle_diff ( i_cross_integral , j_cross_integral ) * 0. , x_loc_fit ( f_loop ), sig_z_loc_fit ( f_loop ), sig_y_loc_fit ( f_loop ), sig_z_0_loc_fit , sig_y_0_loc_fit ) call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc_fit ( f_loop ), 0. , 0. , 0. , sig_z_loc_fit ( f_loop ), h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ) * 0. , u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc_fit ( f_loop ), sig_y_loc_fit ( f_loop ), FF_zc_loc_fit ( f_loop )) enddo !Fit bz_loc_fit = ( log ( sig_z_loc_fit ( 2 )) - log ( sig_z_loc_fit ( 1 ))) / ( log ( x_loc_fit ( 2 )) - log ( x_loc_fit ( 1 ))) az_loc_fit = exp ( log ( sig_z_loc_fit ( 1 )) - bz_loc_fit * log ( x_loc_fit ( 1 ))) by_loc_fit = ( log ( sig_y_loc_fit ( 2 )) - log ( sig_y_loc_fit ( 1 ))) / ( log ( x_loc_fit ( 2 )) - log ( x_loc_fit ( 1 ))) ay_loc_fit = exp ( log ( sig_y_loc_fit ( 1 )) - by_loc_fit * log ( x_loc_fit ( 1 ))) ay_loc = ay_loc_fit by_loc = by_loc_fit az_loc = az_loc_fit bz_loc = bz_loc_fit !Having made the fit need also to calculate sig_z,y if wind flag 6 is used if ( wind_level_flag . eq . 6 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !Use the average of the emision height and zc to determine wind speed. Is set to true if wind_level_flag=6 !FF_loc=FF_zc_loc !Set the minimum wind speed FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !If this flag set then use the centre of mass wind speed no matter which wind flag is called !This is actually overwritten to be the wind speed at the emission height in the next commands if ( wind_level_zc_flag ) then FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif h_temp = h_emis_loc if ( wind_level_flag . eq . 5. or . wind_level_zc_flag ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) else FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) endif !In the annual case then make the wind level to be at emission height for emissions greater than 10 m, if meteoflag 1 or 3 is called if ( wind_level_flag . eq . 2. or .( h_temp . gt . H_meteo . and . wind_level_flag . eq . 1 )) then !FF_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FFgrid_subgrid_index)*(1.-(log((H_meteo+z0_temp)/z0_temp)-log((h_temp+z0_temp)/z0_temp))/log((H_meteo+z0_temp)/z0_temp)) FFgrid_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FFgrid_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FFgrid_loc , H_meteo , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif if ( wind_level_flag . eq . 4. or .( h_temp . gt . 1 0. and . wind_level_flag . eq . 3 )) then !FF_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FF10_subgrid_index)*(1.-(log((10.+z0_temp)/z0_temp)-log((h_temp+z0_temp)/z0_temp))/log((10.+z0_temp)/z0_temp)) FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif !if (source_index.eq.industry_index) write(*,'(5es12.2)') meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FFgrid_subgrid_index),H_meteo,z0_temp,h_temp,FF_loc !if (source_index.eq.industry_index) write(*,'(6ES12.2)') sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc !if (source_index.eq.traffic_index.and.distance_subgrid.eq.0) write(*,'(16es12.2)') sigy_0_subgid_width_scale,distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_00_loc,sig_z_00_loc,sig_y_0_loc,sig_z_0_loc,sig_y_loc,sig_z_loc,h_emis_loc,FF_loc,1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FF10_subgrid_index) !Divide by wind speed at receptor position if ( calc_grid_vertical_average_concentration_annual_flag ) then temp_subgrid_rotated = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc , 0. , H_emep ) else temp_subgrid_rotated = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_func ( distance_subgrid , z_rec_loc , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc ) endif !If wind level flag is 6 in annual means then the average height is not calculated because a fit is used so valid for all stability types now !Needs to be calculated after sig_z_loc is calculated if ( wind_level_flag . eq . 6. or . wind_level_zc_flag ) then !if (wind_level_flag.eq.6.and.stability_scheme_flag.ne.3) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) !write(*,'(2i,7es12.2)') ii,jj,zc_loc,FF10_loc,10.,h_mix_loc,exp(logz0_loc),FF_zc_loc,u_star0_loc endif !write(*,'(a,5f12.3)') 'INFO:   ',h_mix_loc,invL_loc,exp(logz0_loc),FF_loc,u_star0_loc !write(*,'(a,8f12.3)') 'Z and h:',x_loc,az_loc,bz_loc,sig_z_loc_fit(1),sig_z_loc_fit(2),sig_z_loc,h_emis_loc,zc_loc !write(*,'(a,8f12.3)') 'Y and U:',x_loc,ay_loc,by_loc,sig_y_loc_fit(1),sig_y_loc_fit(2),sig_y_loc,FF10_loc,FF_loc !write(*,'(11f12.3)') distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_0_loc,sig_z_0_loc,h_emis_loc,h_mix_loc,FF_loc !Add the wind to the calculation temp_subgrid_rotated = temp_subgrid_rotated / FF_loc !Changed from 00 to 0 in the sigmas if ( use_target_subgrid ) then temp_target_subgrid ( i , j ,:) = temp_target_subgrid ( i , j ,:) + temp_subgrid_rotated else temp_subgrid ( i , j ,:) = temp_subgrid ( i , j ,:) + temp_subgrid_rotated endif if ( trace_emissions_from_in_region ) then ! New version of in-region calculations: allowing target region to vary with the target grid ! **************** emission_region_index = emission_subgrid_region_index ( ii , jj , source_index ) if ( use_target_subgrid ) then ! one temp_target_subgrid may contain multiple regions in the finer resolution, so we must store results in a per-region array ! -> add this contribution to the region ID that matches the current emission grid if ( emission_region_index > 0 ) then i_region = regionindex_loop_back_index ( emission_region_index ) if ( i_region > 0 ) then temp_target_subgrid_per_source_region ( i , j ,:, i_region ) = temp_target_subgrid_per_source_region ( i , j ,:, i_region ) + temp_subgrid_rotated end if end if else ! dispersion calculation is done directly on the fine-resolution target grid, so there is only one target region ! -> we can directly check if the target subgrid region ID matches the current emission grid region ID if ( emission_region_index > 0 . and . emission_region_index == subgrid_region_index ( i , j )) then subgrid_from_in_region_new ( i , j ,:) = subgrid_from_in_region_new ( i , j ,:) + temp_subgrid_rotated end if end if ! ************************ endif !write(*,'(4i5,2es12.2,4f12.3)') i,j,ii,jj,temp_subgrid(i,j,:), & !    gauss_plume_second_order_rotated_func(distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_00_loc,sig_z_00_loc,h_emis_loc)/FF_loc & !    ,distance_subgrid,az_loc,bz_loc,sig_z_00_loc !Calculate deposition only when it is not using the alternative tarrget subgrid. Fix later to be more general if ( calculate_deposition_flag . and .. not . use_target_subgrid ) then !Only use half of the source grid for deposition and depletion if ( distance_subgrid . eq . 0 ) then !s/m3 *m2=s/m deposition_subgrid_scale = 0.5 else deposition_subgrid_scale = 1.0 endif !Find the deposition grid index. Can be moved outside the loop i_cross_deposition = crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ) j_cross_deposition = crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index ,:) = subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index ,:) & + temp_subgrid_rotated * deposition_subgrid ( i_cross_deposition , j_cross_deposition , tt , vd_index ,:) * deposition_subgrid_scale !Wet deposition precip_loc = meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , precip_subgrid_index ) temp_subgrid_rotated_integrated = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc , 0. , h_mix_loc ) / FF_loc * h_mix_loc !write(*,*) temp_emission_subgrid(ii,jj,:),gauss_plume_second_order_rotated_reflected_integral_func(distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_0_loc,sig_z_0_loc,h_emis_loc,h_mix_loc,0,H_emep)/FF_loc !Set the scavenging (s/m2 /m *m/s = /m2). 1e-3/3600 converts mm/hr to m/s subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index ,:) = subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index ,:) & + temp_subgrid_rotated_integrated * wetdepo_scavanging_rate ( pollutant_loop_index (:)) * ( precip_loc / 100 0. / 360 0. ) * deposition_subgrid_scale !write(*,*) subgrid(i,j,tt,wetdepo_local_subgrid_index,source_index,:),temp_subgrid_rotated_integrated,wetdepo_scavanging_rate(nh3_index),precip_loc if ( adjust_wetdepo_integral_to_lowest_layer_flag ) then plume_vertical_integral ( 1 ,:) = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc , 0. , H_emep ) / FF_loc * H_emep plume_vertical_integral ( 2 ,:) = temp_subgrid_rotated_integrated plume_vertical_integral ( 3 ,:) = plume_vertical_integral ( 1 ,:) / H_emep endif integral_subgrid ( i_cross_target_integral , j_cross_target_integral , tt ,:, source_index ,:) = integral_subgrid ( i_cross_target_integral , j_cross_target_integral , tt ,:, source_index ,:) & + plume_vertical_integral (:,:) !write(*,*) integral_subgrid(i_cross_target_integral,j_cross_target_integral,tt,:,source_index,:) endif do i_pollutant = 1 , n_pollutant_loop if ( temp_subgrid_rotated ( i_pollutant ). gt . 0 ) then distance_subgrid = max ( distance_subgrid , distance_subgrid_min ) !Alternative heavier weighting to higher concentrations (pollutant&#94;2). Not in deposition_dispersion routine if ( use_alternative_traveltime_weighting ) then time_weight ( tt , i_pollutant ) = time_weight ( tt , i_pollutant ) + distance_subgrid / FF_loc * temp_subgrid_rotated ( i_pollutant ) ** traveltime_power time_total ( tt , i_pollutant ) = time_total ( tt , i_pollutant ) + temp_subgrid_rotated ( i_pollutant ) ** traveltime_power else !Take weighted average (weighted by concentration) of the time time_weight ( tt , i_pollutant ) = time_weight ( tt , i_pollutant ) + distance_subgrid / FF_loc * temp_subgrid_rotated ( i_pollutant ) !Calculate sum of the concentration for normalisation time_total ( tt , i_pollutant ) = time_total ( tt , i_pollutant ) + temp_subgrid_rotated ( i_pollutant ) endif endif enddo endif endif endif enddo enddo !Add to the travel time array if ( use_target_subgrid ) then traveltime_temp_target_subgrid ( i , j , 1 ,:) = traveltime_temp_target_subgrid ( i , j , 1 ,:) + time_weight ( tt ,:) traveltime_temp_target_subgrid ( i , j , 2 ,:) = traveltime_temp_target_subgrid ( i , j , 2 ,:) + time_total ( tt ,:) else traveltime_subgrid ( i , j , tt , 1 ,:) = traveltime_subgrid ( i , j , tt , 1 ,:) + time_weight ( tt ,:) traveltime_subgrid ( i , j , tt , 2 ,:) = traveltime_subgrid ( i , j , tt , 2 ,:) + time_total ( tt ,:) endif else !Set to nodata value for grids that should not be used for all pollutants temp_subgrid ( i , j ,:) = NODATA_value if ( trace_emissions_from_in_region ) subgrid_from_in_region_new ( i , j ,:) = NODATA_value endif if (. not . use_target_subgrid ) then !write(*,'(3i,3es12.2)') tt,i,j,temp_subgrid(i,j,pollutant_loop_index(nox_index)),diagnostic_subgrid(i,j,1),diagnostic_subgrid(i,j,2) else !write(*,'(3i,3es12.2)') tt,i,j,temp_target_subgrid(i,j,pollutant_loop_index(nox_index)),diagnostic_subgrid(i,j,1),diagnostic_subgrid(i,j,2) endif enddo !if (mod(j,10).eq.0) write(*,'(3a,i5,a,i5,a,i3,a,i3)') 'Gridding ',trim(source_file_str(source_index)),' proxy',j,' of ',subgrid_dim(2),' and ',subsource_index,' of ',n_subsource(source_index) enddo if ( mod ( j , 1 ). eq . 0 ) write ( * , '(3a,i5,a,i5,a,i3,a,i3)' ) 'Gridding ' , trim ( source_file_str ( source_index )), ' proxy for hour ' , tt , ' of ' , subgrid_dim ( t_dim_index ), ' and subsource ' , subsource_index , ' of ' , n_subsource ( source_index ) !Put the temporary subgrid back into the subgrid array only for the selected grids if ( use_target_subgrid ) then !write(*,*) 'Mean temp traveltime target grid',tt,sum(traveltime_temp_target_subgrid(i_target_start:i_target_end,j_target_start:j_target_end,1))/temp_target_subgrid_dim_length(x_dim_index)/temp_target_subgrid_dim_length(y_dim_index) !write(*,*) 'Mean temp target grid',tt,sum(temp_target_subgrid(i_target_start:i_target_end,j_target_start:j_target_end,n_target_comp))/temp_target_subgrid_dim_length(x_dim_index)/temp_target_subgrid_dim_length(y_dim_index) !write(*,*) shape(traveltime_temp_target_subgrid),shape(traveltime_subgrid) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then do i_pollutant = 1 , n_pollutant_loop temp_subgrid ( i , j , i_pollutant ) = area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , temp_target_subgrid (:,:, i_pollutant ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_temp_target_subgrid (:,:, 1 , i_pollutant ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_temp_target_subgrid (:,:, 2 , i_pollutant ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) !write(*,*) tt,i,j,temp_subgrid(i,j) ! New version of in-region, allowing target region to vary within the target grid ! **************** if ( trace_emissions_from_in_region . and . subgrid_region_index ( i , j ) > 0 ) then ! interpolate the contribution corresponding to the region index of this target grid i_region = regionindex_loop_back_index ( subgrid_region_index ( i , j )) subgrid_from_in_region_new ( i , j , i_pollutant ) = area_weighted_interpolation_function ( & x_target_subgrid , y_target_subgrid , temp_target_subgrid_per_source_region (:,:, i_pollutant , i_region ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ) & , emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) end if ! *************** enddo else temp_subgrid ( i , j ,:) = NODATA_value traveltime_subgrid ( i , j , tt ,:,:) = NODATA_value if ( trace_emissions_from_in_region ) then subgrid_from_in_region_new ( i , j ,:) = NODATA_value endif endif enddo enddo endif !Add to allsource integral_subgrid (:,:, tt ,:, allsource_index ,:) = integral_subgrid (:,:, tt ,:, allsource_index ,:) + integral_subgrid (:,:, tt ,:, source_index ,:) !write(*,*) integral_subgrid(:,:,tt,hmix_integral_subgrid_index,allsource_index,i_pollutant) !write(unit_logfile,'(a,3f12.3)') 'Mean, min and max grid concentration: ',sum(temp_subgrid)/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index),minval(temp_subgrid),maxval(temp_subgrid) do i_pollutant = 1 , n_pollutant_loop temp_sum_subgrid ( i_pollutant ) = 0. if ( trace_emissions_from_in_region ) temp_sum_subgrid_from_in_region_new = 0. count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) + temp_subgrid ( i , j , i_pollutant ) if ( trace_emissions_from_in_region ) then temp_sum_subgrid_from_in_region_new ( i_pollutant ) = temp_sum_subgrid_from_in_region_new ( i_pollutant ) + subgrid_from_in_region_new ( i , j , i_pollutant ) endif count = count + 1 endif enddo enddo if ( count . gt . 0 ) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) / count else temp_sum_subgrid ( i_pollutant ) = 0 endif if ( trace_emissions_from_in_region ) then if ( count . gt . 0 ) then temp_sum_subgrid_from_in_region_new ( i_pollutant ) = temp_sum_subgrid_from_in_region_new ( i_pollutant ) / count else temp_sum_subgrid_from_in_region_new ( i_pollutant ) = 0 endif write ( unit_logfile , '(a,2f12.3)' ) 'Mean concentration (total, inregion) ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , temp_sum_subgrid ( i_pollutant ), temp_sum_subgrid_from_in_region_new ( i_pollutant ) else write ( unit_logfile , '(a,3f12.3)' ) 'Mean concentration ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , temp_sum_subgrid ( i_pollutant ) endif enddo subgrid (:,:, tt , proxy_subgrid_index , source_index ,:) = temp_subgrid if ( trace_emissions_from_in_region ) then subgrid_proxy_from_in_region (:,:, tt , source_index ,:) = subgrid_from_in_region_new endif !Determine the final travel time traveltime_subgrid (:,:, tt , 3 ,:) = traveltime_subgrid (:,:, tt , 1 ,:) / traveltime_subgrid (:,:, tt , 2 ,:) where ( traveltime_subgrid (:,:, tt , 2 ,:). eq . 0 ) traveltime_subgrid (:,:, tt , 3 ,:) = 360 0. * 1 2. enddo !time loop enddo !subsource_index !Combine the subsources in the dispersion if required !if (combine_emission_subsources_during_dispersion(source_index).and.n_subsource(source_index).gt.1) then !    do subsource_index=2,n_subsource(n_source_index) !        subgrid(:,:,:,proxy_subgrid_index,source_index,1)=subgrid(:,:,:,proxy_subgrid_index,source_index,1)+subgrid(:,:,:,proxy_subgrid_index,source_index,subsource_index) !    enddo !    n_subsource(source_index)=1 !endif if ( allocated ( trajectory_subgrid )) deallocate ( trajectory_subgrid ) if ( allocated ( temp_emission_subgrid )) deallocate ( temp_emission_subgrid ) if ( allocated ( temp_subgrid )) deallocate ( temp_subgrid ) if ( allocated ( temp_FF_subgrid )) deallocate ( temp_FF_subgrid ) if ( allocated ( temp_FF_emission_subgrid )) deallocate ( temp_FF_emission_subgrid ) if ( allocated ( temp_subgrid )) deallocate ( temp_subgrid ) if ( allocated ( traveltime_temp_target_subgrid )) deallocate ( traveltime_temp_target_subgrid ) if ( allocated ( temp_target_subgrid )) deallocate ( temp_target_subgrid ) if ( allocated ( subgrid_from_in_region_new )) deallocate ( subgrid_from_in_region_new ) if ( allocated ( temp_target_subgrid_per_source_region )) deallocate ( temp_target_subgrid_per_source_region ) end subroutine uEMEP_subgrid_dispersion","tags":"","loc":"proc/uemep_subgrid_dispersion.html"},{"title":"uEMEP_subgrid_dispersion_integral – uEMEP","text":"private  subroutine uEMEP_subgrid_dispersion_integral(source_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer :: source_index Source Code subroutine uEMEP_subgrid_dispersion_integral ( source_index ) use uEMEP_definitions implicit none integer i , j integer source_index integer jj , ii , tt real distance_subgrid integer i_start , i_end , j_start , j_end , t_start , t_end integer i_cross , j_cross integer i_cross_integral , j_cross_integral , i_cross_target_integral , j_cross_target_integral real cos_subgrid_loc , sin_subgrid_loc , FF_loc , FF_zc_loc , zc_loc integer subsource_index real ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , sig_y_00_loc , sig_z_00_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc real xpos_limit , ypos_limit real x_downwind , y_downwind real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_emission_subgrid , ypos_emission_subgrid real xpos_integral_subgrid , ypos_integral_subgrid real distance_emission_subgrid_min integer traj_max_index logical valid_traj real traj_step_size , x_loc , y_loc , invL_loc , FFgrid_loc , logz0_loc , u_star0_loc , FF10_loc real z0_temp , h_temp !real, allocatable :: temp_emission_subgrid(:,:) !real, allocatable :: temp_subgrid(:,:) real , allocatable :: temp_FF_subgrid (:,:) real , allocatable :: temp_FF_emission_subgrid (:,:) real , allocatable :: trajectory_subgrid (:,:,:,:) real , allocatable :: angle_diff (:,:) !functions !real gauss_plume_second_order_rotated_func !real gauss_plume_cartesian_func allocate ( temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( temp_FF_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) temp_FF_subgrid = 0. temp_FF_emission_subgrid = 0. angle_diff = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Minimum distance for dispersion set to  half of an emission grid diagonal weighted so the circle has the same area as the square with that diagonal distance_emission_subgrid_min = sqrt ( emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( x_dim_index , source_index ) & + emission_subgrid_delta ( y_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 do subsource_index = 1 , n_subsource ( source_index ) call uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) !Set local dispersion parameters prior to time loop for use in annual data ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) sig_y_00_loc = sig_y_00 ( source_index , subsource_index ) sig_z_00_loc = sig_z_00 ( source_index , subsource_index ) h_emis_loc = h_emis ( source_index , subsource_index ) z_rec_loc = z_rec ( source_index , subsource_index ) !write(*,*) z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_0_loc,sig_z_0_loc write ( unit_logfile , '(a,i3)' ) 'Calculating proxy integral concentration data for ' // trim ( source_file_str ( source_index )) // ' with subsource index ' , subsource_index !Set the start and end times of the loop t_start = 1 t_end = integral_subgrid_dim ( t_dim_index ) !Loop through the time do tt = t_start , t_end integral_subgrid (:,:, tt ,:, source_index ,:) = 0. temp_FF_subgrid = 0. !Set the last meteo data subgrid in the case when the internal time loop is used if (. not . use_single_time_loop_flag ) then if ( tt . gt . t_start ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt - 1 ,:) else last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt ,:) endif endif !Precalculate information for the trajectory model !Maxium number of trajectory steps and size of steps based on the integral (meteorology) loop size if ( use_trajectory_flag ( source_index )) then traj_step_size = min ( integral_subgrid_delta ( x_dim_index ), integral_subgrid_delta ( y_dim_index )) * traj_step_scale traj_max_index = floor ( max ( integral_subgrid_loop_index ( x_dim_index ), integral_subgrid_loop_index ( y_dim_index )) / traj_step_scale ) !if (use_downwind_position_flag) traj_max_index=traj_max_index*2 if ( tt . eq . t_start ) write ( unit_logfile , '(a,f12.1,i)' ) 'Trajectory step (m) and dimensions: ' , traj_step_size , traj_max_index if (. not . allocated ( trajectory_subgrid )) allocate ( trajectory_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), traj_max_index , 2 )) trajectory_subgrid = NODATA_value !Loop through the emissions and create trajectories for all emissions source grids do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( emission_subgrid ( i , j , tt , source_index , subsource_index ). ne . 0 ) then call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), tt , & traj_max_index , traj_step_size , trajectory_subgrid ( i , j ,:, x_dim_index ), trajectory_subgrid ( i , j ,:, y_dim_index )) endif enddo enddo endif !Create a temporary wind speed subgrid for each hour temp_FF_subgrid = 0. do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) z0_temp = exp ( meteo_subgrid ( i_cross , j_cross , tt , logz0_subgrid_index )) h_temp = h_emis ( source_index , subsource_index ) if ( annual_calculations . and . wind_level_integral_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) elseif ( annual_calculations . and . wind_level_integral_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( annual_calculations . and . wind_level_integral_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) elseif ( annual_calculations . and . wind_level_integral_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( wind_level_integral_flag . eq . 0 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_integral_flag . eq . 5 ) then !Will set later based on sigma z centre of mass temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_integral_flag . eq . 6 ) then !Will set later based on average sigma z centre of mass and z_emis temp_FF_subgrid ( i_cross , j_cross ) = 1. else write ( unit_logfile , '(a)' ) 'No valid wind_level_integral_flag selected. Stopping (uEMEP_subgrid_dispersion)' stop endif !Setting a minimum value for wind for dispersion purposes (cannot be zero) temp_FF_subgrid ( i_cross , j_cross ) = sqrt ( temp_FF_subgrid ( i_cross , j_cross ) * temp_FF_subgrid ( i_cross , j_cross ) + FF_min_dispersion * FF_min_dispersion ) !Finds the angle difference between the current and last meteo field for dispersion and implements meandering if selected if ( hourly_calculations ) then call delta_wind_direction ( i_cross , j_cross , tt , meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ), angle_diff ( i_cross , j_cross )) else angle_diff ( i_cross , j_cross ) = 0. endif enddo enddo !If wind level flag is set to 5, use of initial plume centre of mass, then set wind speed for each non-zero emission grid if ( wind_level_integral_flag . eq . 5 ) then temp_FF_emission_subgrid = 0. do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( sum ( emission_subgrid ( ii , jj , tt , source_index ,:)). ne . 0 ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) !Set the local variables logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) if ( annual_calculations ) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) endif !Set sig_0's at the emission position x_loc = 0. call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Use the initial plume centre of mass to determine wind advection height call z_centremass_gauss_func ( sig_z_0_loc , h_emis_loc , h_mix_loc , zc_loc ) call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) !Set a minimum wind speed based on traffic (if use_traffic_for_minFF_flag=T) !                FF_loc=sqrt(FF_loc*FF_loc+emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)*emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)) !Set the minimum wind speed FF_loc = sqrt ( FF_loc * FF_loc + FF_min_dispersion * FF_min_dispersion ) temp_FF_emission_subgrid ( ii , jj ) = FF_loc !write(*,*) FF10_loc,FF_loc,zc_loc,sig_z_0_loc endif enddo enddo endif !Loop through the proxy integral grid do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) xpos_integral_subgrid = xproj_integral_subgrid ( i , j ) ypos_integral_subgrid = yproj_integral_subgrid ( i , j ) !Find the cross reference to the integral grid from the emission grid i_cross = crossreference_integral_to_emission_subgrid ( i , j , x_dim_index , source_index ) j_cross = crossreference_integral_to_emission_subgrid ( i , j , y_dim_index , source_index ) i_cross_target_integral = i j_cross_target_integral = j if ( use_downwind_position_flag . and . hourly_calculations ) then x_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , cos_subgrid_index ) * sqrt ( 2. ))) y_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , sin_subgrid_index ) * sqrt ( 2. ))) i_end = min ( ceiling ( i_cross + 1 + ( 1. - x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), emission_subgrid_dim ( x_dim_index , source_index )) i_start = max ( floor ( i_cross - 1 - ( 1. + x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), 1 ) j_end = min ( ceiling ( j_cross + 1 + ( 1. - y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), emission_subgrid_dim ( y_dim_index , source_index )) j_start = max ( floor ( j_cross - 1 - ( 1. + y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), 1 ) !Set new lon and lat limits to include the upwind source region xpos_area_max = xpos_integral_subgrid + ( 1. - x_downwind ) * xpos_limit / 2. + emission_subgrid_dim ( x_dim_index , source_index ) xpos_area_min = xpos_integral_subgrid - ( 1. + x_downwind ) * xpos_limit / 2. - emission_subgrid_dim ( x_dim_index , source_index ) ypos_area_max = ypos_integral_subgrid + ( 1. - y_downwind ) * ypos_limit / 2. + emission_subgrid_dim ( y_dim_index , source_index ) ypos_area_min = ypos_integral_subgrid - ( 1. + y_downwind ) * ypos_limit / 2. - emission_subgrid_dim ( y_dim_index , source_index ) else !Set the size of the loop region around the target cell to be up to integral_subgrid_loop_index i_start = max ( 1 , i_cross - emission_subgrid_loop_index ( x_dim_index , source_index )) i_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), i_cross + emission_subgrid_loop_index ( x_dim_index , source_index )) j_start = max ( 1 , j_cross - emission_subgrid_loop_index ( y_dim_index , source_index )) j_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), j_cross + emission_subgrid_loop_index ( y_dim_index , source_index )) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit endif !Loop through emission sub_grids in the nearby region do jj = j_start , j_end do ii = i_start , i_end if ( sum ( emission_subgrid ( ii , jj , tt , source_index ,:)). ne . 0 ) then ! xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , source_index ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , source_index ) if ( xpos_emission_subgrid . ge . xpos_area_min . and . xpos_emission_subgrid . le . xpos_area_max & . and . ypos_emission_subgrid . ge . ypos_area_min . and . ypos_emission_subgrid . le . ypos_area_max ) then !Determine meteorology grid position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) if ( hourly_calculations ) then if ( use_trajectory_flag ( source_index )) then !Calculate the minimum distance to the trajectory. Time consuming call uEMEP_minimum_distance_trajectory_fast ( x_integral_subgrid ( i , j ), y_integral_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_subgrid ( ii , jj ,:, x_dim_index ), trajectory_subgrid ( ii , jj ,:, y_dim_index ), x_loc , y_loc , valid_traj ) else !Set the local wind cos and sin values cos_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , cos_subgrid_index ) sin_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , sin_subgrid_index ) !Determine the rotated along wind values x_loc = ( x_integral_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc + ( y_integral_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc y_loc =- ( x_integral_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc + ( y_integral_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc !If x is downwind then it is valid if ( x_loc . ge . 0 ) then valid_traj = . true . else valid_traj = . false . endif endif !Calculate dispersion if ( valid_traj ) then !Set the mixing height at the average of the emission and target position h_mix_loc = ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) + meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , hmix_subgrid_index )) / 2. !Set the local wind speed and other parameters at emission position FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) !L_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,invL_subgrid_index) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) !u_star0_loc=max(meteo_subgrid(i_cross_integral,j_cross_integral,tt,ustar_subgrid_index),ustar_min) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) !Set ustar 0 to be consistent with FF10 and z0 call u_profile_neutral_val_func ( 1 0. , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) u_star0_loc = max ( u_star0_loc , ustar_min ) if ( wind_level_integral_flag . eq . 5 ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) endif !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 3 ) then !Set initial values for sigma. Sig_y is set here call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !write(*,*) 'IN:  ',x_loc,sig_z_loc,FF_loc call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_0_loc , sig_y_0_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !write(*,*) 'OUT: ',x_loc,sig_z_loc,FF_loc sig_y_loc = sig_y_loc + x_loc * abs ( angle_diff ( i_cross_integral , j_cross_integral )) !Use the average of the emisiion height and zc to determine wind speed. Is set to true if wind_level_flag=6 if ( wind_level_integral_flag . eq . 6 ) then FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif if ( stability_scheme_flag . eq . 4 ) then call uEMEP_set_dispersion_sigma_Kz_emulator ( h_emis_loc , invL_loc , logz0_loc , h_mix_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( wind_level_integral_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !Calculate the dispersion integral_subgrid ( i , j , tt , hsurf_average_subgrid_index , source_index ,:) = integral_subgrid ( i , j , tt , hsurf_average_subgrid_index , source_index ,:) & + gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc , 0. , H_emep ) & * emission_subgrid ( ii , jj , tt , source_index ,:) !write(*,*) i,j,integral_subgrid(i,j,tt,hsurf_average_subgrid_index,source_index,1) endif else !If annual calculations !Only works withthe simple dispersion parameters distance_subgrid = sqrt (( x_emission_subgrid ( ii , jj , source_index ) - x_integral_subgrid ( i , j )) * ( x_emission_subgrid ( ii , jj , source_index ) - x_integral_subgrid ( i , j )) & + ( y_emission_subgrid ( ii , jj , source_index ) - y_integral_subgrid ( i , j )) * ( y_emission_subgrid ( ii , jj , source_index ) - y_integral_subgrid ( i , j ))) if ( wind_level_integral_flag . eq . 5 ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) else FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) endif integral_subgrid ( i , j , tt , hsurf_average_subgrid_index , source_index ,:) = integral_subgrid ( i , j , hsurf_average_subgrid_index , tt , source_index ,:) & + emission_subgrid ( ii , jj , tt , source_index ,:) & * gauss_plume_second_order_rotated_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , 0. , H_emep ) & / FF_loc endif endif endif enddo enddo !write(*,'(6i6,f)') i,j,i_start,i_end,j_start,j_end,integral_subgrid(i,j,tt,source_index,subsource_index) enddo !write(*,'(3a,i5,a,i5,a,i3,a,i3)') 'Gridding ',trim(source_file_str(source_index)),' integral proxy',j,' of ',integral_subgrid_dim(y_dim_index),' and ',subsource_index,' of ',n_subsource(source_index) enddo if ( mod ( j , 1 ). eq . 0 ) write ( * , '(3a,i5,a,i5,a,i3,a,i3)' ) 'Integral gridding ' , trim ( source_file_str ( source_index )), ' proxy for hour ' , tt , ' of ' , subgrid_dim ( t_dim_index ), ' and ' , subsource_index , ' of ' , n_subsource ( source_index ) enddo !time loop enddo !subsource_index !if (combine_emission_subsources_during_dispersion(source_index).and.n_subsource(source_index).gt.1) then !    do subsource_index=2,n_subsource(n_source_index) !        integral_subgrid(:,:,:,:,source_index,1)=integral_subgrid(:,:,:,:,source_index,1)+integral_subgrid(:,:,:,:,source_index,subsource_index) !    enddo !    n_subsource(source_index)=1 !endif if ( allocated ( trajectory_subgrid )) deallocate ( trajectory_subgrid ) !if (allocated(temp_emission_subgrid)) deallocate(temp_emission_subgrid) !if (allocated(temp_subgrid)) deallocate(temp_subgrid) if ( allocated ( temp_FF_subgrid )) deallocate ( temp_FF_subgrid ) end subroutine uEMEP_subgrid_dispersion_integral","tags":"","loc":"proc/uemep_subgrid_dispersion_integral.html"},{"title":"check_command_line – uEMEP","text":"public  subroutine check_command_line() Checks that a suitable number of command line arguments has been supplied\nand handles some special cases of command line inputs 'check_command_line' will write to stdout instead of the log file\nto give direct feedback to the user Arguments None Source Code subroutine check_command_line () !! Checks that a suitable number of command line arguments has been supplied !! and handles some special cases of command line inputs !! !! 'check_command_line' will write to stdout instead of the log file !! to give direct feedback to the user ! Local variables integer :: n_args , i character ( len = 256 ) :: arg ! Check if no arguments are found n_args = command_argument_count () if ( n_args <= 0 ) then write ( * , \"(a)\" ) \" Insufficient number of command line arguments\" write ( * , \"(a)\" ) \" Try 'uemep --help' for more information\" stop end if ! Loop over input arguments to handle special cases do i = 1 , n_args call get_command_argument ( i , arg ) select case ( adjustl ( arg )) case ( \"--help\" ) call print_help_page () stop case ( \"--version\" ) call print_version () stop end select end do ! After checking that no special cases are found, check if the number of ! arguments are within acceptable bounds (2:n_max_config_files+1) if ( n_args < 2 ) then write ( * , \"(a)\" ) \" Insufficient number of command line arguments\" write ( * , \"(a)\" ) \" Try 'uemep --help' for more information\" stop else if ( n_args > n_max_config_files + 1 ) then write ( * , \"(a)\" ) \" Too many command line arguments\" write ( * , \"(a)\" ) \" Try 'uemep --help' for more information\" stop end if end subroutine check_command_line","tags":"","loc":"proc/check_command_line.html"},{"title":"uEMEP_read_command_line – uEMEP","text":"public  subroutine uEMEP_read_command_line() Assigns the configuration file name(s) and substitution date_str from the command line Arguments None Source Code subroutine uEMEP_read_command_line () !! Assigns the configuration file name(s) and substitution date_str from the command line ! Local variables integer :: n_args , i ! Get number of command line arguments n_args = command_argument_count () n_config_files = n_args - 1 ! Read file names do i = 1 , n_config_files call get_command_argument ( i , name_config_file ( i )) write ( * , \"(a,i0,2a)\" ), \"name_config_file(\" , i , \") = \" , trim ( name_config_file ( i )) end do ! Read date string call get_command_argument ( n_args , config_date_str ) write ( * , \"(2a)\" ) \"config_date_str = \" , trim ( config_date_str ) end subroutine uEMEP_read_command_line","tags":"","loc":"proc/uemep_read_command_line.html"},{"title":"print_help_page – uEMEP","text":"private  subroutine print_help_page() Prints a help message to the terminal console Arguments None Source Code subroutine print_help_page () !! Prints a help message to the terminal console write ( * , \"(a)\" ) \" uEMEP: Air quality dispersion model for high resolution downscaling of EMEP MSC-W\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" To run the uEMEP model:\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" ./uemep config_file_1 config_file_2 ... config_file_10 date_string\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" Where config_file_n is the name of the configuration file(s) which specify\" write ( * , \"(a)\" ) \" the model calculations and with a maximum number of 10 config files, and\" write ( * , \"(a)\" ) \" the date_string, required, takes the form 'yyyymmdd'.\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" Please read the manual on how to configure uEMEP at: <URL>.\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" --help                     displays this help message and exits\" write ( * , \"(a)\" ) \" --version                  outputs the uEMEP version and exits\" end subroutine print_help_page","tags":"","loc":"proc/print_help_page.html"},{"title":"print_version – uEMEP","text":"private  subroutine print_version() Prints the program version to the terminal console Arguments None Source Code subroutine print_version () !! Prints the program version to the terminal console write ( * , \"(a)\" ) \" uEMEP: Air quality dispersion model for high resolution downscaling of EMEP MSC-W\" write ( * , \"(a)\" ) \" \" write ( * , \"(2a)\" ) \" Version: \" , trim ( model_version_str ) write ( * , \"(a)\" ) \" Copyright (C) 2007 Free Software Foundation.\" write ( * , \"(a)\" ) \" License GNU LGPL-3.0 <https://www.gnu.org/licenses/lgpl-3.0.html>.\" write ( * , \"(a)\" ) \" This is free software: you are free to change and redistribute it.\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" Developed and maintained at the Norwegian Meteorological Institute.\" write ( * , \"(a)\" ) \" Contribute at: <https://github.com/metno/uEMEP>\" end subroutine print_version","tags":"","loc":"proc/print_version.html"},{"title":"uEMEP_read_roadlink_data_ascii – uEMEP","text":"public  subroutine uEMEP_read_roadlink_data_ascii() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_roadlink_data_ascii use uEMEP_definitions implicit none integer i , j integer unit_in integer rl_length_short logical :: exists logical nxtdat_flag real sub_nodes_x ( 5000 ), sub_nodes_y ( 5000 ), sub_nodes_lon ( 5000 ), sub_nodes_lat ( 5000 ) integer temp_id , n_subnodes , temp_road_type , temp_nlanes real temp_adt , temp_hdv , temp_speed , temp_width integer counter real size_major ( 3 ) integer n_loop , loop_step real x_grid_min , x_grid_max , y_grid_min , y_grid_max integer counter_major , counter_sub logical :: show_diagnostics = . false . real diagnostic_val ( 10 ) integer temp_category , temp_structure_type , temp_region_id , temp_surface_id , temp_route_id real temp_length , temp_tunnel_length logical :: road_data_in_latlon = . false . real temp_real real , allocatable :: inputdata_rl_temp (:,:) integer , allocatable :: inputdata_int_rl_temp (:,:) real , allocatable :: inputdata_rl_multi (:,:) integer , allocatable :: inputdata_int_rl_multi (:,:) real , allocatable :: inputdata_rl_multi_new (:,:) integer , allocatable :: inputdata_int_rl_multi_new (:,:) integer n_multi_roadlinks_new , n_multi_roadlinks integer m integer n_road_link_file_loop logical :: first_road_link_file_read = . false . integer temp_int integer :: io write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading road link data ascii (uEMEP_read_roadlink_data_ascii)' write ( unit_logfile , '(A)' ) '================================================================' min_adt = 1 0. min_link_size = 1. if ( num_multiple_roadlink_files . eq . 0 ) then n_road_link_file_loop = 1 else n_road_link_file_loop = num_multiple_roadlink_files endif !Start the file loop here !--------------------------- n_multi_roadlinks_new = 0 n_multi_roadlinks = 0 first_road_link_file_read = . false . do m = 1 , n_road_link_file_loop if ( num_multiple_roadlink_files . gt . 0 ) then !pathname_rl(1)=pathname_mrl(m) filename_rl ( 1 ) = filename_mrl ( m ) write ( * , * ) m , n_road_link_file_loop , trim ( filename_rl ( 1 )) endif pathfilename_rl ( 1 ) = trim ( pathname_rl ( 1 )) // trim ( filename_rl ( 1 )) !write(*,*) pathname_rl(2),filename_rl(2),pathfilename_rl(2) !Test existence of the road link filename (2). If does not exist then stop inquire ( file = trim ( pathfilename_rl ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Road link file ascii does not exist: ' , trim ( pathfilename_rl ( 1 )) stop endif !Check filename for the string 'latlon' that specifies if the data is in lat lon coordinates if ( index ( filename_rl ( 1 ), 'latlon' ). gt . 0 ) then road_data_in_latlon = . true . write ( unit_logfile , '(A,A)' ) ' Reading road data positions as lat lon: ' , trim ( pathfilename_rl ( 1 )) endif !Open the file for reading to test the available links in the region if ( reduce_roadlink_region_flag ) then unit_in = 20 open ( unit_in , file = pathfilename_rl ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link file(ascii) ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !read the header to find out how many links there are !read(unit_in,'(a)',ERR=20) temp_str if ( no_header_roadlink_data_flag ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) without header: ' // trim ( pathfilename_rl ( 1 )) i = 0 do read ( unit_in , * , iostat = io ) temp_real , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if if ( temp_real . gt . 0 ) then i = i + 1 n_roadlinks = n_roadlinks + n_subnodes - 1 endif if ( int ( temp_real ). ne . temp_real ) then write ( unit_logfile , '(a,i,f)' ) ' Problem with record at point with ID: ' , i , temp_real stop endif enddo n_roadlinks_major = i !n_roadlinks=0 rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) else read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks endif if ( n_roadlinks . eq . 0 ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) with header but without subnode counts: ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks i = 0 do read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !Read attributes up to n_subnodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if if ( temp_id . gt . 0 ) then i = i + 1 n_roadlinks = n_roadlinks + n_subnodes - 1 endif enddo !Have commented out this in the cases where the number of links are not as written. Can happen with OSM data !n_roadlinks_major=i rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) temp_int , temp_int endif write ( unit_logfile , '(a,i)' ) ' Number of major road links in header = ' , n_roadlinks_major write ( unit_logfile , '(a,i)' ) ' Number of sub road links in header= ' , n_roadlinks !Allocate the arrays after reading in the number of roads !allocate (inputdata_rl_temp(n_roadlinks,num_var_rl)) !allocate (inputdata_int_rl_temp(n_roadlinks,num_int_rl)) if ( allocated ( valid_link_flag )) deallocate ( valid_link_flag ) allocate ( valid_link_flag ( n_roadlinks_major )) valid_link_flag = . false . !Initialise !inputdata_rl_temp=0. !inputdata_int_rl_temp=0 counter_major = 0 counter_sub = 0 !Read the data to find roads in the tile !x_grid_min=emission_subgrid_min(x_dim_index,traffic_index) !x_grid_max=emission_subgrid_min(x_dim_index,traffic_index)+(emission_subgrid_dim(x_dim_index,traffic_index)+1)*emission_subgrid_delta(x_dim_index,traffic_index) !y_grid_min=emission_subgrid_min(y_dim_index,traffic_index) !y_grid_max=emission_subgrid_min(y_dim_index,traffic_index)+(emission_subgrid_dim(y_dim_index,traffic_index)+1)*emission_subgrid_delta(y_dim_index,traffic_index) x_grid_min = init_emission_subgrid_min ( x_dim_index , traffic_index ) x_grid_max = init_emission_subgrid_min ( x_dim_index , traffic_index ) + ( init_emission_subgrid_dim ( x_dim_index , traffic_index ) + 1 ) * init_emission_subgrid_delta ( x_dim_index , traffic_index ) y_grid_min = init_emission_subgrid_min ( y_dim_index , traffic_index ) y_grid_max = init_emission_subgrid_min ( y_dim_index , traffic_index ) + ( init_emission_subgrid_dim ( y_dim_index , traffic_index ) + 1 ) * init_emission_subgrid_delta ( y_dim_index , traffic_index ) !Under the special case where multiple roads are read from different countries then us the intital grid to determine which to keep !This is not implemented yet but needs to select the region when reading multiple files !if !init_subgrid_min(x_dim_index)=subgrid_min(x_dim_index) !init_subgrid_min(y_dim_index)=subgrid_min(y_dim_index) !init_subgrid_max(x_dim_index)=subgrid_max(x_dim_index) !init_subgrid_max(y_dim_index)=subgrid_max(y_dim_index) !endif !rewind(unit_in) !call nxtdat_modern(unit_in,nxtdat_flag) !read(unit_in,*,ERR=20) temp_int,temp_int do i = 1 , n_roadlinks_major !ID ADT HDV ROAD_TYPE SPEED N_SUBLINKS read ( unit_in , * , ERR = 20 ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !read(unit_in,*,ERR=20) !temp_id !write(*,*) temp_id,temp_adt,n_subnodes if ( road_data_in_latlon ) then !Order is reversed in these files read ( unit_in , * ) sub_nodes_y ( 1 ) read ( unit_in , * ) sub_nodes_x ( 1 ) if ( projection_type . eq . UTM_projection_index ) then !write(*,*) i,sub_nodes_x(1),sub_nodes_y(1) call ll2utm ( 1 , utm_zone , sub_nodes_y ( 1 ), sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_x ( 1 )) !write(*,*) i,sub_nodes_x(1),sub_nodes_y(1) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , sub_nodes_y ( 1 ), sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_x ( 1 )) elseif ( projection_type . eq . LCC_projection_index ) then elseif ( projection_type . eq . PS_projection_index ) then elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), projection_attributes ) endif else read ( unit_in , * ) sub_nodes_x ( 1 ) read ( unit_in , * ) sub_nodes_y ( 1 ) endif !Convert to EMEP coordinates from UTM to lambert. No choices here. Special case but should be changed if ( save_emissions_for_EMEP ( traffic_index )) then call PROJ2LL ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_lon ( 1 ), sub_nodes_lat ( 1 ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,sub_nodes_y(1),sub_nodes_x(1),sub_nodes_lat(1),sub_nodes_lon(1)) if ( projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_lon ( 1 ), sub_nodes_lat ( 1 ), EMEP_projection_attributes ) elseif ( projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_lon ( 1 ), sub_nodes_lat ( 1 ), EMEP_projection_attributes ) else !Remains as lat lon endif !write(*,*) sub_nodes_x(1),sub_nodes_y(1),sub_nodes_lon(1),sub_nodes_lat(1) endif !write(*,*) sub_nodes_x(1),sub_nodes_y(1) !write(*,*) x_grid_min,x_grid_max,y_grid_min,y_grid_max !Test position within emission region if ( sub_nodes_x ( 1 ). ge . x_grid_min . and . sub_nodes_x ( 1 ). le . x_grid_max & . and . sub_nodes_y ( 1 ). ge . y_grid_min . and . sub_nodes_y ( 1 ). le . y_grid_max ) then counter_major = counter_major + 1 counter_sub = counter_sub + n_subnodes - 1 valid_link_flag ( i ) = . true . else valid_link_flag ( i ) = . false . endif enddo close ( unit_in , status = 'keep' ) write ( unit_logfile , '(a,i,i)' ) ' Number of major and sub road links within the region = ' , counter_major , counter_sub endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_rl ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link file(ascii) ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !read the header to find out how many links there are !read(unit_in,'(a)',ERR=20) temp_str if ( no_header_roadlink_data_flag ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) without header: ' // trim ( pathfilename_rl ( 1 )) i = 0 do read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !Read attributes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if if ( temp_id . gt . 0 ) then i = i + 1 endif enddo n_roadlinks_major = i n_roadlinks = n_roadlinks + n_subnodes - 1 rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) else read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks endif if ( n_roadlinks . eq . 0. and .. not . reduce_roadlink_region_flag ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) with header but without subnode counts: ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks i = 0 do read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !Read attributes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if !write(*,*) temp_id if ( temp_id . gt . 0 ) then i = i + 1 n_roadlinks = n_roadlinks + n_subnodes - 1 endif enddo !n_roadlinks_major=i rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) endif write ( unit_logfile , '(a,i)' ) ' Number of major road links= ' , n_roadlinks_major write ( unit_logfile , '(a,i)' ) ' Number of sub road links= ' , n_roadlinks !Allocate the arrays after reading in the number of roads if ( reduce_roadlink_region_flag ) then n_roadlinks = counter_sub n_roadlinks_major_selected = counter_major else !Set all road links to valid when not regionally selecting. THis will fail because already allocated if ( allocated ( valid_link_flag )) deallocate ( valid_link_flag ) allocate ( valid_link_flag ( n_roadlinks_major )) valid_link_flag = . true . endif if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_temp )) deallocate ( inputdata_int_rl_temp ) allocate ( inputdata_rl_temp ( n_roadlinks , num_var_rl )) allocate ( inputdata_int_rl_temp ( n_roadlinks , num_int_rl )) !Initialise inputdata_rl_temp = 0. inputdata_int_rl_temp = 0 counter = 0 counter_major = 0 !rewind(unit_in) !call nxtdat_modern(unit_in,nxtdat_flag) !read(unit_in,*,ERR=20) temp_int,temp_int !Read the data do i = 1 , n_roadlinks_major !    if (.not.valid_link_flag(i)) then !        if (read_OSM_roadlink_data_flag) then !ID ADT HDV ROAD_TYPE SPEED N_SUBLINKS !            if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_id,temp_adt,temp_hdv,temp_road_type,temp_speed,temp_width,temp_nlanes,n_subnodes !        else !ID ADT HDV ROAD_ACTIVITY_TYPE SPEED ROAD_WIDTH N_LANES N_SUBNODES ROAD_CATEGORY ROAD_LENGTH ROAD_STRUCTURE_TYPE REGION_ID ROAD_SURFACE_ID TUNNEL_LENGTH ROUTE_ID !            if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_id,temp_adt,temp_hdv,temp_road_type,temp_speed,temp_width,temp_nlanes,n_subnodes & !            ,temp_category,temp_length,temp_structure_type,temp_region_id,temp_surface_id,temp_tunnel_length,temp_route_id !        endif !write(*,*) temp_id,temp_adt,n_subnodes !        if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_val !        if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_val !    else if ( read_OSM_roadlink_data_flag ) then !ID ADT HDV ROAD_TYPE SPEED N_SUBLINKS read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if temp_category = 0 ; temp_length = 0 ; temp_structure_type = 0 ; temp_region_id = 0 ; temp_surface_id = 0 ; temp_tunnel_length = 0 ; temp_route_id = 0 else !ID ADT HDV ROAD_ACTIVITY_TYPE SPEED ROAD_WIDTH N_LANES N_SUBNODES ROAD_CATEGORY ROAD_LENGTH ROAD_STRUCTURE_TYPE REGION_ID ROAD_SURFACE_ID TUNNEL_LENGTH ROUTE_ID read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes & , temp_category , temp_length , temp_structure_type , temp_region_id , temp_surface_id , temp_tunnel_length , temp_route_id if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if endif !write(*,*) i,temp_id,temp_adt,n_subnodes read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 : n_subnodes ) if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 : n_subnodes ) if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if !write(*,*) sub_nodes_x(1:n_subnodes),sub_nodes_y(1:n_subnodes) !put in the road link data !Test size of major link. If less than min_link_size then treat it as a single link from the start sub_node to the end sub_node if ( valid_link_flag ( i )) then !Do not do this with latlon input data as it does not work if (. not . road_data_in_latlon ) then size_major ( 1 ) = maxval ( sub_nodes_x ( 1 : n_subnodes )) - minval ( sub_nodes_x ( 1 : n_subnodes )) size_major ( 2 ) = maxval ( sub_nodes_y ( 1 : n_subnodes )) - minval ( sub_nodes_y ( 1 : n_subnodes )) size_major ( 3 ) = sqrt ( size_major ( 1 ) ** 2 + size_major ( 2 ) ** 2 ) if ( size_major ( 3 ). gt . min_link_size ) then n_loop = n_subnodes - 1 loop_step = 1 else n_loop = 1 loop_step = n_subnodes - 1 !write(*,*) size_major(3) endif else n_loop = n_subnodes - 1 loop_step = 1 endif counter_major = counter_major + 1 !if (n_subnodes.gt.5000) then !    write(*,*) 'Greater than 5000 ',i !endif !Place the data in the road links if ( temp_adt . ge . min_adt ) then do j = 1 , n_loop counter = counter + 1 if ( counter . le . n_roadlinks ) then inputdata_int_rl_temp ( counter , major_index_rl_index ) = counter_major inputdata_int_rl_temp ( counter , id_rl_index ) = temp_id inputdata_rl_temp ( counter , adt_rl_index ) = temp_adt ** osm_adt_power_scale inputdata_rl_temp ( counter , hdv_rl_index ) = temp_hdv inputdata_int_rl_temp ( counter , roadtype_rl_index ) = temp_road_type inputdata_rl_temp ( counter , speed_rl_index ) = temp_speed inputdata_rl_temp ( counter , width_rl_index ) = temp_width inputdata_int_rl_temp ( counter , nlanes_rl_index ) = temp_nlanes inputdata_rl_temp ( counter , x1_rl_index ) = sub_nodes_x ( j ) inputdata_rl_temp ( counter , x2_rl_index ) = sub_nodes_x ( j + loop_step ) inputdata_rl_temp ( counter , y1_rl_index ) = sub_nodes_y ( j ) inputdata_rl_temp ( counter , y2_rl_index ) = sub_nodes_y ( j + loop_step ) !write(*,*) inputdata_int_rl(counter,id_rl_index),inputdata_rl(counter,x1_rl_index),inputdata_rl(counter,y2_rl_index) inputdata_rl_temp ( counter , tunnel_length_rl_index ) = temp_tunnel_length endif enddo !write(*,*) counter, inputdata_int_rl_temp(counter,major_index_rl_index) endif endif enddo write ( unit_logfile , '(a,i)' ) ' Number of counted road links= ' , counter write ( unit_logfile , '(a,i)' ) ' Number of road links allocated = ' , n_roadlinks n_roadlinks = min ( counter , n_roadlinks ) close ( unit_in , status = 'keep' ) !Allocate the arrays after reading in the number of roads if ( allocated ( inputdata_rl )) deallocate ( inputdata_rl ) if ( allocated ( inputdata_int_rl )) deallocate ( inputdata_int_rl ) allocate ( inputdata_rl ( n_roadlinks , num_var_rl )) allocate ( inputdata_int_rl ( n_roadlinks , num_int_rl )) inputdata_rl = inputdata_rl_temp ( 1 : n_roadlinks ,:) inputdata_int_rl = inputdata_int_rl_temp ( 1 : n_roadlinks ,:) if ( road_data_in_latlon ) then !Order is reversed in these files so they are reversed in the projection calls as well do i = 1 , n_roadlinks if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , inputdata_rl_temp ( i , x1_rl_index ), inputdata_rl_temp ( i , y1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , x1_rl_index )) call ll2utm ( 1 , utm_zone , inputdata_rl_temp ( i , x2_rl_index ), inputdata_rl_temp ( i , y2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , x2_rl_index )) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , inputdata_rl_temp ( i , x1_rl_index ), inputdata_rl_temp ( i , y1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , x1_rl_index )) call ll2ltm ( 1 , ltm_lon0 , inputdata_rl_temp ( i , x2_rl_index ), inputdata_rl_temp ( i , y2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , x2_rl_index )) elseif ( projection_type . eq . LCC_projection_index ) then elseif ( projection_type . eq . PS_projection_index ) then elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl_temp ( i , y1_rl_index ), inputdata_rl_temp ( i , x1_rl_index ), projection_attributes ) call LL2LAEA ( inputdata_rl ( i , x2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl_temp ( i , y2_rl_index ), inputdata_rl_temp ( i , x2_rl_index ), projection_attributes ) endif enddo endif if ( num_multiple_roadlink_files . gt . 1 ) then if ( n_roadlinks . gt . 0 ) then n_multi_roadlinks_new = n_multi_roadlinks + n_roadlinks !For the first roadloop if (. not . first_road_link_file_read ) then !Allocate the multi road array for the first time n_multi_roadlinks_new = n_roadlinks n_multi_roadlinks = n_multi_roadlinks_new if (. not . allocated ( inputdata_rl_multi )) allocate ( inputdata_rl_multi ( n_multi_roadlinks , num_var_rl )) if (. not . allocated ( inputdata_int_rl_multi )) allocate ( inputdata_int_rl_multi ( n_multi_roadlinks , num_int_rl )) inputdata_rl_multi ( 1 : n_multi_roadlinks ,:) = inputdata_rl ( 1 : n_multi_roadlinks ,:) inputdata_int_rl_multi ( 1 : n_multi_roadlinks ,:) = inputdata_int_rl ( 1 : n_roadlinks ,:) first_road_link_file_read = . true . else !Allocate the new multi array with all roads so far allocate ( inputdata_rl_multi_new ( n_multi_roadlinks_new , num_var_rl )) allocate ( inputdata_int_rl_multi_new ( n_multi_roadlinks_new , num_int_rl )) !Place the current multi roads in the new multiroads !NOTE: inputdata_rl_multi is not allocated until later, debugging error but do not use this anyway! inputdata_rl_multi_new ( 1 : n_multi_roadlinks ,:) = inputdata_rl_multi ( 1 : n_multi_roadlinks ,:) inputdata_int_rl_multi_new ( 1 : n_multi_roadlinks ,:) = inputdata_int_rl_multi ( 1 : n_roadlinks ,:) !Place the last read road links in the new multiroads inputdata_rl_multi_new ( n_multi_roadlinks + 1 : n_multi_roadlinks_new ,:) = inputdata_rl ( 1 : n_roadlinks ,:) inputdata_int_rl_multi_new ( n_multi_roadlinks + 1 : n_multi_roadlinks_new ,:) = inputdata_int_rl ( 1 : n_roadlinks ,:) !Deallocate the old multi road arrays if ( allocated ( inputdata_rl_multi )) deallocate ( inputdata_rl_multi ) if ( allocated ( inputdata_int_rl_multi )) deallocate ( inputdata_int_rl_multi ) n_multi_roadlinks = n_multi_roadlinks_new !Allocate the multi road array allocate ( inputdata_rl_multi ( n_multi_roadlinks , num_var_rl )) allocate ( inputdata_int_rl_multi ( n_multi_roadlinks , num_int_rl )) !Put the new data in the old one inputdata_rl_multi = inputdata_rl_multi_new inputdata_int_rl_multi = inputdata_int_rl_multi_new !Deallocate the new multi road arrays if ( allocated ( inputdata_rl_multi_new )) deallocate ( inputdata_rl_multi_new ) if ( allocated ( inputdata_int_rl_multi_new )) deallocate ( inputdata_int_rl_multi_new ) endif endif !Deallocate the other arrays as well if ( allocated ( inputdata_rl )) deallocate ( inputdata_rl ) if ( allocated ( inputdata_int_rl )) deallocate ( inputdata_int_rl ) if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_temp )) deallocate ( inputdata_int_rl_temp ) if ( allocated ( valid_link_flag )) deallocate ( valid_link_flag ) write ( unit_logfile , '(a,i)' ) ' Number of accumulated multi-road links used = ' , n_multi_roadlinks_new endif !End the multiloop here enddo if ( num_multiple_roadlink_files . gt . 1 ) then allocate ( inputdata_rl ( n_multi_roadlinks , num_var_rl )) allocate ( inputdata_int_rl ( n_multi_roadlinks , num_int_rl )) inputdata_rl = inputdata_rl_multi inputdata_int_rl = inputdata_int_rl_multi if ( allocated ( inputdata_rl_multi )) deallocate ( inputdata_rl_multi ) if ( allocated ( inputdata_int_rl_multi )) deallocate ( inputdata_int_rl_multi ) n_roadlinks = n_multi_roadlinks_new write ( unit_logfile , '(a,i)' ) ' Number of accumulated multi-road links used = ' , n_multi_roadlinks endif if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_temp )) deallocate ( inputdata_int_rl_temp ) !No speed in the files currently. Set all to 50 km/hr. Temporary !inputdata_rl(:,speed_rl_index)=50. !inputdata_rl(:,width_rl_index)=10. !inputdata_int_rl(:,nlanes_rl_index)=2 !Set the road type, normal or tunnel (tunnel or jet). When a tunnel then there is no retention, always dry !do i=1,n_roadlinks !    if (inputdata_int_rl(i,roadtype_rl_index).eq.5.or.inputdata_int_rl(i,roadtype_rl_index).eq.6) then !        inputdata_int_rl(i,roadtype_rl_index)=tunnel_roadtype !    else !        inputdata_int_rl(i,roadtype_rl_index)=normal_roadtype !    endif !enddo !Calculate some additional values inputdata_rl (:, x0_rl_index ) = ( inputdata_rl (:, x1_rl_index ) + inputdata_rl (:, x2_rl_index )) / 2. inputdata_rl (:, y0_rl_index ) = ( inputdata_rl (:, y1_rl_index ) + inputdata_rl (:, y2_rl_index )) / 2. inputdata_rl (:, length_rl_index ) = sqrt (( inputdata_rl (:, x1_rl_index ) - inputdata_rl (:, x2_rl_index )) ** 2 + ( inputdata_rl (:, y1_rl_index ) - inputdata_rl (:, y2_rl_index )) ** 2 ) !Calculate road orientation and check for range overflows for length as well !inputdata_rl(angle_rl_index,:)=180./3.14159*acos((inputdata_rl(y2_rl_index,:)-inputdata_rl(y1_rl_index,:))/inputdata_rl(length_rl_index,:)) do i = 1 , n_roadlinks call PROJ2LL ( inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , lon1_rl_index ), inputdata_rl ( i , lat1_rl_index ), projection_attributes , projection_type ) call PROJ2LL ( inputdata_rl ( i , x2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , lon2_rl_index ), inputdata_rl ( i , lat2_rl_index ), projection_attributes , projection_type ) call PROJ2LL ( inputdata_rl ( i , x0_rl_index ), inputdata_rl ( i , y0_rl_index ), inputdata_rl ( i , lon0_rl_index ), inputdata_rl ( i , lat0_rl_index ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,inputdata_rl(i,y1_rl_index),inputdata_rl(i,x1_rl_index),inputdata_rl(i,lat1_rl_index),inputdata_rl(i,lon1_rl_index)) !call UTM2LL(utm_zone,inputdata_rl(i,y2_rl_index),inputdata_rl(i,x2_rl_index),inputdata_rl(i,lat2_rl_index),inputdata_rl(i,lon2_rl_index)) !call UTM2LL(utm_zone,inputdata_rl(i,y0_rl_index),inputdata_rl(i,x0_rl_index),inputdata_rl(i,lat0_rl_index),inputdata_rl(i,lon0_rl_index)) enddo !Check lengths rl_length_short = 0 do i = 1 , n_roadlinks if ( inputdata_rl ( i , length_rl_index ). eq . 0.0 ) then rl_length_short = rl_length_short + 1 !write(unit_logfile,'(a,2i,f12.5)') ' WARNING: Zero link length, setting to 1 m ',i,inputdata_int_rl(i,id_rl_index),inputdata_rl(i,length_rl_index) inputdata_rl ( i , length_rl_index ) = 1. endif enddo !write(*,*) 'Max length: ',maxval(inputdata_rl(:,length_rl_index)),inputdata_rl(maxloc(inputdata_rl(:,length_rl_index)),lat0_rl_index),inputdata_rl(maxloc(inputdata_rl(:,length_rl_index)),lon0_rl_index) write ( unit_logfile , * ) 'Number of road links with 0 length: ' , rl_length_short , '  Setting to 1 m' write ( unit_logfile , * ) 'Max road link x and y: ' , maxval ( inputdata_rl (:, x0_rl_index )), maxval ( inputdata_rl (:, y0_rl_index )) write ( unit_logfile , * ) 'Min road link x and y: ' , minval ( inputdata_rl (:, x0_rl_index )), minval ( inputdata_rl (:, y0_rl_index )) if ( n_roadlinks . gt . 0 ) then write ( unit_logfile , '(a14,12a10)' ) ' LINK ' , 'ID' , 'X1' , 'X2' , 'Y1' , 'Y2' , 'WIDTH' , 'LENGTH' , 'ADT' , 'LON' , 'LAT' , 'N_LANES' , 'TYPE' i = 1 write ( unit_logfile , '(a14,i10,7f10.1,2f10.4,2i10)' ) ' First link = ' , inputdata_int_rl ( i , id_rl_index ), inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , x2_rl_index ) & , inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , width_rl_index ) & , inputdata_rl ( i , length_rl_index ), inputdata_rl ( i , adt_rl_index ) & , inputdata_rl ( i , lon0_rl_index ), inputdata_rl ( i , lat0_rl_index ) & , inputdata_int_rl ( i , nlanes_rl_index ), inputdata_int_rl ( i , roadtype_rl_index ) i = n_roadlinks write ( unit_logfile , '(a14,i10,7f10.1,2f10.4,2i10)' ) ' Last link = ' , inputdata_int_rl ( i , id_rl_index ), inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , x2_rl_index ) & , inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , width_rl_index ) & , inputdata_rl ( i , length_rl_index ), inputdata_rl ( i , adt_rl_index ) & , inputdata_rl ( i , lon0_rl_index ), inputdata_rl ( i , lat0_rl_index ) & , inputdata_int_rl ( i , nlanes_rl_index ), inputdata_int_rl ( i , roadtype_rl_index ) else write ( unit_logfile , '(a)' ) 'No road links available in this region' endif !Calculate the veh km totals if ( show_diagnostics ) then diagnostic_val = 0. do i = 1 , n_roadlinks !Total kilometres diagnostic_val ( 1 ) = diagnostic_val ( 1 ) + inputdata_rl ( i , length_rl_index ) / 100 0. !Total veh kilometres diagnostic_val ( 2 ) = diagnostic_val ( 2 ) + inputdata_rl ( i , length_rl_index ) / 100 0. * inputdata_rl ( i , adt_rl_index ) * 36 5. !Light veh kilometres diagnostic_val ( 3 ) = diagnostic_val ( 3 ) + ( 1. - inputdata_rl ( i , hdv_rl_index ) / 10 0. ) * inputdata_rl ( i , length_rl_index ) / 100 0. * inputdata_rl ( i , adt_rl_index ) * 36 5. !Light veh kilometres diagnostic_val ( 4 ) = diagnostic_val ( 4 ) + ( inputdata_rl ( i , hdv_rl_index ) / 10 0. ) * inputdata_rl ( i , length_rl_index ) / 100 0. * inputdata_rl ( i , adt_rl_index ) * 36 5. enddo write ( unit_logfile , '(a,es12.4)' ) 'Total km= ' , diagnostic_val ( 1 ) write ( unit_logfile , '(a,es12.4)' ) 'Total veh.km= ' , diagnostic_val ( 2 ) write ( unit_logfile , '(a,es12.4)' ) 'Total light veh.km= ' , diagnostic_val ( 3 ) write ( unit_logfile , '(a,es12.4)' ) 'Total heavy veh.km= ' , diagnostic_val ( 4 ) endif return 20 write ( unit_logfile , '(2A)' ) 'ERROR reading road link file: ' , trim ( pathfilename_rl ( 2 )) stop end subroutine uEMEP_read_roadlink_data_ascii","tags":"","loc":"proc/uemep_read_roadlink_data_ascii.html"},{"title":"uEMEP_read_roadlink_emission_data – uEMEP","text":"public  subroutine uEMEP_read_roadlink_emission_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_roadlink_emission_data !Reads in NORTRIP formatted emission data and places it in the correct road links use uEMEP_definitions implicit none integer i , j integer unit_in logical :: exists logical nxtdat_flag integer counter real , allocatable :: inputdata_rl_temp (:) integer , allocatable :: inputdata_int_rl_id (:) integer emission_date_array ( 6 ) integer n_roadlink_emission_compound character ( 16 ) n_roadlink_emission_compound_str ( 10 ) character ( 256 ) n_roadlink_emission_unit_str character ( 256 ) n_roadlink_emission_date_str integer n_roadlink_emission , n_roadlink_emission_time integer time_index_temp , t_match_index , t integer date_array_temp ( 6 ) integer n_roadlink_emission_selected character ( 256 ) format_temp character ( len = 32 ) :: fmt double precision emission_date_number_start , emission_date_number write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading road link emission data (uEMEP_read_roadlink_emission_data)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_rl ( 2 ) = trim ( pathname_rl ( 2 )) // trim ( filename_rl ( 2 )) !write(*,*) pathname_rl(2),filename_rl(2),pathfilename_rl(2) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_rl ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Road link emission file does not exist: ' , trim ( pathfilename_rl ( 2 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_rl ( 2 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link file(ascii) ' // trim ( pathfilename_rl ( 2 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !read the header to find out how many links there are !read(unit_in,'(a)',ERR=20) temp_str read ( unit_in , * , ERR = 20 ) n_roadlink_emission_compound write ( unit_logfile , '(a,i)' ) ' Number of road link emission compounds= ' , n_roadlink_emission_compound call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission_compound_str ( 1 : n_roadlink_emission_compound ) write ( fmt , '(a,i0,a)' ) '(a,' , n_roadlink_emission_compound , 'a16)' write ( unit_logfile , fmt ) ' Road link emission compounds= ' , n_roadlink_emission_compound_str ( 1 : n_roadlink_emission_compound ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission_unit_str write ( unit_logfile , '(a,a)' ) ' Road link emission units= ' , trim ( n_roadlink_emission_unit_str ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission_date_str write ( unit_logfile , '(a,a)' ) ' Road link emission start date= ' , trim ( n_roadlink_emission_date_str ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission , n_roadlink_emission_time write ( unit_logfile , '(a,i)' ) ' Number of road links= ' , n_roadlink_emission write ( unit_logfile , '(a,i)' ) ' Number of time steps= ' , n_roadlink_emission_time if ( n_roadlink_emission . ne . n_roadlinks_major ) then write ( unit_logfile , '(A,2i12)' ) 'ERROR: Number of emission road links is not the same as the static road links: ' , n_roadlink_emission , n_roadlinks_major stop endif !Check that start time and end time are covered in the emission data before progressing further format_temp = 'yyyymmddHH' call datestr_to_date ( n_roadlink_emission_date_str , format_temp , emission_date_array ) if ( use_single_time_loop_flag ) then time_index_temp = end_time_loop_index else time_index_temp = subgrid_dim ( t_dim_index ) endif t_match_index = 0 !write(*,*) shape(val_dim_nc) !do t=1,time_index_temp !    call number_to_date(val_dim_nc(t,time_dim_nc_index),date_array_temp,ref_year_EMEP) !    if (date_array_temp(1).eq.emission_date_array(1).and.date_array_temp(2).eq.emission_date_array(2).and. & !        date_array_temp(3).eq.emission_date_array(3).and.date_array_temp(4).eq.emission_date_array(4)) then !        t_match_index=t !    endif !    write(*,'(4i)') date_array_temp(1:4) !enddo emission_date_number_start = date_to_number ( emission_date_array , ref_year_EMEP ) call number_to_date ( val_dim_nc ( 1 , time_dim_nc_index ), date_array_temp , ref_year_EMEP ) do t = 1 , n_roadlink_emission_time emission_date_number = emission_date_number_start + ( t - 1 ) / 2 4. call number_to_date ( emission_date_number , emission_date_array , ref_year_EMEP ) if ( date_array_temp ( 1 ). eq . emission_date_array ( 1 ). and . date_array_temp ( 2 ). eq . emission_date_array ( 2 ). and . & date_array_temp ( 3 ). eq . emission_date_array ( 3 ). and . date_array_temp ( 4 ). eq . emission_date_array ( 4 )) then t_match_index = t endif !write(*,'(4i)') emission_date_array(1:4) enddo if ( t_match_index . eq . 0 ) then write ( unit_logfile , '(A,6i6)' ) 'ERROR: No starting date found in road emission data: ' , emission_date_array stop else write ( unit_logfile , '(A,6i6)' ) ' Road link emission starting date found. Index: ' , t_match_index write ( unit_logfile , '(A,6i6)' ) ' Road link emission starting date found. Index: ' , t_match_index endif if ( n_roadlink_emission_time - t_match_index + 1. lt . time_index_temp ) then write ( unit_logfile , '(A,2i6)' ) 'ERROR: Not enough time data in road link emission files: ' , n_roadlink_emission_time - t_match_index + 1 , time_index_temp stop else write ( unit_logfile , '(A,6i6)' ) ' Road link emission ending date found. Index: ' , t_match_index + time_index_temp - 1 endif !endif !Allocate the arrays after reading in the number of roads n_roadlink_emission_selected = n_roadlink_emission if ( reduce_roadlink_region_flag ) then n_roadlink_emission_selected = n_roadlinks_major_selected endif allocate ( inputdata_rl_emissions ( n_roadlink_emission_selected , n_roadlink_emission_time , n_roadlink_emission_compound )) allocate ( inputdata_rl_temp ( n_roadlink_emission_time )) allocate ( inputdata_int_rl_id ( n_roadlink_emission_selected )) !Initialise inputdata_rl_temp = 0. counter = 0 !Read the data call nxtdat ( unit_in , nxtdat_flag ) do i = 1 , n_roadlink_emission if ( valid_link_flag ( i )) then counter = counter + 1 read ( unit_in , * , ERR = 20 ) inputdata_int_rl_id ( counter ) !write(*,*) i,inputdata_int_rl_id(i) do j = 1 , n_roadlink_emission_compound read ( unit_in , * ) inputdata_rl_temp ( 1 : n_roadlink_emission_time ) if ( j . le . n_pollutant_loop ) then inputdata_rl_emissions ( counter , 1 : time_index_temp , j ) = inputdata_rl_temp ( t_match_index : t_match_index + time_index_temp - 1 ) endif enddo !write(*,*) counter,inputdata_rl_emissions(counter,10,1),inputdata_rl_emissions(counter,10,2) else read ( unit_in , * , ERR = 20 ) do j = 1 , n_roadlink_emission_compound read ( unit_in , * ) enddo endif enddo write ( unit_logfile , '(a,i)' ) ' Number of road links that should be read = ' , n_roadlink_emission_selected write ( unit_logfile , '(a,i)' ) ' Number of road links read = ' , counter close ( unit_in , status = 'keep' ) !Check that road link ID's match do i = 1 , n_roadlinks if ( inputdata_int_rl ( i , id_rl_index ). ne . inputdata_int_rl_id ( inputdata_int_rl ( i , major_index_rl_index ))) then write ( unit_logfile , '(A,3i12)' ) 'ERROR: Mismatch of road link IDs in the emission files: ' , i , inputdata_int_rl ( i , id_rl_index ), inputdata_int_rl_id ( i ) stop endif enddo if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_id )) deallocate ( inputdata_int_rl_id ) return 20 write ( unit_logfile , '(2A)' ) 'ERROR reading road link emission file: ' , trim ( pathfilename_rl ( 2 )) stop end subroutine uEMEP_read_roadlink_emission_data","tags":"","loc":"proc/uemep_read_roadlink_emission_data.html"},{"title":"uEMEP_change_road_data – uEMEP","text":"public  subroutine uEMEP_change_road_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_change_road_data use uEMEP_definitions implicit none integer i , j character ( 256 ) pathfilename_rl_change integer unit_in integer change_offset_index , change_scale_index , change_replace_index parameter ( change_offset_index = 1 , change_scale_index = 2 , change_replace_index = 3 ) !integer change_adt_index,change_hdv_index,change_speed_index !parameter (change_adt_index=1,change_hdv_index=2,change_speed_index=3) real change_val ( num_var_rl , 3 ) character ( 256 ) temp_str real change_x ( 2 ), change_y ( 2 ) integer count integer change_loop ( 3 ), change_index integer :: n_change_loop = 3 logical :: exists change_loop ( 1 ) = adt_rl_index change_loop ( 2 ) = hdv_rl_index change_loop ( 3 ) = speed_rl_index !If there is no path or file name for the replacement file then do not calculate if ( pathname_rl_change . eq . '' . or . filename_rl_change . eq . '' ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Changing road link data (uEMEP_change_road_data)' write ( unit_logfile , '(A)' ) '================================================================' !Read in replacement file pathfilename_rl_change = trim ( pathname_rl_change ) // trim ( filename_rl_change ) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_rl_change ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Road link change file does not exist: ' , trim ( pathfilename_rl_change ) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_rl_change , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link change file(ascii) ' // trim ( pathfilename_rl_change ) rewind ( unit_in ) !Skip over coordinates header read ( unit_in , * ) temp_str !Read coordinates read ( unit_in , * ) change_x ( 1 ), change_y ( 1 ), change_x ( 2 ), change_y ( 2 ) !write(*,*) change_x(1),change_y(1),change_x(2),change_y(2) !Skip over values header read ( unit_in , * ) temp_str !Read values do j = 1 , n_change_loop change_index = change_loop ( j ) !write(*,*) change_index read ( unit_in , * ) temp_str , change_val ( change_index , change_offset_index ), change_val ( change_index , change_scale_index ), change_val ( change_index , change_replace_index ) !write(*,*) trim(temp_str),change_val(change_index,change_offset_index),change_val(change_index,change_scale_index),change_val(change_index,change_replace_index) enddo close ( unit_in ) !Search for road links. If found change them count = 0 do i = 1 , n_roadlinks if ( inputdata_rl ( i , x0_rl_index ). ge . change_x ( 1 ). and . inputdata_rl ( i , x0_rl_index ). le . change_x ( 2 ). and . & inputdata_rl ( i , y0_rl_index ). ge . change_y ( 1 ). and . inputdata_rl ( i , y0_rl_index ). le . change_y ( 2 )) then count = count + 1 do j = 1 , n_change_loop change_index = change_loop ( j ) inputdata_rl ( i , change_index ) = change_val ( change_index , change_offset_index ) + change_val ( change_index , change_scale_index ) * inputdata_rl ( i , change_index ) if ( change_val ( change_index , change_replace_index ). ne . 0 ) inputdata_rl ( i , change_index ) = change_val ( change_index , change_replace_index ) enddo endif enddo write ( unit_logfile , '(A,i)' ) 'Number of road links changed = ' , count end subroutine uEMEP_change_road_data","tags":"","loc":"proc/uemep_change_road_data.html"},{"title":"read_country_bounding_box_data – uEMEP","text":"public  subroutine read_country_bounding_box_data() Uses uEMEP_definitions Arguments None Source Code subroutine read_country_bounding_box_data !This routine reads in a file that provides information on the country bounding box !as well as reference to the filename used in the OSM files !Is also useful for other purposes but used here only for OSM file names use uEMEP_definitions implicit none logical :: exists integer i character ( 256 ) CNTR_ID character ( 256 ) OSM_country , Long_name real min_lat , min_lon , max_lat , max_lon , min_y_3035 , min_x_3035 , max_y_3035 , max_x_3035 real lon_grid_min , lat_grid_min , lon_grid_max , lat_grid_max real lon_grid_min2 , lat_grid_min2 , lon_grid_max2 , lat_grid_max2 real lon_new_min , lat_new_min , lon_new_max , lat_new_max integer unit_in character ( 256 ) temp_str integer count logical found_country real x_out ( 4 ), y_out ( 4 ) integer :: io !Will fail at lon=-180 !Read in replacement file pathfilename_boundingbox = trim ( pathname_boundingbox ) // trim ( filename_boundingbox ) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_boundingbox ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Bounding box file does not exist: ' , trim ( pathfilename_boundingbox ) stop endif if ( trim ( select_country_by_name ). ne . '' ) then !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_boundingbox , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening Bounding box file  ' // trim ( filename_boundingbox ) rewind ( unit_in ) !Skip over the header !Index\tCNTR_ID\tOSM_country\tmin_lat\tmin_lon\tmax_lat\tmax_lon\tmin_y_3035\tmin_x_3035\tmax_y_3035\tmax_x_3035\t\tLong_name read ( unit_in , * ) temp_str !Read coordinates found_country = . false . do read ( unit_in , * , iostat = io ) i , CNTR_ID , OSM_country , min_lon , min_lat , max_lon , max_lat , min_x_3035 , min_y_3035 , max_x_3035 , max_y_3035 , Long_name if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading file: \" , trim ( pathfilename_boundingbox ) stop 1 end if !write(*,*) i,trim(CNTR_ID),trim(OSM_country),min_lon,min_lat,max_lon,max_lat,min_x_3035,min_y_3035,max_x_3035,max_y_3035,trim(Long_name) if ( index ( trim ( select_country_by_name ), trim ( CNTR_ID )). gt . 0 ) then !Set the min and max lat and lon values for the current grid if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , min_lat , min_lon , y_out ( 1 ), x_out ( 1 )) call ll2utm ( 1 , utm_zone , max_lat , max_lon , y_out ( 2 ), x_out ( 2 )) call ll2utm ( 1 , utm_zone , max_lat , min_lon , y_out ( 3 ), x_out ( 3 )) call ll2utm ( 1 , utm_zone , min_lat , max_lon , y_out ( 4 ), x_out ( 4 )) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , min_lat , min_lon , y_out ( 1 ), x_out ( 1 )) call ll2ltm ( 1 , ltm_lon0 , max_lat , max_lon , y_out ( 2 ), x_out ( 2 )) call ll2ltm ( 1 , ltm_lon0 , max_lat , min_lon , y_out ( 3 ), x_out ( 3 )) call ll2ltm ( 1 , ltm_lon0 , min_lat , max_lon , y_out ( 4 ), x_out ( 4 )) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_out ( 1 ), y_out ( 1 ), min_lon , min_lat , projection_attributes ) call LL2LAEA ( x_out ( 2 ), y_out ( 2 ), max_lon , max_lat , projection_attributes ) call LL2LAEA ( x_out ( 3 ), y_out ( 3 ), min_lon , max_lat , projection_attributes ) call LL2LAEA ( x_out ( 4 ), y_out ( 4 ), max_lon , min_lat , projection_attributes ) endif subgrid_min ( x_dim_index ) = minval ( x_out ) subgrid_max ( x_dim_index ) = maxval ( x_out ) subgrid_min ( y_dim_index ) = minval ( y_out ) subgrid_max ( y_dim_index ) = maxval ( y_out ) !Snap to nearest 10 km subgrid_min ( x_dim_index ) = floor ( subgrid_min ( x_dim_index ) / 1000 0. ) * 10000 subgrid_min ( y_dim_index ) = floor ( subgrid_min ( y_dim_index ) / 1000 0. ) * 10000 subgrid_max ( x_dim_index ) = ceiling ( subgrid_max ( x_dim_index ) / 1000 0. ) * 10000 subgrid_max ( y_dim_index ) = ceiling ( subgrid_max ( y_dim_index ) / 1000 0. ) * 10000 write ( unit_logfile , '(i,a)' ) i , ' Setting grid for ID: ' // trim ( CNTR_ID ) // '   OSM name: ' // trim ( OSM_country ) // '   Name: ' // trim ( Long_name ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_min(x_dim_index)=' , subgrid_min ( x_dim_index ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_min(y_dim_index)=' , subgrid_min ( y_dim_index ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_max(x_dim_index)=' , subgrid_max ( x_dim_index ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_max(y_dim_index)=' , subgrid_max ( y_dim_index ) found_country = . true . endif !Reset the initial subgrid as well, needed for EMEP and receptor selection init_subgrid_min ( x_dim_index ) = subgrid_min ( x_dim_index ) init_subgrid_min ( y_dim_index ) = subgrid_min ( y_dim_index ) init_subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) init_subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) enddo close ( unit_in ) if (. not . found_country ) then write ( unit_logfile , '(a)' ) ' No country with this ID found: ' // trim ( select_country_by_name ) endif endif !Open the file for reading if ( auto_select_OSM_country_flag ) then !Set the min and max lat and lon values for the current grid call PROJ2LL ( subgrid_min ( x_dim_index ), subgrid_min ( y_dim_index ), lon_grid_min , lat_grid_min , projection_attributes , projection_type ) call PROJ2LL ( subgrid_max ( x_dim_index ), subgrid_max ( y_dim_index ), lon_grid_max , lat_grid_max , projection_attributes , projection_type ) call PROJ2LL ( subgrid_min ( x_dim_index ), subgrid_max ( y_dim_index ), lon_grid_min2 , lat_grid_max2 , projection_attributes , projection_type ) call PROJ2LL ( subgrid_max ( x_dim_index ), subgrid_min ( y_dim_index ), lon_grid_max2 , lat_grid_min2 , projection_attributes , projection_type ) lon_grid_max = max ( lon_grid_max , lon_grid_max2 ) lon_grid_min = min ( lon_grid_min , lon_grid_min2 ) lat_grid_max = max ( lat_grid_max , lat_grid_max2 ) lat_grid_min = min ( lat_grid_min , lat_grid_min2 ) !write(*,*) projection_attributes !write(*,*) projection_type !Test !lon_grid_max=5.;lat_grid_max=50. !call LL2LAEA(subgrid_max(x_dim_index),subgrid_max(y_dim_index),lon_grid_max,lat_grid_max,projection_attributes,projection_type) !call LAEA2LL(subgrid_max(x_dim_index),subgrid_max(y_dim_index),lon_grid_max,lat_grid_max,projection_attributes,projection_type) write ( unit_logfile , '(a)' ) ' Opening Bounding box file  ' // trim ( filename_boundingbox ) write ( unit_logfile , '(a,2f12.6)' ) ' Lon (min,max)  ' , lon_grid_min , lon_grid_max write ( unit_logfile , '(a,2f12.6)' ) ' Lat (min,max)  ' , lat_grid_min , lat_grid_max unit_in = 20 open ( unit_in , file = pathfilename_boundingbox , access = 'sequential' , status = 'old' , readonly ) rewind ( unit_in ) !Skip over the header !Index\tCNTR_ID\tOSM_country\tmin_lat\tmin_lon\tmax_lat\tmax_lon\tmin_y_3035\tmin_x_3035\tmax_y_3035\tmax_x_3035\t\tLong_name read ( unit_in , * ) temp_str !Read coordinates count = 0 filename_mrl = '' do read ( unit_in , * , iostat = io ) i , CNTR_ID , OSM_country , min_lon , min_lat , max_lon , max_lat , min_x_3035 , min_y_3035 , max_x_3035 , max_y_3035 , Long_name if ( io /= 0 ) exit !write(*,*) i,trim(CNTR_ID),trim(OSM_country),min_lon,min_lat,max_lon,max_lat,min_x_3035,min_y_3035,max_x_3035,max_y_3035,trim(Long_name) !test the bounding box in lat lon coordinates lon_new_min = max ( min_lon , lon_grid_min ) lat_new_min = max ( min_lat , lat_grid_min ) lon_new_max = min ( max_lon , lon_grid_max ) lat_new_max = min ( max_lat , lat_grid_max ) if ( lon_new_min . gt . lon_new_max . or . lat_new_min . gt . lat_new_max ) then !No intersection so do nothing elseif ( index ( 'none' , trim ( OSM_country )). le . 0 ) then !update and attribute the filename count = count + 1 if ( count . gt . 50 ) then write ( unit_logfile , '(a)' ) ' Max files are 50. Stopping  ' stop endif filename_mrl ( count ) = 'Road_data_OSM_' // trim ( OSM_country ) // '_latlon.txt' write ( unit_logfile , '(2i,a)' ) count , i , ' Including OSM file:  ' // trim ( filename_mrl ( count )) endif enddo if ( count . eq . 0 ) then write ( unit_logfile , '(a)' ) ' No countries overlap this area. Setting OSM to default file andorra' OSM_country = 'andorra' ; count = 1 filename_mrl ( count ) = 'Road_data_OSM_' // trim ( OSM_country ) // '_latlon.txt' num_multiple_roadlink_files = count else write ( unit_logfile , '(a,i)' ) ' Specifying this many OSM road link files to be read' , count num_multiple_roadlink_files = count endif close ( unit_in ) endif !stop end subroutine read_country_bounding_box_data","tags":"","loc":"proc/read_country_bounding_box_data.html"},{"title":"uEMEP_aggregate_proxy_emission_in_EMEP_grid – uEMEP","text":"private  subroutine uEMEP_aggregate_proxy_emission_in_EMEP_grid() Arguments None Source Code subroutine uEMEP_aggregate_proxy_emission_in_EMEP_grid () ! This routine takes subgrid emissions and aggregates them in the EMEP grid ! This is used for cross checking emissions integer :: i , j integer :: i_source real , allocatable :: EMEP_aggregated_subgid_emission (:,:) real , allocatable :: EMEP_aggregated_emission (:,:) integer , allocatable :: EMEP_aggregated_subgid_emission_count (:,:) real , allocatable :: lon_array (:,:), lat_array (:,:) integer :: iii , jjj character ( 256 ) :: temp_name real :: var3d_nc_local_temp integer :: t integer :: i_nc_source integer :: i_subsource = 1 integer :: i_pollutant , p_loop allocate ( EMEP_aggregated_subgid_emission_count ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( EMEP_aggregated_subgid_emission ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( EMEP_aggregated_emission ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( lon_array ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( lat_array ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) EMEP_aggregated_subgid_emission = 0.0 EMEP_aggregated_subgid_emission_count = 0 t = 1 unit_conversion = 1.0 ! Units should be specified in the reading emission files ! Loop through the emission grid and aggregate data ! Units are the same as EMEP mg/m2 do i_pollutant = 1 , n_pollutant_loop p_loop = pollutant_loop_index ( i_pollutant ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then if ( make_EMEP_grid_emission_data ( i_source )) then write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Aggregating proxy emissions in EMEP grids for diagnostics (uEMEP_aggregate_proxy_emission_in_EMEP_grid)' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving proxy subgrid emissions in EMEP grid (' // trim ( source_file_str ( i_source )) // '_' // trim ( pollutant_file_str ( p_loop )) // ')' if ( i_source . eq . agriculture_index ) then i_nc_source = agriculture_nc_index elseif ( i_source . eq . traffic_index ) then i_nc_source = traffic_nc_index elseif ( i_source . eq . shipping_index ) then i_nc_source = shipping_nc_index elseif ( i_source . eq . heating_index ) then i_nc_source = heating_nc_index else write ( unit_logfile , '(A)' ) 'Undefined source in routine uEMEP_aggregate_proxy_emission_in_EMEP_grid. Stopping' stop 1 end if EMEP_aggregated_subgid_emission = 0.0 EMEP_aggregated_emission = 0.0 EMEP_aggregated_subgid_emission_count = 0 do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) ! Get indexes iii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) jjj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) EMEP_aggregated_subgid_emission_count ( iii , jjj ) = EMEP_aggregated_subgid_emission_count ( iii , jjj ) + 1 ! Calculate as tonnes per year EMEP_aggregated_subgid_emission ( iii , jjj ) = EMEP_aggregated_subgid_emission ( iii , jjj ) & + proxy_emission_subgrid ( i , j , i_source , i_pollutant ) * emission_factor_conversion ( compound_index , i_source , i_subsource ) & * 1.0e-12 * 360 0.0 * 2 4.0 * 36 5.0 ! Conversion from ug/sec/subgrid to ton/year if ( hourly_calculations ) then EMEP_aggregated_emission ( iii , jjj ) = EMEP_aggregated_emission ( iii , jjj ) & + sum ( var3d_nc ( iii , jjj ,:, emis_nc_index , allsource_index , i_pollutant )) / dim_length_nc ( time_dim_nc_index ) & * ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) * 1.0e-9 * 2 4.0 * 36 5.0 ! Conversion from mg/m2/hr to ton/year (EMEP) ! NOTE: Have put in allsource_index because on this occasion there were no sectors in the EMEP file for this. Beware for later comparisons!!! end if if ( annual_calculations ) then EMEP_aggregated_emission ( iii , jjj ) = EMEP_aggregated_emission ( iii , jjj ) + sum ( var3d_nc ( iii , jjj ,:, emis_nc_index , i_nc_source , i_pollutant )) / dim_length_nc ( time_dim_nc_index ) & * ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) * 1.0e-9 ! Conversion from mg/m2/yr to ton/year (EMEP) end if end do end do do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) if ( EMEP_aggregated_subgid_emission_count ( i , j ) . gt . 0 ) then EMEP_aggregated_subgid_emission ( i , j ) = EMEP_aggregated_subgid_emission ( i , j ) !/EMEP_aggregated_subgid_emission_count(i,j) EMEP_aggregated_emission ( i , j ) = EMEP_aggregated_emission ( i , j ) !/EMEP_aggregated_subgid_emission_count(i,j) else EMEP_aggregated_subgid_emission ( i , j ) = 0.0 EMEP_aggregated_emission ( i , j ) = 0.0 end if lon_array ( i , j ) = var1d_nc ( i , x_dim_nc_index ) lat_array ( i , j ) = var1d_nc ( j , y_dim_nc_index ) end do end do ! Check this. This is no longer valid and does not take into account neighbouring grids. Do not use if ( replace_EMEP_local_with_subgrid_local ( i_source )) then do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) if ( EMEP_aggregated_subgid_emission ( i , j ) . ge . 0 . and . var3d_nc ( i , j , t , emis_nc_index , i_nc_source , i_pollutant ) . gt . 0 ) then var3d_nc_local_temp = var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) * ( 1.0 - var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant )) ! nonlocal contribution var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant ) = EMEP_aggregated_subgid_emission ( i , j ) / var3d_nc ( i , j , t , emis_nc_index , i_nc_source , i_pollutant ) * var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant ) ! New local fraction var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) = var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) * var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant ) + var3d_nc_local_temp ! new total contribution var3d_nc ( i , j , t , conc_nc_index , allsource_index , i_pollutant ) = var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) end if end do end do end if temp_name = trim ( pathname_grid ( emission_file_index ( i_source ))) // trim ( filename_grid ( emission_file_index ( i_source ))) // '_' // trim ( pollutant_file_str ( p_loop )) // '_aggregated_proxy_EMEP_' // trim ( file_tag ) // '.asc' write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name ) write ( unit_logfile , '(a,f12.2)' ) 'Total local emissions (ton/year): ' , sum ( EMEP_aggregated_subgid_emission ) call write_esri_ascii_file ( temp_name , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dgrid_nc ( lat_nc_index ), EMEP_aggregated_subgid_emission (:,:), lon_array , lat_array ) temp_name = trim ( pathname_grid ( emission_file_index ( i_source ))) // trim ( filename_grid ( emission_file_index ( i_source ))) // '_' // trim ( pollutant_file_str ( p_loop )) // '_EMEP_' // trim ( file_tag ) // '.asc' write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name ) write ( unit_logfile , '(a,f12.2)' ) 'Total EMEP emissions (ton/year): ' , sum ( EMEP_aggregated_emission ) call write_esri_ascii_file ( temp_name , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dgrid_nc ( lat_nc_index ), EMEP_aggregated_emission (:,:), lon_array , lat_array ) write ( unit_logfile , '(a,f12.4)' ) 'Ratio of local to EMEP emissions: ' , sum ( EMEP_aggregated_subgid_emission ) / sum ( EMEP_aggregated_emission ) end if end if end do end do if ( allocated ( EMEP_aggregated_subgid_emission_count )) deallocate ( EMEP_aggregated_subgid_emission_count ) if ( allocated ( EMEP_aggregated_subgid_emission )) deallocate ( EMEP_aggregated_subgid_emission ) if ( allocated ( EMEP_aggregated_emission )) deallocate ( EMEP_aggregated_emission ) if ( allocated ( lon_array )) deallocate ( lon_array ) if ( allocated ( lat_array )) deallocate ( lat_array ) end subroutine uEMEP_aggregate_proxy_emission_in_EMEP_grid","tags":"","loc":"proc/uemep_aggregate_proxy_emission_in_emep_grid.html"},{"title":"uEMEP_calculate_emissions_for_EMEP – uEMEP","text":"public  subroutine uEMEP_calculate_emissions_for_EMEP() Arguments None Source Code subroutine uEMEP_calculate_emissions_for_EMEP implicit none !double precision :: EMEP_projection_attributes(10) !real, allocatable :: EMEP_emissions_grid(:,:,:,:,:) !x,y,t,source,pollutant integer a_start ( 6 ), date_array ( 6 ), a_start_emission ( 6 ) character ( 256 ) format_temp double precision date_num_temp , date_num_start , date_num_start_emission integer t , i_source , i , j write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving emission data for EMEP (uEMEP_calculate_emissions_for_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !Read in example EMEP file for dimensions and projection information !Or just defne them here without reading if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then EMEP_projection_type = LCC_projection_index !grid_mapping_name = \"lambert_conformal_conic\"; !float i(i=531); !standard_name = \"projection_x_coordinate\"; !long_name = \"x-coordinate in Cartesian system\"; !units = \"m\"; !axis = \"X\"; if ( trim ( save_emissions_for_EMEP_region ). eq . 'NO' ) then emission_subgrid_min ( x_dim_index ,:) = save_emission_subgrid_min ( x_dim_index ) emission_subgrid_delta ( x_dim_index ,:) = save_emission_subgrid_delta ( x_dim_index ) emission_subgrid_dim ( x_dim_index ,:) = save_emission_subgrid_dim ( x_dim_index ) emission_max_subgrid_dim ( x_dim_index ) = save_emission_subgrid_dim ( x_dim_index ) !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( x_dim_index ,:) = emission_subgrid_min ( x_dim_index ,:) - emission_subgrid_delta ( x_dim_index ,:) / 2. !float j(j=671); !standard_name = \"projection_y_coordinate\"; !long_name = \"y-coordinate in Cartesian system\"; !units = \"m\"; !axis = \"Y\"; emission_subgrid_min ( y_dim_index ,:) = save_emission_subgrid_min ( y_dim_index ) emission_subgrid_delta ( y_dim_index ,:) = save_emission_subgrid_delta ( y_dim_index ) emission_subgrid_dim ( y_dim_index ,:) = save_emission_subgrid_dim ( y_dim_index ) emission_max_subgrid_dim ( y_dim_index ) = save_emission_subgrid_dim ( y_dim_index ) !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( y_dim_index ,:) = emission_subgrid_min ( y_dim_index ,:) - emission_subgrid_delta ( y_dim_index ,:) / 2. !if(use_meteo_file_for_emission_gridding_flag) then !   call uEMEP_read_meteo_nc !    emission_subgrid_min(x_dim_index,:)=-6.498834E+05 ! 6.751166E+05 !   emission_subgrid_delta(x_dim_index,:)=2500. !   emission_subgrid_dim(x_dim_index,:)=531 !    emission_max_subgrid_dim(x_dim_index)=531 !Move minium to edge, for consistency with normal subgrid definition !    emission_subgrid_min(x_dim_index,:)=emission_subgrid_min(x_dim_index,:)-emission_subgrid_delta(x_dim_index,:)/2. !endif else write ( unit_logfile , '(A)' ) 'ERROR: Emission region ' // trim ( save_emissions_for_EMEP_region ) // ' not currently defined for lambert coordinates' stop endif elseif ( trim ( save_emissions_for_EMEP_projection ). eq . 'latlon' ) then EMEP_projection_type = LL_projection_index write ( unit_logfile , '(A,i)' ) 'Projection of emission grid set to ' // trim ( save_emissions_for_EMEP_projection ), EMEP_projection_type if ( trim ( save_emissions_for_EMEP_region ). eq . 'NL' ) then emission_subgrid_min ( x_dim_index ,:) = 3.0 emission_subgrid_delta ( x_dim_index ,:) = 0.25 emission_subgrid_dim ( x_dim_index ,:) = floor (( 8. - 3. ) / 0.25 ) + 1 emission_max_subgrid_dim ( x_dim_index ) = floor (( 8. - 3. ) / 0.25 ) + 1 !Full EMEP European domain emission_subgrid_min ( x_dim_index ,:) =- 3 0. emission_subgrid_delta ( x_dim_index ,:) = 0.25 emission_subgrid_dim ( x_dim_index ,:) = floor (( 4 5. + 3 0. ) / 0.25 ) + 1 emission_max_subgrid_dim ( x_dim_index ) = floor (( 4 5. + 3 0. ) / 0.25 ) + 1 !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( x_dim_index ,:) = emission_subgrid_min ( x_dim_index ,:) - emission_subgrid_delta ( x_dim_index ,:) / 2. !float j(j=671); !standard_name = \"projection_y_coordinate\"; !long_name = \"y-coordinate in Cartesian system\"; !units = \"m\"; !axis = \"Y\"; emission_subgrid_min ( y_dim_index ,:) = 5 0. emission_subgrid_delta ( y_dim_index ,:) = 0.125 emission_subgrid_dim ( y_dim_index ,:) = floor (( 5 4. - 5 0. ) / 0.125 ) + 1 emission_max_subgrid_dim ( y_dim_index ) = floor (( 5 4. - 5 0. ) / 0.125 ) + 1 !Full EMEP European domain emission_subgrid_min ( y_dim_index ,:) = 3 0. emission_subgrid_delta ( y_dim_index ,:) = 0.125 emission_subgrid_dim ( y_dim_index ,:) = floor (( 7 6. - 3 0. ) / 0.125 ) + 1 emission_max_subgrid_dim ( y_dim_index ) = floor (( 7 6. - 3 0. ) / 0.125 ) + 1 !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( y_dim_index ,:) = emission_subgrid_min ( y_dim_index ,:) - emission_subgrid_delta ( y_dim_index ,:) / 2. else write ( unit_logfile , '(A)' ) 'ERROR: Emission region ' // trim ( save_emissions_for_EMEP_region ) // ' not currently defined for lat lon coordinates' stop endif else write ( unit_logfile , '(A)' ) 'ERROR: Emission projection ' // trim ( save_emissions_for_EMEP_projection ) // ' not currently defined' stop endif !subgrid_dim(t_dim_index)=save_emissions_end_index-save_emissions_start_index+1 subgrid_dim ( t_dim_index ) = save_emissions_end_index dim_length_nc ( x_dim_nc_index ) = emission_subgrid_dim ( x_dim_index , allsource_index ) dim_length_nc ( y_dim_nc_index ) = emission_subgrid_dim ( y_dim_index , allsource_index ) dim_length_nc ( time_dim_nc_index ) = subgrid_dim ( t_dim_index ) write ( unit_logfile , '(a,3i6)' ) 'EMEP emission grid dimensions: ' , emission_subgrid_dim ( x_dim_index , allsource_index ), emission_subgrid_dim ( y_dim_index , allsource_index ), dim_length_nc ( time_dim_nc_index ) if (. not . allocated ( val_dim_nc )) allocate ( val_dim_nc ( maxval ( dim_length_nc ), num_dims_nc )) !x, y, z and time dimension values if (. not . allocated ( unit_dim_nc )) allocate ( unit_dim_nc ( num_dims_nc )) !x, y, z and time dimension values !Define the emission subgrid to correspond to the EMEP grid if (. not . allocated ( emission_subgrid )) allocate ( emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( proxy_emission_subgrid )) allocate ( proxy_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( x_emission_subgrid )) allocate ( x_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( y_emission_subgrid )) allocate ( y_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lon_emission_subgrid )) allocate ( lon_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lat_emission_subgrid )) allocate ( lat_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( emission_time_profile_subgrid )) allocate ( emission_time_profile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( emission_properties_subgrid )) allocate ( emission_properties_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_emission_index , n_source_index )) !Set the timing data. Assumes no single loops with the time based on the input date and array length defined by the length of the EMEP input data format_temp = 'yyyymmddHH' call datestr_to_date ( config_date_str , format_temp , a_start ) !Assumes it starts at hour 1 !a_start(4)=1 !Do not assume it starts at hour 1 any more a_start ( 5 : 6 ) = 0 a_start_emission = a_start date_num_start = date_to_number ( a_start , ref_year_EMEP ) !Move the starting time according to the index value given (index is the number of hours) date_num_start_emission = date_num_start + dble ( save_emissions_start_index - 1 ) / 2 4. !Set the emission_date_str to be used to name the output file as this may not be the same as the input file call number_to_date ( date_num_start , a_start , ref_year_EMEP ) call number_to_date ( date_num_start_emission , a_start_emission , ref_year_EMEP ) call date_to_datestr ( a_start_emission , format_temp , emission_date_str ) !Do not do this now emission_date_str = config_date_str !write(*,*) config_date_str,emission_date_str !long_name = \"time at middle of period\"; unit_dim_nc ( time_dim_nc_index ) = \"days since 1900-1-1 0:0:0\" ; do t = 1 , subgrid_dim ( t_dim_index ) date_num_temp = date_num_start + dble ( t - 1 ) / 2 4. + dble ( 0.0001 ) / dble ( 2 4. ) / dble ( 360 0. ) !Add 0.0001 of a second to avoid any rounding off errors call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) write ( * , '(6i6)' ) date_array ( 1 : 6 ) val_dim_nc ( t , time_dim_nc_index ) = date_num_temp enddo unit_dim_nc ( x_dim_nc_index ) = 'm' unit_dim_nc ( y_dim_nc_index ) = 'm' !Define emission grids do i_source = 1 , n_source_index if ( save_emissions_for_EMEP ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) x_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( x_dim_index , i_source ) + emission_subgrid_delta ( x_dim_index , i_source ) * ( i - 0.5 ) y_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( y_dim_index , i_source ) + emission_subgrid_delta ( y_dim_index , i_source ) * ( j - 0.5 ) if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call lambert2lb2_uEMEP ( x_emission_subgrid ( i , j , i_source ), y_emission_subgrid ( i , j , i_source ) & , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) elseif ( trim ( save_emissions_for_EMEP_projection ). eq . 'latlon' ) then lon_emission_subgrid ( i , j , i_source ) = x_emission_subgrid ( i , j , i_source ) lat_emission_subgrid ( i , j , i_source ) = y_emission_subgrid ( i , j , i_source ) else write ( unit_logfile , '(A)' ) 'ERROR: Emission projection ' // trim ( save_emissions_for_EMEP_projection ) // ' not currently defined' stop endif !write(*,*) x_emission_subgrid(i,j,i_source),y_emission_subgrid(i,j,i_source),lon_emission_subgrid(i,j,i_source),lat_emission_subgrid(i,j,i_source) enddo enddo if ( i_source . eq . industry_index ) then !Read in industry data call uEMEP_read_industry_data call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif if ( i_source . eq . agriculture_index ) then !Read agriculture data call uEMEP_read_agriculture_rivm_data call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif if ( i_source . eq . traffic_index ) then g_loop = 1 !Read inthe road data call uEMEP_read_roadlink_data_ascii if ( use_NORTRIP_emission_data ) then call uEMEP_read_roadlink_emission_data endif !Redefine the road link positions to correspond to the EMEP coordinates !Grid the data. Road link coordinates will be redefined within this routine call uEMEP_grid_roads !call uEMEP_read_time_profiles !call uEMEP_set_emission_factors !call uEMEP_convert_proxy_to_emissions !Adjust traffic emissions of NOx based on temperature if ( use_traffic_nox_emission_temperature_dependency ) then use_alternative_meteorology_flag = . true . !Set the maximum dimension to that which is necessary. Minimum is not changed as it is selected in uEMEP_save_emission_netcdf end_time_meteo_nc_index = start_time_meteo_nc_index + ( save_emissions_end_index - 1 ) call uEMEP_read_meteo_nc !call uEMEP_subgrid_meteo_EMEP !call uEMEP_crossreference_grids call uEMEP_nox_emission_temperature endif endif if ( i_source . eq . heating_index ) then !meteo_var3d_nc(i_nc,j_nc,:,t2m_nc_index) !Read the heating data. Emission grid coordinates will be redefined within this routine !Must set g_loop=1 for it to read g_loop = 1 call uEMEP_read_RWC_heating_data !Read in the temperature fields from the alternative meteorology always, since EMEP data should not exist yet use_alternative_meteorology_flag = . true . !Set the maximum dimension to that which is necessary. Minimum is not changed as it is selected in uEMEP_save_emission_netcdf !start_time_meteo_nc_index=start_time_meteo_nc_index+(save_emissions_start_index-1) end_time_meteo_nc_index = start_time_meteo_nc_index + ( save_emissions_end_index - 1 ) call uEMEP_read_meteo_nc !Need to make a cross reference here or simply skip the two based on an if statement call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif if ( i_source . eq . shipping_index ) then !meteo_var3d_nc(i_nc,j_nc,:,t2m_nc_index) !Read the heating data. Emission grid coordinates will be redefined within this routine !Must set g_loop=1 for it to read g_loop = 1 if ( read_weekly_shipping_data_flag ) then call uEMEP_read_weekly_shipping_asi_data elseif ( read_monthly_and_daily_shipping_data_flag ) then call uEMEP_read_monthly_and_daily_shipping_asi_data else call uEMEP_read_shipping_asi_data endif !Read in the temperature fields from the alternative meteorology always, since EMEP data should not exist yet !use_alternative_meteorology_flag=.true. !call uEMEP_read_meteo_nc !Need to make a cross reference here or simply skip the two based on an if statement call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif endif enddo call uEMEP_save_emission_netcdf write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(a)' ) 'Finished saving emission data for EMEP.' write ( unit_logfile , '(A)' ) '================================================================' stop end subroutine uEMEP_calculate_emissions_for_EMEP","tags":"","loc":"proc/uemep_calculate_emissions_for_emep.html"},{"title":"uEMEP_save_emission_netcdf – uEMEP","text":"private  subroutine uEMEP_save_emission_netcdf() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_save_emission_netcdf use uEMEP_definitions implicit none character ( 256 ) temp_date_str , temp_compound_str , variable_type , unit_str , temp_name , var_name_temp , title_str logical create_file real scale_factor , valid_min integer i_file , i_pollutant , i_source real , allocatable :: temp_subgrid (:,:,:) logical :: exists integer temp_time_dim integer i , j temp_time_dim = save_emissions_end_index - save_emissions_start_index + 1 write ( unit_logfile , '(A,3i6)' ) 'Time dimensions to be saved: ' , save_emissions_start_index , save_emissions_end_index , temp_time_dim if (. not . allocated ( temp_subgrid )) allocate ( temp_subgrid ( emission_subgrid_dim ( x_dim_index , allsource_index ), emission_subgrid_dim ( y_dim_index , allsource_index ), temp_time_dim )) valid_min = 0. unit_str = \"ug/m3\" !variable_type='byte' !variable_type='double' variable_type = 'float' scale_factor = 1. !Save the data !i_file=subgrid_total_file_index(allsource_index) !temp_name=trim(pathname_grid(i_file))//trim(filename_grid(i_file))//'_'//trim(file_tag)//'.nc' if ( len ( emission_date_str ). gt . 0 ) then temp_date_str = '_' // trim ( emission_date_str ) else temp_date_str = '' endif !Do not use the actual emission start date for the file name but use the format specified by filename_date_output_grid if ( len ( filename_date_output_grid ). gt . 0 ) then temp_date_str = '_' // trim ( filename_date_output_grid ) else temp_date_str = '' endif !Do not write 'all' in file name if all compounds are selected if ( pollutant_index . eq . all_nc_index ) then temp_compound_str = '' else temp_compound_str = '_' // trim ( var_name_nc ( conc_nc_index , compound_index , allsource_index )) endif title_str = 'uEMEP_emission_' // trim ( file_tag ) // temp_date_str i_file = subgrid_total_file_index ( allsource_index ) write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving emission netcdf data (uEMEP_save_emission_netcdf)' write ( unit_logfile , '(A)' ) '================================================================' inquire ( file = trim ( pathname_emissions_for_EMEP ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A)' ) 'ERROR: Path to EMEP emission output ' // trim ( pathname_emissions_for_EMEP ) // ' does not exist.' stop endif !Save the emissions interpolated to the target grid variable_type = 'float' unit_str = \"mg/m2\" do i_source = 1 , n_source_index if ( save_emissions_for_EMEP ( i_source ). and . i_source . ne . allsource_index ) then !Create a new file for each source create_file = . true . !temp_name=trim(pathname_emissions_for_EMEP)//'uEMEP_emission_for_EMEP_'//trim(file_tag)//'_'//trim(source_file_str(i_source))//trim(temp_compound_str)//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' temp_name = trim ( pathname_emissions_for_EMEP ) // 'uEMEP_emission_for_EMEP_' // trim ( file_tag ) // '_' // trim ( source_file_str ( i_source )) // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.nc' write ( unit_logfile , '(a,a)' ) 'Saving netcdf file: ' , trim ( temp_name ) do i_pollutant = 1 , n_pollutant_loop !if (pollutant_loop_index(i_pollutant).ne.pmex_nc_index.and.pollutant_loop_index(i_pollutant).ne.pm10_sand_nc_index.and.pollutant_loop_index(i_pollutant).ne.pm10_salt_nc_index & !    .and.pollutant_loop_index(i_pollutant).ne.pm25_sand_nc_index.and.pollutant_loop_index(i_pollutant).ne.pm25_salt_nc_index) then if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . nh3_nc_index & . or .( pollutant_loop_index ( i_pollutant ). eq . pmex_nc_index . and . i_source . eq . traffic_index )) then i_file = emission_file_index ( i_source ) var_name_temp = trim ( var_name_nc ( emis_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) !//'_'//trim(filename_grid(i_file)) !Calculate the emissions in the target grid temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , i_pollutant ) if ( save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag . and . i_source . eq . traffic_index . and . pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pm25_nc_index , allsource_index )) // '_' // 'nonexhaust' temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm25_nc_index )) - emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pmex_nc_index )) endif if ( save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag . and . i_source . eq . traffic_index . and . pollutant_loop_index ( i_pollutant ). eq . pmex_nc_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pm25_nc_index , allsource_index )) // '_' // 'exhaust' temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pmex_nc_index )) endif !Convert the PM10 to PMco, special case if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pmco_nc_index , allsource_index )) !//'_'//trim(filename_grid(i_file)) temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm10_nc_index )) - emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm25_nc_index )) if ( save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag . and . i_source . eq . traffic_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pmco_nc_index , allsource_index )) // '_' // 'nonexhaust' temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm10_nc_index )) & - emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm25_nc_index )) endif endif !Subgrid emissions are in units ug/sec/subgrid. Convert to mg/m2/hour. Acount for the difference in subgrid sizes here if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then temp_subgrid (:,:,:) = 1.0e-3 * 360 0. * temp_subgrid (:,:,:) / ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) else !Temporary estimate of area of lat lon. Needs to be fixed do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) temp_subgrid ( i , j ,:) = 1.0e-3 * 360 0. * temp_subgrid ( i , j ,:) / ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source ) & * 11057 0. * 11057 0. * cos ( 3.14159 / 18 0. * y_emission_subgrid ( i , j , i_source ))) enddo enddo endif !write(*,'(4i,a)') i_pollutant,i_file,i_source,pollutant_loop_index(i_pollutant),trim(var_name_temp) if ( save_netcdf_file_flag . or . save_netcdf_receptor_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_for_EMEP_netcdf_file ( temp_name , emission_subgrid_dim ( x_dim_index , i_source ), emission_subgrid_dim ( y_dim_index , i_source ), temp_time_dim & , temp_subgrid (:,:,:), x_emission_subgrid (:,:, i_source ), y_emission_subgrid (:,:, i_source ), lon_emission_subgrid (:,:, i_source ), lat_emission_subgrid (:,:, i_source ), var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif !Do not create file after first loop create_file = . false . endif enddo endif enddo end subroutine uEMEP_save_emission_netcdf","tags":"","loc":"proc/uemep_save_emission_netcdf.html"},{"title":"uEMEP_save_for_EMEP_netcdf_file – uEMEP","text":"private  subroutine uEMEP_save_for_EMEP_netcdf_file(filename_netcdf, nx, ny, nt, val_array, x_array, y_array, lon_array, lat_array, name_array, unit_array, title_str, create_file, valid_min, variable_type, scale_factor) Uses uEMEP_definitions netcdf Arguments Type Intent Optional Attributes Name character(len=256) :: filename_netcdf integer :: nx integer :: ny integer :: nt real :: val_array (nx,ny,nt) real :: x_array (nx,ny) real :: y_array (nx,ny) real :: lon_array (nx,ny) real :: lat_array (nx,ny) character(len=256) :: name_array character(len=256) :: unit_array character(len=256) :: title_str logical :: create_file real :: valid_min character(len=256) :: variable_type real :: scale_factor Source Code subroutine uEMEP_save_for_EMEP_netcdf_file ( filename_netcdf , nx , ny , nt , val_array , x_array , y_array , lon_array , lat_array , name_array , unit_array , title_str , create_file , valid_min , variable_type , scale_factor ) use uEMEP_definitions use netcdf implicit none character ( 256 ) filename_netcdf , name_array , unit_array , title_str , temp_name integer nx , ny , nt real val_array ( nx , ny , nt ) !,val_array_temp(nx,ny,nt) real x_array ( nx , ny ) real y_array ( nx , ny ) real lon_array ( nx , ny ) real lat_array ( nx , ny ) !,lat_array_temp(nx,ny) !real time_array(nt) real x_vector ( nx ) real y_vector ( ny ) logical create_file real valid_min character ( 256 ) variable_type real scale_factor integer ncid integer y_dimid , x_dimid , time_dimid integer y_varid , x_varid , lat_varid , lon_varid , val_varid , time_varid , proj_varid integer dimids3 ( 3 ), dimids2 ( 2 ), chunks3 ( 3 ) integer n_dims ( 3 ) integer status integer nf90_type if ( trim ( variable_type ). eq . 'byte' ) nf90_type = NF90_BYTE if ( trim ( variable_type ). eq . 'short' ) nf90_type = NF90_SHORT if ( trim ( variable_type ). eq . 'float' ) nf90_type = NF90_FLOAT if ( trim ( variable_type ). eq . 'double' ) nf90_type = NF90_DOUBLE !Assumes x and y are the dimensions x_vector = x_array (:, 1 ) y_vector = y_array ( 1 ,:) !write(*,*) x_vector !write(*,*) y_vector if ( create_file ) then !Create a netcdf file !call check(  nf90_create(filename_netcdf, nf90_clobber, ncid) ) !call check(  nf90_create(filename_netcdf, NF90_HDF5, ncid) ) call check ( nf90_create ( filename_netcdf , IOR ( NF90_HDF5 , NF90_CLASSIC_MODEL ), ncid ) ) !New !Specify global attributes call check ( nf90_put_att ( ncid , nf90_global , \"Conventions\" , \"CF-1.4\" ) ) call check ( nf90_put_att ( ncid , nf90_global , \"title\" , trim ( title_str )) ) call check ( nf90_put_att ( ncid , nf90_global , \"Model\" , \"uEMEP emissions for EMEP\" ) ) !Projection data if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call check ( nf90_def_var ( ncid , \"projection_lambert\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"standard_parallel\" , EMEP_projection_attributes ( 1 : 2 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , EMEP_projection_attributes ( 3 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"lambert_conformal_conic\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , EMEP_projection_attributes ( 4 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"earth_radius\" , EMEP_projection_attributes ( 5 ) ) ) endif !Define the dimensions call check ( nf90_def_dim ( ncid , \"time\" , NF90_UNLIMITED , time_dimid ) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_def_dim ( ncid , \"y\" , ny , y_dimid ) ) call check ( nf90_def_dim ( ncid , \"x\" , nx , x_dimid ) ) !else !call check(  nf90_def_dim(ncid, \"lat\", ny, y_dimid) ) !call check(  nf90_def_dim(ncid, \"lon\", nx, x_dimid) ) !endif !Define the dimension variables call check ( nf90_def_var ( ncid , \"time\" , NF90_DOUBLE , time_dimid , time_varid ) ) !call check(  nf90_def_var(ncid, \"time\", NF90_INT, time_dimid, time_varid) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_def_var ( ncid , \"y\" , NF90_REAL , y_dimid , y_varid ) ) call check ( nf90_def_var ( ncid , \"x\" , NF90_REAL , x_dimid , x_varid ) ) !else !call check(  nf90_def_var(ncid, \"lat\", NF90_REAL, y_dimid, y_varid) ) !call check(  nf90_def_var(ncid, \"lon\", NF90_REAL, x_dimid, x_varid) ) !endif !Define the values dimids3 = ( / x_dimid , y_dimid , time_dimid / ) dimids2 = ( / x_dimid , y_dimid / ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_def_var ( ncid , \"lat\" , NF90_REAL , dimids2 , lat_varid ) ) call check ( nf90_def_var ( ncid , \"lon\" , NF90_REAL , dimids2 , lon_varid ) ) !endif !Specify the units call check ( nf90_put_att ( ncid , lat_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , lon_varid , \"units\" , \"degrees_east\" ) ) if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"m\" ) ) else call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"degrees_east\" ) ) endif call check ( nf90_put_att ( ncid , time_varid , \"units\" , trim ( unit_dim_nc ( time_dim_nc_index ))) ) !Specify other dimension attributes !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_put_att ( ncid , y_varid , \"standard_name\" , \"projection_y_coordinate\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"standard_name\" , \"projection_x_coordinate\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"axis\" , \"Y\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"axis\" , \"X\" ) ) !else !call check(  nf90_put_att(ncid, y_varid, \"standard_name\", \"latitude\") ) !call check(  nf90_put_att(ncid, x_varid, \"standard_name\", \"longitude\") ) !endif !Close the definitions call check ( nf90_enddef ( ncid ) ) !write(*,*) 'here6',shape(val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index)) !write(*,*) val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index) call check ( nf90_put_var ( ncid , time_varid , val_dim_nc ( save_emissions_start_index : save_emissions_end_index , time_dim_nc_index )) ) !call check( nf90_put_var(ncid, time_varid, time_seconds_output(1:dim_length_nc(time_dim_nc_index))) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_put_var ( ncid , y_varid , y_vector ) ) call check ( nf90_put_var ( ncid , x_varid , x_vector ) ) call check ( nf90_put_var ( ncid , lat_varid , lat_array ) ) call check ( nf90_put_var ( ncid , lon_varid , lon_array ) ) !else !call check( nf90_put_var(ncid, y_varid, y_vector) ) !call check( nf90_put_var(ncid, x_varid, x_vector) ) !endif call check ( nf90_close ( ncid ) ) endif !Add to the existing file call check ( nf90_open ( filename_netcdf , NF90_WRITE , ncid ) ) !Get the dimensions id from the existing file call check ( nf90_inq_dimid ( ncid , \"time\" , time_dimid ) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_inq_dimid ( ncid , \"y\" , y_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"x\" , x_dimid ) ) !else !call check( nf90_inq_dimid(ncid, \"lat\", y_dimid) ) !call check( nf90_inq_dimid(ncid, \"lon\", x_dimid) ) !endif dimids3 = ( / x_dimid , y_dimid , time_dimid / ) chunks3 = ( / nx , ny , 1 / ) !New call check ( nf90_inquire_dimension ( ncid , dimids3 ( 1 ), temp_name , n_dims ( 1 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 2 ), temp_name , n_dims ( 2 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 3 ), temp_name , n_dims ( 3 )) ) !write(*,*) 'here7' status = nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) if ( status . ne . nf90_NoErr ) then call check ( nf90_redef ( ncid ) ) !if the variable does not exist then create a new one !write(*,*) 'Creating new: ',trim(name_array) call check ( nf90_def_var ( ncid , trim ( name_array ), nf90_type , dimids3 , val_varid ) ) ! gzip level 3 compression and shuffling ! optional _FillValue for values which never have been written, unpacked value call check ( nf90_def_var_chunking ( ncid , val_varid , NF90_CHUNKED , chunks3 ) ) !New call check ( nf90_def_var_deflate ( ncid , val_varid , 1 , 1 , 3 ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"units\" , trim ( unit_array )) ) !Specify other variable attributes if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 1 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 2 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 2 )) ) else call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , NODATA_value ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , valid_min ) ) endif !write(*,*) 'here8' if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_lambert\" ) ) else call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"latitude_longitude\" ) ) endif !write(*,*) 'here9' call check ( nf90_put_att ( ncid , val_varid , \"coordinates\" , \"lon lat\" ) ) if ( scale_factor . ne . 1. ) call check ( nf90_put_att ( ncid , val_varid , \"scale_factor\" , scale_factor ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) !write(*,*) 'here10' endif if ( use_single_time_loop_flag ) then write ( unit_logfile , '(A)' ) 'ERROR: Saving emissions for EMEP will not work when use_single_time_loop_flag=.true. Set to false' stop !Add time to the time dimension call check ( nf90_inq_varid ( ncid , \"time\" , time_varid ) ) !write(*,*) 'here11a' !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 n_dims ( 3 ) = t_loop !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) call check ( nf90_put_var ( ncid , time_varid , val_dim_nc ( 1 , time_dim_nc_index ), start = ( / n_dims ( 3 ) / ) ) ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !write(*,*) 'here11b' !Add dimension and array to existing call check ( nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) ) if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 1 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 2 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) else call check ( nf90_put_var ( ncid , val_varid , val_array , start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) endif !write(*,*) 'here11' else !Write the variable to file. Default is float if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 2 )) ) else !write(*,*) ncid, val_varid, shape(val_array) call check ( nf90_put_var ( ncid , val_varid , val_array ) ) endif endif call check ( nf90_close ( ncid ) ) end subroutine uEMEP_save_for_EMEP_netcdf_file","tags":"","loc":"proc/uemep_save_for_emep_netcdf_file.html"},{"title":"DIRECTION – uEMEP","text":"private  function DIRECTION(UD, VD) Arguments Type Intent Optional Attributes Name real :: UD real :: VD Return Value real Source Code FUNCTION DIRECTION ( UD , VD ) !\tCALCULATES THE WIND DIRECTION !Taken from NBLM1 IMPLICIT NONE REAL DIRECTION , UD , VD , PI PI = 18 0. / 3.14159 DIRECTION = 0. IF ( UD . GT . 0. AND . VD . GE . 0 ) DIRECTION = 27 0. - ATAN ( ABS ( VD / UD )) * PI IF ( UD . LE . 0. AND . VD . GT . 0 ) DIRECTION = 18 0. - ATAN ( ABS ( UD / VD )) * PI IF ( UD . LT . 0. AND . VD . LE . 0 ) DIRECTION = 9 0. - ATAN ( ABS ( VD / UD )) * PI IF ( UD . GE . 0. AND . VD . LT . 0 ) DIRECTION = 36 0. - ATAN ( ABS ( UD / VD )) * PI END FUNCTION DIRECTION","tags":"","loc":"proc/direction.html"},{"title":"mean_nodata – uEMEP","text":"private  function mean_nodata(array, n1, n2, n3, nodata_num) Arguments Type Intent Optional Attributes Name real :: array (n1,n2,n3) integer :: n1 integer :: n2 integer :: n3 real :: nodata_num Return Value real Source Code function mean_nodata ( array , n1 , n2 , n3 , nodata_num ) !use uEMEP_definitions implicit none real :: array ( n1 , n2 , n3 ) real :: nodata_num integer :: n1 , n2 , n3 real :: mean_nodata integer i , j , t real :: count = 0 real :: sum_array = 0 do t = 1 , n3 do j = 1 , n2 do i = 1 , n1 if ( array ( i , j , t ). ne . nodata_num ) then sum_array = sum_array + array ( i , j , t ) count = count + 1. endif enddo enddo enddo if ( count . gt . 0 ) then mean_nodata = sum_array / count else mean_nodata = 0 endif end function mean_nodata","tags":"","loc":"proc/mean_nodata.html"},{"title":"mean_mask – uEMEP","text":"public  function mean_mask(array, mask, n1, n2, n3) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (n1,n2,n3) logical, intent(in) :: mask (n1,n2) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value real Source Code function mean_mask ( array , mask , n1 , n2 , n3 ) !use uEMEP_definitions implicit none real , intent ( in ) :: array ( n1 , n2 , n3 ) logical , intent ( in ) :: mask ( n1 , n2 ) integer , intent ( in ) :: n1 , n2 , n3 real :: mean_mask integer i , j , t real :: count = 0 real :: sum_array = 0 sum_array = 0 count = 0 do t = 1 , n3 do j = 1 , n2 do i = 1 , n1 if ( mask ( i , j )) then sum_array = sum_array + array ( i , j , t ) count = count + 1. endif enddo enddo enddo if ( count . gt . 0 ) then mean_mask = sum_array / count else mean_mask = 0 endif end function mean_mask","tags":"","loc":"proc/mean_mask.html"},{"title":"uEMEP_save_netcdf_control – uEMEP","text":"public  subroutine uEMEP_save_netcdf_control() Uses uEMEP_definitions .or. use_region_select_and_mask_flag ??\n!!!!! what to write here??? Arguments None Source Code subroutine uEMEP_save_netcdf_control use uEMEP_definitions implicit none integer i , j , k , t , l integer i_comp , i_file , i_meteo character ( 256 ) temp_name , unit_str , title_str , title_str_rec , var_name_temp , temp_date_str , station_name_str , temp_name_rec , temp_compound_str logical create_file , create_file_rec integer i_source real :: valid_min = 0. real , allocatable :: temp_subgrid (:,:,:) real , allocatable :: temp_integral_subgrid (:,:,:) real , allocatable :: aqi_subgrid (:,:,:,:) integer , allocatable :: aqi_responsible_pollutant_index (:,:,:) real , allocatable :: temp_subgrid_ascii (:,:) integer ii , jj , tt real aqi_limits_temp ( n_compound_index , 1 : 5 ) real max_aqi integer n_aqi_pollutant_index parameter ( n_aqi_pollutant_index = 4 ) integer aqi_pollutant_index ( n_aqi_pollutant_index ) integer i_pollutant , i_loop character ( 256 ) variable_type logical :: receptor_available = . true . real scale_factor integer n_save_aqi_pollutant_index real temp_sum_comp integer count character ( 256 ) filename_ascii integer i_sp , ii_sp integer source_domain_loop integer no2_o3_loop , comp_index , comp_nc_index character ( 256 ) filename_append if ( include_o3_in_aqi_index ) then n_save_aqi_pollutant_index = n_aqi_pollutant_index else n_save_aqi_pollutant_index = n_aqi_pollutant_index - 1 endif if (. not . allocated ( temp_subgrid )) allocate ( temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ))) if (. not . allocated ( temp_integral_subgrid )) allocate ( temp_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ))) if (. not . allocated ( aqi_subgrid ). and . save_aqi ) allocate ( aqi_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) if (. not . allocated ( aqi_responsible_pollutant_index ). and . save_aqi ) allocate ( aqi_responsible_pollutant_index ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ))) if (. not . allocated ( temp_subgrid_ascii ). and . save_compounds_as_ascii ) allocate ( temp_subgrid_ascii ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) !Save subgrid calculations valid_min = 0. unit_str = \"ug/m3\" variable_type = 'byte' !variable_type='double' variable_type = 'float' scale_factor = 1. !Save the data i_file = subgrid_total_file_index ( allsource_index ) !temp_name=trim(pathname_grid(i_file))//trim(filename_grid(i_file))//'_'//trim(file_tag)//'.nc' !if (len(config_date_str).gt.0) then !    temp_date_str='_'//trim(config_date_str) !else !    temp_date_str='' !endif if ( len ( filename_date_output_grid ). gt . 0 ) then temp_date_str = '_' // filename_date_output_grid else temp_date_str = '' endif if ( use_multiple_receptor_grids_flag ) then station_name_str = trim ( name_receptor_in ( g_loop , 1 )) // '_' ; else station_name_str = '' endif !Do not write 'all' in file name if all compounds are selected if ( pollutant_index . eq . all_nc_index ) then temp_compound_str = '' else temp_compound_str = '_' // trim ( var_name_nc ( conc_nc_index , compound_index , allsource_index )) endif !Do not write anything about the compounds temp_compound_str = '' !temp_name=trim(pathname_grid(i_file))//trim(station_name_str)//'uEMEP_'//trim(file_tag)//trim(temp_compound_str)//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !temp_name_rec=trim(pathname_grid(i_file))//'uEMEP_'//trim(file_tag)//'_station'//trim(temp_compound_str)//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !if (save_netcdf_average_flag) then !temp_name=trim(pathname_grid(i_file))//trim(station_name_str)//'uEMEP_'//trim(file_tag)//trim(temp_compound_str)//'_mean'//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !temp_name_rec=trim(pathname_grid(i_file))//'uEMEP_'//trim(file_tag)//'_station'//trim(temp_compound_str)//'_mean'//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !endif temp_name = trim ( pathname_grid ( i_file )) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.nc' temp_name_rec = trim ( pathname_grid ( i_file )) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.nc' if ( save_netcdf_average_flag ) then temp_name = trim ( pathname_grid ( i_file )) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.nc' temp_name_rec = trim ( pathname_grid ( i_file )) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.nc' endif finished_file = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.' // trim ( finished_filename ) finished_file_rec = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.' // trim ( finished_filename ) if ( save_netcdf_average_flag ) then finished_file = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.' // trim ( finished_filename ) finished_file_rec = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.' // trim ( finished_filename ) endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving netcdf data (uEMEP_save_netcdf_control)' write ( unit_logfile , '(A)' ) '================================================================' i_comp = 1 if ( save_netcdf_receptor_flag . and . n_valid_receptor . eq . 0 ) then if ( i_comp . eq . 1. and . t_loop . eq . start_time_loop_index ) then write ( unit_logfile , '(a)' ) 'No receptor positions available. Will not save receptor data.' receptor_available = . false . endif endif if ( save_netcdf_average_flag ) then if (. not . allocated ( val_array_av )) then allocate ( val_array_av ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_var_av )) val_array_av = 0. endif if (. not . allocated ( time_seconds_output_av )) then allocate ( time_seconds_output_av ( n_var_av )) time_seconds_output_av = 0 endif !Reset average file counter for every time step saving occurs counter_av = 0 write ( unit_logfile , * ) 'Saving as mean data' endif !Save the final result of the subgrid calculation in ascii format !This should only be used for annual mean calculations since it cannot have a time dimmension !Intended for FAIRMODE output !Makes a new file for each compound and averages over time, if there is a time dimension if ( save_compounds_as_ascii ) then variable_type = 'float' unit_str = \"ug/m3\" do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) !write(*,*) i_comp var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) title_str = trim ( var_name_temp ) // '_' // trim ( file_tag ) // trim ( temp_date_str ) write ( unit_logfile , '(a)' ) 'Writing ascii data to: ' // trim ( title_str ) filename_ascii = trim ( pathname_output_grid ) // trim ( title_str ) // '.asc' temp_subgrid_ascii (:,:) = sum ( comp_subgrid (:,:,:, i_comp ), 3 ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(a,f12.3)' ) 'Writing ascii array variable: ' // trim ( var_name_temp ), sum ( comp_subgrid (:,:,:, i_comp )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) call write_esri_ascii_file ( filename_ascii , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_delta ( x_dim_index ), temp_subgrid_ascii , x_subgrid , y_subgrid ) enddo endif enddo endif !Save the final result of the subgrid calculation if ( save_compounds ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving all total compounds' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' unit_str = \"ug/m3\" do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) !write(*,*) i_comp if ( i_pollutant . eq . 1. and . i_loop . eq . 1. and . t_loop . eq . start_time_loop_index . and . save_netcdf_file_flag ) then create_file = . true . title_str = 'uEMEP_concentration_' // trim ( file_tag ) // temp_date_str write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name ) else create_file = . false . endif if ( i_pollutant . eq . 1. and . i_loop . eq . 1. and . t_loop . eq . start_time_loop_index . and . first_g_loop . and . save_netcdf_receptor_flag ) then create_file_rec = . true . title_str_rec = 'uEMEP_receptor_' // trim ( file_tag ) // temp_date_str if ( receptor_available ) write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name_rec ) else create_file_rec = . false . endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_concentration' if ( save_netcdf_file_flag ) then temp_sum_comp = 0. count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then temp_sum_comp = temp_sum_comp + sum ( comp_subgrid ( i , j ,:, i_comp )) / subgrid_dim ( t_dim_index ) count = count + 1 endif enddo enddo if ( count . gt . 0 ) then temp_sum_comp = temp_sum_comp / count else temp_sum_comp = 0 endif !write(unit_logfile,'(a,f12.3)')'Writing netcdf array variable:    '//trim(var_name_temp),temp_sum_comp write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( comp_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( comp_subgrid (:,:,:, i_comp ), 1 ), size ( comp_subgrid (:,:,:, i_comp ), 2 ), size ( comp_subgrid (:,:,:, i_comp ), 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , comp_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( comp_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( comp_subgrid (:,:,:, i_comp ), 1 ), size ( comp_subgrid (:,:,:, i_comp ), 2 ), size ( comp_subgrid (:,:,:, i_comp ), 3 )) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(comp_subgrid(:,:,:,i_comp))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , comp_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo endif enddo endif create_file = . false . create_file_rec = . false . ! Save downscaled source contributions for pollutants (not no2 or o3) ! 1 = local ! 2 = local, cut down to from_in_region ! 3-4: not used here, but kept to make numbering consistent with the other loops over source_domain_loop ! 5 = total: contribution from big domain, but using downscaled within moving window: 1 + (additional_emep_local(3) - emep_local(1) ! 6 = total from in region = 2 + semilocal emep contribution (4)) do source_domain_loop = 1 , 6 ! Skip this round in the loop if this type of source contributions are not to be saved if ( source_domain_loop == 1 ) then if (. not . save_source_contributions ) cycle filename_append = '' else if ( source_domain_loop == 2 ) then if (. not . ( trace_emissions_from_in_region . and . save_local_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 5 ) then if (. not . ( save_total_source_contributions . and . EMEP_additional_grid_interpolation_size . gt . 0 )) cycle filename_append = '' else if ( source_domain_loop == 6 ) then if (. not . ( trace_emissions_from_in_region . and . save_total_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else ! skip rounds 3-4 cycle end if write ( unit_logfile , '(a)' ) '--------------------------' if ( source_domain_loop == 1 ) write ( unit_logfile , '(a)' ) 'Saving downscaled contributions' if ( source_domain_loop == 2 ) write ( unit_logfile , '(a)' ) 'Saving downscaled contributions from-in-region' if ( source_domain_loop == 5 ) write ( unit_logfile , '(a)' ) 'Saving total contributions' if ( source_domain_loop == 6 ) write ( unit_logfile , '(a)' ) 'Saving total contributions from-in-region' write ( unit_logfile , '(a)' ) '--------------------------' if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" else variable_type = 'byte' unit_str = \"%\" endif do i_pollutant = 1 , n_pollutant_loop do i_source = 1 , n_source_index if ( source_domain_loop == 5 ) then i_file = subgrid_sourcetotal_file_index ( i_source ) else if ( source_domain_loop == 6 ) then i_file = subgrid_sourcetotal_inregion_file_index ( i_source ) else ! 1 or 2 i_file = subgrid_local_file_index ( i_source ) end if !if (calculate_source(i_source).or.i_source.eq.allsource_index) then !Don't save any exhaust, sand or salt pollutant sources. Dealt with later !(calculate_source(i_source).or.calculate_emep_source(i_source)) if ( calculate_source ( i_source ). and . i_source . ne . allsource_index . and . pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then !Only save nonexhaust pm and all the other sources if (( pollutant_loop_index ( i_pollutant ). eq . nox_index . and . i_source . eq . traffic_index )) then !if ((pollutant_loop_index(i_pollutant).ne.nox_index.or.i_source.ne.traffic_index)) then else if ( i_source . eq . traffic_index . and .( pollutant_loop_index ( i_pollutant ). eq . pm10_index . or . pollutant_loop_index ( i_pollutant ). eq . pm25_index )) then ! Special case for traffic pm: In some setups we need to subtract exhaust to get non-exhaust if ( pollutant_index . eq . all_totals_nc_index . or . pollutant_index . eq . aaqd_totals_nc_index . or . pollutant_index . eq . gp_totals_nc_index . or . pollutant_index . eq . op_totals_nc_index ) then ! Traffic exhaust is not a separate pollutant, so just save total traffic var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else ! source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) endif else ! Calculate non-exhaust as difference between total traffic and exhaust for downscaled contributions ! For EMEP contributions, non-exhaust can be directly accessed with traffic_nonexhaust_nc_index var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // '_nonexhaust' // trim ( filename_append ) if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) - subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) - subgrid (:,:,:, emep_local_subgrid_index , traffic_nonexhaust_nc_index , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , traffic_nonexhaust_nc_index , i_pollutant ) else !source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) - subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) + subgrid_EMEP_semilocal_from_in_region (:,:,:, traffic_nonexhaust_nc_index , i_pollutant ) end if endif else var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else ! source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) endif endif ! Convert to fractions if (. not . save_netcdf_fraction_as_contribution_flag ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. end if !In case of any 0 concentrations when using the fractional contributions where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp), mean_nodata(temp_subgrid,size(temp_subgrid,1),size(temp_subgrid,2),size(temp_subgrid,3),NODATA_value) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) ! write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif !Special case for exhaust as this must be given as a fraction for both PM2.5 and PM10. !if ((pollutant_loop_index(i_pollutant).eq.pm10_index.or.pollutant_loop_index(i_pollutant).eq.pm25_index).and.i_source.eq.traffic_index) then !Write all exhaust pollutants except the pmex if ( i_source . eq . traffic_index . and .(. not . pollutant_index . eq . all_totals_nc_index . and .. not . pollutant_index . eq . aaqd_totals_nc_index . and .. not . pollutant_index . eq . gp_totals_nc_index . and .. not . pollutant_index . eq . op_totals_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . nox_index )) then !If PM then exhaust output is exhaust if ( pollutant_loop_index ( i_pollutant ). eq . pm10_index . or . pollutant_loop_index ( i_pollutant ). eq . pm25_index ) then if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) - subgrid (:,:,:, emep_local_subgrid_index , traffic_exhaust_nc_index , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , traffic_exhaust_nc_index , i_pollutant ) else !source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) + subgrid_EMEP_semilocal_from_in_region (:,:,:, traffic_exhaust_nc_index , i_pollutant ) end if else if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else !source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) end if endif var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // '_exhaust' // trim ( filename_append ) if (. not . save_netcdf_fraction_as_contribution_flag ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. end if where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif !Special case for salt and sand if ( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_sand_index & . or . pollutant_loop_index ( i_pollutant ). eq . pm25_salt_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_salt_index ) then !Save the nonexhaust sand and salt ! NB: sand and salt do not have EMEP contributions, so total is the same as local if ( i_source . eq . traffic_index ) then var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) if ( source_domain_loop == 1 . or . source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else ! 2 or 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) end if if (. not . save_netcdf_fraction_as_contribution_flag ) then !temp_subgrid=subgrid(:,:,:,local_subgrid_index,i_source,i_pollutant) if ( pollutant_loop_index ( i_pollutant ). eq . pm10_sand_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_salt_index ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_index )) * 10 0. else temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_index )) * 10 0. endif endif where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif end do ! i_source end do ! i_pollutant end do ! source_domain_loop ! Save the total nonlocal contributions from EMEP (not saving it for in-region domains!) ! 1 = nonlocal to the moving window ! 2 = not used, but kept for consistency with other source_domain_loop loops ! 3 = nonlocal to the additional domain do source_domain_loop = 1 , 3 if ( source_domain_loop == 2 ) cycle write ( unit_logfile , '(A)' ) '-------------------------------' if ( source_domain_loop == 1 ) write ( unit_logfile , '(A)' ) 'Saving nonlocal contributions' if ( source_domain_loop == 3 ) write ( unit_logfile , '(A)' ) 'Saving additional nonlocal contributions' write ( unit_logfile , '(A)' ) '-------------------------------' do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then if ( source_domain_loop == 1 ) then if (. not . ( save_source_contributions . or . save_emep_source_contributions . or . save_total_source_contributions )) cycle i_file = emep_subgrid_nonlocal_file_index ( allsource_index ) temp_subgrid = subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) else ! source_domain_loop == 3 if (. not . ( EMEP_additional_grid_interpolation_size . gt . 0 . and . ( save_emep_additional_source_contributions . or . save_total_source_contributions ))) cycle i_file = emep_additional_subgrid_nonlocal_file_index ( allsource_index ) temp_subgrid = subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ) end if var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) if (. not . ( save_netcdf_fraction_as_contribution_flag )) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. end if where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif end if enddo ! i_pollutant end do ! source_domain_loop ! Calculate and save NO2 and O3 source contributions if ( save_no2_source_contributions . or . save_o3_source_contributions ) then ! Calculate NO2 and O3 source contributions if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then calculate_EMEP_additional_grid_flag = . true . call uEMEP_source_fraction_chemistry endif calculate_EMEP_additional_grid_flag = . false . call uEMEP_source_fraction_chemistry ! Save the contributions to file ! 1 = normal source contributions from within moving window ! 2 = source contributions cut down to region ! 3 = additional nonlocal ! 4 = semilocal contribution from in region, based on background ! 5 = not used, but kept to be consistent with other loops over \"source_domain_loop\" ! 6 = total contribution from in region = 2+4 do source_domain_loop = 1 , 6 ! Skip this round in the loop if this type of source contributions are not to be saved ! or set appropriate variable name extension if ( source_domain_loop == 1 ) then if (. not . save_source_contributions ) cycle filename_append = '' else if ( source_domain_loop == 2 ) then if (. not . ( trace_emissions_from_in_region . and . save_local_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 3 ) then if (. not . ( EMEP_additional_grid_interpolation_size . gt . 0 . and . ( save_emep_additional_source_contributions . or . save_total_source_contributions ))) cycle filename_append = '' else if ( source_domain_loop == 4 ) then if (. not . ( trace_emissions_from_in_region . and . save_semilocal_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 5 ) then cycle else ! source_domain_loop == 6 if (. not . ( trace_emissions_from_in_region . and . save_total_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' end if write ( unit_logfile , '(A)' ) '-------------------------------' if ( source_domain_loop == 1 ) write ( unit_logfile , '(A)' ) 'Saving local NO2 and O3 contributions' if ( source_domain_loop == 2 ) write ( unit_logfile , '(A)' ) 'Saving local NO2 and O3 contributions from-in-region' if ( source_domain_loop == 3 ) write ( unit_logfile , '(A)' ) 'Saving additional nonlocal NO2 and O3 contributions' if ( source_domain_loop == 4 ) write ( unit_logfile , '(A)' ) 'Saving semilocal NO2 and O3 contributions from-in-region' if ( source_domain_loop == 6 ) write ( unit_logfile , '(A)' ) 'Saving total NO2 and O3 contributions from-in-region' write ( unit_logfile , '(A)' ) '-------------------------------' ! Save NO2 in round 1 and O3 in round 2 do no2_o3_loop = 1 , 2 if ( no2_o3_loop == 1 ) then ! no2 comp_index = no2_index comp_nc_index = no2_nc_index if (. not . save_no2_source_contributions ) cycle valid_min = 0. if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" else variable_type = 'byte' unit_str = \"%\" endif else ! o3 comp_index = o3_index comp_nc_index = o3_nc_index if (. not . save_o3_source_contributions ) cycle if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" valid_min =- 100 0. else variable_type = 'short' unit_str = \"%\" valid_min =- 10 0. endif end if do i_source = 1 , n_source_index if ( i_source . eq . allsource_index . or . calculate_source ( i_source ) . or . calculate_emep_source ( i_source )) then !Do not save nonexhaust for exhaust gas emissions if ( i_source . eq . traffic_nonexhaust_index ) then cycle end if if ( i_source == allsource_index ) then ! Non-local contributions if ( source_domain_loop == 1 ) then ! nonlocal to the normal domain i_file = emep_subgrid_nonlocal_file_index ( i_source ) temp_subgrid = comp_source_EMEP_subgrid (:,:,:, comp_index , i_source ) else if ( source_domain_loop == 3 ) then ! nonlocal to the additional domain i_file = emep_additional_subgrid_nonlocal_file_index ( i_source ) temp_subgrid = comp_source_EMEP_additional_subgrid (:,:,:, comp_index , i_source ) else ! do not save nonlocal for the in-region versions cycle end if else ! Sector source contributions if ( source_domain_loop == 1 ) then ! normal local domain if ( calculate_source ( i_source )) then i_file = subgrid_local_file_index ( i_source ) else ! calculate_emep_source(i_source) i_file = emep_subgrid_local_file_index ( i_source ) endif temp_subgrid = comp_source_subgrid (:,:,:, comp_index , i_source ) else if ( source_domain_loop == 2 ) then ! in-region contributions within the normal local domain if ( calculate_source ( i_source )) then i_file = subgrid_local_file_index ( i_source ) else ! calculate_emep_source(i_source) i_file = emep_subgrid_local_file_index ( i_source ) endif temp_subgrid = comp_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) else if ( source_domain_loop == 3 ) then ! additional domain: save only non-local for additional domain cycle else if ( source_domain_loop == 4 ) then ! semilocal inregion contributions i_file = emep_subgrid_semilocal_file_index ( i_source ) temp_subgrid = comp_semilocal_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) else ! source_domain_loop == 6 ! sum of local inregion and semilocal inregion i_file = subgrid_sourcetotal_inregion_file_index ( i_source ) temp_subgrid = comp_semilocal_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) + comp_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) end if end if ! Variable name if ( i_source . eq . traffic_index . and . comp_index . eq . no2_index ) then ! special case for no2 traffic: add exhaust to variable name var_name_temp = trim ( var_name_nc ( conc_nc_index , comp_nc_index , allsource_nc_index )) // '_' // trim ( filename_grid ( i_file )) // '_exhaust' // trim ( filename_append ) else var_name_temp = trim ( var_name_nc ( conc_nc_index , comp_nc_index , allsource_nc_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) endif if (. not . save_netcdf_fraction_as_contribution_flag ) then ! Transform to fraction if ( comp_index == o3_index ) then ! For O3, only include nonlocal when saving as fractions, and normalize with EMEP concentration to always get 100% if ( i_source == allsource_index ) then temp_subgrid = temp_subgrid / comp_EMEP_subgrid (:,:,:, comp_index ) temp_subgrid = min ( temp_subgrid , 100 0. ) temp_subgrid = max ( temp_subgrid , - 10 0. ) else cycle end if else ! for NO2, normalize with EMEP concentration for additional, and with uEMEP concentration in all other cases if ( source_domain_loop == 3 ) then temp_subgrid = temp_subgrid / comp_EMEP_subgrid (:,:,:, comp_index ) * 10 0. else temp_subgrid = temp_subgrid / comp_subgrid (:,:,:, comp_index ) * 10 0. end if end if endif ! Save to file if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo !i_source end do !no2_o3_loop end do !source_domain_loop valid_min = 0. end if !(save_no2_source_contributions .or. save_o3_source_contributions) !Save the emissions interpolated to the target grid if ( save_emissions ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving emissions' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' unit_str = \"g/s\" do i_pollutant = 1 , n_pollutant_loop do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then !Do not save emissions if the source is not traffic and the pollutant is road sand and salt or exhaust as these do not exist if ( i_source . ne . traffic_index . and .( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_sand_index & . or . pollutant_loop_index ( i_pollutant ). eq . pm25_salt_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_salt_index & . or . pollutant_loop_index ( i_pollutant ). eq . pmex_index )) then !Do nothing because these pollutants only exist for traffic else i_file = emission_file_index ( i_source ) var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) !Calculate the emissions in the target grid temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) jj = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) temp_subgrid ( i , j ,:) = emission_subgrid ( ii , jj ,:, i_source , i_pollutant ) !Subgrid emissions, if relevant, are in units ug/sec/subgrid. Convert to g/s. Acount for the difference in subgrid sizes here temp_subgrid ( i , j ,:) = 1.0e-6 * temp_subgrid ( i , j ,:) * ( subgrid_delta ( y_dim_index ) * subgrid_delta ( x_dim_index )) & / ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif enddo enddo endif !Save population interpolated to the target grid if ( save_population ) then write ( unit_logfile , '(A)' ) '-------------------------------' write ( unit_logfile , '(A)' ) 'Saving population data' write ( unit_logfile , '(A)' ) '-------------------------------' variable_type = 'float' unit_str = \"inhabitants/grid\" i_file = population_file_index ( population_index ) var_name_temp = trim ( filename_grid ( i_file )) !Calculate the population in the target grid temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_population_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_population_subgrid ( i , j , y_dim_index ) temp_subgrid ( i , j ,:) = population_subgrid ( ii , jj , population_index ) !Acount for the difference in subgrid sizes here temp_subgrid ( i , j ,:) = temp_subgrid ( i , j ,:) * ( subgrid_delta ( y_dim_index ) * subgrid_delta ( x_dim_index )) & / ( population_subgrid_delta ( y_dim_index ) * population_subgrid_delta ( x_dim_index )) enddo enddo unit_str = 'inhabitants/grid' if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif ! Save region mask at target subgrid if ( trace_emissions_from_in_region ) then !! .or. use_region_select_and_mask_flag ?? write ( unit_logfile , '(A)' ) '-------------------------------' write ( unit_logfile , '(A)' ) 'Saving region mask' write ( unit_logfile , '(A)' ) '-------------------------------' variable_type = 'short' var_name_temp = 'region_index' unit_str = '1' !!!!!!! what to write here??? temp_subgrid = 0. do tt = 1 , subgrid_dim ( t_dim_index ) ! add 0.1 to all values to avoid them being rounded down to 1 less than original value temp_subgrid (:,:, tt ) = subgrid_region_index + 0.1 end do if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ) ! NB: hard-coding scale_factor=1 since it does not make sense to have scale_factor for an ID variable! call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , 1. ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then ! check if region is the same for the whole grid. If not, set to zero to avoid getting wrong ID when interpolating if (. not . ( minval ( subgrid_region_index ) == maxval ( subgrid_region_index ))) then write ( unit_logfile , '(A)' ) 'Warning: Not the same region_index for the whole receptor grid. Setting to 0.' temp_subgrid = 0. end if write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , 1. ) endif end if ! Save EMEP allsources ! NB: For now, this is always saved write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving EMEP allsources' write ( unit_logfile , '(a)' ) '--------------------------' do i_pollutant = 1 , n_emep_pollutant_loop !EMEP does not have all pollutants so only save to n_emep_pollutant_loop !Only save the allsource value here 'EMEP_allsources' variable_type = 'float' i_file = emep_subgrid_file_index ( allsource_index ) var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) unit_str = 'ug/m3' if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif end do !Save the EMEP data interpolated to the subgrid. These are based on the gridded concentrations ! Loop over 5 different verions ! 1 = emep local contributions from the moving-window (downscaling domain) ! 2 = As 1, but only the part of the moving window that is within the receptor region ! 3 = emep additional local contributions, extending further using larger LF grid ! 4 = Semilocal contribution, i.e. outside moving-window but inside the receptor region ! 5 = total contribution: Same as 3 (but saved as a different name and under different flag) ! 6 = total contribution from_in_region = 2+4, only for sources not downscaled do source_domain_loop = 1 , 6 ! check if this version of source contributions should be saved if ( source_domain_loop == 1 ) then if (. not . save_emep_source_contributions ) cycle filename_append = '' else if ( source_domain_loop == 2 ) then if (. not . ( save_local_source_contributions_from_in_region . and . trace_emissions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 3 ) then if (. not . ( save_emep_additional_source_contributions . and . EMEP_additional_grid_interpolation_size . gt . 0 )) cycle filename_append = '' else if ( source_domain_loop == 4 ) then if (. not . ( save_semilocal_source_contributions_from_in_region . and . trace_emissions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 5 ) then if (. not . ( save_total_source_contributions . and . EMEP_additional_grid_interpolation_size . gt . 0 )) cycle filename_append = '' else !source_domain_loop == 6 if (. not . ( save_total_source_contributions_from_in_region . and . trace_emissions_from_in_region )) cycle filename_append = '_from_in_region' end if write ( unit_logfile , '(a)' ) '--------------------------' if ( source_domain_loop . eq . 1 ) write ( unit_logfile , '(a)' ) 'Saving EMEP contributions' if ( source_domain_loop . eq . 2 ) write ( unit_logfile , '(a)' ) 'Saving EMEP contributions from in region' if ( source_domain_loop . eq . 3 ) write ( unit_logfile , '(a)' ) 'Saving EMEP additional contributions' if ( source_domain_loop . eq . 4 ) write ( unit_logfile , '(a)' ) 'Saving EMEP semilocal contributions from in region' if ( source_domain_loop . eq . 5 ) write ( unit_logfile , '(a)' ) 'Saving total contributions' if ( source_domain_loop . eq . 6 ) write ( unit_logfile , '(a)' ) 'Saving total contributions from in region' write ( unit_logfile , '(a)' ) '--------------------------' if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" else variable_type = 'byte' unit_str = \"%\" endif do i_pollutant = 1 , n_emep_pollutant_loop !EMEP does not have all pollutants so only save to n_emep_pollutant_loop do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . save_EMEP_source ( i_source ). or . i_source . eq . allsource_index ) then !Do not save for the additional GNFR sources if ( i_source . eq . traffic_gasoline_nc_index . or . i_source . eq . traffic_diesel_nc_index . or . i_source . eq . traffic_gas_nc_index . or . i_source . eq . publicpower_point_nc_index . or . i_source . eq . publicpower_area_nc_index ) then cycle end if !Do not save nonexhaust for exhaust gas emissions if ( i_source . eq . traffic_nonexhaust_nc_index . and .( pollutant_loop_index ( i_pollutant ). eq . no2_index . or . pollutant_loop_index ( i_pollutant ). eq . nox_index . or . pollutant_loop_index ( i_pollutant ). eq . o3_index )) then cycle end if if ( source_domain_loop == 1 ) then ! local EMEP contribution i_file = emep_subgrid_local_file_index ( i_source ) temp_subgrid = subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then ! local EMEP contribution cut down to in-region i_file = emep_subgrid_local_file_index ( i_source ) temp_subgrid = subgrid_EMEP_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 3 ) then ! additional local EMEP contribution i_file = emep_additional_subgrid_local_file_index ( i_source ) temp_subgrid = subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 4 ) then ! semilocal EMEP contribution i_file = emep_subgrid_semilocal_file_index ( i_source ) temp_subgrid = subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) else ! source_domain_loop is 5 or 6 ! Only save total for non-downscaled sources, since downscaled sources were saved earlier if ( i_source == allsource_index . or . calculate_source ( i_source )) then cycle else if (( i_source == traffic_exhaust_nc_index . or . i_source == traffic_nonexhaust_nc_index ) . and . calculate_source ( traffic_index )) then ! if traffic is downscaled, then total contributions to traffic exhaust and nonexhaust are saved earlier in the subroutine using downscaled local contributions cycle end if if ( source_domain_loop == 5 ) then ! EMEP contribution from additional domain i_file = subgrid_sourcetotal_file_index ( i_source ) temp_subgrid = subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else !source_domain_loop == 6 ! sum of EMEP local and EMEP semilocal contribution i_file = subgrid_sourcetotal_inregion_file_index ( i_source ) temp_subgrid = subgrid_EMEP_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) end if end if var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) !if (i_source.eq.traffic_exhaust_nc_index) var_name_temp=var_name_temp//'_exhaust' !if (i_source.eq.traffic_nonexhaust_nc_index) var_name_temp=var_name_temp//'_nonexhaust' ! Transform to fraction if (. not . save_netcdf_fraction_as_contribution_flag ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ) * 10 0. temp_subgrid = min ( temp_subgrid , 100 0. ) temp_subgrid = max ( temp_subgrid , - 100 0. ) endif if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo ! i_source enddo ! i_pollutant enddo !source_domain_loop !Save the other interpolated EMEP compounds used for nox chemistry as well. These are based on the surface comp values if ( save_for_chemistry ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving for offline chemistry' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_pollutant = 1 , n_emep_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . nox_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) !Somo35 may be included here. Do not include it if it is. if ( i_comp . ne . somo35_nc_index ) then i_file = emep_subgrid_file_index ( allsource_index ) var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_forchemistry' // '_' // trim ( filename_grid ( i_file )) temp_subgrid = comp_EMEP_subgrid (:,:,:, i_comp ) unit_str = \"ug/m3\" if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( comp_EMEP_subgrid (:,:,:, i_comp )) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo endif enddo endif !Save weighted travel time if ( save_for_chemistry ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving weighted travel time' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' var_name_temp = 'Weighted_travel_time' unit_str = 'seconds' i_pollutant = pollutant_loop_back_index ( nox_nc_index ) !Only save the travel time for nox. Though this may be expanded for other compounds if necessary, like ammonia temp_subgrid = traveltime_subgrid (:,:,:, 3 , i_pollutant ) if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a)')'Writing netcdf variable: '//trim(var_name_temp) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(traveltime_subgrid(:,:,:,1,i_pollutant))/size(subgrid,1)/size(subgrid,2)/size(subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif if ( save_for_chemistry ) then variable_type = 'float' i_file = subgrid_J_file_index i_meteo = J_subgrid_index unit_str = \"1/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a)')'Writing netcdf variable: '//trim(var_name_temp) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- !Save temperature if not also saving the meteo data. if (. not . save_other_meteo ) then variable_type = 'float' i_file = subgrid_t2m_file_index i_meteo = t2m_subgrid_index unit_str = \"Celcius\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) - 27 3.13 enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a)')'Writing netcdf variable: '//trim(var_name_temp) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif if ( save_emep_species ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving EMEP species' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) if ( i_sp . ne . sp_pm_index ) then !Do not include the total do i_loop = 1 , n_pmxx_sp_index if ( i_loop . eq . pm25_sp_index . or . i_loop . eq . pm10_sp_index ) then if ( i_loop . eq . pm25_sp_index ) i_pollutant = pollutant_loop_back_index ( pm25_index ) if ( i_loop . eq . pm10_sp_index ) i_pollutant = pollutant_loop_back_index ( pm10_index ) if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' var_name_temp = trim ( species_name_nc ( i_loop , ii_sp )) // '_nonlocal_contribution' unit_str = \"ug/m3\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) else variable_type = 'byte' var_name_temp = trim ( species_name_nc ( i_loop , i_sp )) // '_nonlocal_fraction' unit_str = \"%\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. endif if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo endif enddo endif !Only save sea salt in this way when emep species are not saved in the general way if ( save_seasalt . and .. not . save_emep_species ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving EMEP sea salt' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' i_sp = n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index if ( i_loop . eq . pm25_sp_index . or . i_loop . eq . pm10_sp_index ) then if ( i_loop . eq . pm25_sp_index ) i_pollutant = pollutant_loop_back_index ( pm25_index ) if ( i_loop . eq . pm10_sp_index ) i_pollutant = pollutant_loop_back_index ( pm10_index ) if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' var_name_temp = trim ( species_name_nc ( i_loop , ii_sp )) // '_nonlocal_contribution' unit_str = \"ug/m3\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) else variable_type = 'byte' var_name_temp = trim ( species_name_nc ( i_loop , ii_sp )) // '_nonlocal_fraction' unit_str = \"%\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. endif if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo endif !Save the original EMEP compounds if ( save_emep_original ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving original EMEP' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_pollutant = 1 , n_emep_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) i_file = emep_subgrid_file_index ( allsource_index ) var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_original_EMEP_concentration' unit_str = \"ug/m3\" if ( i_comp . eq . somo35_index ) unit_str = \"ppb�d\" if ( save_netcdf_file_flag ) then !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp),sum(orig_EMEP_subgrid(:,:,:,i_comp))/size(subgrid,1)/size(subgrid,2)/size(subgrid,3) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( orig_EMEP_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , orig_EMEP_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then ! write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(orig_EMEP_subgrid(:,:,:,i_comp))/size(subgrid,1)/size(subgrid,2)/size(subgrid,3) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( orig_EMEP_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , orig_EMEP_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo endif enddo endif !Save AQI if ( save_aqi ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving AQI' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'byte' scale_factor = 0.1 !Hard coded AQI limits aqi_pollutant_index ( 1 ) = no2_index ; aqi_pollutant_index ( 2 ) = pm10_index ; aqi_pollutant_index ( 3 ) = pm25_index ; aqi_pollutant_index ( 4 ) = o3_index aqi_limits_temp (:, 2 : 4 ) = aqi_hourly_limits (:, 1 : 3 ) aqi_limits_temp (:, 1 ) = 0. aqi_limits_temp (:, 5 ) = 2. * aqi_hourly_limits (:, 3 ) aqi_subgrid = 0. do t = 1 , subgrid_dim ( t_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) max_aqi = 0. do l = 1 , n_save_aqi_pollutant_index !pollutant (no2,pm10,pm2.5,o3) do k = 1 , 4 !level if ( comp_subgrid ( i , j , t , aqi_pollutant_index ( l )). ge . aqi_limits_temp ( aqi_pollutant_index ( l ), k ). and . comp_subgrid ( i , j , t , aqi_pollutant_index ( l )). lt . aqi_limits_temp ( aqi_pollutant_index ( l ), k + 1 )) then aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )) = k + ( comp_subgrid ( i , j , t , aqi_pollutant_index ( l )) - aqi_limits_temp ( aqi_pollutant_index ( l ), k )) / ( aqi_limits_temp ( aqi_pollutant_index ( l ), k + 1 ) - aqi_limits_temp ( aqi_pollutant_index ( l ), k )) endif enddo aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )) = min ( aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )), 4.99 ) if ( aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )). gt . max_aqi ) then max_aqi = aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )) aqi_responsible_pollutant_index ( i , j , t ) = l endif !write(*,*)  i,j,t,aqi_responsible_pollutant_index(i,j,t),aqi_subgrid(i,j,t,aqi_pollutant_index(l)),max_aqi enddo enddo enddo enddo do l = 1 , n_save_aqi_pollutant_index !write(unit_logfile,*)  'MAX AQI in time and space from '//trim(pollutant_file_str(aqi_pollutant_index(l)))//' = ',maxval(aqi_subgrid(:,:,:,aqi_pollutant_index(l))) enddo var_name_temp = 'AQI' unit_str = '1' !Take the maximum of the pollutants temp_subgrid = maxval ( aqi_subgrid (:,:,:, aqi_pollutant_index ( 1 : n_save_aqi_pollutant_index )), 4 ) / scale_factor if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid * scale_factor ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif do l = 1 , n_save_aqi_pollutant_index i_comp = aqi_pollutant_index ( l ) var_name_temp = 'AQI_' // trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) unit_str = '1' !Take the maximum of the pollutants temp_subgrid = aqi_subgrid (:,:,:, i_comp ) / scale_factor if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid * scale_factor ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo !Reset scale_factor scale_factor = 1. endif !Save deposition if ( save_deposition . and . calculate_deposition_flag ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving deposition' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_pollutant = 1 , n_pollutant_loop do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i_comp = pollutant_loop_index ( i_pollutant ) var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_local_dry_deposition_' // source_file_str ( i_source ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, drydepo_local_subgrid_index , i_source , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_local_wet_deposition_' // source_file_str ( i_source ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, wetdepo_local_subgrid_index , i_source , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_nonlocal_dry_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_total_dry_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = ( subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) + subgrid (:,:,:, drydepo_local_subgrid_index , allsource_index , i_pollutant )) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_nonlocal_wet_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_total_wet_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = ( subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) + subgrid (:,:,:, wetdepo_local_subgrid_index , allsource_index , i_pollutant )) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !Deposition velocity temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) temp_subgrid ( i , j ,:) = deposition_subgrid ( ii , jj ,:, vd_index , i_pollutant ) enddo enddo var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_deposition_velocity_' // source_file_str ( allsource_index ) unit_str = \"cm/s\" !Save in cm/s, conversition from ug/m2/s temp_subgrid = temp_subgrid * 10 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !Landuse category if ( read_landuse_flag ) then temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) temp_subgrid ( i , j ,:) = landuse_subgrid ( ii , jj , grid_index ) enddo enddo var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_EMEP_landuse_category' unit_str = \"1\" variable_type = 'byte' if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif variable_type = 'float' !Save the original emep wet and dry deposition var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_original_EMEP_wet_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = orig_emep_deposition_subgrid (:,:,:, wetdepo_index , i_pollutant ) if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_original_EMEP_dry_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = orig_emep_deposition_subgrid (:,:,:, drydepo_index , i_pollutant ) if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo endif !Save the meteo interpolated to the target grid valid_min =- 1.e24 if ( save_wind_vectors ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving wind vectors' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' if ( wind_vectors_10m_available ) then i_file = subgrid_u10_file_index i_meteo = u10_subgrid_index else i_file = subgrid_ugrid_file_index i_meteo = ugrid_subgrid_index endif unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( wind_vectors_10m_available ) then i_file = subgrid_v10_file_index i_meteo = v10_subgrid_index else i_file = subgrid_vgrid_file_index i_meteo = vgrid_subgrid_index endif unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- endif if ( save_other_meteo ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving other meteo data' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' i_file = subgrid_hmix_file_index i_meteo = hmix_subgrid_index unit_str = \"m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- variable_type = 'float' i_file = subgrid_t2m_file_index i_meteo = t2m_subgrid_index unit_str = \"Celcius\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) - 27 3.13 enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- variable_type = 'float' i_file = subgrid_hmix_file_index i_meteo = precip_subgrid_index unit_str = \"mm/hr\" !The same for all-------------------- var_name_temp = 'precipitation' !trim(filename_grid(i_file)) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_kz_file_index i_meteo = kz_subgrid_index unit_str = \"m2/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( hourly_calculations ) then if ( wind_vectors_10m_available ) then i_file = subgrid_FF10_file_index i_meteo = FF10_subgrid_index else i_file = subgrid_FFgrid_file_index i_meteo = FFgrid_subgrid_index endif unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( wind_vectors_10m_available ) then i_file = subgrid_DD10_file_index else i_file = subgrid_DDgrid_file_index endif !i_meteo=DDgrid_subgrid_index !i_meteo not used in this conversion to wind direction unit_str = \"degrees\" do tt = 1 , subgrid_dim ( t_dim_index ) do jj = 1 , integral_subgrid_dim ( y_dim_index ) do ii = 1 , integral_subgrid_dim ( x_dim_index ) if ( wind_vectors_10m_available ) then temp_integral_subgrid ( ii , jj , tt ) = DIRECTION ( meteo_subgrid ( ii , jj , tt , u10_subgrid_index ), meteo_subgrid ( ii , jj , tt , v10_subgrid_index )) else temp_integral_subgrid ( ii , jj , tt ) = DIRECTION ( meteo_subgrid ( ii , jj , tt , ugrid_subgrid_index ), meteo_subgrid ( ii , jj , tt , vgrid_subgrid_index )) endif enddo enddo enddo !This is not converted to real degrees, but subgrid degrees, so is wrong but close !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); !In this case this is not the same for all temp_subgrid ( i , j ,:) = temp_integral_subgrid ( ii , jj ,:) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- endif i_file = subgrid_invL_file_index i_meteo = invL_subgrid_index unit_str = \"1/m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.4)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.4)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_logz0_file_index i_meteo = logz0_subgrid_index unit_str = \"log(m)\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_ustar_file_index i_meteo = ustar_subgrid_index unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( annual_calculations ) then i_file = subgrid_invFFgrid_file_index i_meteo = inv_FFgrid_subgrid_index unit_str = \"s/m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_invFF10_file_index i_meteo = inv_FF10_subgrid_index unit_str = \"s/m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- endif endif !Deallocate the averaging arrays with each receptor grid if ( use_multiple_receptor_grids_flag . and .. not . use_single_time_loop_flag . and . save_netcdf_average_flag ) then if ( allocated ( val_array_av )) deallocate ( val_array_av ) if ( allocated ( time_seconds_output_av )) deallocate ( time_seconds_output_av ) counter_av = 0 endif end subroutine uEMEP_save_netcdf_control","tags":"","loc":"proc/uemep_save_netcdf_control.html"},{"title":"uEMEP_save_netcdf_file – uEMEP","text":"private  subroutine uEMEP_save_netcdf_file(unit_logfile_in, filename_netcdf, nx, ny, nt_in, val_array_in, x_array, y_array, lon_array, lat_array, name_array, unit_array, title_str, create_file, valid_min, variable_type, scale_factor) Uses uEMEP_definitions netcdf Arguments Type Intent Optional Attributes Name integer :: unit_logfile_in character(len=256) :: filename_netcdf integer :: nx integer :: ny integer :: nt_in real :: val_array_in (nx,ny,nt_in) real :: x_array (nx,ny) real :: y_array (nx,ny) real :: lon_array (nx,ny) real :: lat_array (nx,ny) character(len=256) :: name_array character(len=256) :: unit_array character(len=256) :: title_str logical :: create_file real :: valid_min character(len=256) :: variable_type real :: scale_factor Source Code subroutine uEMEP_save_netcdf_file ( unit_logfile_in , filename_netcdf , nx , ny , nt_in , val_array_in , x_array , y_array , lon_array , lat_array , name_array , unit_array , title_str , create_file , valid_min , variable_type , scale_factor ) use uEMEP_definitions use netcdf implicit none character ( 256 ) filename_netcdf , name_array , unit_array , title_str , temp_name integer unit_logfile_in integer nx , ny , nt_in real val_array ( nx , ny , nt_in ), val_array_in ( nx , ny , nt_in ) !,val_array_temp(nx,ny,nt) real x_array ( nx , ny ) real y_array ( nx , ny ) real lon_array ( nx , ny ) real lat_array ( nx , ny ) !,lat_array_temp(nx,ny) !real time_array(nt) real x_vector ( nx ) real y_vector ( ny ) logical create_file real valid_min character ( 256 ) variable_type real scale_factor integer ncid integer y_dimid , x_dimid , time_dimid integer y_varid , x_varid , lat_varid , lon_varid , val_varid , time_varid , proj_varid integer dimids3 ( 3 ), dimids2 ( 2 ), chunks3 ( 3 ) integer n_dims ( 3 ) integer status integer nf90_type integer t integer n_time_total integer nt integer ( 8 ) time_seconds_output_nc ( nt_in ) !Need integer 8 for the averaging integer i_source character ( 2 ) temp_str integer i character ( 256 ) temp_str2 if ( trim ( variable_type ). eq . 'byte' ) nf90_type = NF90_BYTE if ( trim ( variable_type ). eq . 'short' ) nf90_type = NF90_SHORT if ( trim ( variable_type ). eq . 'float' ) nf90_type = NF90_FLOAT if ( trim ( variable_type ). eq . 'double' ) nf90_type = NF90_DOUBLE !Assumes x and y are the dimensions x_vector = x_array (:, 1 ) y_vector = y_array ( 1 ,:) n_time_total = end_time_nc_index - start_time_nc_index + 1 nt = nt_in val_array = val_array_in time_seconds_output_nc = time_seconds_output !Save averages only if ( save_netcdf_average_flag ) then counter_av = counter_av + 1 if ( counter_av . gt . n_var_av ) then write ( unit_logfile_in , * ) 'ERROR: Array size for saving averages (n_var_av) not large enough. Stopping' stop endif if ( use_single_time_loop_flag ) then val_array_av (:,:, counter_av ) = val_array_av (:,:, counter_av ) + val_array (:,:, nt ) !nt=1 in this case time_seconds_output_av ( counter_av ) = time_seconds_output_av ( counter_av ) + time_seconds_output_nc ( nt ) if ( t_loop . eq . end_time_loop_index ) then val_array (:,:, nt ) = val_array_av (:,:, counter_av ) / n_time_total time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) / n_time_total endif !write(unit_logfile_in,'(a,3i)') 'Saving as average single time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(nt) else val_array_av (:,:, counter_av ) = sum ( val_array , 3 ) / size ( val_array , 3 ) time_seconds_output_av ( counter_av ) = sum ( time_seconds_output_nc ) / size ( time_seconds_output_nc , 1 ) nt = 1 val_array (:,:, nt ) = val_array_av (:,:, counter_av ) time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) !write(unit_logfile_in,'(a,3i)') 'Saving as average multiple time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(nt) endif endif !Mask the regions if required if ( use_region_select_and_mask_flag ) then do t = 1 , nt ! NB: Array subgrid_val is no longer allocated or used !where (use_subgrid_val(:,:,allsource_index).eq.outside_region_index) val_array(:,:,t)=NODATA_value where (. not . use_subgrid (:,:, allsource_index )) val_array (:,:, t ) = NODATA_value enddo endif if ( create_file ) then !Create a netcdf file !call check(  nf90_create(filename_netcdf, nf90_clobber, ncid) ) !call check(  nf90_create(filename_netcdf, NF90_HDF5, ncid) ) call check ( nf90_create ( filename_netcdf , IOR ( NF90_HDF5 , NF90_CLASSIC_MODEL ), ncid ) ) !New !Specify global attributes call check ( nf90_put_att ( ncid , nf90_global , \"Conventions\" , \"CF-1.6\" ) ) call check ( nf90_put_att ( ncid , nf90_global , \"title\" , trim ( title_str )) ) call check ( nf90_put_att ( ncid , nf90_global , \"Model\" , trim ( model_version_str ) ) ) !Save some model flags for later reference call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_flag\" , EMEP_grid_interpolation_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_chemistry_scheme_flag\" , no2_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_size\" , EMEP_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_additional_grid_interpolation_size\" , EMEP_additional_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_background_chemistry_scheme_flag\" , no2_background_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_subgrid_method_flag\" , local_subgrid_method_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_emission_grid_interpolation_flag\" , EMEP_emission_grid_interpolation_flag ) ) if ( limit_emep_grid_interpolation_region_to_calculation_region ) then call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"true\" ) ) else call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"false\" ) ) endif call check ( nf90_put_att ( ncid , nf90_global , \"n_local_fraction_grids\" , n_local_fraction_grids ) ) do i = 1 , n_local_fraction_grids write ( temp_str , '(i0)' ) i temp_str2 = \"local_fraction_grid_size(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), local_fraction_grid_size ( i )) ) enddo call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_grid_interpolation\" , local_fraction_grid_for_EMEP_grid_interpolation ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_additional_grid_interpolation\" , local_fraction_grid_for_EMEP_additional_grid_interpolation ) ) if (. not . use_GNFR_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR_emissions_from_EMEP_flag\" , \"false\" ) ) endif if ( use_GNFR_emissions_from_EMEP_flag . and .. not . use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR13_emissions_from_EMEP_flag\" , \"true\" ) ) endif if ( use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR19_emissions_from_EMEP_flag\" , \"true\" ) ) endif !Write out sources i = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"uEMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_uEMEP_sources\" , i )) i = 0 do i_source = 1 , n_source_index if ( calculate_EMEP_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"EMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_EMEP_sources\" , i )) !Projection data if ( projection_type . eq . UTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_utm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) if ( utm_zone . ge . 0 ) then call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) else call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 1000000 0. ) ) endif call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) endif if ( projection_type . eq . LTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_tm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) if ( utm_zone . ge . 0 ) then call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) else call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 1000000 0. ) ) endif call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , ltm_lon0 ) ) endif if ( projection_type . eq . RDM_projection_index ) then !Not properly assigned, same as UTM call check ( nf90_def_var ( ncid , \"projection_RDM\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) endif if ( projection_type . eq . LAEA_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_ETRS89_LAEA\" , NF90_int , proj_varid ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378137.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"inverse_flattening\", 298.257222101 ) ) !https://github.com/mdsumner/rasterwise/blob/master/README.md !EPSG:3035 !int ETRS89-LAEA ; !    ETRS89-LAEA:missing_value = -1. ; !   ETRS89-LAEA:grid_mapping_name = \"lambert_azimuthal_equal_area\" ; !   ETRS89-LAEA:longitude_of_projection_origin = 10. ; !   ETRS89-LAEA:latitude_of_projection_origin = 52. ; !   ETRS89-LAEA:false_easting = 4321000. ; !   ETRS89-LAEA:false_northing = 3210000. ; !   ETRS89-LAEA:inverse_flattening = 298.257222101 ; !   ETRS89-LAEA:semi_major_axis = 6378137. ; !call check(  nf90_put_att(ncid, proj_varid, \"grid_mapping_name\", \"lambert_azimuthal_equal_area\" ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378137.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"inverse_flattening\", 298.257222101 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"scale_factor_at_central_meridian\", 0.9996 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"latitude_of_projection_origin\",  52. ) ) !call check(  nf90_put_att(ncid, proj_varid, \"false_easting\", 4321000. ) ) !call check(  nf90_put_att(ncid, proj_varid, \"false_northing\", 3210000. ) ) !call check(  nf90_put_att(ncid, proj_varid, \"longitude_of_projection_origin\", 10.) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"lambert_azimuthal_equal_area\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , projection_attributes ( 5 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , projection_attributes ( 6 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , projection_attributes ( 2 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , projection_attributes ( 3 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , projection_attributes ( 4 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_projection_origin\" , projection_attributes ( 1 )) ) endif !Define the dimensions call check ( nf90_def_dim ( ncid , \"time\" , NF90_UNLIMITED , time_dimid ) ) call check ( nf90_def_dim ( ncid , \"y\" , ny , y_dimid ) ) call check ( nf90_def_dim ( ncid , \"x\" , nx , x_dimid ) ) !Define the dimension variables !call check(  nf90_def_var(ncid, \"time\", NF90_DOUBLE, time_dimid, time_varid) ) call check ( nf90_def_var ( ncid , \"time\" , NF90_INT , time_dimid , time_varid ) ) call check ( nf90_def_var ( ncid , \"y\" , NF90_REAL , y_dimid , y_varid ) ) call check ( nf90_def_var ( ncid , \"x\" , NF90_REAL , x_dimid , x_varid ) ) !Define the values dimids3 = ( / x_dimid , y_dimid , time_dimid / ) dimids2 = ( / x_dimid , y_dimid / ) call check ( nf90_def_var ( ncid , \"lat\" , NF90_REAL , dimids2 , lat_varid ) ) call check ( nf90_def_var ( ncid , \"lon\" , NF90_REAL , dimids2 , lon_varid ) ) !Specify the units call check ( nf90_put_att ( ncid , lat_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , lon_varid , \"units\" , \"degrees_east\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , time_varid , \"units\" , trim ( unit_dim_nc ( time_dim_nc_index ))) ) !Specify other dimension attributes call check ( nf90_put_att ( ncid , y_varid , \"standard_name\" , \"projection_y_coordinate\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"standard_name\" , \"projection_x_coordinate\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"axis\" , \"Y\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"axis\" , \"X\" ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index)) ) !call check( nf90_put_var(ncid, time_varid, time_seconds_output(1:dim_length_nc(time_dim_nc_index))) ) call check ( nf90_put_var ( ncid , time_varid , time_seconds_output_nc ( 1 : nt )) ) call check ( nf90_put_var ( ncid , y_varid , y_vector ) ) call check ( nf90_put_var ( ncid , x_varid , x_vector ) ) call check ( nf90_put_var ( ncid , lat_varid , lat_array ) ) call check ( nf90_put_var ( ncid , lon_varid , lon_array ) ) call check ( nf90_close ( ncid ) ) endif !Do not save any average data for single time loops until the last time step where it will save the average if ( save_netcdf_average_flag . and . use_single_time_loop_flag . and . t_loop . ne . end_time_loop_index ) then !call check( nf90_close(ncid) ) return endif !Add to the existing file call check ( nf90_open ( filename_netcdf , NF90_WRITE , ncid ) ) !Get the dimensions id from the existing file call check ( nf90_inq_dimid ( ncid , \"time\" , time_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"y\" , y_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"x\" , x_dimid ) ) dimids3 = ( / x_dimid , y_dimid , time_dimid / ) chunks3 = ( / nx , ny , 1 / ) !New call check ( nf90_inquire_dimension ( ncid , dimids3 ( 1 ), temp_name , n_dims ( 1 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 2 ), temp_name , n_dims ( 2 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 3 ), temp_name , n_dims ( 3 )) ) status = nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) if ( status . ne . nf90_NoErr ) then call check ( nf90_redef ( ncid ) ) !if the variable does not exist then create a new one !write(*,*) 'Creating new: ',trim(name_array) call check ( nf90_def_var ( ncid , trim ( name_array ), nf90_type , dimids3 , val_varid ) ) ! gzip level 3 compression and shuffling ! optional _FillValue for values which never have been written, unpacked value call check ( nf90_def_var_chunking ( ncid , val_varid , NF90_CHUNKED , chunks3 ) ) !New call check ( nf90_def_var_deflate ( ncid , val_varid , 1 , 1 , 3 ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"units\" , trim ( unit_array )) ) !Specify other variable attributes if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 1 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 2 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 2 )) ) else call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , NODATA_value ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , valid_min ) ) endif if ( projection_type . eq . UTM_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_utm\" ) ) elseif ( projection_type . eq . LTM_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_tm\" ) ) elseif ( projection_type . eq . LAEA_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_ETRS89_LAEA\" ) ) elseif ( projection_type . eq . RDM_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_RDM\" ) ) endif call check ( nf90_put_att ( ncid , val_varid , \"coordinates\" , \"lon lat\" ) ) if ( scale_factor . ne . 1. ) call check ( nf90_put_att ( ncid , val_varid , \"scale_factor\" , scale_factor ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) endif if ( use_single_time_loop_flag ) then !Add time to the time dimension call check ( nf90_inq_varid ( ncid , \"time\" , time_varid ) ) !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 if ( save_netcdf_average_flag ) then n_dims ( 3 ) = nt else n_dims ( 3 ) = t_loop endif call check ( nf90_put_var ( ncid , time_varid , time_seconds_output_nc ( 1 ), start = ( / n_dims ( 3 ) / ) ) ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !Add dimension and array to existing call check ( nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) ) if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 1 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 2 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) else call check ( nf90_put_var ( ncid , val_varid , val_array , start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) endif else !Write the whole variable to file. Default is float if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 2 )) ) else call check ( nf90_put_var ( ncid , val_varid , val_array (:,:, 1 : nt )) ) endif endif call check ( nf90_close ( ncid ) ) end subroutine uEMEP_save_netcdf_file","tags":"","loc":"proc/uemep_save_netcdf_file.html"},{"title":"check – uEMEP","text":"public  subroutine check(status) Uses netcdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Source Code subroutine check ( status ) use netcdf implicit none integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( * , * ) 'Stopping due to netcdf error: ' // trim ( nf90_strerror ( status )) error stop end if end subroutine check","tags":"","loc":"proc/check.html"},{"title":"uEMEP_save_netcdf_receptor_file – uEMEP","text":"private  subroutine uEMEP_save_netcdf_receptor_file(unit_logfile_in, filename_netcdf, nx, ny, nt_in, val_array_in, x_array, y_array, lon_array, lat_array, name_array, unit_array, title_str, create_file, valid_min, x_rec, y_rec, lon_rec, lat_rec, height_rec, name_rec_in, nr, variable_type, scale_factor) Uses uEMEP_definitions netcdf call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index), start=(/n_dims_start(2)/), count=(/n_dims_length(2)/)) )\ncall check( nf90_put_var(ncid, station_varid, name_rec(:), start = (/1,1/), count=(/n_dims(1),n_char/)) ) call check( nf90_put_var(ncid, station_name_varid, name_rec, start = (/1,1/), count=(/n_char,n_dims(1)/)) )\ncall check( nf90_put_var(ncid, station_name_varid, name_rec, start = (/1/), count=(/n_dims(1)/)) ) Arguments Type Intent Optional Attributes Name integer :: unit_logfile_in character(len=256) :: filename_netcdf integer :: nx integer :: ny integer :: nt_in real :: val_array_in (nx,ny,nt_in) real :: x_array (nx,ny) real :: y_array (nx,ny) real :: lon_array (nx,ny) real :: lat_array (nx,ny) character(len=256) :: name_array character(len=256) :: unit_array character(len=256) :: title_str logical :: create_file real :: valid_min real :: x_rec (nr) real :: y_rec (nr) real :: lon_rec (nr) real :: lat_rec (nr) real :: height_rec (nr) character(len=256) :: name_rec_in (nr) integer :: nr character(len=256) :: variable_type real :: scale_factor Source Code subroutine uEMEP_save_netcdf_receptor_file ( unit_logfile_in , filename_netcdf , nx , ny , nt_in , val_array_in , x_array , y_array , lon_array , lat_array , name_array , unit_array , title_str , create_file , valid_min & , x_rec , y_rec , lon_rec , lat_rec , height_rec , name_rec_in , nr , variable_type , scale_factor ) use uEMEP_definitions use netcdf implicit none character ( 256 ) filename_netcdf , name_array , unit_array , title_str , temp_name integer unit_logfile_in integer nx , ny , nt_in , nr real val_array ( nx , ny , nt_in ), val_array_in ( nx , ny , nt_in ) !,val_array_temp(nx,ny,nt_in) real x_array ( nx , ny ) real y_array ( nx , ny ) real lon_array ( nx , ny ) real lat_array ( nx , ny ) !,lat_array_temp(nx,ny) !real time_array(nt_in) !real x_vector(nx) !real y_vector(ny) logical create_file real valid_min character ( 256 ) variable_type real scale_factor integer ncid integer station_dimid , time_dimid , charlen_dimid integer station_varid , station_name_varid , lat_varid , lon_varid , val_varid , time_varid , proj_varid , x_varid , y_varid , height_varid integer dimids2 ( 2 ) integer n_dims_length ( 3 ), n_dims_start ( 3 ) integer status integer tr , rr real x_rec ( nr ), y_rec ( nr ), height_rec ( nr ) real lon_rec ( nr ), lat_rec ( nr ) character ( 256 ) name_rec_in ( nr ) character ( 256 ) temp_char integer n_char !parameter (n_char=7) parameter ( n_char = 64 ) character ( 1 ) name_rec ( n_char , nr ) integer n_time_total real val_rec ( nr , nt_in ) real delta ( 2 ) integer id_rec ( nr ) integer nf90_type integer nt integer ( 8 ) time_seconds_output_nc ( nt_in ) integer tr_0 integer i_source character ( 2 ) temp_str integer i character ( 256 ) temp_str2 !Do not save if no receptor position data is available if ( nr . eq . 0 ) then return endif if ( trim ( variable_type ). eq . 'byte' ) nf90_type = NF90_BYTE if ( trim ( variable_type ). eq . 'short' ) nf90_type = NF90_SHORT if ( trim ( variable_type ). eq . 'float' ) nf90_type = NF90_FLOAT if ( trim ( variable_type ). eq . 'double' ) nf90_type = NF90_DOUBLE nt = nt_in val_array = val_array_in time_seconds_output_nc = time_seconds_output !Save averages only if ( save_netcdf_average_flag ) then counter_av = counter_av + 1 if ( counter_av . gt . n_var_av ) then write ( unit_logfile_in , * ) 'ERROR: Array size for saving averages (n_var_av) not large enough. Stopping' stop endif if ( use_single_time_loop_flag ) then val_array_av (:,:, counter_av ) = val_array_av (:,:, counter_av ) + val_array (:,:, nt ) !nt=1 in this case time_seconds_output_av ( counter_av ) = time_seconds_output_av ( counter_av ) + time_seconds_output_nc ( nt ) if ( t_loop . eq . end_time_loop_index ) then val_array (:,:, nt ) = val_array_av (:,:, counter_av ) / end_time_loop_index time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) / end_time_loop_index endif !write(unit_logfile_in,*) 'Saving as average single time loop (nt,counter_av):',nt,counter_av else !write(unit_logfile_in,*) 'Saving as average multiple time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(1),time_seconds_output_nc(nt) !write(*,*) time_seconds_output_nc(1:nt) val_array_av (:,:, counter_av ) = sum ( val_array (:,:, 1 : nt ), 3 ) / nt time_seconds_output_av ( counter_av ) = sum ( time_seconds_output_nc ( 1 : nt ), 1 ) / nt !write(*,*) sum(time_seconds_output_nc(1:nt),1) nt = 1 val_array (:,:, nt ) = val_array_av (:,:, counter_av ) time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) !write(unit_logfile_in,*) 'Saving as average multiple time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(nt),time_seconds_output_av(counter_av) endif endif !Interpolate to receptor position given the input array !write(unit_logfile,'(a)')' Interpolating to receptor point ' !Assumes 2 elements to an array delta ( 1 ) = ( x_array ( 2 , 1 ) - x_array ( 1 , 1 )) delta ( 2 ) = ( y_array ( 1 , 2 ) - y_array ( 1 , 1 )) do rr = 1 , nr do tr = 1 , nt val_rec ( rr , tr ) = area_weighted_interpolation_function ( x_array , y_array , val_array (:,:, tr ), nx , ny , delta , x_rec ( rr ), y_rec ( rr )) enddo enddo !Make the receptor name to fit to netcdf requirements do rr = 1 , nr id_rec ( rr ) = rr temp_char = name_rec_in ( rr ) tr_0 = len_trim ( temp_char ) do tr = 1 , tr_0 name_rec ( tr , rr ) = temp_char ( tr : tr ) !write(*,*) trim(name_rec_in(rr)),trim(name_rec(rr)) enddo do tr = tr_0 + 1 , n_char name_rec ( tr , rr ) = char ( 0 ) enddo enddo if ( save_netcdf_average_flag ) then n_time_total = 1 else n_time_total = end_time_nc_index - start_time_nc_index + 1 endif if ( create_file ) then !Create a netcdf file !call check(  nf90_create(filename_netcdf, nf90_clobber, ncid) ) !call check(  nf90_create(filename_netcdf, NF90_HDF5, ncid) ) call check ( nf90_create ( filename_netcdf , IOR ( NF90_HDF5 , NF90_CLASSIC_MODEL ), ncid ) ) !New !Specify global attributes call check ( nf90_put_att ( ncid , nf90_global , \"Conventions\" , \"CF-1.6\" ) ) call check ( nf90_put_att ( ncid , nf90_global , \"title\" , trim ( title_str )) ) call check ( nf90_put_att ( ncid , nf90_global , \"Model\" , trim ( model_version_str ) ) ) call check ( nf90_put_att ( ncid , nf90_global , \"featureType\" , \"timeSeries\" ) ) !Save some model flags for later reference call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_flag\" , EMEP_grid_interpolation_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_chemistry_scheme_flag\" , no2_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_size\" , EMEP_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_additional_grid_interpolation_size\" , EMEP_additional_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_background_chemistry_scheme_flag\" , no2_background_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_subgrid_method_flag\" , local_subgrid_method_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_emission_grid_interpolation_flag\" , EMEP_emission_grid_interpolation_flag ) ) if ( limit_emep_grid_interpolation_region_to_calculation_region ) then call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"true\" ) ) else call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"false\" ) ) endif call check ( nf90_put_att ( ncid , nf90_global , \"n_local_fraction_grids\" , n_local_fraction_grids ) ) do i = 1 , n_local_fraction_grids write ( temp_str , '(i0)' ) i temp_str2 = \"local_fraction_grid_size(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), local_fraction_grid_size ( i )) ) enddo call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_grid_interpolation\" , local_fraction_grid_for_EMEP_grid_interpolation ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_additional_grid_interpolation\" , local_fraction_grid_for_EMEP_additional_grid_interpolation ) ) if (. not . use_GNFR_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR_emissions_from_EMEP_flag\" , \"false\" ) ) endif if ( use_GNFR_emissions_from_EMEP_flag . and .. not . use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR13_emissions_from_EMEP_flag\" , \"true\" ) ) endif if ( use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR19_emissions_from_EMEP_flag\" , \"true\" ) ) endif !Write out sources i = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"uEMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_uEMEP_sources\" , i )) i = 0 do i_source = 1 , n_source_index if ( calculate_EMEP_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"EMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_EMEP_sources\" , i )) !Projection data if ( projection_type . eq . UTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_utm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378140.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_minor_axis\", 6356750.0 ) ) endif if ( projection_type . eq . LTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_tm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , ltm_lon0 ) ) endif if ( projection_type . eq . RDM_projection_index ) then !Not properly assigned, same as UTM call check ( nf90_def_var ( ncid , \"projection_RDM\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) endif if ( projection_type . eq . LAEA_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_ETRS89_LAEA\" , NF90_int , proj_varid ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378137.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"inverse_flattening\", 298.257222101 ) ) !https://github.com/mdsumner/rasterwise/blob/master/README.md !EPSG:3035 call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"lambert_azimuthal_equal_area\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , projection_attributes ( 5 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , projection_attributes ( 6 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , projection_attributes ( 2 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , projection_attributes ( 3 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , projection_attributes ( 4 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_projection_origin\" , projection_attributes ( 1 )) ) endif !Define the dimensions for the entire dataset !write(*,*) 'n_valid_receptor_in',n_valid_receptor_in !write(*,*) 'n_valid_receptor',n_valid_receptor call check ( nf90_def_dim ( ncid , \"station_id\" , n_valid_receptor_in , station_dimid ) ) call check ( nf90_def_dim ( ncid , \"charlen\" , n_char , charlen_dimid ) ) !call check(  nf90_def_dim(ncid,\"time\",n_time_total, time_dimid) ) !To have time as unlimittec (Heiko) call check ( nf90_def_dim ( ncid , \"time\" , NF90_UNLIMITED , time_dimid ) ) !Define the dimension variables call check ( nf90_def_var ( ncid , \"station_id\" , NF90_INT , station_dimid , station_varid ) ) !call check(  nf90_def_var(ncid, \"time\", NF90_DOUBLE, time_dimid, time_varid) ) call check ( nf90_def_var ( ncid , \"time\" , NF90_INT , time_dimid , time_varid ) ) !Define the values dimids2 = ( / station_dimid , time_dimid / ) !dimids1 = (/ station_dimid /) call check ( nf90_def_var ( ncid , \"lat\" , NF90_REAL , station_dimid , lat_varid ) ) call check ( nf90_def_var ( ncid , \"lon\" , NF90_REAL , station_dimid , lon_varid ) ) call check ( nf90_def_var ( ncid , \"y\" , NF90_REAL , station_dimid , y_varid ) ) call check ( nf90_def_var ( ncid , \"x\" , NF90_REAL , station_dimid , x_varid ) ) call check ( nf90_def_var ( ncid , \"station_name\" , NF90_CHAR , ( / charlen_dimid , station_dimid / ), station_name_varid ) ) call check ( nf90_def_var ( ncid , \"station_height\" , NF90_REAL , station_dimid , height_varid ) ) !call check(  nf90_def_var(ncid, \"station_name\", NF90_CHAR, (/station_dimid/), station_name_varid) ) !call check(  nf90_def_var(ncid, \"station_name\", NF90_CHAR, (/charlen_dimid,station_dimid/), station_name_varid) ) !Specify the units call check ( nf90_put_att ( ncid , lat_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , lon_varid , \"units\" , \"degrees_east\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , height_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , time_varid , \"units\" , trim ( unit_dim_nc ( time_dim_nc_index ))) ) call check ( nf90_put_att ( ncid , station_varid , \"long_name\" , \"station index\" ) ) call check ( nf90_put_att ( ncid , station_name_varid , \"long_name\" , \"station name\" ) ) call check ( nf90_put_att ( ncid , station_name_varid , \"cf_role\" , \"timeseries_id\" ) ) !Specify other dimension attributes !call check(  nf90_put_att(ncid, y_varid, \"standard_name\", \"projection_y_coordinate\") ) !call check(  nf90_put_att(ncid, x_varid, \"standard_name\", \"projection_x_coordinate\") ) !call check(  nf90_put_att(ncid, y_varid, \"axis\", \"Y\") ) !call check(  nf90_put_att(ncid, x_varid, \"axis\", \"X\") ) !Close the definitions call check ( nf90_enddef ( ncid ) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index)) ) !call check( nf90_put_var(ncid, station_varid, name_rec(:,1:n_char) ) !call check( nf90_put_var(ncid, lat_varid, lat_array) ) !call check( nf90_put_var(ncid, lon_varid, lon_array) ) !Put this in to fix unlimitted problem? If works on annual need to check it works other places as well! !call check( nf90_put_var(ncid, time_varid, time_seconds_output_nc(1:nt), start=(/1/), count=(/nt/)) ) !call check( nf90_put_var(ncid, time_varid, time_seconds_output_nc(1:nt)) ) call check ( nf90_close ( ncid ) ) endif !Add to the existing file call check ( nf90_open ( filename_netcdf , NF90_WRITE , ncid ) ) !Get the dimensions id from the existing file call check ( nf90_inq_dimid ( ncid , \"time\" , time_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"station_id\" , station_dimid ) ) ! write(*,*) 'station_dimid ',station_dimid ! write(*,*) 'time_dimid ',time_dimid dimids2 = ( / station_dimid , time_dimid / ) !Get the size of the dimensions call check ( nf90_inquire_dimension ( ncid , dimids2 ( 1 ), temp_name , n_dims_length ( 1 )) ) call check ( nf90_inquire_dimension ( ncid , dimids2 ( 2 ), temp_name , n_dims_length ( 2 )) ) !Set the starting point to 1 n_dims_start ( 1 : 2 ) = 1 !Set time to full length in unlimitted case (Heiko) n_dims_length ( 2 ) = n_time_total ! write(*,*) 'n_dims_length(1) ',n_dims_length(1) ! write(*,*) 'n_dims_length(2) ',n_dims_length(2) status = nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) if ( status . ne . nf90_NoErr ) then !if the variable does not exist then create a new one !write(*,*) 'Creating new: ',trim(name_array) call check ( nf90_redef ( ncid ) ) call check ( nf90_def_var ( ncid , trim ( name_array ), nf90_type , dimids2 , val_varid ) ) call check ( nf90_put_att ( ncid , val_varid , \"units\" , trim ( unit_array )) ) !Specify other variable attributes if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 1 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 2 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 2 )) ) else call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , NODATA_value ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , valid_min ) ) endif call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_utm\" ) ) call check ( nf90_put_att ( ncid , val_varid , \"coordinates\" , \"station_name lat lon\" ) ) if ( scale_factor . ne . 1. ) call check ( nf90_put_att ( ncid , val_varid , \"scale_factor\" , scale_factor ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) endif !Should not be used but can be if ( use_single_time_loop_flag ) then !Add time to the time dimension !call check( nf90_inq_varid(ncid, \"time\", time_varid) ) !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 if ( save_netcdf_average_flag ) then n_dims_start ( 2 ) = 1 n_dims_length ( 2 ) = 1 else n_dims_start ( 2 ) = t_loop n_dims_length ( 2 ) = 1 endif !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1,time_dim_nc_index), start = (/n_dims(2)/) ) ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !Add dimension and array to existing !call check( nf90_inq_varid(ncid, trim(name_array), val_varid) ) !call check( nf90_put_var(ncid, val_varid, val_rec, start=(/1,n_dims(2)/), count=(/n_dims(1),1/)) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index), start=(/n_dims(2)/), count=(/1/)) ) !call check( nf90_put_var(ncid, station_varid, name_rec(1,:), start=(/1,1/), count=(/n_dims(1),n_char/)) ) elseif ( use_multiple_receptor_grids_flag ) then !Add time to the time dimension !call check( nf90_inq_varid(ncid, \"station\", station_varid) ) !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 n_dims_start ( 1 ) = valid_receptor_inverse_index ( g_loop ) n_dims_length ( 1 ) = 1 id_rec ( 1 ) = valid_receptor_inverse_index ( g_loop ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !Add dimension and array to existing !call check( nf90_inq_varid(ncid, trim(name_array), val_varid) ) !call check( nf90_put_var(ncid, val_varid, val_rec, start=(/n_dims(1),1/), count=(/1,n_dims(2)/)) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index) , start=(/1/), count=(/n_dims(2)/)) ) !call check( nf90_put_var(ncid, station_varid, name_rec(1,:), start = (/n_dims(1),1/), count=(/1,n_char/)) ) endif !write(*,*) 'n_dims_start',n_dims_start !write(*,*) 'n_dims_length',n_dims_length !Fill in the complete dimension variables for time and receptor names call check ( nf90_inq_varid ( ncid , \"station_id\" , station_varid ) ) call check ( nf90_inq_varid ( ncid , \"time\" , time_varid ) ) call check ( nf90_inq_varid ( ncid , \"station_name\" , station_name_varid ) ) call check ( nf90_inq_varid ( ncid , \"x\" , x_varid ) ) call check ( nf90_inq_varid ( ncid , \"y\" , y_varid ) ) call check ( nf90_inq_varid ( ncid , \"lon\" , lon_varid ) ) call check ( nf90_inq_varid ( ncid , \"lat\" , lat_varid ) ) call check ( nf90_inq_varid ( ncid , \"station_height\" , height_varid ) ) !Write time to the file !!call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index), start=(/n_dims_start(2)/), count=(/n_dims_length(2)/)) ) call check ( nf90_put_var ( ncid , time_varid , time_seconds_output_nc ( 1 : nt ), start = ( / n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 2 ) / )) ) !!call check( nf90_put_var(ncid, station_varid, name_rec(:), start = (/1,1/), count=(/n_dims(1),n_char/)) ) !Write station index and name call check ( nf90_put_var ( ncid , station_varid , id_rec , start = ( / n_dims_start ( 1 ), 1 / ), count = ( / n_dims_length ( 1 ), n_char / )) ) call check ( nf90_put_var ( ncid , station_name_varid , name_rec , start = ( / 1 , n_dims_start ( 1 ) / ), count = ( / n_char , n_dims_length ( 1 ) / )) ) !!call check( nf90_put_var(ncid, station_name_varid, name_rec, start = (/1,1/), count=(/n_char,n_dims(1)/)) ) !!call check( nf90_put_var(ncid, station_name_varid, name_rec, start = (/1/), count=(/n_dims(1)/)) ) !Write the variable to file if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_rec (:, 1 : nt ), kind = 1 ), start = ( / n_dims_start ( 1 ), n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 1 ), n_dims_length ( 2 ) / )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_rec (:, 1 : nt ), kind = 2 ), start = ( / n_dims_start ( 1 ), n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 1 ), n_dims_length ( 2 ) / )) ) else call check ( nf90_put_var ( ncid , val_varid , val_rec (:, 1 : nt ), start = ( / n_dims_start ( 1 ), n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 1 ), n_dims_length ( 2 ) / )) ) endif !Write position data to the file call check ( nf90_put_var ( ncid , x_varid , x_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , y_varid , y_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , lon_varid , lon_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , lat_varid , lat_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , height_varid , height_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_close ( ncid ) ) end subroutine uEMEP_save_netcdf_receptor_file","tags":"","loc":"proc/uemep_save_netcdf_receptor_file.html"},{"title":"replace_string_char – uEMEP","text":"public  function replace_string_char(replace_str, match_str, read_str) Arguments Type Intent Optional Attributes Name character(len=*) :: replace_str character(len=*) :: match_str character(len=*) :: read_str Return Value character(len=256) Source Code function replace_string_char ( replace_str , match_str , read_str ) !Finds a match_str in read_str and replaces it with replace_str to give a new version of read_str implicit none character ( 256 ) replace_string_char character ( * ) match_str , replace_str , read_str character ( 256 ) temp_str1 , temp_str2 integer index_start , index_stop replace_string_char = read_str index_start = index ( read_str , trim ( match_str )) if ( index_start . ne . 0 ) then index_stop = index_start + len ( trim ( match_str )) temp_str1 = read_str ( 1 : index_start - 1 ) temp_str2 = read_str ( index_stop : len ( read_str )) replace_string_char = trim ( temp_str1 ) // trim ( replace_str ) // trim ( temp_str2 ) endif !write(*,'(A)') trim(replace_string_char) end function replace_string_char","tags":"","loc":"proc/replace_string_char.html"},{"title":"uEMEP_read_config – uEMEP","text":"public  subroutine uEMEP_read_config() Arguments None Source Code subroutine uEMEP_read_config implicit none integer i character ( 256 ) pathfilename_log_file logical :: exists integer a ( 6 ) character ( 256 ) format_temp integer :: unit_in = 30 integer i_config , i_source , i_landuse double precision datenum_temp character ( 256 ) yesterday_date_str character ( 256 ) a_str , b_str character ( 256 ) temp_str !========================================================================== !   uEMEP model setup !========================================================================== write ( * , '(A)' ) '' write ( * , '(A)' ) '================================================================' write ( * , '(A)' ) 'Reading model run configuration (uEMEP_read_config)' write ( * , '(A)' ) '================================================================' do i_config = 1 , n_config_files !Temporary hardcoding of config file name. Will be read in as command line string if ( len ( name_config_file ( i_config )). eq . 0 ) then !name_config_file='C:\\uEMEP\\Fortran\\application\\config\\uEMEP_config_test.txt' write ( * , '(a)' ) 'ERROR: No configuration file available. Stopping.' stop endif write ( * , '(a)' ) 'Reading configuration file: ' // trim ( name_config_file ( i_config )) !Check existence of file inquire ( file = trim ( name_config_file ( i_config )), exist = exists ) if (. not . exists ) then write ( * , '(A)' ) 'ERROR: Configuration file ' // trim ( name_config_file ( i_config )) // ' does not exist.' stop endif !Open the config file for reading open ( unit_in , file = name_config_file ( i_config ), access = 'sequential' , status = 'old' , readonly ) !First read log file name and open it filename_log_file = read_name_char ( 'filename_log_file' , filename_log_file , unit_in , unit_logfile ) pathname_log_file = read_name_char ( 'pathname_log_file' , pathname_log_file , unit_in , unit_logfile ) !Open log file when reading the first configuration file if ( i_config . eq . 1 ) then if ( len ( trim ( filename_log_file )). gt . 0 ) then unit_logfile = 10 !Check existence of path inquire ( file = trim ( pathname_log_file ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A)' ) 'ERROR: Log file directory path ' // trim ( pathname_log_file ) // ' does not exist.' stop endif !Write to screen if writing to log file pathfilename_log_file = trim ( pathname_log_file ) // trim ( filename_log_file ) write ( * , '(A,A)' ) 'Writing to log file: ' , trim ( pathfilename_log_file ) write ( * , '(A)' ) '================================================================' open ( unit_logfile , file = trim ( pathfilename_log_file ), access = 'sequential' , form = 'formatted' , status = 'unknown' ) if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) '------------------------------------------------------------------------' write ( unit_logfile , * ) 'Starting programm ' , trim ( model_version_str ) write ( unit_logfile , * ) '------------------------------------------------------------------------' endif else unit_logfile = 0 endif endif file_tag = read_name_char ( 'file_tag' , file_tag , unit_in , unit_logfile ) replacement_date_str = read_name_char ( 'replacement_date_str' , replacement_date_str , unit_in , unit_logfile ) replacement_yesterday_date_str = read_name_char ( 'replacement_yesterday_date_str' , replacement_yesterday_date_str , unit_in , unit_logfile ) replacement_hour_str = read_name_char ( 'replacement_hour_str' , replacement_hour_str , unit_in , unit_logfile ) NORTRIP_replacement_hour_str = read_name_char ( 'NORTRIP_replacement_hour_str' , NORTRIP_replacement_hour_str , unit_in , unit_logfile ) input_comp_name = read_name_char ( 'input_comp_name' , input_comp_name , unit_in , unit_logfile ) hourly_calculations = read_name_logical ( 'hourly_calculations' , hourly_calculations , unit_in , unit_logfile ) annual_calculations = read_name_logical ( 'annual_calculations' , annual_calculations , unit_in , unit_logfile ) !Not implemented !start_month_in_annual_calculations=read_name_integer('start_month_in_annual_calculations',start_month_in_annual_calculations,unit_in,unit_logfile) !end_month_in_annual_calculations=read_name_integer('end_month_in_annual_calculations',end_month_in_annual_calculations,unit_in,unit_logfile) start_time_nc_index = read_name_integer ( 'start_time_nc_index' , start_time_nc_index , unit_in , unit_logfile ) end_time_nc_index = read_name_integer ( 'end_time_nc_index' , end_time_nc_index , unit_in , unit_logfile ) start_time_meteo_nc_index = read_name_integer ( 'start_time_meteo_nc_index' , start_time_meteo_nc_index , unit_in , unit_logfile ) end_time_meteo_nc_index = read_name_integer ( 'end_time_meteo_nc_index' , end_time_meteo_nc_index , unit_in , unit_logfile ) use_single_time_loop_flag = read_name_logical ( 'use_single_time_loop_flag' , use_single_time_loop_flag , unit_in , unit_logfile ) reduce_EMEP_region_flag = read_name_logical ( 'reduce_EMEP_region_flag' , reduce_EMEP_region_flag , unit_in , unit_logfile ) use_multiple_receptor_grids_flag = read_name_logical ( 'use_multiple_receptor_grids_flag' , use_multiple_receptor_grids_flag , unit_in , unit_logfile ) use_receptor_region = read_name_integer ( 'use_receptor_region' , use_receptor_region , unit_in , unit_logfile ) reduce_roadlink_region_flag = read_name_logical ( 'reduce_roadlink_region_flag' , reduce_roadlink_region_flag , unit_in , unit_logfile ) !Choose which sources to calculate !calculate_source(:)=read_name_logical('calculate_source(:)',calculate_source(allsource_index),unit_in,unit_logfile) calculate_source ( traffic_index ) = read_name_logical ( 'calculate_source(traffic_index)' , calculate_source ( traffic_index ), unit_in , unit_logfile ) calculate_source ( shipping_index ) = read_name_logical ( 'calculate_source(shipping_index)' , calculate_source ( shipping_index ), unit_in , unit_logfile ) calculate_source ( heating_index ) = read_name_logical ( 'calculate_source(heating_index)' , calculate_source ( heating_index ), unit_in , unit_logfile ) calculate_source ( agriculture_index ) = read_name_logical ( 'calculate_source(agriculture_index)' , calculate_source ( agriculture_index ), unit_in , unit_logfile ) calculate_source ( industry_index ) = read_name_logical ( 'calculate_source(industry_index)' , calculate_source ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources calculate_source ( publicpower_index ) = read_name_logical ( 'calculate_source(publicpower_index)' , calculate_source ( publicpower_index ), unit_in , unit_logfile ) calculate_source ( fugitive_index ) = read_name_logical ( 'calculate_source(fugitive_index)' , calculate_source ( fugitive_index ), unit_in , unit_logfile ) calculate_source ( solvents_index ) = read_name_logical ( 'calculate_source(solvents_index)' , calculate_source ( solvents_index ), unit_in , unit_logfile ) calculate_source ( aviation_index ) = read_name_logical ( 'calculate_source(aviation_index)' , calculate_source ( aviation_index ), unit_in , unit_logfile ) calculate_source ( offroad_index ) = read_name_logical ( 'calculate_source(offroad_index)' , calculate_source ( offroad_index ), unit_in , unit_logfile ) calculate_source ( waste_index ) = read_name_logical ( 'calculate_source(waste_index)' , calculate_source ( waste_index ), unit_in , unit_logfile ) calculate_source ( livestock_index ) = read_name_logical ( 'calculate_source(livestock_index)' , calculate_source ( livestock_index ), unit_in , unit_logfile ) calculate_source ( other_index ) = read_name_logical ( 'calculate_source(other_index)' , calculate_source ( other_index ), unit_in , unit_logfile ) !Choose which EMEP sources to include/calculate. Will not be downscaled but will included as gridded source contributions !calculate_source(:)=read_name_logical('calculate_source(:)',calculate_source(allsource_index),unit_in,unit_logfile) calculate_EMEP_source ( traffic_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_index)' , calculate_EMEP_source ( traffic_index ), unit_in , unit_logfile ) calculate_EMEP_source ( shipping_index ) = read_name_logical ( 'calculate_EMEP_source(shipping_index)' , calculate_EMEP_source ( shipping_index ), unit_in , unit_logfile ) calculate_EMEP_source ( heating_index ) = read_name_logical ( 'calculate_EMEP_source(heating_index)' , calculate_EMEP_source ( heating_index ), unit_in , unit_logfile ) calculate_EMEP_source ( agriculture_index ) = read_name_logical ( 'calculate_EMEP_source(agriculture_index)' , calculate_EMEP_source ( agriculture_index ), unit_in , unit_logfile ) calculate_EMEP_source ( industry_index ) = read_name_logical ( 'calculate_EMEP_source(industry_index)' , calculate_EMEP_source ( industry_index ), unit_in , unit_logfile ) !Additional GNFR13 sources calculate_EMEP_source ( publicpower_index ) = read_name_logical ( 'calculate_EMEP_source(publicpower_index)' , calculate_EMEP_source ( publicpower_index ), unit_in , unit_logfile ) calculate_EMEP_source ( fugitive_index ) = read_name_logical ( 'calculate_EMEP_source(fugitive_index)' , calculate_EMEP_source ( fugitive_index ), unit_in , unit_logfile ) calculate_EMEP_source ( solvents_index ) = read_name_logical ( 'calculate_EMEP_source(solvents_index)' , calculate_EMEP_source ( solvents_index ), unit_in , unit_logfile ) calculate_EMEP_source ( aviation_index ) = read_name_logical ( 'calculate_EMEP_source(aviation_index)' , calculate_EMEP_source ( aviation_index ), unit_in , unit_logfile ) calculate_EMEP_source ( offroad_index ) = read_name_logical ( 'calculate_EMEP_source(offroad_index)' , calculate_EMEP_source ( offroad_index ), unit_in , unit_logfile ) calculate_EMEP_source ( waste_index ) = read_name_logical ( 'calculate_EMEP_source(waste_index)' , calculate_EMEP_source ( waste_index ), unit_in , unit_logfile ) calculate_EMEP_source ( livestock_index ) = read_name_logical ( 'calculate_EMEP_source(livestock_index)' , calculate_EMEP_source ( livestock_index ), unit_in , unit_logfile ) calculate_EMEP_source ( other_index ) = read_name_logical ( 'calculate_EMEP_source(other_index)' , calculate_EMEP_source ( other_index ), unit_in , unit_logfile ) !GNFR19 sources. Note nc_index not in the input calculate_EMEP_source ( traffic_gasoline_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_gasoline_index)' , calculate_EMEP_source ( traffic_gasoline_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( traffic_diesel_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_diesel_index)' , calculate_EMEP_source ( traffic_diesel_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( traffic_gas_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_gas_index)' , calculate_EMEP_source ( traffic_gas_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( traffic_nonexhaust_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_nonexhaust_index)' , calculate_EMEP_source ( traffic_nonexhaust_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( publicpower_point_nc_index ) = read_name_logical ( 'calculate_EMEP_source(publicpower_point_index)' , calculate_EMEP_source ( publicpower_point_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( publicpower_area_nc_index ) = read_name_logical ( 'calculate_EMEP_source(publicpower_area_index)' , calculate_EMEP_source ( publicpower_area_nc_index ), unit_in , unit_logfile ) !do i_source=1,n_source_index !    if (calculate_source(i_source)) calculate_source(allsource_index)=.true. !enddo !For aggregating proxy emission data to EMEP grids in ascii test routines that no longer exist. Default is false make_EMEP_grid_emission_data ( traffic_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(traffic_index)' , make_EMEP_grid_emission_data ( traffic_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( shipping_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(shipping_index)' , make_EMEP_grid_emission_data ( shipping_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( heating_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(heating_index)' , make_EMEP_grid_emission_data ( heating_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( agriculture_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(agriculture_index)' , make_EMEP_grid_emission_data ( agriculture_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( industry_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(industry_index)' , make_EMEP_grid_emission_data ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources make_EMEP_grid_emission_data ( publicpower_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(publicpower_index)' , make_EMEP_grid_emission_data ( publicpower_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( fugitive_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(fugitive_index)' , make_EMEP_grid_emission_data ( fugitive_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( solvents_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(solvents_index)' , make_EMEP_grid_emission_data ( solvents_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( aviation_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(aviation_index)' , make_EMEP_grid_emission_data ( aviation_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( offroad_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(offroad_index)' , make_EMEP_grid_emission_data ( offroad_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( waste_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(waste_index)' , make_EMEP_grid_emission_data ( waste_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( livestock_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(livestock_index)' , make_EMEP_grid_emission_data ( livestock_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( other_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(other_index)' , make_EMEP_grid_emission_data ( other_index ), unit_in , unit_logfile ) do i_source = 1 , n_source_index if ( make_EMEP_grid_emission_data ( i_source )) make_EMEP_grid_emission_data ( allsource_index ) = . true . enddo !For scaling EMEP concentrations with EMEP/local emission ratio. for testing purposes only. Default is false replace_EMEP_local_with_subgrid_local ( traffic_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(traffic_index)' , replace_EMEP_local_with_subgrid_local ( traffic_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( shipping_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(shipping_index)' , replace_EMEP_local_with_subgrid_local ( shipping_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( heating_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(heating_index)' , replace_EMEP_local_with_subgrid_local ( heating_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( agriculture_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(agriculture_index)' , replace_EMEP_local_with_subgrid_local ( agriculture_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( industry_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(industry_index)' , replace_EMEP_local_with_subgrid_local ( industry_index ), unit_in , unit_logfile ) projection_type = read_name_integer ( 'projection_type' , projection_type , unit_in , unit_logfile ) EMEP_projection_type = read_name_integer ( 'EMEP_projection_type' , EMEP_projection_type , unit_in , unit_logfile ) utm_zone = read_name_integer ( 'utm_zone' , utm_zone , unit_in , unit_logfile ) !Present UTM central lon position if not overridden by input utm_lon0 = abs ( utm_zone ) * 6 - 180 - 3 utm_lon0 = read_name_real ( 'utm_lon0' , utm_lon0 , unit_in , unit_logfile ) ltm_lon0 = read_name_real ( 'ltm_lon0' , ltm_lon0 , unit_in , unit_logfile ) !Read the projection attributes for uEMEP if they are available projection_attributes ( 1 ) = read_name_double ( 'projection_attributes(1)' , projection_attributes ( 1 ), unit_in , unit_logfile ) projection_attributes ( 2 ) = read_name_double ( 'projection_attributes(2)' , projection_attributes ( 2 ), unit_in , unit_logfile ) projection_attributes ( 3 ) = read_name_double ( 'projection_attributes(3)' , projection_attributes ( 3 ), unit_in , unit_logfile ) projection_attributes ( 4 ) = read_name_double ( 'projection_attributes(4)' , projection_attributes ( 4 ), unit_in , unit_logfile ) projection_attributes ( 5 ) = read_name_double ( 'projection_attributes(5)' , projection_attributes ( 5 ), unit_in , unit_logfile ) projection_attributes ( 6 ) = read_name_double ( 'projection_attributes(6)' , projection_attributes ( 6 ), unit_in , unit_logfile ) projection_attributes ( 7 ) = read_name_double ( 'projection_attributes(7)' , projection_attributes ( 7 ), unit_in , unit_logfile ) !Read the projection attributes for EMEP if they are available !THese will be reset if EMEP data is read in EMEP_projection_attributes ( 1 ) = read_name_double ( 'EMEP_projection_attributes(1)' , EMEP_projection_attributes ( 1 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 2 ) = read_name_double ( 'EMEP_projection_attributes(2)' , EMEP_projection_attributes ( 2 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 3 ) = read_name_double ( 'EMEP_projection_attributes(3)' , EMEP_projection_attributes ( 3 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 4 ) = read_name_double ( 'EMEP_projection_attributes(4)' , EMEP_projection_attributes ( 4 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 5 ) = read_name_double ( 'EMEP_projection_attributes(5)' , EMEP_projection_attributes ( 5 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 6 ) = read_name_double ( 'EMEP_projection_attributes(6)' , EMEP_projection_attributes ( 6 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 7 ) = read_name_double ( 'EMEP_projection_attributes(7)' , EMEP_projection_attributes ( 7 ), unit_in , unit_logfile ) EMEP_grid_interpolation_flag = read_name_integer ( 'EMEP_grid_interpolation_flag' , EMEP_grid_interpolation_flag , unit_in , unit_logfile ) EMEP_meteo_grid_interpolation_flag = read_name_integer ( 'EMEP_meteo_grid_interpolation_flag' , EMEP_meteo_grid_interpolation_flag , unit_in , unit_logfile ) EMEP_emission_grid_interpolation_flag = read_name_integer ( 'EMEP_emission_grid_interpolation_flag' , EMEP_emission_grid_interpolation_flag , unit_in , unit_logfile ) subgrid_emission_distribution_flag = read_name_logical ( 'subgrid_emission_distribution_flag' , subgrid_emission_distribution_flag , unit_in , unit_logfile ) !Not used EMEP_grid_interpolation_simple_flag = read_name_logical ( 'EMEP_grid_interpolation_simple_flag' , EMEP_grid_interpolation_simple_flag , unit_in , unit_logfile ) EMEP_grid_interpolation_size = read_name_real ( 'EMEP_grid_interpolation_size' , EMEP_grid_interpolation_size , unit_in , unit_logfile ) EMEP_additional_grid_interpolation_size = read_name_real ( 'EMEP_additional_grid_interpolation_size' , EMEP_additional_grid_interpolation_size , unit_in , unit_logfile ) use_downwind_position_flag = read_name_logical ( 'use_downwind_position_flag' , use_downwind_position_flag , unit_in , unit_logfile ) local_subgrid_method_flag = read_name_integer ( 'local_subgrid_method_flag' , local_subgrid_method_flag , unit_in , unit_logfile ) stability_scheme_flag = read_name_integer ( 'stability_scheme_flag' , stability_scheme_flag , unit_in , unit_logfile ) average_zc_h_in_Kz_flag = read_name_logical ( 'average_zc_h_in_Kz_flag' , average_zc_h_in_Kz_flag , unit_in , unit_logfile ) wind_level_flag = read_name_integer ( 'wind_level_flag' , wind_level_flag , unit_in , unit_logfile ) wind_level_integral_flag = read_name_integer ( 'wind_level_integral_flag' , wind_level_flag , unit_in , unit_logfile ) !Default is wind_level_flag no2_chemistry_scheme_flag = read_name_integer ( 'no2_chemistry_scheme_flag' , no2_chemistry_scheme_flag , unit_in , unit_logfile ) no2_background_chemistry_scheme_flag = read_name_integer ( 'no2_background_chemistry_scheme_flag' , no2_background_chemistry_scheme_flag , unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( traffic_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(traffic_index)' , use_emission_positions_for_auto_subgrid_flag ( traffic_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( shipping_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(shipping_index)' , use_emission_positions_for_auto_subgrid_flag ( shipping_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( heating_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(heating_index)' , use_emission_positions_for_auto_subgrid_flag ( heating_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( agriculture_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(agriculture_index)' , use_emission_positions_for_auto_subgrid_flag ( agriculture_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( industry_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(industry_index)' , use_emission_positions_for_auto_subgrid_flag ( industry_index ), unit_in , unit_logfile ) !Set all source index to true if any of the sources are to be auto gridded. allsource_index defines if the routine is called or not do i_source = 1 , n_source_index if ( use_emission_positions_for_auto_subgrid_flag ( i_source ). and . i_source . ne . allsource_index ) use_emission_positions_for_auto_subgrid_flag ( allsource_index ) = . true . enddo !do i_source=1,n_source_index !write(*,*) 'Using auto subgrid for source ',trim(source_file_str(i_source)),use_emission_positions_for_auto_subgrid_flag(i_source) !enddo use_receptor_positions_for_auto_subgrid_flag = read_name_logical ( 'use_receptor_positions_for_auto_subgrid_flag' , use_receptor_positions_for_auto_subgrid_flag , unit_in , unit_logfile ) use_population_positions_for_auto_subgrid_flag = read_name_logical ( 'use_population_positions_for_auto_subgrid_flag' , use_population_positions_for_auto_subgrid_flag , unit_in , unit_logfile ) interpolate_subgrids_flag = read_name_logical ( 'interpolate_subgrids_flag' , interpolate_subgrids_flag , unit_in , unit_logfile ) !use_trajectory_flag(:)=read_name_logical('use_trajectory_flag',use_trajectory_flag(allsource_index),unit_in,unit_logfile) use_trajectory_flag ( shipping_index ) = read_name_logical ( 'use_trajectory_flag(shipping_index)' , use_trajectory_flag ( shipping_index ), unit_in , unit_logfile ) use_trajectory_flag ( traffic_index ) = read_name_logical ( 'use_trajectory_flag(traffic_index)' , use_trajectory_flag ( traffic_index ), unit_in , unit_logfile ) use_trajectory_flag ( heating_index ) = read_name_logical ( 'use_trajectory_flag(heating_index)' , use_trajectory_flag ( heating_index ), unit_in , unit_logfile ) use_trajectory_flag ( agriculture_index ) = read_name_logical ( 'use_trajectory_flag(agriculture_index)' , use_trajectory_flag ( agriculture_index ), unit_in , unit_logfile ) use_trajectory_flag ( industry_index ) = read_name_logical ( 'use_trajectory_flag(industry_index)' , use_trajectory_flag ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources use_trajectory_flag ( publicpower_index ) = read_name_logical ( 'use_trajectory_flag(publicpower_index)' , use_trajectory_flag ( publicpower_index ), unit_in , unit_logfile ) use_trajectory_flag ( fugitive_index ) = read_name_logical ( 'use_trajectory_flag(fugitive_index)' , use_trajectory_flag ( fugitive_index ), unit_in , unit_logfile ) use_trajectory_flag ( solvents_index ) = read_name_logical ( 'use_trajectory_flag(solvents_index)' , use_trajectory_flag ( solvents_index ), unit_in , unit_logfile ) use_trajectory_flag ( aviation_index ) = read_name_logical ( 'use_trajectory_flag(aviation_index)' , use_trajectory_flag ( aviation_index ), unit_in , unit_logfile ) use_trajectory_flag ( offroad_index ) = read_name_logical ( 'use_trajectory_flag(offroad_index)' , use_trajectory_flag ( offroad_index ), unit_in , unit_logfile ) use_trajectory_flag ( waste_index ) = read_name_logical ( 'use_trajectory_flag(waste_index)' , use_trajectory_flag ( waste_index ), unit_in , unit_logfile ) use_trajectory_flag ( livestock_index ) = read_name_logical ( 'use_trajectory_flag(livestock_index)' , use_trajectory_flag ( livestock_index ), unit_in , unit_logfile ) use_trajectory_flag ( other_index ) = read_name_logical ( 'use_trajectory_flag(other_index)' , use_trajectory_flag ( other_index ), unit_in , unit_logfile ) traj_step_scale = read_name_real ( 'traj_step_scale' , traj_step_scale , unit_in , unit_logfile ) calculate_aggregated_shipping_emissions_flag = read_name_logical ( 'calculate_aggregated_shipping_emissions_flag' , calculate_aggregated_shipping_emissions_flag , unit_in , unit_logfile ) use_aggregated_shipping_emissions_flag = read_name_logical ( 'use_aggregated_shipping_emissions_flag' , use_aggregated_shipping_emissions_flag , unit_in , unit_logfile ) calculate_population_exposure_flag = read_name_logical ( 'calculate_population_exposure_flag' , calculate_population_exposure_flag , unit_in , unit_logfile ) !Grid specific parameters integral_subgrid_step = read_name_integer ( 'integral_subgrid_step' , integral_subgrid_step , unit_in , unit_logfile ) !Specify the site grid information subgrid_delta ( x_dim_index ) = read_name_real ( 'subgrid_delta(x_dim_index)' , subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) subgrid_delta ( y_dim_index ) = read_name_real ( 'subgrid_delta(y_dim_index)' , subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) subgrid_min ( x_dim_index ) = read_name_real ( 'subgrid_min(x_dim_index)' , subgrid_min ( x_dim_index ), unit_in , unit_logfile ) subgrid_min ( y_dim_index ) = read_name_real ( 'subgrid_min(y_dim_index)' , subgrid_min ( y_dim_index ), unit_in , unit_logfile ) subgrid_max ( x_dim_index ) = read_name_real ( 'subgrid_max(x_dim_index)' , subgrid_max ( x_dim_index ), unit_in , unit_logfile ) subgrid_max ( y_dim_index ) = read_name_real ( 'subgrid_max(y_dim_index)' , subgrid_max ( y_dim_index ), unit_in , unit_logfile ) !Save the read in grid data. This will be used to select EMEP region and receptor points init_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) init_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) init_subgrid_min ( x_dim_index ) = subgrid_min ( x_dim_index ) init_subgrid_min ( y_dim_index ) = subgrid_min ( y_dim_index ) init_subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) init_subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) !These will probably be set by the input data deposition_subgrid_delta ( x_dim_index ) = read_name_real ( 'deposition_subgrid_delta(x_dim_index)' , deposition_subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) deposition_subgrid_delta ( y_dim_index ) = read_name_real ( 'deposition_subgrid_delta(y_dim_index)' , deposition_subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) landuse_subgrid_delta ( x_dim_index ) = read_name_real ( 'landuse_subgrid_delta(x_dim_index)' , landuse_subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) landuse_subgrid_delta ( y_dim_index ) = read_name_real ( 'landuse_subgrid_delta(y_dim_index)' , landuse_subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) !Specifies the number of subsources for each source. Not used as default is 1 n_subsource ( traffic_index ) = read_name_integer ( 'n_subsource(traffic_index)' , n_subsource ( traffic_index ), unit_in , unit_logfile ) n_subsource ( shipping_index ) = read_name_integer ( 'n_subsource(shipping_index)' , n_subsource ( shipping_index ), unit_in , unit_logfile ) n_subsource ( heating_index ) = read_name_integer ( 'n_subsource(heating_index)' , n_subsource ( heating_index ), unit_in , unit_logfile ) n_subsource ( agriculture_index ) = read_name_integer ( 'n_subsource(agriculture_index)' , n_subsource ( agriculture_index ), unit_in , unit_logfile ) n_subsource ( industry_index ) = read_name_integer ( 'n_subsource(industry_index)' , n_subsource ( industry_index ), unit_in , unit_logfile ) h_emis ( traffic_index , 1 ) = read_name_real ( 'h_emis(traffic_index,1)' , h_emis ( traffic_index , 1 ), unit_in , unit_logfile ) h_emis ( shipping_index , 1 ) = read_name_real ( 'h_emis(shipping_index,1)' , h_emis ( shipping_index , 1 ), unit_in , unit_logfile ) h_emis ( heating_index , 1 ) = read_name_real ( 'h_emis(heating_index,1)' , h_emis ( heating_index , 1 ), unit_in , unit_logfile ) h_emis ( agriculture_index , 1 ) = read_name_real ( 'h_emis(agriculture_index,1)' , h_emis ( agriculture_index , 1 ), unit_in , unit_logfile ) h_emis ( industry_index , 1 ) = read_name_real ( 'h_emis(industry_index,1)' , h_emis ( industry_index , 1 ), unit_in , unit_logfile ) !Additional GNFR sources h_emis ( publicpower_index , 1 ) = read_name_real ( 'h_emis(publicpower_index,1)' , h_emis ( publicpower_index , 1 ), unit_in , unit_logfile ) h_emis ( fugitive_index , 1 ) = read_name_real ( 'h_emis(fugitive_index,1)' , h_emis ( fugitive_index , 1 ), unit_in , unit_logfile ) h_emis ( solvents_index , 1 ) = read_name_real ( 'h_emis(solvents_index,1)' , h_emis ( solvents_index , 1 ), unit_in , unit_logfile ) h_emis ( aviation_index , 1 ) = read_name_real ( 'h_emis(aviation_index,1)' , h_emis ( aviation_index , 1 ), unit_in , unit_logfile ) h_emis ( offroad_index , 1 ) = read_name_real ( 'h_emis(offroad_index,1)' , h_emis ( offroad_index , 1 ), unit_in , unit_logfile ) h_emis ( waste_index , 1 ) = read_name_real ( 'h_emis(waste_index,1)' , h_emis ( waste_index , 1 ), unit_in , unit_logfile ) h_emis ( livestock_index , 1 ) = read_name_real ( 'h_emis(livestock_index,1)' , h_emis ( livestock_index , 1 ), unit_in , unit_logfile ) h_emis ( other_index , 1 ) = read_name_real ( 'h_emis(other_index,1)' , h_emis ( other_index , 1 ), unit_in , unit_logfile ) !These second subsources do not exist but still possible to implement h_emis ( traffic_index , 2 ) = read_name_real ( 'h_emis(traffic_index,2)' , h_emis ( traffic_index , 2 ), unit_in , unit_logfile ) h_emis ( shipping_index , 2 ) = read_name_real ( 'h_emis(shipping_index,2)' , h_emis ( shipping_index , 2 ), unit_in , unit_logfile ) h_emis ( heating_index , 2 ) = read_name_real ( 'h_emis(heating_index,2)' , h_emis ( heating_index , 2 ), unit_in , unit_logfile ) h_emis ( agriculture_index , 2 ) = read_name_real ( 'h_emis(agriculture_index,2)' , h_emis ( agriculture_index , 2 ), unit_in , unit_logfile ) h_emis ( industry_index , 2 ) = read_name_real ( 'h_emis(industry_index,2)' , h_emis ( industry_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( traffic_index , 1 ) = read_name_real ( 'sig_y_00(traffic_index,1)' , sig_y_00 ( traffic_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( shipping_index , 1 ) = read_name_real ( 'sig_y_00(shipping_index,1)' , sig_y_00 ( shipping_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( heating_index , 1 ) = read_name_real ( 'sig_y_00(heating_index,1)' , sig_y_00 ( heating_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( agriculture_index , 1 ) = read_name_real ( 'sig_y_00(agriculture_index,1)' , sig_y_00 ( agriculture_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( industry_index , 1 ) = read_name_real ( 'sig_y_00(industry_index,1)' , sig_y_00 ( industry_index , 1 ), unit_in , unit_logfile ) !Additional GNFR sources sig_y_00 ( publicpower_index , 1 ) = read_name_real ( 'sig_y_00(publicpower_index,1)' , sig_y_00 ( publicpower_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( fugitive_index , 1 ) = read_name_real ( 'sig_y_00(fugitive_index,1)' , sig_y_00 ( fugitive_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( solvents_index , 1 ) = read_name_real ( 'sig_y_00(solvents_index,1)' , sig_y_00 ( solvents_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( aviation_index , 1 ) = read_name_real ( 'sig_y_00(aviation_index,1)' , sig_y_00 ( aviation_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( offroad_index , 1 ) = read_name_real ( 'sig_y_00(offroad_index,1)' , sig_y_00 ( offroad_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( waste_index , 1 ) = read_name_real ( 'sig_y_00(waste_index,1)' , sig_y_00 ( waste_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( livestock_index , 1 ) = read_name_real ( 'sig_y_00(livestock_index,1)' , sig_y_00 ( livestock_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( other_index , 1 ) = read_name_real ( 'sig_y_00(other_index,1)' , sig_y_00 ( other_index , 1 ), unit_in , unit_logfile ) !These second subsources do not exist but still possible to implement sig_y_00 ( traffic_index , 2 ) = read_name_real ( 'sig_y_00(traffic_index,2)' , sig_y_00 ( traffic_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( shipping_index , 2 ) = read_name_real ( 'sig_y_00(shipping_index,2)' , sig_y_00 ( shipping_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( heating_index , 2 ) = read_name_real ( 'sig_y_00(heating_index,2)' , sig_y_00 ( heating_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( agriculture_index , 2 ) = read_name_real ( 'sig_y_00(agriculture_index,2)' , sig_y_00 ( agriculture_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( industry_index , 2 ) = read_name_real ( 'sig_y_00(industry_index,2)' , sig_y_00 ( industry_index , 2 ), unit_in , unit_logfile ) !This scales the subgrid size to give to give sig_y_0. Optimal value is 0.8 so sig_y_0=0.8/2*delta_y sigy_0_subgid_width_scale = read_name_real ( 'sigy_0_subgid_width_scale' , sigy_0_subgid_width_scale , unit_in , unit_logfile ) sig_z_00 ( traffic_index , 1 ) = read_name_real ( 'sig_z_00(traffic_index,1)' , sig_z_00 ( traffic_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( shipping_index , 1 ) = read_name_real ( 'sig_z_00(shipping_index,1)' , sig_z_00 ( shipping_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( heating_index , 1 ) = read_name_real ( 'sig_z_00(heating_index,1)' , sig_z_00 ( heating_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( agriculture_index , 1 ) = read_name_real ( 'sig_z_00(agriculture_index,1)' , sig_z_00 ( agriculture_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( industry_index , 1 ) = read_name_real ( 'sig_z_00(industry_index,1)' , sig_z_00 ( industry_index , 1 ), unit_in , unit_logfile ) !Additional GNFR sources sig_z_00 ( publicpower_index , 1 ) = read_name_real ( 'sig_z_00(publicpower_index,1)' , sig_z_00 ( publicpower_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( fugitive_index , 1 ) = read_name_real ( 'sig_z_00(fugitive_index,1)' , sig_z_00 ( fugitive_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( solvents_index , 1 ) = read_name_real ( 'sig_z_00(solvents_index,1)' , sig_z_00 ( solvents_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( aviation_index , 1 ) = read_name_real ( 'sig_z_00(aviation_index,1)' , sig_z_00 ( aviation_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( offroad_index , 1 ) = read_name_real ( 'sig_z_00(offroad_index,1)' , sig_z_00 ( offroad_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( waste_index , 1 ) = read_name_real ( 'sig_z_00(waste_index,1)' , sig_z_00 ( waste_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( livestock_index , 1 ) = read_name_real ( 'sig_z_00(livestock_index,1)' , sig_z_00 ( livestock_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( other_index , 1 ) = read_name_real ( 'sig_z_00(other_index,1)' , sig_z_00 ( other_index , 1 ), unit_in , unit_logfile ) !These second subsources do not exist but still possible to implement sig_z_00 ( traffic_index , 2 ) = read_name_real ( 'sig_z_00(traffic_index,2)' , sig_z_00 ( traffic_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( shipping_index , 2 ) = read_name_real ( 'sig_z_00(shipping_index,2)' , sig_z_00 ( shipping_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( heating_index , 2 ) = read_name_real ( 'sig_z_00(heating_index,2)' , sig_z_00 ( heating_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( agriculture_index , 2 ) = read_name_real ( 'sig_z_00(agriculture_index,2)' , sig_z_00 ( agriculture_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( industry_index , 2 ) = read_name_real ( 'sig_z_00(industry_index,2)' , sig_z_00 ( industry_index , 2 ), unit_in , unit_logfile ) !Read output grid path for all data pathname_output_grid = read_name_char ( 'pathname_output_grid' , pathname_output_grid , unit_in , unit_logfile ) filename_date_output_grid = read_name_char ( 'filename_date_output_grid' , filename_date_output_grid , unit_in , unit_logfile ) !Read in file names. Only 2 choices for most file types pathname_rl ( 1 ) = read_name_char ( 'pathname_rl(1)' , pathname_rl ( 1 ), unit_in , unit_logfile ) pathname_rl ( 2 ) = read_name_char ( 'pathname_rl(2)' , pathname_rl ( 2 ), unit_in , unit_logfile ) filename_rl ( 1 ) = read_name_char ( 'filename_rl(1)' , filename_rl ( 1 ), unit_in , unit_logfile ) filename_rl ( 2 ) = read_name_char ( 'filename_rl(2)' , filename_rl ( 2 ), unit_in , unit_logfile ) pathname_mrl ( 1 ) = read_name_char ( 'pathname_mrl(1)' , pathname_mrl ( 1 ), unit_in , unit_logfile ) pathname_mrl ( 2 ) = read_name_char ( 'pathname_mrl(2)' , pathname_mrl ( 2 ), unit_in , unit_logfile ) pathname_mrl ( 3 ) = read_name_char ( 'pathname_mrl(3)' , pathname_mrl ( 3 ), unit_in , unit_logfile ) pathname_mrl ( 4 ) = read_name_char ( 'pathname_mrl(4)' , pathname_mrl ( 4 ), unit_in , unit_logfile ) pathname_mrl ( 5 ) = read_name_char ( 'pathname_mrl(5)' , pathname_mrl ( 5 ), unit_in , unit_logfile ) pathname_mrl ( 6 ) = read_name_char ( 'pathname_mrl(6)' , pathname_mrl ( 6 ), unit_in , unit_logfile ) pathname_mrl ( 7 ) = read_name_char ( 'pathname_mrl(7)' , pathname_mrl ( 7 ), unit_in , unit_logfile ) pathname_mrl ( 8 ) = read_name_char ( 'pathname_mrl(8)' , pathname_mrl ( 8 ), unit_in , unit_logfile ) pathname_mrl ( 9 ) = read_name_char ( 'pathname_mrl(9)' , pathname_mrl ( 9 ), unit_in , unit_logfile ) pathname_mrl ( 10 ) = read_name_char ( 'pathname_mrl(10)' , pathname_mrl ( 10 ), unit_in , unit_logfile ) filename_mrl ( 1 ) = read_name_char ( 'filename_mrl(1)' , filename_mrl ( 1 ), unit_in , unit_logfile ) filename_mrl ( 2 ) = read_name_char ( 'filename_mrl(2)' , filename_mrl ( 2 ), unit_in , unit_logfile ) filename_mrl ( 3 ) = read_name_char ( 'filename_mrl(3)' , filename_mrl ( 3 ), unit_in , unit_logfile ) filename_mrl ( 4 ) = read_name_char ( 'filename_mrl(4)' , filename_mrl ( 4 ), unit_in , unit_logfile ) filename_mrl ( 5 ) = read_name_char ( 'filename_mrl(5)' , filename_mrl ( 5 ), unit_in , unit_logfile ) filename_mrl ( 6 ) = read_name_char ( 'filename_mrl(6)' , filename_mrl ( 6 ), unit_in , unit_logfile ) filename_mrl ( 7 ) = read_name_char ( 'filename_mrl(7)' , filename_mrl ( 7 ), unit_in , unit_logfile ) filename_mrl ( 8 ) = read_name_char ( 'filename_mrl(8)' , filename_mrl ( 8 ), unit_in , unit_logfile ) filename_mrl ( 9 ) = read_name_char ( 'filename_mrl(9)' , filename_mrl ( 9 ), unit_in , unit_logfile ) filename_mrl ( 10 ) = read_name_char ( 'filename_mrl(10)' , filename_mrl ( 10 ), unit_in , unit_logfile ) num_multiple_roadlink_files = read_name_integer ( 'num_multiple_roadlink_files' , num_multiple_roadlink_files , unit_in , unit_logfile ) pathname_EMEP ( 1 ) = read_name_char ( 'pathname_EMEP(1)' , pathname_EMEP ( 1 ), unit_in , unit_logfile ) pathname_EMEP ( 2 ) = read_name_char ( 'pathname_EMEP(2)' , pathname_EMEP ( 2 ), unit_in , unit_logfile ) pathname_EMEP ( 3 ) = read_name_char ( 'pathname_EMEP(3)' , pathname_EMEP ( 3 ), unit_in , unit_logfile ) pathname_EMEP ( 4 ) = read_name_char ( 'pathname_EMEP(4)' , pathname_EMEP ( 4 ), unit_in , unit_logfile ) filename_EMEP ( 1 ) = read_name_char ( 'filename_EMEP(1)' , filename_EMEP ( 1 ), unit_in , unit_logfile ) filename_EMEP ( 2 ) = read_name_char ( 'filename_EMEP(2)' , filename_EMEP ( 2 ), unit_in , unit_logfile ) filename_EMEP ( 3 ) = read_name_char ( 'filename_EMEP(3)' , filename_EMEP ( 3 ), unit_in , unit_logfile ) filename_EMEP ( 4 ) = read_name_char ( 'filename_EMEP(4)' , filename_EMEP ( 4 ), unit_in , unit_logfile ) original_pathname_EMEP = pathname_EMEP original_filename_EMEP = filename_EMEP pathname_ship ( 1 ) = read_name_char ( 'pathname_ship(1)' , pathname_ship ( 1 ), unit_in , unit_logfile ) pathname_ship ( 2 ) = read_name_char ( 'pathname_ship(2)' , pathname_ship ( 2 ), unit_in , unit_logfile ) filename_ship ( 1 ) = read_name_char ( 'filename_ship(1)' , filename_ship ( 1 ), unit_in , unit_logfile ) filename_ship ( 2 ) = read_name_char ( 'filename_ship(2)' , filename_ship ( 2 ), unit_in , unit_logfile ) pathname_agriculture ( 1 ) = read_name_char ( 'pathname_agriculture(1)' , pathname_agriculture ( 1 ), unit_in , unit_logfile ) pathname_agriculture ( 2 ) = read_name_char ( 'pathname_agriculture(2)' , pathname_agriculture ( 2 ), unit_in , unit_logfile ) filename_agriculture ( 1 ) = read_name_char ( 'filename_agriculture(1)' , filename_agriculture ( 1 ), unit_in , unit_logfile ) filename_agriculture ( 2 ) = read_name_char ( 'filename_agriculture(2)' , filename_agriculture ( 2 ), unit_in , unit_logfile ) pathname_emission_rivm ( 1 ) = read_name_char ( 'pathname_emission_rivm(1)' , pathname_emission_rivm ( 1 ), unit_in , unit_logfile ) pathname_emission_rivm ( 2 ) = read_name_char ( 'pathname_emission_rivm(2)' , pathname_emission_rivm ( 2 ), unit_in , unit_logfile ) filename_emission_rivm ( 1 ) = read_name_char ( 'filename_emission_rivm(1)' , filename_emission_rivm ( 1 ), unit_in , unit_logfile ) filename_emission_rivm ( 2 ) = read_name_char ( 'filename_emission_rivm(2)' , filename_emission_rivm ( 2 ), unit_in , unit_logfile ) pathname_industry ( 1 ) = read_name_char ( 'pathname_industry(1)' , pathname_industry ( 1 ), unit_in , unit_logfile ) pathname_industry ( 2 ) = read_name_char ( 'pathname_industry(2)' , pathname_industry ( 2 ), unit_in , unit_logfile ) filename_industry ( 1 ) = read_name_char ( 'filename_industry(1)' , filename_industry ( 1 ), unit_in , unit_logfile ) filename_industry ( 2 ) = read_name_char ( 'filename_industry(2)' , filename_industry ( 2 ), unit_in , unit_logfile ) pathname_heating ( dwelling_index ) = read_name_char ( 'pathname_heating(dwelling_index)' , pathname_heating ( dwelling_index ), unit_in , unit_logfile ) pathname_heating ( population_index ) = read_name_char ( 'pathname_heating(population_index)' , pathname_heating ( population_index ), unit_in , unit_logfile ) filename_heating ( dwelling_index ) = read_name_char ( 'filename_heating(dwelling_index)' , filename_heating ( dwelling_index ), unit_in , unit_logfile ) filename_heating ( population_index ) = read_name_char ( 'filename_heating(population_index)' , filename_heating ( population_index ), unit_in , unit_logfile ) pathname_heating ( RWC_heating_index ) = read_name_char ( 'pathname_heating(RWC_heating_index)' , pathname_heating ( RWC_heating_index ), unit_in , unit_logfile ) filename_heating ( RWC_heating_index ) = read_name_char ( 'filename_heating(RWC_heating_index)' , filename_heating ( RWC_heating_index ), unit_in , unit_logfile ) pathname_population ( dwelling_index ) = read_name_char ( 'pathname_population(dwelling_index)' , pathname_population ( dwelling_index ), unit_in , unit_logfile ) pathname_population ( population_index ) = read_name_char ( 'pathname_population(population_index)' , pathname_population ( population_index ), unit_in , unit_logfile ) pathname_population ( establishment_index ) = read_name_char ( 'pathname_population(establishment_index)' , pathname_population ( establishment_index ), unit_in , unit_logfile ) pathname_population ( school_index ) = read_name_char ( 'pathname_population(school_index)' , pathname_population ( school_index ), unit_in , unit_logfile ) pathname_population ( kindergaten_index ) = read_name_char ( 'pathname_population(kindergaten_index)' , pathname_population ( kindergaten_index ), unit_in , unit_logfile ) pathname_population ( home_index ) = read_name_char ( 'pathname_population(home_index)' , pathname_population ( home_index ), unit_in , unit_logfile ) pathname_population ( municipality_index ) = read_name_char ( 'pathname_population(municipality_index)' , pathname_population ( municipality_index ), unit_in , unit_logfile ) filename_population ( dwelling_index ) = read_name_char ( 'filename_population(dwelling_index)' , filename_population ( dwelling_index ), unit_in , unit_logfile ) filename_population ( population_index ) = read_name_char ( 'filename_population(population_index)' , filename_population ( population_index ), unit_in , unit_logfile ) filename_population ( establishment_index ) = read_name_char ( 'filename_population(establishment_index)' , filename_population ( establishment_index ), unit_in , unit_logfile ) filename_population ( school_index ) = read_name_char ( 'filename_population(school_index)' , filename_population ( school_index ), unit_in , unit_logfile ) filename_population ( kindergaten_index ) = read_name_char ( 'filename_population(kindergaten_index)' , filename_population ( kindergaten_index ), unit_in , unit_logfile ) filename_population ( home_index ) = read_name_char ( 'filename_population(home_index)' , filename_population ( home_index ), unit_in , unit_logfile ) filename_population ( municipality_index ) = read_name_char ( 'filename_population(municipality_index)' , filename_population ( municipality_index ), unit_in , unit_logfile ) pathname_receptor = read_name_char ( 'pathname_receptor' , pathname_receptor , unit_in , unit_logfile ) filename_receptor = read_name_char ( 'filename_receptor' , filename_receptor , unit_in , unit_logfile ) pathname_timeprofile = read_name_char ( 'pathname_timeprofile' , pathname_timeprofile , unit_in , unit_logfile ) filename_timeprofile = read_name_char ( 'filename_timeprofile' , filename_timeprofile , unit_in , unit_logfile ) population_data_type = read_name_integer ( 'population_data_type' , population_data_type , unit_in , unit_logfile ) FF_min_dispersion = read_name_real ( 'FF_min_dispersion' , FF_min_dispersion , unit_in , unit_logfile ) emission_timeprofile_hour_shift = read_name_integer ( 'emission_timeprofile_hour_shift' , emission_timeprofile_hour_shift , unit_in , unit_logfile ) use_last_meteo_in_dispersion = read_name_logical ( 'use_last_meteo_in_dispersion' , use_last_meteo_in_dispersion , unit_in , unit_logfile ) use_meandering_in_dispersion = read_name_logical ( 'use_meandering_in_dispersion' , use_meandering_in_dispersion , unit_in , unit_logfile ) use_traffic_for_sigma0_flag = read_name_logical ( 'use_traffic_for_sigma0_flag' , use_traffic_for_sigma0_flag , unit_in , unit_logfile ) !use_traffic_for_minFF_flag=read_name_logical('use_traffic_for_minFF_flag',use_traffic_for_minFF_flag,unit_in,unit_logfile) use_alternative_meteorology_flag = read_name_logical ( 'use_alternative_meteorology_flag' , use_alternative_meteorology_flag , unit_in , unit_logfile ) ustar_min = read_name_real ( 'ustar_min' , ustar_min , unit_in , unit_logfile ) hmix_min = read_name_real ( 'hmix_min' , hmix_min , unit_in , unit_logfile ) hmix_max = read_name_real ( 'hmix_max' , hmix_max , unit_in , unit_logfile ) use_alternative_z0_flag = read_name_logical ( 'use_alternative_z0_flag' , use_alternative_z0_flag , unit_in , unit_logfile ) alternative_meteorology_type = read_name_char ( 'alternative_meteorology_type' , alternative_meteorology_type , unit_in , unit_logfile ) !Read emission factors for traffic emission_factor ( nox_index , traffic_index ,:) = read_name_real ( 'emission_factor(nox_index,traffic_index,:)' , emission_factor ( nox_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( nox_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(nox_index,traffic_index,1)' , emission_factor ( nox_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( nox_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(nox_index,traffic_index,2)' , emission_factor ( nox_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( no2_index , traffic_index ,:) = read_name_real ( 'emission_factor(no2_index,traffic_index,:)' , emission_factor ( no2_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( no2_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(no2_index,traffic_index,1)' , emission_factor ( no2_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( no2_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(no2_index,traffic_index,2)' , emission_factor ( no2_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( pm25_index , traffic_index ,:) = read_name_real ( 'emission_factor(pm25_index,traffic_index,:)' , emission_factor ( pm25_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm25_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(pm25_index,traffic_index,1)' , emission_factor ( pm25_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm25_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(pm25_index,traffic_index,2)' , emission_factor ( pm25_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( pm10_index , traffic_index ,:) = read_name_real ( 'emission_factor(pm10_index,traffic_index,:)' , emission_factor ( pm10_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm10_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(pm10_index,traffic_index,1)' , emission_factor ( pm10_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm10_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(pm10_index,traffic_index,2)' , emission_factor ( pm10_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( pmex_index , traffic_index ,:) = read_name_real ( 'emission_factor(pmex_index,traffic_index,:)' , emission_factor ( pmex_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pmex_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(pmex_index,traffic_index,1)' , emission_factor ( pmex_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pmex_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(pmex_index,traffic_index,2)' , emission_factor ( pmex_index , traffic_index , 2 ), unit_in , unit_logfile ) ratio_truck_car_emission ( nox_index ) = read_name_real ( 'ratio_truck_car_emission(nox_index)' , ratio_truck_car_emission ( nox_index ), unit_in , unit_logfile ) ratio_truck_car_emission ( pm25_index ) = read_name_real ( 'ratio_truck_car_emission(pm25_index)' , ratio_truck_car_emission ( pm25_index ), unit_in , unit_logfile ) ratio_truck_car_emission ( pm10_index ) = read_name_real ( 'ratio_truck_car_emission(pm10_index)' , ratio_truck_car_emission ( pm10_index ), unit_in , unit_logfile ) !NO2 ratio does not do anything but is included for possible future changes ratio_truck_car_emission ( no2_index ) = read_name_real ( 'ratio_truck_car_emission(no2_index)' , ratio_truck_car_emission ( no2_index ), unit_in , unit_logfile ) z_rec = read_name_real ( 'z_rec' , z_rec ( allsource_index , 1 ), unit_in , unit_logfile ) replace_z0 = read_name_real ( 'replace_z0' , replace_z0 , unit_in , unit_logfile ) replace_invL = read_name_real ( 'replace_invL' , replace_invL , unit_in , unit_logfile ) replace_hmix = read_name_real ( 'replace_hmix' , replace_hmix , unit_in , unit_logfile ) FF_scale = read_name_real ( 'FF_scale' , FF_scale , unit_in , unit_logfile ) FF10_offset = read_name_real ( 'FF10_offset' , FF10_offset , unit_in , unit_logfile ) DD_offset = read_name_real ( 'DD_offset' , DD_offset , unit_in , unit_logfile ) J_scale = read_name_real ( 'J_scale' , J_scale , unit_in , unit_logfile ) save_netcdf_file_flag = read_name_logical ( 'save_netcdf_file_flag' , save_netcdf_file_flag , unit_in , unit_logfile ) save_netcdf_receptor_flag = read_name_logical ( 'save_netcdf_receptor_flag' , save_netcdf_receptor_flag , unit_in , unit_logfile ) save_netcdf_fraction_as_contribution_flag = read_name_logical ( 'save_netcdf_fraction_as_contribution_flag' , save_netcdf_fraction_as_contribution_flag , unit_in , unit_logfile ) calculate_tiling_flag = read_name_logical ( 'calculate_tiling_flag' , calculate_tiling_flag , unit_in , unit_logfile ) calculate_region_tiling_flag = read_name_logical ( 'calculate_region_tiling_flag' , calculate_region_tiling_flag , unit_in , unit_logfile ) pathname_region_id = read_name_char ( 'pathname_region_id' , pathname_region_id , unit_in , unit_logfile ) filename_region_id = read_name_char ( 'filename_region_id' , filename_region_id , unit_in , unit_logfile ) region_name = read_name_char ( 'region_name' , region_name , unit_in , unit_logfile ) region_id = read_name_integer ( 'region_id' , region_id , unit_in , unit_logfile ) region_index = read_name_integer ( 'region_index' , region_index , unit_in , unit_logfile ) region_subgrid_delta = read_name_real ( 'region_subgrid_delta' , region_subgrid_delta , unit_in , unit_logfile ) use_region_select_and_mask_flag = read_name_logical ( 'use_region_select_and_mask_flag' , use_region_select_and_mask_flag , unit_in , unit_logfile ) max_interpolation_subgrid_size = read_name_real ( 'max_interpolation_subgrid_size' , max_interpolation_subgrid_size , unit_in , unit_logfile ) pathname_tiles = read_name_char ( 'pathname_tiles' , pathname_tiles , unit_in , unit_logfile ) filename_tiles = read_name_char ( 'filename_tiles' , filename_tiles , unit_in , unit_logfile ) tile_tag = read_name_char ( 'tile_tag' , tile_tag , unit_in , unit_logfile ) save_tile_tag = read_name_char ( 'save_tile_tag' , save_tile_tag , unit_in , unit_logfile ) use_NORTRIP_emission_data = read_name_logical ( 'use_NORTRIP_emission_data' , use_NORTRIP_emission_data , unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( nox_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(nox_index)' , use_NORTRIP_emission_pollutant ( nox_index ), unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( pm10_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(pm10_index)' , use_NORTRIP_emission_pollutant ( pm10_index ), unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( pm25_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(pm25_index)' , use_NORTRIP_emission_pollutant ( pm25_index ), unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( pmex_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(pmex_index)' , use_NORTRIP_emission_pollutant ( pmex_index ), unit_in , unit_logfile ) use_RWC_emission_data = read_name_logical ( 'use_RWC_emission_data' , use_RWC_emission_data , unit_in , unit_logfile ) HDD_threshold_value = read_name_integer ( 'HDD_threshold_value' , HDD_threshold_value , unit_in , unit_logfile ) DMT_min_value = read_name_real ( 'DMT_min_value' , DMT_min_value , unit_in , unit_logfile ) inpath_region_heating_scaling = read_name_char ( 'inpath_region_heating_scaling' , inpath_region_heating_scaling , unit_in , unit_logfile ) infile_region_heating_scaling = read_name_char ( 'infile_region_heating_scaling' , infile_region_heating_scaling , unit_in , unit_logfile ) integral_subgrid_delta_ref = read_name_real ( 'integral_subgrid_delta_ref' , integral_subgrid_delta_ref , unit_in , unit_logfile ) pathname_rl_change = read_name_char ( 'pathname_rl_change' , pathname_rl_change , unit_in , unit_logfile ) filename_rl_change = read_name_char ( 'filename_rl_change' , filename_rl_change , unit_in , unit_logfile ) forecast_hour_str = read_name_char ( 'forecast_hour_str' , forecast_hour_str , unit_in , unit_logfile ) NORTRIP_hour_str = read_name_char ( 'NORTRIP_hour_str' , NORTRIP_hour_str , unit_in , unit_logfile ) include_o3_in_aqi_index = read_name_logical ( 'include_o3_in_aqi_index' , include_o3_in_aqi_index , unit_in , unit_logfile ) n_kz_iterations = read_name_integer ( 'n_kz_iterations' , n_kz_iterations , unit_in , unit_logfile ) read_weekly_shipping_data_flag = read_name_logical ( 'read_weekly_shipping_data_flag' , read_weekly_shipping_data_flag , unit_in , unit_logfile ) read_monthly_and_daily_shipping_data_flag = read_name_logical ( 'read_monthly_and_daily_shipping_data_flag' , read_monthly_and_daily_shipping_data_flag , unit_in , unit_logfile ) use_tunnel_emissions_flag = read_name_logical ( 'use_tunnel_emissions_flag' , use_tunnel_emissions_flag , unit_in , unit_logfile ) use_tunnel_deposition_flag = read_name_logical ( 'use_tunnel_deposition_flag' , use_tunnel_deposition_flag , unit_in , unit_logfile ) ventilation_factor = read_name_real ( 'ventilation_factor' , ventilation_factor , unit_in , unit_logfile ) min_ADT_ventilation_factor = read_name_real ( 'min_ADT_ventilation_factor' , min_ADT_ventilation_factor , unit_in , unit_logfile ) min_length_ventilation_factor = read_name_real ( 'min_length_ventilation_factor' , min_length_ventilation_factor , unit_in , unit_logfile ) windspeed_tunnel = read_name_real ( 'windspeed_tunnel' , windspeed_tunnel , unit_in , unit_logfile ) save_emissions_for_EMEP ( traffic_index ) = read_name_logical ( 'save_emissions_for_EMEP(traffic_index)' , save_emissions_for_EMEP ( traffic_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( shipping_index ) = read_name_logical ( 'save_emissions_for_EMEP(shipping_index)' , save_emissions_for_EMEP ( shipping_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( industry_index ) = read_name_logical ( 'save_emissions_for_EMEP(industry_index)' , save_emissions_for_EMEP ( industry_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( heating_index ) = read_name_logical ( 'save_emissions_for_EMEP(heating_index)' , save_emissions_for_EMEP ( heating_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( agriculture_index ) = read_name_logical ( 'save_emissions_for_EMEP(agriculture_index)' , save_emissions_for_EMEP ( agriculture_index ), unit_in , unit_logfile ) !Additional GNFR sources save_emissions_for_EMEP ( publicpower_index ) = read_name_logical ( 'save_emissions_for_EMEP(publicpower_index)' , save_emissions_for_EMEP ( publicpower_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( fugitive_index ) = read_name_logical ( 'save_emissions_for_EMEP(fugitive_index)' , save_emissions_for_EMEP ( fugitive_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( solvents_index ) = read_name_logical ( 'save_emissions_for_EMEP(solvents_index)' , save_emissions_for_EMEP ( solvents_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( aviation_index ) = read_name_logical ( 'save_emissions_for_EMEP(aviation_index)' , save_emissions_for_EMEP ( aviation_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( offroad_index ) = read_name_logical ( 'save_emissions_for_EMEP(offroad_index)' , save_emissions_for_EMEP ( offroad_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( waste_index ) = read_name_logical ( 'save_emissions_for_EMEP(waste_index)' , save_emissions_for_EMEP ( waste_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( livestock_index ) = read_name_logical ( 'save_emissions_for_EMEP(livestock_index)' , save_emissions_for_EMEP ( livestock_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( other_index ) = read_name_logical ( 'save_emissions_for_EMEP(other_index)' , save_emissions_for_EMEP ( other_index ), unit_in , unit_logfile ) !Set all source index to true if any of the sources are to be saved. allsource_index defines if the routine is called or not do i_source = 1 , n_source_index if ( save_emissions_for_EMEP ( i_source )) save_emissions_for_EMEP ( allsource_index ) = . true . enddo pathname_emissions_for_EMEP = read_name_char ( 'pathname_emissions_for_EMEP' , pathname_emissions_for_EMEP , unit_in , unit_logfile ) save_emissions_start_index = read_name_integer ( 'save_emissions_start_index' , save_emissions_start_index , unit_in , unit_logfile ) save_emissions_end_index = read_name_integer ( 'save_emissions_end_index' , save_emissions_end_index , unit_in , unit_logfile ) save_emissions_for_EMEP_projection = read_name_char ( 'save_emissions_for_EMEP_projection' , save_emissions_for_EMEP_projection , unit_in , unit_logfile ) save_emissions_for_EMEP_region = read_name_char ( 'save_emissions_for_EMEP_region' , save_emissions_for_EMEP_region , unit_in , unit_logfile ) save_compounds = read_name_logical ( 'save_compounds' , save_compounds , unit_in , unit_logfile ) save_source_contributions = read_name_logical ( 'save_source_contributions' , save_source_contributions , unit_in , unit_logfile ) save_emep_source_contributions = read_name_logical ( 'save_emep_source_contributions' , save_emep_source_contributions , unit_in , unit_logfile ) save_emep_additional_source_contributions = read_name_logical ( 'save_emep_additional_source_contributions' , save_emep_additional_source_contributions , unit_in , unit_logfile ) save_total_source_contributions = read_name_logical ( 'save_total_source_contributions' , save_total_source_contributions , unit_in , unit_logfile ) save_local_source_contributions_from_in_region = read_name_logical ( 'save_local_source_contributions_from_in_region' , save_local_source_contributions_from_in_region , unit_in , unit_logfile ) save_semilocal_source_contributions_from_in_region = read_name_logical ( 'save_semilocal_source_contributions_from_in_region' , save_semilocal_source_contributions_from_in_region , unit_in , unit_logfile ) save_total_source_contributions_from_in_region = read_name_logical ( 'save_total_source_contributions_from_in_region' , save_total_source_contributions_from_in_region , unit_in , unit_logfile ) save_no2_source_contributions = read_name_logical ( 'save_no2_source_contributions' , save_no2_source_contributions , unit_in , unit_logfile ) save_o3_source_contributions = read_name_logical ( 'save_o3_source_contributions' , save_o3_source_contributions , unit_in , unit_logfile ) save_wind_vectors = read_name_logical ( 'save_wind_vectors' , save_wind_vectors , unit_in , unit_logfile ) save_other_meteo = read_name_logical ( 'save_other_meteo' , save_other_meteo , unit_in , unit_logfile ) save_emep_original = read_name_logical ( 'save_emep_original' , save_emep_original , unit_in , unit_logfile ) save_emissions = read_name_logical ( 'save_emissions' , save_emissions , unit_in , unit_logfile ) save_for_chemistry = read_name_logical ( 'save_for_chemistry' , save_for_chemistry , unit_in , unit_logfile ) save_population = read_name_logical ( 'save_population' , save_population , unit_in , unit_logfile ) save_aqi = read_name_logical ( 'save_aqi' , save_aqi , unit_in , unit_logfile ) save_emep_species = read_name_logical ( 'save_emep_species' , save_emep_species , unit_in , unit_logfile ) save_deposition = read_name_logical ( 'save_deposition' , save_deposition , unit_in , unit_logfile ) save_seasalt = read_name_logical ( 'save_seasalt' , save_seasalt , unit_in , unit_logfile ) lowest_stable_L = read_name_real ( 'lowest_stable_L' , lowest_stable_L , unit_in , unit_logfile ) lowest_unstable_L = read_name_real ( 'lowest_unstable_L' , lowest_unstable_L , unit_in , unit_logfile ) tunnel_sig_z_00 = read_name_real ( 'tunnel_sig_z_00' , tunnel_sig_z_00 , unit_in , unit_logfile ) bridge_h_emis = read_name_real ( 'bridge_h_emis' , bridge_h_emis , unit_in , unit_logfile ) !Input variable names for meteo data read from EMEP var_name_nc ( hmix_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(hmix_nc_index)' , var_name_nc ( hmix_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( u10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(u10_nc_index)' , var_name_nc ( u10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( v10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(v10_nc_index)' , var_name_nc ( v10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( FF10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(FF10_nc_index)' , var_name_nc ( FF10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( ugrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(ugrid_nc_index)' , var_name_nc ( ugrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( vgrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(vgrid_nc_index)' , var_name_nc ( vgrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( FFgrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(FFgrid_nc_index)' , var_name_nc ( FFgrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( inv_FFgrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(inv_FFgrid_nc_index)' , var_name_nc ( inv_FFgrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( inv_FF10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(inv_FF10_nc_index)' , var_name_nc ( inv_FF10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( kz_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(kz_nc_index)' , var_name_nc ( kz_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( ustar_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(ustar_nc_index)' , var_name_nc ( ustar_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( logz0_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(logz0_nc_index)' , var_name_nc ( logz0_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( invL_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(invL_nc_index)' , var_name_nc ( invL_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( ZTOP_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(ZTOP_nc_index)' , var_name_nc ( ZTOP_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(t2m_nc_index)' , var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( precip_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(precip_nc_index)' , var_name_nc ( precip_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( J_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(J_nc_index)' , var_name_nc ( J_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( phi_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(phi_nc_index)' , var_name_nc ( phi_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) save_netcdf_average_flag = read_name_logical ( 'save_netcdf_average_flag' , save_netcdf_average_flag , unit_in , unit_logfile ) use_traffic_nox_emission_temperature_dependency = read_name_logical ( 'use_traffic_nox_emission_temperature_dependency' , use_traffic_nox_emission_temperature_dependency , unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_temperature ( 1 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_temperature(1)' , traffic_nox_emission_temperature_ref_temperature ( 1 ), unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_temperature ( 2 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_temperature(2)' , traffic_nox_emission_temperature_ref_temperature ( 2 ), unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_scaling ( 1 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_scaling(1)' , traffic_nox_emission_temperature_ref_scaling ( 1 ), unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_scaling ( 2 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_scaling(2)' , traffic_nox_emission_temperature_ref_scaling ( 2 ), unit_in , unit_logfile ) calculate_deposition_flag = read_name_logical ( 'calculate_deposition_flag' , calculate_deposition_flag , unit_in , unit_logfile ) calculate_source_depletion_flag = read_name_logical ( 'calculate_source_depletion_flag' , calculate_source_depletion_flag , unit_in , unit_logfile ) read_landuse_flag = read_name_logical ( 'read_landuse_flag' , read_landuse_flag , unit_in , unit_logfile ) use_plume_dispersion_deposition_flag = read_name_logical ( 'use_plume_dispersion_deposition_flag' , use_plume_dispersion_deposition_flag , unit_in , unit_logfile ) pathname_landuse = read_name_char ( 'pathname_landuse' , pathname_landuse , unit_in , unit_logfile ) filename_landuse = read_name_char ( 'filename_landuse' , filename_landuse , unit_in , unit_logfile ) adjust_wetdepo_integral_to_lowest_layer_flag = read_name_logical ( 'adjust_wetdepo_integral_to_lowest_layer_flag' , adjust_wetdepo_integral_to_lowest_layer_flag , unit_in , unit_logfile ) auto_adjustment_for_summertime = read_name_logical ( 'auto_adjustment_for_summertime' , auto_adjustment_for_summertime , unit_in , unit_logfile ) use_EMEP_surface_ozone_flag = read_name_logical ( 'use_EMEP_surface_ozone_flag' , use_EMEP_surface_ozone_flag , unit_in , unit_logfile ) use_EMEP_surface_compounds_flag = read_name_logical ( 'use_EMEP_surface_compounds_flag' , use_EMEP_surface_compounds_flag , unit_in , unit_logfile ) use_water_in_EMEP_surface_pm_flag = read_name_logical ( 'use_water_in_EMEP_surface_pm_flag' , use_water_in_EMEP_surface_pm_flag , unit_in , unit_logfile ) save_compounds_as_ascii = read_name_logical ( 'save_compounds_as_ascii' , save_compounds_as_ascii , unit_in , unit_logfile ) use_GNFR_emissions_from_EMEP_flag = read_name_logical ( 'use_GNFR_emissions_from_EMEP_flag' , use_GNFR_emissions_from_EMEP_flag , unit_in , unit_logfile ) use_GNFR19_emissions_from_EMEP_flag = read_name_logical ( 'use_GNFR19_emissions_from_EMEP_flag' , use_GNFR19_emissions_from_EMEP_flag , unit_in , unit_logfile ) use_alphabetic_GNFR_emissions_from_EMEP_flag = read_name_logical ( 'use_alphabetic_GNFR_emissions_from_EMEP_flag' , use_alphabetic_GNFR_emissions_from_EMEP_flag , unit_in , unit_logfile ) use_emission_naming_template_flag = read_name_logical ( 'use_emission_naming_template_flag' , use_emission_naming_template_flag , unit_in , unit_logfile ) emission_naming_template_str = read_name_char ( 'emission_naming_template_str' , emission_naming_template_str , unit_in , unit_logfile ) read_OSM_roadlink_data_flag = read_name_logical ( 'read_OSM_roadlink_data_flag' , read_OSM_roadlink_data_flag , unit_in , unit_logfile ) no_header_roadlink_data_flag = read_name_logical ( 'no_header_roadlink_data_flag' , no_header_roadlink_data_flag , unit_in , unit_logfile ) EMEP_surface_level_nc = read_name_integer ( 'EMEP_surface_level_nc' , EMEP_surface_level_nc , unit_in , unit_logfile ) EMEP_surface_level_nc_2 = read_name_integer ( 'EMEP_surface_level_nc_2' , EMEP_surface_level_nc_2 , unit_in , unit_logfile ) limit_industry_delta = read_name_real ( 'limit_industry_delta' , limit_industry_delta , unit_in , unit_logfile ) limit_shipping_delta = read_name_real ( 'limit_shipping_delta' , limit_shipping_delta , unit_in , unit_logfile ) limit_heating_delta = read_name_real ( 'limit_heating_delta' , limit_heating_delta , unit_in , unit_logfile ) limit_population_delta = read_name_real ( 'limit_population_delta' , limit_population_delta , unit_in , unit_logfile ) use_user_specified_sectors_flag = read_name_logical ( 'use_user_specified_sectors_flag' , use_user_specified_sectors_flag , unit_in , unit_logfile ) if ( use_user_specified_sectors_flag ) then uEMEP_to_EMEP_replace_sector ( traffic_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(traffic_index)' , uEMEP_to_EMEP_replace_sector ( traffic_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( shipping_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(shipping_index)' , uEMEP_to_EMEP_replace_sector ( shipping_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( agriculture_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(agriculture_index)' , uEMEP_to_EMEP_replace_sector ( agriculture_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( heating_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(heating_index)' , uEMEP_to_EMEP_replace_sector ( heating_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( industry_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(industry_index)' , uEMEP_to_EMEP_replace_sector ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources uEMEP_to_EMEP_replace_sector ( publicpower_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(publicpower_index)' , uEMEP_to_EMEP_replace_sector ( publicpower_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( fugitive_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(fugitive_index)' , uEMEP_to_EMEP_replace_sector ( fugitive_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( solvents_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(solvents_index)' , uEMEP_to_EMEP_replace_sector ( solvents_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( aviation_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(aviation_index)' , uEMEP_to_EMEP_replace_sector ( aviation_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( offroad_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(offroad_index)' , uEMEP_to_EMEP_replace_sector ( offroad_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( waste_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(waste_index)' , uEMEP_to_EMEP_replace_sector ( waste_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( livestock_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(livestock_index)' , uEMEP_to_EMEP_replace_sector ( livestock_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( other_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(other_index)' , uEMEP_to_EMEP_replace_sector ( other_index ), unit_in , unit_logfile ) endif EMEP_emission_aggregation_period = read_name_real ( 'EMEP_emission_aggregation_period' , EMEP_emission_aggregation_period , unit_in , unit_logfile ) read_population_from_netcdf_flag = read_name_logical ( 'read_population_from_netcdf_flag' , read_population_from_netcdf_flag , unit_in , unit_logfile ) read_population_from_netcdf_local_flag = read_name_logical ( 'read_population_from_netcdf_local_flag' , read_population_from_netcdf_flag , unit_in , unit_logfile ) auto_select_OSM_country_flag = read_name_logical ( 'auto_select_OSM_country_flag' , auto_select_OSM_country_flag , unit_in , unit_logfile ) pathname_boundingbox = read_name_char ( 'pathname_boundingbox' , pathname_boundingbox , unit_in , unit_logfile ) filename_boundingbox = read_name_char ( 'filename_boundingbox' , filename_boundingbox , unit_in , unit_logfile ) select_country_by_name = read_name_char ( 'select_country_by_name' , select_country_by_name , unit_in , unit_logfile ) select_latlon_centre_domain_position_flag = read_name_logical ( 'select_latlon_centre_domain_position_flag' , select_latlon_centre_domain_position_flag , unit_in , unit_logfile ) select_lat_centre_position = read_name_real ( 'select_lat_centre_position' , select_lat_centre_position , unit_in , unit_logfile ) select_lon_centre_position = read_name_real ( 'select_lon_centre_position' , select_lon_centre_position , unit_in , unit_logfile ) select_domain_width_EW_km = read_name_real ( 'select_domain_width_EW_km' , select_domain_width_EW_km , unit_in , unit_logfile ) select_domain_height_NS_km = read_name_real ( 'select_domain_height_NS_km' , select_domain_height_NS_km , unit_in , unit_logfile ) osm_adt_power_scale = read_name_real ( 'osm_adt_power_scale' , osm_adt_power_scale , unit_in , unit_logfile ) romberg_parameters ( 1 ) = read_name_real ( 'romberg_parameters(1)' , romberg_parameters ( 1 ), unit_in , unit_logfile ) romberg_parameters ( 2 ) = read_name_real ( 'romberg_parameters(2)' , romberg_parameters ( 2 ), unit_in , unit_logfile ) romberg_parameters ( 3 ) = read_name_real ( 'romberg_parameters(3)' , romberg_parameters ( 3 ), unit_in , unit_logfile ) SRM_parameters ( 1 ) = read_name_real ( 'SRM_parameters(1)' , SRM_parameters ( 1 ), unit_in , unit_logfile ) !beta SRM_parameters ( 2 ) = read_name_real ( 'SRM_parameters(2)' , SRM_parameters ( 2 ), unit_in , unit_logfile ) !K SRM_parameters ( 3 ) = read_name_real ( 'SRM_parameters(3)' , SRM_parameters ( 3 ), unit_in , unit_logfile ) !F sig_y_scaling_factor = read_name_real ( 'sig_y_scaling_factor' , sig_y_scaling_factor , unit_in , unit_logfile ) read_shipping_from_netcdf_flag = read_name_logical ( 'read_shipping_from_netcdf_flag' , read_shipping_from_netcdf_flag , unit_in , unit_logfile ) min_proxy_emission_shipping_value = read_name_real ( 'min_proxy_emission_shipping_value' , min_proxy_emission_shipping_value , unit_in , unit_logfile ) population_power_scale = read_name_real ( 'population_power_scale' , population_power_scale , unit_in , unit_logfile ) H_emep = read_name_real ( 'H_emep' , H_emep , unit_in , unit_logfile ) !Allow the user to change the EMEP PM used for nonlocal contribution. !Will be overridden by use_EMEP_surface_compounds_flag and use_water_in_EMEP_surface_pm_flag if they are set to true comp_name_nc ( pm10_nc_index ) = read_name_char ( 'comp_name_nc(pm10_nc_index)' , comp_name_nc ( pm10_nc_index ), unit_in , unit_logfile ) comp_name_nc ( pm25_nc_index ) = read_name_char ( 'comp_name_nc(pm25_nc_index)' , comp_name_nc ( pm25_nc_index ), unit_in , unit_logfile ) comp_name_nc ( o3_nc_index ) = read_name_char ( 'comp_name_nc(o3_nc_index)' , comp_name_nc ( o3_nc_index ), unit_in , unit_logfile ) comp_name_nc ( no2_nc_index ) = read_name_char ( 'comp_name_nc(no2_nc_index)' , comp_name_nc ( no2_nc_index ), unit_in , unit_logfile ) comp_name_nc ( nox_nc_index ) = read_name_char ( 'comp_name_nc(nox_nc_index)' , comp_name_nc ( nox_nc_index ), unit_in , unit_logfile ) comp_name_nc ( nh3_nc_index ) = read_name_char ( 'comp_name_nc(nh3_nc_index)' , comp_name_nc ( nh3_nc_index ), unit_in , unit_logfile ) comp_name_nc ( nh4_nc_index ) = read_name_char ( 'comp_name_nc(nh4_nc_index)' , comp_name_nc ( nh4_nc_index ), unit_in , unit_logfile ) comp_name_nc ( pmex_nc_index ) = read_name_char ( 'comp_name_nc(pmex_nc_index)' , comp_name_nc ( pmex_nc_index ), unit_in , unit_logfile ) comp_name_nc ( co_nc_index ) = read_name_char ( 'comp_name_nc(co_nc_index)' , comp_name_nc ( co_nc_index ), unit_in , unit_logfile ) comp_name_nc ( bap_nc_index ) = read_name_char ( 'comp_name_nc(bap_nc_index)' , comp_name_nc ( bap_nc_index ), unit_in , unit_logfile ) comp_name_nc ( c6h6_nc_index ) = read_name_char ( 'comp_name_nc(c6h6_nc_index)' , comp_name_nc ( c6h6_nc_index ), unit_in , unit_logfile ) comp_name_nc ( so2_nc_index ) = read_name_char ( 'comp_name_nc(so2_nc_index)' , comp_name_nc ( so2_nc_index ), unit_in , unit_logfile ) comp_name_nc ( somo35_nc_index ) = read_name_char ( 'comp_name_nc(somo35_nc_index)' , comp_name_nc ( somo35_nc_index ), unit_in , unit_logfile ) comp_name_nc ( comax_nc_index ) = read_name_char ( 'comp_name_nc(comax_nc_index)' , comp_name_nc ( comax_nc_index ), unit_in , unit_logfile ) comp_name_nc ( o3max_nc_index ) = read_name_char ( 'comp_name_nc(o3max_nc_index)' , comp_name_nc ( o3max_nc_index ), unit_in , unit_logfile ) comp_name_nc ( o3_26th_nc_index ) = read_name_char ( 'comp_name_nc(o3_26th_nc_index)' , comp_name_nc ( o3_26th_nc_index ), unit_in , unit_logfile ) read_RWC_file_with_extra_HDD = read_name_logical ( 'read_RWC_file_with_extra_HDD' , read_RWC_file_with_extra_HDD , unit_in , unit_logfile ) read_RWC_file_with_extra_HDD_and_height = read_name_logical ( 'read_RWC_file_with_extra_HDD_and_height' , read_RWC_file_with_extra_HDD_and_height , unit_in , unit_logfile ) !Allows a scaling of EMEP input ozone. For testing. comp_scale_nc ( o3_nc_index ) = read_name_real ( 'comp_scale_nc(o3_nc_index)' , comp_scale_nc ( o3_nc_index ), unit_in , unit_logfile ) comp_scale_nc ( nox_nc_index ) = read_name_real ( 'comp_scale_nc(nox_nc_index)' , comp_scale_nc ( nox_nc_index ), unit_in , unit_logfile ) comp_scale_nc ( no2_nc_index ) = read_name_real ( 'comp_scale_nc(no2_nc_index)' , comp_scale_nc ( no2_nc_index ), unit_in , unit_logfile ) use_alternative_traveltime_weighting = read_name_logical ( 'use_alternative_traveltime_weighting' , use_alternative_traveltime_weighting , unit_in , unit_logfile ) traveltime_power = read_name_real ( 'traveltime_power' , traveltime_power , unit_in , unit_logfile ) traveltime_scaling = read_name_real ( 'traveltime_scaling' , traveltime_scaling , unit_in , unit_logfile ) use_straightline_traveltime_distance = read_name_logical ( 'use_straightline_traveltime_distance' , use_straightline_traveltime_distance , unit_in , unit_logfile ) !Name of the netcdf variable read for population or dwelling proxy var_name_population_nc ( population_nc_index ) = read_name_char ( 'var_name_population_nc(population_nc_index)' , var_name_population_nc ( population_nc_index ), unit_in , unit_logfile ) var_name_population_nc ( dwelling_nc_index ) = read_name_char ( 'var_name_population_nc(dwelling_nc_index)' , var_name_population_nc ( dwelling_nc_index ), unit_in , unit_logfile ) f_no2_emep = read_name_real ( 'f_no2_emep' , f_no2_emep , unit_in , unit_logfile ) limit_emep_grid_interpolation_region_to_calculation_region = read_name_logical ( 'limit_emep_grid_interpolation_region_to_calculation_region' , limit_emep_grid_interpolation_region_to_calculation_region , unit_in , unit_logfile ) use_local_fraction_naming_template_flag = read_name_logical ( 'use_local_fraction_naming_template_flag' , use_local_fraction_naming_template_flag , unit_in , unit_logfile ) use_local_fraction_grid_size_in_template_flag = read_name_logical ( 'use_local_fraction_grid_size_in_template_flag' , use_local_fraction_grid_size_in_template_flag , unit_in , unit_logfile ) local_fraction_grid_size ( 1 ) = read_name_integer ( 'local_fraction_grid_size(1)' , local_fraction_grid_size ( 1 ), unit_in , unit_logfile ) local_fraction_grid_size ( 2 ) = read_name_integer ( 'local_fraction_grid_size(2)' , local_fraction_grid_size ( 2 ), unit_in , unit_logfile ) local_fraction_grid_size ( 3 ) = read_name_integer ( 'local_fraction_grid_size(3)' , local_fraction_grid_size ( 3 ), unit_in , unit_logfile ) n_local_fraction_grids = read_name_integer ( 'n_local_fraction_grids' , n_local_fraction_grids , unit_in , unit_logfile ) local_fraction_naming_template_str = read_name_char ( 'local_fraction_naming_template_str' , local_fraction_naming_template_str , unit_in , unit_logfile ) local_fraction_grid_for_EMEP_grid_interpolation = read_name_integer ( 'local_fraction_grid_for_EMEP_grid_interpolation' , local_fraction_grid_for_EMEP_grid_interpolation , unit_in , unit_logfile ) local_fraction_grid_for_EMEP_additional_grid_interpolation = read_name_integer ( 'local_fraction_grid_for_EMEP_additional_grid_interpolation' , local_fraction_grid_for_EMEP_additional_grid_interpolation , unit_in , unit_logfile ) save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag = read_name_logical ( 'save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag' , save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag , unit_in , unit_logfile ) n_var_av = read_name_integer ( 'n_var_av' , n_var_av , unit_in , unit_logfile ) finished_filename = read_name_char ( 'finished_filename' , finished_filename , unit_in , unit_logfile ) finished_subpath = read_name_char ( 'finished_subpath' , finished_subpath , unit_in , unit_logfile ) use_annual_mean_pdf_chemistry_correction = read_name_logical ( 'use_annual_mean_pdf_chemistry_correction' , use_annual_mean_pdf_chemistry_correction , unit_in , unit_logfile ) quick_annual_mean_pdf_chemistry_correction = read_name_logical ( 'quick_annual_mean_pdf_chemistry_correction' , quick_annual_mean_pdf_chemistry_correction , unit_in , unit_logfile ) ox_sigma_ratio_pdf = read_name_real ( 'ox_sigma_ratio_pdf' , ox_sigma_ratio_pdf , unit_in , unit_logfile ) nox_sigma_ratio_pdf = read_name_real ( 'nox_sigma_ratio_pdf' , nox_sigma_ratio_pdf , unit_in , unit_logfile ) min_bin_pdf = read_name_real ( 'min_bin_pdf' , min_bin_pdf , unit_in , unit_logfile ) max_bin_pdf = read_name_real ( 'max_bin_pdf' , max_bin_pdf , unit_in , unit_logfile ) log10_step_bin_pdf = read_name_real ( 'log10_step_bin_pdf' , log10_step_bin_pdf , unit_in , unit_logfile ) use_landuse_as_proxy = read_name_logical ( 'use_landuse_as_proxy' , use_landuse_as_proxy , unit_in , unit_logfile ) read_rivm_landuse_flag = read_name_logical ( 'read_rivm_landuse_flag' , read_rivm_landuse_flag , unit_in , unit_logfile ) var_name_landuse_nc ( num_var_landuse_nc ) = read_name_char ( 'var_name_landuse_nc' , var_name_landuse_nc ( num_var_landuse_nc ), unit_in , unit_logfile ) use_rivm_agricuture_emission_data = read_name_logical ( 'use_rivm_agricuture_emission_data' , use_rivm_agricuture_emission_data , unit_in , unit_logfile ) read_subgrid_emission_data = read_name_logical ( 'read_subgrid_emission_data' , read_subgrid_emission_data , unit_in , unit_logfile ) use_rivm_subgrid_emission_format = read_name_logical ( 'use_rivm_subgrid_emission_format' , use_rivm_subgrid_emission_format , unit_in , unit_logfile ) !Read landuse weighting this may take some time !Source input is numbered as GNFR13 in input but is placed in the uEMEP source sectors do i_source = 1 , n_source_index do i_landuse = 1 , n_clc_landuse_index write ( UNIT = a_str , FMT =* ) convert_uEMEP_to_GNFR_sector_index ( i_source ) write ( UNIT = b_str , FMT =* ) i_landuse temp_str = 'landuse_proxy_weighting(' // trim ( adjustl ( a_str )) // ',' // trim ( adjustl ( b_str )) // ')' !write(*,*) i_source,trim(temp_str) landuse_proxy_weighting ( i_source , i_landuse ) = read_name_real ( trim ( temp_str ), landuse_proxy_weighting ( i_source , i_landuse ), unit_in , unit_logfile ) enddo enddo !Scale EMEP emission by sector !Source input is numbered as GNFR13 in input but is placed in the uEMEP source sectors do i_source = 1 , n_source_index write ( UNIT = a_str , FMT =* ) convert_uEMEP_to_GNFR_sector_index ( i_source ) temp_str = 'scale_GNFR_emission_source(' // trim ( adjustl ( a_str )) // ')' !write(*,*) i_source,trim(temp_str) scale_GNFR_emission_source ( i_source ) = read_name_real ( trim ( temp_str ), scale_GNFR_emission_source ( i_source ), unit_in , unit_logfile ) enddo !Save original EMEP values for save_EMEP_somo35 = read_name_logical ( 'save_EMEP_somo35' , save_EMEP_somo35 , unit_in , unit_logfile ) save_EMEP_comax = read_name_logical ( 'save_EMEP_comax' , save_EMEP_comax , unit_in , unit_logfile ) save_EMEP_o3max = read_name_logical ( 'save_EMEP_o3max' , save_EMEP_o3max , unit_in , unit_logfile ) save_EMEP_o3_26th = read_name_logical ( 'save_EMEP_o3_26th' , save_EMEP_o3_26th , unit_in , unit_logfile ) save_EMEP_so2 = read_name_logical ( 'save_EMEP_so2' , save_EMEP_so2 , unit_in , unit_logfile ) !Read subgrid receptor offset. This is for testing purposes only and applies only to the receptor subgrids subgrid_receptor_offset ( x_dim_index ) = read_name_real ( 'subgrid_receptor_offset(x_dim_index)' , subgrid_receptor_offset ( x_dim_index ), unit_in , unit_logfile ) subgrid_receptor_offset ( y_dim_index ) = read_name_real ( 'subgrid_receptor_offset(y_dim_index)' , subgrid_receptor_offset ( y_dim_index ), unit_in , unit_logfile ) derive_SOA_from_other_species = read_name_logical ( 'derive_SOA_from_other_species' , derive_SOA_from_other_species , unit_in , unit_logfile ) Kz_scheme = read_name_integer ( 'Kz_scheme' , Kz_scheme , unit_in , unit_logfile ) use_phi_for_invL = read_name_logical ( 'use_phi_for_invL' , use_phi_for_invL , unit_in , unit_logfile ) z_invL = read_name_real ( 'z_invL' , z_invL , unit_in , unit_logfile ) save_emission_subgrid_min ( x_dim_index ) = read_name_real ( 'save_emission_subgrid_min(x_dim_index)' , save_emission_subgrid_min ( x_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_min ( y_dim_index ) = read_name_real ( 'save_emission_subgrid_min(y_dim_index)' , save_emission_subgrid_min ( y_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_delta ( x_dim_index ) = read_name_real ( 'save_emission_subgrid_delta(x_dim_index)' , save_emission_subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_delta ( y_dim_index ) = read_name_real ( 'save_emission_subgrid_delta(y_dim_index)' , save_emission_subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_dim ( x_dim_index ) = read_name_integer ( 'save_emission_subgrid_dim(x_dim_index)' , save_emission_subgrid_dim ( x_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_dim ( y_dim_index ) = read_name_integer ( 'save_emission_subgrid_dim(y_dim_index)' , save_emission_subgrid_dim ( y_dim_index ), unit_in , unit_logfile ) trace_emissions_from_in_region = read_name_logical ( 'trace_emissions_from_in_region' , trace_emissions_from_in_region , unit_in , unit_logfile ) calc_grid_vertical_average_concentration_annual_flag = read_name_logical ( 'calc_grid_vertical_average_concentration_annual_flag' , calc_grid_vertical_average_concentration_annual_flag , unit_in , unit_logfile ) wind_level_zc_flag = read_name_logical ( 'wind_level_zc_flag' , wind_level_zc_flag , unit_in , unit_logfile ) use_alternative_ppm_variable_for_lf = read_name_logical ( 'use_alternative_ppm_variable_for_lf' , use_alternative_ppm_variable_for_lf , unit_in , unit_logfile ) alternative_ppm_variable_for_lf_dim = read_name_integer ( 'alternative_ppm_variable_for_lf_dim' , alternative_ppm_variable_for_lf_dim , unit_in , unit_logfile ) var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index ) = read_name_char ( 'var_name_nc(conc_nc_index,pm25_nc_index,extrasource_nc_index)' , var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index ), unit_in , unit_logfile ) var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index ) = read_name_char ( 'var_name_nc(conc_nc_index,pmco_nc_index,extrasource_nc_index)' , var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index ), unit_in , unit_logfile ) save_emep_OP_species = read_name_logical ( 'save_emep_OP_species' , save_emep_OP_species , unit_in , unit_logfile ) ! Read configs added for the nonlocal from-in-region method pathname_region_mask = read_name_char ( 'pathname_region_mask' , pathname_region_mask , unit_in , unit_logfile ) filename_region_mask = read_name_char ( 'filename_region_mask' , filename_region_mask , unit_in , unit_logfile ) varname_region_mask = read_name_char ( 'varname_region_mask' , varname_region_mask , unit_in , unit_logfile ) close ( unit_in ) enddo !End configuration file number loop !The rest below was inside the file loop before. Have moved to outside now. Hope that works! !Call some error traps if ( len ( trim ( pathname_output_grid )). eq . 0 ) then write ( unit_logfile , '(A)' ) 'WARNING: No output path given in configuration file. Stopping' stop endif if ( local_subgrid_method_flag == 1 . and . trace_emissions_from_in_region ) then write ( unit_logfile , '(A)' ) 'trace_emissions_from_in_region must be false when local_subgrid_method_flag is 1, since it is not possible to trace emission origin when EMEP concentrations are directly redistributed. Stopping' stop end if !Find the correct compound index based on the compound string do i = 1 , n_pollutant_nc_index if ( trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )). eq . trim ( input_comp_name )) then compound_index = i pollutant_index = i write ( unit_logfile , * ) 'Selected pollutant: ' , trim ( input_comp_name ), i endif enddo !Replace some of the strings with the date_str. Do this twice in case there are two occurences of it in a string do i = 1 , 2 pathname_EMEP ( 1 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 1 )) pathname_EMEP ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 2 )) pathname_EMEP ( 3 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 3 )) pathname_EMEP ( 4 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 4 )) filename_EMEP ( 1 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 1 )) filename_EMEP ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 2 )) filename_EMEP ( 3 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 3 )) filename_EMEP ( 4 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 4 )) pathname_output_grid = replace_string_char ( config_date_str , replacement_date_str , pathname_output_grid ) filename_date_output_grid = replace_string_char ( config_date_str , replacement_date_str , filename_date_output_grid ) !NORTRIP file and path name pathname_rl ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_rl ( 2 )) filename_rl ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , filename_rl ( 2 )) pathname_EMEP ( 1 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 1 )) pathname_EMEP ( 2 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 2 )) pathname_EMEP ( 3 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 3 )) pathname_EMEP ( 4 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 4 )) filename_EMEP ( 1 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 1 )) filename_EMEP ( 2 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 2 )) filename_EMEP ( 3 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 3 )) filename_EMEP ( 4 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 4 )) pathname_output_grid = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_output_grid ) filename_date_output_grid = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_date_output_grid ) !NORTRIP file and path name pathname_rl ( 2 ) = replace_string_char ( NORTRIP_hour_str , NORTRIP_replacement_hour_str , pathname_rl ( 2 )) filename_rl ( 2 ) = replace_string_char ( NORTRIP_hour_str , NORTRIP_replacement_hour_str , filename_rl ( 2 )) enddo !Replace date in the output file if required, 3 times for yyyy mm dd format_temp = 'yyyymmdd' call datestr_to_date ( config_date_str , format_temp , a ) !write (unit_logfile,'(2A)') ' Updating output path from: ',trim(pathname_output_grid) do i = 1 , 3 call date_to_datestr_bracket ( a , pathname_output_grid , pathname_output_grid ) call date_to_datestr_bracket ( a , filename_date_output_grid , filename_date_output_grid ) call date_to_datestr_bracket ( a , pathname_EMEP ( 1 ), pathname_EMEP ( 1 )) call date_to_datestr_bracket ( a , pathname_EMEP ( 2 ), pathname_EMEP ( 2 )) call date_to_datestr_bracket ( a , pathname_EMEP ( 3 ), pathname_EMEP ( 3 )) call date_to_datestr_bracket ( a , pathname_EMEP ( 4 ), pathname_EMEP ( 4 )) call date_to_datestr_bracket ( a , pathname_rl ( 1 ), pathname_rl ( 1 )) call date_to_datestr_bracket ( a , pathname_rl ( 2 ), pathname_rl ( 2 )) call date_to_datestr_bracket ( a , filename_EMEP ( 1 ), filename_EMEP ( 1 )) call date_to_datestr_bracket ( a , filename_EMEP ( 2 ), filename_EMEP ( 2 )) call date_to_datestr_bracket ( a , filename_EMEP ( 3 ), filename_EMEP ( 3 )) call date_to_datestr_bracket ( a , filename_EMEP ( 4 ), filename_EMEP ( 4 )) call date_to_datestr_bracket ( a , filename_rl ( 1 ), filename_rl ( 1 )) call date_to_datestr_bracket ( a , filename_rl ( 2 ), filename_rl ( 2 )) call date_to_datestr_bracket ( a , pathname_emissions_for_EMEP , pathname_emissions_for_EMEP ) enddo !write (unit_logfile,'(2A)') ' Updating output path to:   ',trim(pathname_output_grid) !write (unit_logfile,'(2A)') ' Updating output file to:   ',trim(pathname_EMEP(1)) !Specify the yesterday date string and replace it if found. Identified wiht a square bracket !call datestr_to_date(config_date_str,format_temp,a) datenum_temp = date_to_number ( a , ref_year_EMEP ) datenum_temp = datenum_temp - 1. call number_to_date ( datenum_temp , a , ref_year_EMEP ) call date_to_datestr ( a , format_temp , yesterday_date_str ) write ( unit_logfile , '(2a)' ) 'Todays date string: ' , trim ( config_date_str ) write ( unit_logfile , '(2a)' ) 'Yesterdays date string: ' , trim ( yesterday_date_str ) do i = 1 , 3 call date_to_datestr_squarebracket ( a , pathname_output_grid , pathname_output_grid ) call date_to_datestr_squarebracket ( a , filename_date_output_grid , filename_date_output_grid ) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 1 ), pathname_EMEP ( 1 )) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 2 ), pathname_EMEP ( 2 )) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 3 ), pathname_EMEP ( 3 )) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 4 ), pathname_EMEP ( 4 )) call date_to_datestr_squarebracket ( a , pathname_rl ( 1 ), pathname_rl ( 1 )) call date_to_datestr_squarebracket ( a , pathname_rl ( 2 ), pathname_rl ( 2 )) enddo do i = 1 , 2 pathname_EMEP ( 1 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 1 )) pathname_EMEP ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 2 )) pathname_EMEP ( 3 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 3 )) pathname_EMEP ( 4 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 4 )) filename_EMEP ( 1 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 1 )) filename_EMEP ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 2 )) filename_EMEP ( 3 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 3 )) filename_EMEP ( 4 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 4 )) pathname_output_grid = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_output_grid ) filename_date_output_grid = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_date_output_grid ) !NORTRIP file and path name pathname_rl ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_rl ( 2 )) filename_rl ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_rl ( 2 )) enddo !write(*,*) trim(filename_EMEP(3)) !write(*,*) trim(pathname_EMEP(3)) !Place tile_tag in front of file_tag if it has been read if ( tile_tag . ne . '' ) then file_tag = trim ( file_tag ) // '_' // trim ( tile_tag ) endif end subroutine uEMEP_read_config","tags":"","loc":"proc/uemep_read_config.html"},{"title":"uEMEP_set_subgrids – uEMEP","text":"public  subroutine uEMEP_set_subgrids() Arguments None Source Code subroutine uEMEP_set_subgrids () ! Local variables integer :: i real :: dim_check ( 2 ) ! In the case of interpolation and auto subgridding we need to extend the domain by dx and dy to get the different grids to fit ! Assume the maximum is 1 km if ( use_emission_positions_for_auto_subgrid_flag ( allsource_index )) then ! Check that it is divisable by the largest grid size dim_check ( x_dim_index ) = mod (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )), max_interpolation_subgrid_size ) dim_check ( y_dim_index ) = mod (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )), max_interpolation_subgrid_size ) if ( dim_check ( x_dim_index ) . eq . 0 ) then subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) + subgrid_delta ( x_dim_index ) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to x grid max: ' , subgrid_delta ( x_dim_index ) else subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) + ( max_interpolation_subgrid_size - dim_check ( x_dim_index ) + subgrid_delta ( x_dim_index )) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to x grid max: ' , ( max_interpolation_subgrid_size - dim_check ( x_dim_index ) + subgrid_delta ( x_dim_index )) end if if ( dim_check ( x_dim_index ) . eq . 0 ) then subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) + subgrid_delta ( y_dim_index ) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to y grid max: ' , subgrid_delta ( y_dim_index ) else subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) + ( max_interpolation_subgrid_size - dim_check ( y_dim_index ) + subgrid_delta ( y_dim_index )) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to y grid max: ' , ( max_interpolation_subgrid_size - dim_check ( y_dim_index ) + subgrid_delta ( y_dim_index )) end if end if ! Reset min and max with the buffer and calculate dimensions subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) ! Set all integral subgrids relative to the target subgrid if ( integral_subgrid_delta_ref . eq . 0. ) then integral_subgrid_delta = subgrid_delta * integral_subgrid_step else integral_subgrid_delta ( x_dim_index ) = max ( integral_subgrid_delta_ref , subgrid_delta ( x_dim_index )) integral_subgrid_delta ( y_dim_index ) = max ( integral_subgrid_delta_ref , subgrid_delta ( y_dim_index )) integral_subgrid_step = floor ( integral_subgrid_delta_ref / subgrid_delta ( x_dim_index ) + 0.5 ) end if integral_subgrid_min = subgrid_min integral_subgrid_max = subgrid_max integral_subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) integral_subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) integral_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) ! Set the integral subgrid dimensions so they cannot be larger than the target subgrid integral_subgrid_dim ( x_dim_index ) = min ( integral_subgrid_dim ( x_dim_index ), subgrid_dim ( x_dim_index )) integral_subgrid_dim ( y_dim_index ) = min ( integral_subgrid_dim ( y_dim_index ), subgrid_dim ( y_dim_index )) ! Set all population subgrids relative to the target subgrid if ( population_data_type . eq . population_index . and . . not . use_region_select_and_mask_flag ) then ! When not using regional mask then 250 m population data is used then set this as a limit population_subgrid_delta ( x_dim_index ) = max ( subgrid_delta ( x_dim_index ), limit_population_delta ) population_subgrid_delta ( y_dim_index ) = max ( subgrid_delta ( y_dim_index ), limit_population_delta ) else ! Allow the population data to have the same grid as the target grid population_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) population_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) end if population_subgrid_min = subgrid_min population_subgrid_max = subgrid_max population_subgrid_dim ( x_dim_index ) = floor (( population_subgrid_max ( x_dim_index ) - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) population_subgrid_dim ( y_dim_index ) = floor (( population_subgrid_max ( y_dim_index ) - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) ! Set the population subgrid dimensions so they cannot be larger than the target subgrid. Not certain why I do this. population_subgrid_dim ( x_dim_index ) = min ( population_subgrid_dim ( x_dim_index ), subgrid_dim ( x_dim_index )) population_subgrid_dim ( y_dim_index ) = min ( population_subgrid_dim ( y_dim_index ), subgrid_dim ( y_dim_index )) ! Set population subgrid so it has a minimum of 1 dimensions, to avoid problems when running receptor calculations population_subgrid_dim ( x_dim_index ) = max ( population_subgrid_dim ( x_dim_index ), 1 ) population_subgrid_dim ( y_dim_index ) = max ( population_subgrid_dim ( y_dim_index ), 1 ) ! Set all emission subgrids to be the same as the target subgrid emission_max_subgrid_dim = subgrid_dim do i = 1 , n_source_index emission_subgrid_delta (:, i ) = subgrid_delta emission_subgrid_min (:, i ) = subgrid_min emission_subgrid_max (:, i ) = subgrid_max emission_subgrid_dim (:, i ) = subgrid_dim end do ! Set shipping data to a minimum value for all sources (Cannot be smaller than the target subgrid) emission_subgrid_delta ( x_dim_index , shipping_index ) = max ( subgrid_delta ( x_dim_index ), limit_shipping_delta ) emission_subgrid_delta ( y_dim_index , shipping_index ) = max ( subgrid_delta ( y_dim_index ), limit_shipping_delta ) emission_subgrid_delta ( x_dim_index , heating_index ) = max ( subgrid_delta ( x_dim_index ), limit_heating_delta ) emission_subgrid_delta ( y_dim_index , heating_index ) = max ( subgrid_delta ( y_dim_index ), limit_heating_delta ) emission_subgrid_delta ( x_dim_index , industry_index ) = max ( subgrid_delta ( x_dim_index ), limit_industry_delta ) emission_subgrid_delta ( y_dim_index , industry_index ) = max ( subgrid_delta ( y_dim_index ), limit_industry_delta ) ! Set all the emission subgrid dimensions after changes do i = 1 , n_source_index emission_subgrid_dim ( x_dim_index , i ) = floor (( emission_subgrid_max ( x_dim_index , i ) - emission_subgrid_min ( x_dim_index , i )) / emission_subgrid_delta ( x_dim_index , i )) emission_subgrid_dim ( y_dim_index , i ) = floor (( emission_subgrid_max ( y_dim_index , i ) - emission_subgrid_min ( y_dim_index , i )) / emission_subgrid_delta ( y_dim_index , i )) write ( unit_logfile , '(A,I6,A5,2I6)' ) 'Emission grid dimensions for source ' , i , ': ' , emission_subgrid_dim ( 1 : 2 , i ) end do ! Set the landuse and deposition grids to have the same extent as the target grid if ( calculate_deposition_flag ) then if ( deposition_subgrid_delta ( x_dim_index ) . eq . 0 ) deposition_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) if ( deposition_subgrid_delta ( y_dim_index ) . eq . 0 ) deposition_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) deposition_subgrid_min (:) = subgrid_min deposition_subgrid_max (:) = subgrid_max deposition_subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / deposition_subgrid_delta ( x_dim_index )) deposition_subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / deposition_subgrid_delta ( y_dim_index )) deposition_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) end if if ( read_landuse_flag ) then if ( landuse_subgrid_delta ( x_dim_index ) . eq . 0 ) landuse_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) if ( landuse_subgrid_delta ( y_dim_index ) . eq . 0 ) landuse_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) landuse_subgrid_min (:) = subgrid_min landuse_subgrid_max (:) = subgrid_max landuse_subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / landuse_subgrid_delta ( x_dim_index )) landuse_subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / landuse_subgrid_delta ( y_dim_index )) landuse_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) end if write ( unit_logfile , '(A,2I6)' ) 'Concentration grid dimensions: ' , subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Integral grid dimensions: ' , integral_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2f10.1)' ) 'Concentration subgrid grid sizes: ' , subgrid_delta write ( unit_logfile , '(A,I6,2f10.1)' ) 'Integral subgrid step and grid sizes: ' , integral_subgrid_step , integral_subgrid_delta if ( calculate_deposition_flag ) then write ( unit_logfile , '(A,2I6)' ) 'Deposition grid dimensions: ' , deposition_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2f10.1)' ) 'Deposition subgrid grid sizes: ' , deposition_subgrid_delta end if if ( read_landuse_flag ) then write ( unit_logfile , '(A,2I6)' ) 'Landuse grid dimensions: ' , landuse_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2f10.1)' ) 'Landuse subgrid grid sizes: ' , landuse_subgrid_delta end if end subroutine uEMEP_set_subgrids","tags":"","loc":"proc/uemep_set_subgrids.html"},{"title":"uEMEP_set_subgrid_select_latlon_centre – uEMEP","text":"public  subroutine uEMEP_set_subgrid_select_latlon_centre() Arguments None Source Code subroutine uEMEP_set_subgrid_select_latlon_centre () ! If specified using select_latlon_centre_domain_position_flag then this routines specifies ! the grid according to the lat lon position and the width and height ! This is intended to make life easier for users and to implement uEMEP in a more global context ! Local variables real :: x_out , y_out ! Find centre position in specified coordinates if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , select_lat_centre_position , select_lon_centre_position , y_out , x_out ) else if ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , select_lat_centre_position , select_lon_centre_position , y_out , x_out ) else if ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_out , y_out , select_lon_centre_position , select_lat_centre_position , projection_attributes ) end if ! Snap to nearest 1 km x_out = floor ( x_out / 100 0.0 + 0.5 ) * 100 0.0 y_out = floor ( y_out / 100 0.0 + 0.5 ) * 100 0.0 ! Set max and min values subgrid_min ( x_dim_index ) = x_out - select_domain_width_EW_km * 100 0.0 / 2.0 subgrid_min ( y_dim_index ) = y_out - select_domain_height_NS_km * 100 0.0 / 2.0 subgrid_max ( x_dim_index ) = x_out + select_domain_width_EW_km * 100 0.0 / 2.0 subgrid_max ( y_dim_index ) = y_out + select_domain_height_NS_km * 100 0.0 / 2.0 write ( unit_logfile , '(A,2f12.1)' ) 'Setting domain centre (lon,lat) to: ' , select_lon_centre_position , select_lat_centre_position write ( unit_logfile , '(A,2f12.1)' ) 'Setting min domain (x,y) to: ' , subgrid_min ( 1 : 2 ) write ( unit_logfile , '(A,2f12.1)' ) 'Setting max domain (x,y) to: ' , subgrid_max ( 1 : 2 ) ! Reset the initial subgrid as well, needed for EMEP and receptor selection init_subgrid_min ( x_dim_index ) = subgrid_min ( x_dim_index ) init_subgrid_min ( y_dim_index ) = subgrid_min ( y_dim_index ) init_subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) init_subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) end subroutine uEMEP_set_subgrid_select_latlon_centre","tags":"","loc":"proc/uemep_set_subgrid_select_latlon_centre.html"},{"title":"uEMEP_read_industry_data – uEMEP","text":"public  subroutine uEMEP_read_industry_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_industry_data use uEMEP_definitions implicit none integer i , j integer unit_in character ( 256 ) temp_str integer count integer n_industries logical exists integer subsource_index integer , allocatable :: industry_ref (:) character ( 256 ), allocatable :: industry_num (:) real , allocatable :: industry_lb_pos (:,:) real , allocatable :: industry_xy_pos (:,:) real , allocatable :: industry_height (:) real , allocatable :: industry_emission (:,:) character ( 256 ), allocatable :: industry_code (:) integer industry_emission_year character ( 256 ) industry_emission_num , industry_emission_comp_str , industry_emission_unit real industry_emission_comp_val integer industry_number integer i_industry_index , j_industry_index , source_index , i_pollutant real ratio_industry_pm25_to_pm10 real x_industry , y_industry integer , allocatable :: count_subgrid (:,:,:) real , allocatable :: emission_height_subgrid (:,:,:) integer pollutant_count integer :: io subsource_index = 1 source_index = industry_index !Set default pm25/pm10 ratio for when pm10 is given but not pm25. Value of 1 appropriate for exhaust but not for fugitive dust emissions ratio_industry_pm25_to_pm10 = 1.0 write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading industry data  (uEMEP_read_industry_data)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_industry ( 1 ) = trim ( pathname_industry ( 1 )) // trim ( filename_industry ( 1 )) !Metadata pathfilename_industry ( 2 ) = trim ( pathname_industry ( 2 )) // trim ( filename_industry ( 2 )) !Emission data !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_industry ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Industry metadata file does not exist: ' , trim ( pathfilename_industry ( 1 )) stop endif inquire ( file = trim ( pathfilename_industry ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Industry emission file does not exist: ' , trim ( pathfilename_industry ( 2 )) stop endif !Open the metadata file for reading unit_in = 20 open ( unit_in , file = pathfilename_industry ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening industry metadata file ' // trim ( pathfilename_industry ( 1 )) rewind ( unit_in ) !Read header: AnleggIdRef\tAnleggNummer\tGeografiskLatitude\tGeografiskLongitude\tUtm33Nord\tUtm33Ost\tHeight\tNACEKode read ( unit_in , '(A)' ) temp_str !write(*,*) trim(temp_str) !Count how many lines for allocation of arrays count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit count = count + 1 enddo !Allocate arrays n_industries = count allocate ( industry_ref ( n_industries )) allocate ( industry_num ( n_industries )) allocate ( industry_lb_pos ( n_industries , 2 )) allocate ( industry_xy_pos ( n_industries , 2 )) allocate ( industry_height ( n_industries )) allocate ( industry_code ( n_industries )) allocate ( industry_emission ( n_industries , n_compound_index )) rewind ( unit_in ) !Read header again read ( unit_in , '(A)' ) temp_str do i = 1 , n_industries read ( unit_in , * ) industry_ref ( i ), industry_num ( i ), industry_lb_pos ( i , 2 ), industry_lb_pos ( i , 1 ), industry_xy_pos ( i , 2 ), industry_xy_pos ( i , 1 ), industry_height ( i ), industry_code ( i ) !write(unit_logfile,'(i12,a16,2f12.4,3f12.1,a16)' ) industry_ref(i),trim(industry_num(i)),industry_lb_pos(i,2),industry_lb_pos(i,1),industry_xy_pos(i,2),industry_xy_pos(i,1),industry_height(i),trim(industry_code(i)) enddo close ( unit_in ) write ( unit_logfile , '(a,i)' ) ' Number of industries: ' , n_industries !Read in emission file and write emisions to industry array allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) allocate ( emission_height_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 emission_height_subgrid = 0. !Open the emission file for reading industry_emission = 0. unit_in = 20 open ( unit_in , file = pathfilename_industry ( 2 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening industry emission file ' // trim ( pathfilename_industry ( 2 )) rewind ( unit_in ) !Read header: �r\tAnleggNummer\tKomponent\tSamlet_mengde\tEnhet read ( unit_in , '(A)' ) temp_str do read ( unit_in , * , iostat = io ) industry_emission_year , industry_emission_num , industry_emission_comp_str , industry_emission_comp_val , industry_emission_unit if ( io /= 0 ) exit !write(unit_logfile,'(i12,2a16,f12.2,a16)' ) industry_emission_year,trim(industry_emission_num),trim(industry_emission_comp_str),industry_emission_comp_val,trim(industry_emission_unit) !Find index for the industry industry_number = 0 do i = 1 , n_industries if ( trim ( industry_emission_num ). eq . trim ( industry_num ( i ))) then industry_number = i exit endif enddo if ( industry_number . eq . 0 ) then write ( unit_logfile , * ) 'No matching industry ID for the emissions: ' // trim ( industry_emission_num ) else !write(unit_logfile,*) 'Matching industry ID found: '//trim(industry_emission_num) endif !If an industry is found then put the emissions in the industry_emission array if ( industry_number . gt . 0 ) then if ( trim ( industry_emission_comp_str ). eq . 'nox' ) then industry_emission ( industry_number , nox_index ) = industry_emission ( industry_number , nox_index ) + industry_emission_comp_val endif if ( trim ( industry_emission_comp_str ). eq . 'pm10' ) then industry_emission ( industry_number , pm10_index ) = industry_emission ( industry_number , pm10_index ) + industry_emission_comp_val endif if ( trim ( industry_emission_comp_str ). eq . 'pm25' ) then industry_emission ( industry_number , pm25_index ) = industry_emission ( industry_number , pm25_index ) + industry_emission_comp_val endif endif enddo close ( unit_in ) !Adjust pm10 and pm25 dependent on if they exist or not do i = 1 , n_industries !Set pm10 to pm25 in the case when it is less than pm25. if ( industry_emission ( i , pm10_index ). lt . industry_emission ( i , pm25_index )) then industry_emission ( i , pm10_index ) = industry_emission ( i , pm25_index ) endif !Set pm25 to pm10*ratio in cases where pm10 exists but pm25 does not if ( industry_emission ( i , pm25_index ). eq . 0. and . industry_emission ( i , pm10_index ). gt . 0 ) then industry_emission ( i , pm25_index ) = industry_emission ( i , pm10_index ) * ratio_industry_pm25_to_pm10 endif enddo !Initialise the industry emission arrays proxy_emission_subgrid (:,:, source_index ,:) = 0. emission_properties_subgrid (:,:, emission_h_index , source_index ) = 0. !Count the number of industry emission grid placements count = 0 do industry_number = 1 , n_industries !Convert lat lon to utm coords if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , industry_lb_pos ( industry_number , 2 ), industry_lb_pos ( industry_number , 1 ), y_industry , x_industry ) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , industry_lb_pos ( industry_number , 2 ), industry_lb_pos ( industry_number , 1 ), y_industry , x_industry ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_industry , y_industry , industry_lb_pos ( industry_number , 1 ), industry_lb_pos ( industry_number , 2 ), projection_attributes ) endif !Special case when saving emissions, convert to either latlon or lambert if ( save_emissions_for_EMEP ( industry_index )) then if ( EMEP_projection_type . eq . LL_projection_index ) then x_industry = industry_lb_pos ( industry_number , 1 ) y_industry = industry_lb_pos ( industry_number , 2 ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_industry , y_industry , industry_lb_pos ( industry_number , 1 ), industry_lb_pos ( industry_number , 2 ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_industry , y_industry , industry_lb_pos ( industry_number , 1 ), industry_lb_pos ( industry_number , 2 ), EMEP_projection_attributes ) endif endif !Find the grid index it belongs to i_industry_index = 1 + floor (( x_industry - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_industry_index = 1 + floor (( y_industry - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if it is within the subgrid range if ( i_industry_index . ge . 1. and . i_industry_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_industry_index . ge . 1. and . j_industry_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index . and . industry_emission ( industry_number , nox_index ). gt . 0 ) then proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) & + industry_emission ( industry_number , nox_index ) emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + industry_height ( industry_number ) * industry_emission ( industry_number , nox_index ) count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + 1 count = count + 1 !write(*,'(a,3i,f12.2)') 'Industry height nox: ',industry_number,i_industry_index,j_industry_index,industry_height(industry_number) endif if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index . and . industry_emission ( industry_number , pm10_index ). gt . 0 ) then proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) & + industry_emission ( industry_number , pm10_index ) emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + industry_height ( industry_number ) * industry_emission ( industry_number , pm10_index ) count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + 1 count = count + 1 !write(*,'(a,3i,f12.2)') 'Industry height pm10: ',industry_number,i_industry_index,j_industry_index,industry_height(industry_number) endif if ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . and . industry_emission ( industry_number , pm25_index ). gt . 0 ) then proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) & + industry_emission ( industry_number , pm25_index ) emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + industry_height ( industry_number ) * industry_emission ( industry_number , pm25_index ) count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + 1 count = count + 1 !write(*,'(a,3i,f12.2)') 'Industry height pm25: ',industry_number,i_industry_index,j_industry_index,industry_height(industry_number) endif enddo endif enddo !Loop through the emission subgrid and take the average emission height !This is not weighted as it is averaged over all pollutants as well. Could do this but will not. !Probably need a pollutant dependent emission property do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) pollutant_count = 0 do i_pollutant = 1 , n_pollutant_loop if ( proxy_emission_subgrid ( i , j , source_index , i_pollutant ). gt . 0 ) then emission_height_subgrid ( i , j , i_pollutant ) = emission_height_subgrid ( i , j , i_pollutant ) / proxy_emission_subgrid ( i , j , source_index , i_pollutant ) !write(unit_logfile,'(2a,2i6,f12.2)') 'Emission height: ',trim(pollutant_file_str(pollutant_loop_index(i_pollutant))),i,j,emission_height_subgrid(i,j,i_pollutant) !Take the average of the pollutants emission_properties_subgrid ( i , j , emission_h_index , source_index ) = emission_properties_subgrid ( i , j , emission_h_index , source_index ) + emission_height_subgrid ( i , j , i_pollutant ) pollutant_count = pollutant_count + 1 endif enddo if ( pollutant_count . gt . 0 ) then emission_properties_subgrid ( i , j , emission_h_index , source_index ) = emission_properties_subgrid ( i , j , emission_h_index , source_index ) / pollutant_count !write(unit_logfile,'(2a,2i6,f12.2)') 'Final emission height: ',trim('mean'),i,j,emission_properties_subgrid(i,j,emission_h_index,source_index) endif !Set the industry emission heights to that given in the config file if it is > 0 if ( h_emis ( industry_index , 1 ). ge . 0 ) then emission_properties_subgrid ( i , j , emission_h_index , source_index ) = h_emis ( industry_index , 1 ) endif enddo enddo write ( unit_logfile , '(A,I)' ) 'Industry counts = ' , count do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo write ( unit_logfile , '(A,f12.2)' ) 'Average industry emission height for all industries = ' , sum ( industry_height ( 1 : n_industries )) / n_industries close ( unit_in ) deallocate ( industry_ref ) deallocate ( industry_num ) deallocate ( industry_lb_pos ) deallocate ( industry_xy_pos ) deallocate ( industry_height ) deallocate ( industry_code ) deallocate ( count_subgrid ) deallocate ( industry_emission ) end subroutine uEMEP_read_industry_data","tags":"","loc":"proc/uemep_read_industry_data.html"},{"title":"uEMEP_read_meteo_nc – uEMEP","text":"public  subroutine uEMEP_read_meteo_nc() Arguments None Source Code subroutine uEMEP_read_meteo_nc implicit none integer i , j , t integer ii , jj logical exists integer status_nc !Error message integer id_nc integer dim_id_nc ( num_dims_meteo_nc ) character ( 256 ) dimname_temp , var_name_nc_temp , unit_name_nc_temp integer var_id_nc integer i_file , i_dim integer temp_num_dims integer temp_start_time_meteo_nc_index , temp_end_time_meteo_nc_index integer valid_dim_length_meteo_nc ( num_dims_meteo_nc ) !dimensions of file 3 real temp_lat ( 4 ), temp_lon ( 4 ) real temp_y ( 4 ), temp_x ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max double precision temp_var1d_nc_dp ( 2 , 2 ) real temp_delta ( 2 ) real scale_grid_interpolation_size ( 2 ) real EMEP_temp_delta ( 2 ) real temp_lat_mean integer n_file , n_file_start double precision date_num_temp integer date_array ( 6 ) double precision scale_factor_nc logical found_file integer :: search_hour_step = 6 integer new_start_date_input ( 6 ) character ( 256 ) format_temp real EMEP_grid_interpolation_size_temp !Temporary reading rvariables double precision , allocatable :: var1d_nc_dp (:) double precision , allocatable :: var2d_nc_dp (:,:) !Temporary files for roatating wind field real , allocatable :: temp_meteo_var3d_nc (:,:,:,:) !Daily mean temperature variables integer DMT_start_time_nc_index , DMT_end_time_nc_index , DMT_dim_length_nc write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading additional meteo data (uEMEP_read_meteo_nc)' write ( unit_logfile , '(A)' ) '================================================================' !This if statement is already specified in uEMEP_define_subgrid and is not necessary here if ( hourly_calculations ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index temp_end_time_meteo_nc_index = end_time_meteo_nc_index else temp_start_time_meteo_nc_index = 1 temp_end_time_meteo_nc_index = 1 endif if ( use_single_time_loop_flag ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index + t_loop - 1 temp_end_time_meteo_nc_index = temp_start_time_meteo_nc_index endif !Presettng the surface level to 1. Valid when there is no inverting of layers surface_level_nc = 1 write ( unit_logfile , '(A,I)' ) ' Surface level base set to: ' , surface_level_nc if ( allocated ( val_dim_meteo_nc )) deallocate ( val_dim_meteo_nc ) if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( meteo_var1d_nc )) deallocate ( meteo_var1d_nc ) if ( allocated ( meteo_var2d_nc )) deallocate ( meteo_var2d_nc ) if ( allocated ( meteo_var3d_nc )) deallocate ( meteo_var3d_nc ) if ( allocated ( meteo_var4d_nc )) deallocate ( meteo_var4d_nc ) !Loop through the meteorological files containing the data if ( use_alternative_meteorology_flag ) then n_file_start = 3 n_file = 3 endif if ( use_alternative_z0_flag ) then n_file_start = 4 n_file = 4 endif if ( use_alternative_meteorology_flag . and . use_alternative_z0_flag ) then n_file_start = 3 n_file = 4 endif do i_file = n_file_start , n_file !Set the filename pathfilename_EMEP ( i_file ) = trim ( pathname_EMEP ( i_file )) // trim ( filename_EMEP ( i_file )) !Test existence of the filename 4. If does not exist then stop if ( i_file . eq . 4 ) then inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif endif !Test existence of the filename. If does not exist then try 6 hours before if ( i_file . eq . 3 ) then inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' WARNING: Meteo netcdf file does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) ' Will try 6 hours before 4 times' !Start search back 6 hours found_file = . false . do i = 1 , 4 if ( hourly_calculations ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index + search_hour_step * ( i ) temp_end_time_meteo_nc_index = end_time_meteo_nc_index + search_hour_step * ( i ) endif if ( use_single_time_loop_flag ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index + t_loop - 1 + search_hour_step * ( i ) temp_end_time_meteo_nc_index = temp_start_time_meteo_nc_index + search_hour_step * ( i ) endif !Create new date_str format_temp = 'yyyymmddHH' call datestr_to_date ( config_date_str , format_temp , new_start_date_input ) date_num_temp = date_to_number ( new_start_date_input , ref_year_meteo ) call number_to_date ( date_num_temp - dble ( search_hour_step * i + 0.5 ) / dble ( 2 4. ), new_start_date_input , ref_year_meteo ) !Replace replacement_date_str with <yyyyhhmm> so the new_start_date_input can be inserted format_temp = '<yyyymmdd>' filename_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_date_str , original_filename_EMEP ( i_file )) pathname_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_date_str , original_pathname_EMEP ( i_file )) !write(*,*) trim(filename_EMEP(i_file)),'  ',trim(replacement_date_str) !Replace replacement_hour_str with <HH> so the forecast hour can be inserted format_temp = '<HH>' filename_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_hour_str , filename_EMEP ( i_file )) pathname_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_hour_str , pathname_EMEP ( i_file )) !write(*,*) trim(filename_EMEP(i_file)),'  ',trim(forecast_hour_str) !Replace datestr twice for both forecast_hour and config_date call date_to_datestr_bracket ( new_start_date_input , filename_EMEP ( i_file ), filename_EMEP ( i_file )) call date_to_datestr_bracket ( new_start_date_input , pathname_EMEP ( i_file ), pathname_EMEP ( i_file )) call date_to_datestr_bracket ( new_start_date_input , filename_EMEP ( i_file ), filename_EMEP ( i_file )) call date_to_datestr_bracket ( new_start_date_input , pathname_EMEP ( i_file ), pathname_EMEP ( i_file )) pathfilename_EMEP ( i_file ) = trim ( pathname_EMEP ( i_file )) // trim ( filename_EMEP ( i_file )) write ( unit_logfile , '(A,A)' ) ' Trying: ' , trim ( pathfilename_EMEP ( i_file )) inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if ( exists ) then found_file = . true . exit else found_file = . false . endif enddo if (. not . found_file ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Meteo netcdf file still does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) ' STOPPING' stop else write ( unit_logfile , '(A,A)' ) ' Found earlier meteo netcdf file: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A,2i6)' ) ' New start and end index: ' , temp_start_time_meteo_nc_index , temp_end_time_meteo_nc_index endif endif endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_EMEP ( i_file )) status_nc = NF90_OPEN ( pathfilename_EMEP ( i_file ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif meteo_nc_projection_type = LL_projection_index !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'projection_lambert' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) status_nc = nf90_get_att ( id_nc , var_id_nc , 'standard_parallel' , meteo_nc_projection_attributes ( 1 : 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_central_meridian' , meteo_nc_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , meteo_nc_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , meteo_nc_projection_attributes ( 5 )) meteo_nc_projection_type = LCC_projection_index write ( unit_logfile , '(A,5f12.2)' ) 'Reading lambert_conformal_conic projection. ' , meteo_nc_projection_attributes ( 1 : 5 ) if ( meteo_nc_projection_attributes ( 1 ). ne . meteo_nc_projection_attributes ( 4 ). or . meteo_nc_projection_attributes ( 2 ). ne . meteo_nc_projection_attributes ( 4 )) then use_alternative_LCC_projection_flag = . true . write ( unit_logfile , '(A,l)' ) 'Using alternative lambert_conformal_conic projection: ' , use_alternative_LCC_projection_flag else use_alternative_LCC_projection_flag = . false . endif !Always set to true. i.e. not use anymore use_alternative_LCC_projection_flag = . true . endif !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'Polar_Stereographic' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then EMEP_projection_attributes = 0. EMEP_projection_attributes ( 5 ) = 6.370e6 status_nc = nf90_get_att ( id_nc , var_id_nc , 'straight_vertical_longitude_from_pole' , meteo_nc_projection_attributes ( 1 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , meteo_nc_projection_attributes ( 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_easting' , meteo_nc_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_northing' , meteo_nc_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , meteo_nc_projection_attributes ( 5 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'scale_factor_at_projection_origin' , meteo_nc_projection_attributes ( 6 )) meteo_nc_projection_type = PS_projection_index write ( unit_logfile , '(A,5f12.2)' ) 'Reading Polar_Stereographic projection. ' , meteo_nc_projection_attributes ( 1 : 5 ) endif !Find the (x,y,z,time) dimensions of the file do i_dim = 1 , num_dims_meteo_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_meteo_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_meteo_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_meteo_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_meteo_nc ( i_dim ) = 1 endif enddo if ( i_file . eq . 3 ) then valid_dim_length_meteo_nc = dim_length_meteo_nc endif if ( i_file . eq . 3 ) then if ( subgrid_dim ( t_dim_index ). gt . dim_length_meteo_nc ( time_dim_nc_index )) then write ( unit_logfile , '(A,2I)' ) 'ERROR: Specified time dimensions are greater than meteo netcdf dimensions. Stopping ' , subgrid_dim ( t_dim_index ), dim_length_meteo_nc ( time_dim_nc_index ) stop endif if ( temp_end_time_meteo_nc_index . gt . dim_length_meteo_nc ( time_dim_nc_index )) then write ( unit_logfile , '(A,2I)' ) 'ERROR: Required meteo time dimension larger than available meteo time dimension. Stopping ' , temp_end_time_meteo_nc_index , dim_length_meteo_nc ( time_dim_nc_index ) stop endif endif write ( unit_logfile , '(A,6I)' ) ' Size of meteo dimensions (x,y,z,t): ' , dim_length_meteo_nc if ( i_file . eq . 3 ) then dim_start_meteo_nc ( time_dim_nc_index ) = temp_start_time_meteo_nc_index dim_length_meteo_nc ( time_dim_nc_index ) = min ( dim_length_meteo_nc ( time_dim_nc_index ), subgrid_dim ( t_dim_index )) elseif ( i_file . eq . 4 ) then dim_start_meteo_nc ( time_dim_nc_index ) = 1 dim_length_meteo_nc ( time_dim_nc_index ) = 1 endif write ( unit_logfile , '(A,6I)' ) ' New size of meteo dimensions (x,y,z,t): ' , dim_length_meteo_nc !Calculate the necessary extent of the meteo_nc grid region and only read these grids if ( reduce_EMEP_region_flag ) then !Determine the LL cordinates of the target grid !EMEP_grid_interpolation_size_temp=max(EMEP_grid_interpolation_size*local_fraction_grid_size_scaling,EMEP_additional_grid_interpolation_size_original*local_fraction_grid_size_scaling) EMEP_grid_interpolation_size_temp = EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Retrieve the four corners of the target grid in lat and lon call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(1),temp_lon(1)) !call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(2),temp_lon(2)) !call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(3),temp_lon(3)) !call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(4),temp_lon(4)) !Find the average for use later temp_lat_mean = sum ( temp_lat ) / 4. temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 if ( meteo_nc_projection_type . eq . LCC_projection_index ) then !Convert lat lon corners to lambert do i = 1 , 4 call lb2lambert2_uEMEP ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), meteo_nc_projection_attributes ) enddo elseif ( meteo_nc_projection_type . eq . PS_projection_index ) then !Convert lat lon corners to lambert do i = 1 , 4 call LL2PS_spherical ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), meteo_nc_projection_attributes ) enddo elseif ( meteo_nc_projection_type . eq . LL_projection_index ) then !Set lat lon corners if EMEP is in lat lon temp_x = temp_lon ; temp_y = temp_lat else !Otherwise assume the same coordinate system temp_x ( 1 ) = init_subgrid_min ( x_dim_index ); temp_y ( 1 ) = init_subgrid_min ( y_dim_index ) temp_x ( 2 ) = init_subgrid_max ( x_dim_index ); temp_y ( 2 ) = init_subgrid_min ( y_dim_index ) temp_x ( 3 ) = init_subgrid_min ( x_dim_index ); temp_y ( 3 ) = init_subgrid_max ( y_dim_index ) temp_x ( 4 ) = init_subgrid_max ( x_dim_index ); temp_y ( 4 ) = init_subgrid_max ( y_dim_index ) endif do i = 1 , 4 if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo !Read in the first 2 x and y position values from the nc file to get min values and delta values !write(*,*) temp_x_min,temp_x_max,temp_y_min,temp_y_max status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_meteo_nc ( x_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 1 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_meteo_nc ( y_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 2 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_name_nc_temp ) if ( trim ( unit_name_nc_temp ). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' temp_var1d_nc_dp = temp_var1d_nc_dp * 100 0. endif !HERE FIX. The EMEP_grid_interpolation_size is too small when using EMEP is a different grid to the meteo grid. Need to rescale this somehow !By using meteo_dgrid_nc(lon_nc_index), not defined yet, and dgrid_nc(lon_nc_index) !For example  dx_temp=111000.*dgrid_nc(lon_nc_index)*cos(lat_temp*pi/180.) and dy_temp=111000.*dgrid_nc(lat_nc_index) !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = temp_var1d_nc_dp ( 1 , 2 ) - temp_var1d_nc_dp ( 1 , 1 ) temp_delta ( 2 ) = temp_var1d_nc_dp ( 2 , 2 ) - temp_var1d_nc_dp ( 2 , 1 ) !write(*,*) temp_delta if (( meteo_nc_projection_type . eq . LCC_projection_index . and . EMEP_projection_type . eq . LCC_projection_index ) & . or .( meteo_nc_projection_type . eq . LL_projection_index . and . EMEP_projection_type . eq . LL_projection_index ) & . or .( meteo_nc_projection_type . eq . PS_projection_index . and . EMEP_projection_type . eq . PS_projection_index )) then !If both EMEP and meteo are in the same coordinates then set the EMEP size to be the same as the meteo siz EMEP_temp_delta ( 1 ) = dgrid_nc ( lon_nc_index ) EMEP_temp_delta ( 2 ) = dgrid_nc ( lat_nc_index ) elseif (( meteo_nc_projection_type . eq . LCC_projection_index . and . EMEP_projection_type . eq . LL_projection_index ) & . or .( meteo_nc_projection_type . eq . PS_projection_index . and . EMEP_projection_type . eq . LL_projection_index )) then !EMEP is in latlon, convert to local coordinates EMEP_temp_delta ( 1 ) = dgrid_nc ( lon_nc_index ) * 11100 0. * cos ( temp_lat_mean * 3.14159 / 18 0. ) EMEP_temp_delta ( 2 ) = dgrid_nc ( lat_nc_index ) * 11100 0. elseif (( meteo_nc_projection_type . eq . LL_projection_index . and . EMEP_projection_type . eq . LCC_projection_index )& . or .( meteo_nc_projection_type . eq . LL_projection_index . and . EMEP_projection_type . eq . PS_projection_index )) then !This conversion not available write ( unit_logfile , '(A,3I)' ) 'Use of lat lon projection in meteo data, together with Lambert or PS in EMEP not available. Stopping' stop else write ( unit_logfile , '(A,3I)' ) 'Use of current projections in meteo and EMEP data not available. Stopping' stop endif scale_grid_interpolation_size = EMEP_temp_delta / temp_delta !write(*,*) dgrid_nc(lon_nc_index),dgrid_nc(lat_nc_index) !write(*,*) EMEP_temp_delta !write(*,*) scale_grid_interpolation_size !stop !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max i_temp_min = max ( 1 , i_temp_min - 1 - ceiling ( scale_grid_interpolation_size ( 1 ) * EMEP_grid_interpolation_size_temp )) i_temp_max = min ( dim_length_meteo_nc ( x_dim_nc_index ), i_temp_max + 1 + ceiling ( scale_grid_interpolation_size ( 1 ) * EMEP_grid_interpolation_size_temp )) j_temp_min = max ( 1 , j_temp_min - 1 - ceiling ( scale_grid_interpolation_size ( 2 ) * EMEP_grid_interpolation_size_temp )) j_temp_max = min ( dim_length_meteo_nc ( y_dim_nc_index ), j_temp_max + 1 + ceiling ( scale_grid_interpolation_size ( 2 ) * EMEP_grid_interpolation_size_temp )) dim_length_meteo_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_meteo_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_meteo_nc ( x_dim_nc_index ) = i_temp_min dim_start_meteo_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading meteo x grids: ' , i_temp_min , i_temp_max , dim_length_meteo_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading meteo y grids: ' , j_temp_min , j_temp_max , dim_length_meteo_nc ( y_dim_nc_index ) !Set the new valid meteo dimensions if ( i_file . ge . 3 ) then valid_dim_length_meteo_nc ( x_dim_nc_index ) = dim_length_meteo_nc ( x_dim_nc_index ) valid_dim_length_meteo_nc ( y_dim_nc_index ) = dim_length_meteo_nc ( y_dim_nc_index ) endif endif !Allocate the nc arrays for reading if (. not . allocated ( val_dim_meteo_nc )) allocate ( val_dim_meteo_nc ( maxval ( dim_length_meteo_nc ), num_dims_meteo_nc )) !x, y, z and time dimension values if (. not . allocated ( unit_dim_meteo_nc )) allocate ( unit_dim_meteo_nc ( num_dims_meteo_nc )) !x, y, z and time dimension values if (. not . allocated ( var1d_nc_dp )) allocate ( var1d_nc_dp ( maxval ( dim_length_meteo_nc ))) if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ))) !Lat and lon !Allocate array for the alternative meteo files if ( i_file . ge . 3 ) then if (. not . allocated ( meteo_var1d_nc )) allocate ( meteo_var1d_nc ( maxval ( dim_length_meteo_nc ), num_dims_meteo_nc )) !x, y, z and time maximum dimensions if (. not . allocated ( meteo_var2d_nc )) allocate ( meteo_var2d_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 2 )) !Lat and lon if (. not . allocated ( meteo_var3d_nc )) allocate ( meteo_var3d_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 0 : dim_length_meteo_nc ( time_dim_nc_index ), num_var_meteo_nc )) if (. not . allocated ( meteo_var4d_nc )) allocate ( meteo_var4d_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( z_dim_nc_index ), 0 : dim_length_meteo_nc ( time_dim_nc_index ), num_var_meteo_nc )) endif !Read in the dimensions and check values of the dimensions. do i = 1 , num_dims_meteo_nc status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_meteo_nc ( i )), var_id_nc ) !write(*,*) id_nc, trim(dim_name_nc(i)), var_id_nc(i),dim_length_nc(i) var1d_nc_dp = 0. !write(*,*) 'HERE',i,dim_start_nc(i),dim_length_nc(i) unit_dim_meteo_nc ( i ) = '' if ( status_nc . EQ . NF90_NOERR ) then status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_dim_meteo_nc ( i )) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var1d_nc_dp ( 1 : dim_length_meteo_nc ( i )), start = ( / dim_start_meteo_nc ( i ) / ), count = ( / dim_length_meteo_nc ( i ) / )); meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_meteo_nc ( i ))) !Use the first file to give valid time stamps if ( i_file . eq . 3. and . i . eq . time_dim_nc_index ) then val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_meteo_nc ( i ))) valid_dim_length_meteo_nc ( i ) = dim_length_meteo_nc ( i ) endif !Use first file to get the valid height of the wind measurements (height3) if ( i_file . eq . 3. and . i . eq . z_dim_nc_index ) then val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_meteo_nc ( i ))) valid_dim_length_meteo_nc ( i ) = dim_length_meteo_nc ( i ) endif !Convert from meters to km for AROME data if necessary if (( i . eq . x_dim_nc_index . or . i . eq . y_dim_nc_index ). and . trim ( unit_dim_meteo_nc ( i )). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) = val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) * 100 0. meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i ) = meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i ) * 100 0. endif write ( unit_logfile , '(3A,2es12.4)' ) ' ' , trim ( dim_name_meteo_nc ( i )), ' (min, max): ' & , minval ( meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i )), maxval ( meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i )) else !meteo_var1d_nc(1:dim_length_meteo_nc(i),i)=0. !val_dim_meteo_nc(1:dim_length_meteo_nc(i),i)=0. endif enddo !i_conc=compound_index !Loop through the meteo_variables do i = 1 , num_var_meteo_nc !Identify the variable name and ID in the nc file var_name_nc_temp = var_name_meteo_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) !write(*,*) 'Status1: ',status_nc,var_id_nc,trim(var_name_nc_temp),i_source !If a variable name is found in the file then go further if ( status_nc . eq . NF90_NOERR ) then scale_factor_nc = 1. !Find the dimensions of the variable (temp_num_dims) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) !write(*,*) temp_num_dims,status_nc if ( temp_num_dims . eq . 2. and . i_file . eq . 3 ) then !Read latitude and longitude data into a 2d grid if available. Only lat lon is 2d? if ( i . eq . lat_nc_index . or . i . eq . lon_nc_index ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ); meteo_var2d_nc (:,:, i ) = real ( var2d_nc_dp ) write ( unit_logfile , '(A,i3,A,2A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var2d_nc (:,:, i )), maxval ( meteo_var2d_nc (:,:, i )) endif elseif ( temp_num_dims . eq . 3. and . i_file . eq . 4 ) then !Special case for z0 file as they are scaled integers and a single time file !write(*,'(6i)') dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(time_dim_nc_index),dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = nf90_get_att ( id_nc , var_id_nc , \"scale_factor\" , scale_factor_nc ) if ( status_nc . ne . NF90_NOERR ) scale_factor_nc = 1. !write(*,*) 'scale_factor=',scale_factor_nc status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var3d_nc (:,:, 1 , i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) / )) meteo_var3d_nc (:,:,:, i ) = real ( meteo_var3d_nc (:,:,:, i ) * scale_factor_nc ) !write(*,*) status_nc write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) elseif ( temp_num_dims . eq . 4. and . i_file . eq . 3 ) then !write(*,*) dim_start_nc(z_dim_nc_index),dim_start_nc(z_dim_nc_index)+dim_length_nc(z_dim_nc_index)-1 !write(*,*) dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),dim_start_nc(time_dim_nc_index) !write(*,*) dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 ,:, i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( z_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) - 1 / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( z_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) + 1 / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, meteo_var4d_nc(:,:,dim_start_meteo_nc(z_dim_nc_index):dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1,dim_start_meteo_nc(time_dim_nc_index)-1:dim_start_meteo_nc(time_dim_nc_index)+dim_length_meteo_nc(time_dim_nc_index)-1,i),start=(/dim_start_meteo_nc(x_dim_nc_index),dim_start_meteo_nc(y_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(time_dim_nc_index)-1/),count=(/dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index),dim_length_meteo_nc(z_dim_nc_index),dim_length_meteo_nc(time_dim_nc_index)+1/)) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, meteo_var4d_nc(:,:,1,dim_start_meteo_nc(time_dim_nc_index):dim_length_meteo_nc(time_dim_nc_index),i),start=(/dim_start_meteo_nc(x_dim_nc_index),dim_start_meteo_nc(y_dim_nc_index),1,dim_start_meteo_nc(time_dim_nc_index)/),count=(/dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index),1,dim_length_meteo_nc(time_dim_nc_index)/)) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) !var4d_nc(:,val_dim_nc:,:,:,i,i_source)=real(temp_var4d_nc(:,:,:,:)) write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var4d_nc ( 1 : dim_length_meteo_nc ( x_dim_nc_index ), 1 : dim_length_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) !write(*,*) dim_start_meteo_nc(time_dim_nc_index)-1,dim_length_meteo_nc(time_dim_nc_index)+1,dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1 elseif ( temp_num_dims . eq . 3. and . i_file . eq . 3 ) then !NBV meteo data status_nc = nf90_get_att ( id_nc , var_id_nc , \"scale_factor\" , scale_factor_nc ) if ( status_nc . ne . NF90_NOERR ) scale_factor_nc = 1. !write(*,*) dim_start_nc(z_dim_nc_index),dim_start_nc(z_dim_nc_index)+dim_length_nc(z_dim_nc_index)-1 !write(*,*) dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),dim_start_nc(time_dim_nc_index) !write(*,*) dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, meteo_var4d_nc(:,:,1,:,i),start=(/dim_start_meteo_nc(x_dim_nc_index),dim_start_meteo_nc(y_dim_nc_index),dim_start_meteo_nc(time_dim_nc_index)-1/),count=(/dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index),dim_length_meteo_nc(time_dim_nc_index)+1/)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var4d_nc (:,:, 1 , dim_start_meteo_nc ( time_dim_nc_index ): dim_length_meteo_nc ( time_dim_nc_index ), i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) meteo_var4d_nc (:,:,:,:, i ) = real ( meteo_var4d_nc (:,:,:,:, i ) * scale_factor_nc ) write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var4d_nc (:,:, 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var4d_nc ( 1 : dim_length_meteo_nc ( x_dim_nc_index ), 1 : dim_length_meteo_nc ( y_dim_nc_index ), 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) !write(*,*) dim_start_meteo_nc(time_dim_nc_index)-1,dim_length_meteo_nc(time_dim_nc_index)+1,dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1 elseif ( temp_num_dims . eq . 5. and . i_file . eq . 3 ) then !This is the case when there is an ensemble member in the format !write(*,*) dim_start_nc(z_dim_nc_index),dim_start_nc(z_dim_nc_index)+dim_length_nc(z_dim_nc_index)-1 !write(*,*) dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),dim_start_nc(time_dim_nc_index) !write(*,*) dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 ,:, i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), 1 , dim_start_meteo_nc ( z_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) - 1 / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 1 , dim_length_meteo_nc ( z_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) + 1 / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) !var4d_nc(:,val_dim_nc:,:,:,i,i_source)=real(temp_var4d_nc(:,:,:,:)) write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var4d_nc ( 1 : dim_length_meteo_nc ( x_dim_nc_index ), 1 : dim_length_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) !write(*,*) dim_start_meteo_nc(time_dim_nc_index)-1,dim_length_meteo_nc(time_dim_nc_index)+1,dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1 else write ( unit_logfile , '(8A,8A)' ) ' Cannot find a correct dimension for: ' , trim ( var_name_nc_temp ) endif else !write(unit_logfile,'(8A,8A)') ' Cannot read: ',trim(var_name_nc_temp) endif enddo !Read in 2m temperature completely to get the daily average for home heating !if (use_RWC_emission_data.and.save_emissions_for_EMEP(heating_index).and.i_file.eq.3) then if ( use_RWC_emission_data . and . i_file . eq . 3 ) then DMT_start_time_nc_index = start_time_meteo_nc_index DMT_end_time_nc_index = end_time_meteo_nc_index !DMT_start_time_nc_index=save_emissions_start_index !DMT_end_time_nc_index=save_emissions_end_index DMT_dim_length_nc = DMT_end_time_nc_index - DMT_start_time_nc_index + 1 if ( allocated ( DMT_EMEP_grid_nc )) deallocate ( DMT_EMEP_grid_nc ) if (. not . allocated ( DMT_EMEP_grid_nc )) allocate ( DMT_EMEP_grid_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), DMT_dim_length_nc )) !write(*,*) DMT_start_time_nc_index,DMT_end_time_nc_index,DMT_dim_length_nc if ( calculate_source ( heating_index ). and . i_file . eq . 3 ) then var_name_nc_temp = var_name_meteo_nc ( t2m_nc_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) if ( temp_num_dims . eq . 4 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc (:,:,:), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), 1 , DMT_start_time_nc_index / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 1 , DMT_dim_length_nc / )) elseif ( temp_num_dims . eq . 3 ) then !NBV meteo data status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc (:,:,:), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), DMT_start_time_nc_index / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), DMT_dim_length_nc / )) elseif ( temp_num_dims . eq . 5 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc (:,:,:), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), 1 , 1 , DMT_start_time_nc_index / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 1 , 1 , DMT_dim_length_nc / )) else write ( unit_logfile , '(8A,8A)' ) ' Cannot find a correct dimension for: ' , trim ( var_name_nc_temp ) endif write ( unit_logfile , '(A,i,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc ), maxval ( DMT_EMEP_grid_nc ) DMT_EMEP_grid_nc (:,:, 1 ) = sum ( DMT_EMEP_grid_nc , 3 ) / DMT_dim_length_nc - 27 3.13 write ( unit_logfile , '(3A,2f16.4)' ) ' Calculating mean: ' , trim ( 'Daily mean temperature' ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc (:,:, 1 )), maxval ( DMT_EMEP_grid_nc (:,:, 1 )) endif endif status_nc = NF90_CLOSE ( id_nc ) enddo !End file loop !Set the correct time dimensions to the first file value dim_length_meteo_nc = valid_dim_length_meteo_nc !Set the grid spacing if ( meteo_nc_projection_type . eq . LL_projection_index ) then meteo_dgrid_nc ( lon_nc_index ) = meteo_var1d_nc ( 2 , x_dim_nc_index ) - meteo_var1d_nc ( 1 , x_dim_nc_index ) meteo_dgrid_nc ( lat_nc_index ) = meteo_var1d_nc ( 2 , y_dim_nc_index ) - meteo_var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing meteo (lon,lat): ' , meteo_dgrid_nc ( lon_nc_index ), meteo_dgrid_nc ( lat_nc_index ) else meteo_dgrid_nc ( lon_nc_index ) = meteo_var1d_nc ( 2 , x_dim_nc_index ) - meteo_var1d_nc ( 1 , x_dim_nc_index ) meteo_dgrid_nc ( lat_nc_index ) = meteo_var1d_nc ( 2 , y_dim_nc_index ) - meteo_var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing meteo (x,y) in meters: ' , meteo_dgrid_nc ( lon_nc_index ), meteo_dgrid_nc ( lat_nc_index ) endif !Do manipulations when the additional meteorology is read in !Put everything in 3d data since it is all surface values write ( unit_logfile , '(A)' ) ' Calculating alternative meteorological data' write ( unit_logfile , '(A,4i)' ) ' Dimensions: ' , dim_length_meteo_nc !logz0 is read in as z0 and must be converted to logz0 do t = 1 , dim_length_meteo_nc ( time_dim_nc_index ) meteo_var3d_nc (:,:, t , logz0_nc_index ) = meteo_var3d_nc (:,:, 1 , logz0_nc_index ) !write(*,*) t,sum(meteo_var3d_nc(:,:,t,logz0_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) enddo where ( meteo_var3d_nc (:,:,:, logz0_nc_index ). lt . 0.001 ) meteo_var3d_nc (:,:,:, logz0_nc_index ) = 0.001 meteo_var3d_nc (:,:,:, logz0_nc_index ) = log ( meteo_var3d_nc (:,:,:, logz0_nc_index )) meteo_var3d_nc (:,:,:, t2m_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, t2m_nc_index ) !Assumes that the first step is 0 and data is hourly. So that the start time step for meteo must correspond to the second hour of any calculation !t=1 !meteo_var3d_nc(:,:,t,Hflux_nc_index)=meteo_var4d_nc(:,:,surface_level_nc,t,Hflux_nc_index)/3600. !meteo_var3d_nc(:,:,t,uw_nc_index)=meteo_var4d_nc(:,:,surface_level_nc,t,uw_nc_index)/3600. !meteo_var3d_nc(:,:,t,vw_nc_index)=meteo_var4d_nc(:,:,surface_level_nc,t,vw_nc_index)/3600. if ( index ( alternative_meteorology_type , 'nbv' ). gt . 0 ) then !Flux is upward and not integrated. Stress is not integrated meteo_var3d_nc (:,:,:, Hflux_nc_index ) =- meteo_var4d_nc (:,:, surface_level_nc ,:, Hflux_nc_index ) meteo_var3d_nc (:,:,:, uw_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, uw_nc_index ) meteo_var3d_nc (:,:,:, vw_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, vw_nc_index ) meteo_var3d_nc (:,:,:, precip_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, precip_nc_index ) else do t = dim_length_meteo_nc ( time_dim_nc_index ), 1 , - 1 meteo_var3d_nc (:,:, t , Hflux_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , Hflux_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , Hflux_nc_index )) / 360 0. meteo_var3d_nc (:,:, t , uw_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , uw_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , uw_nc_index )) / 360 0. meteo_var3d_nc (:,:, t , vw_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , vw_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , vw_nc_index )) / 360 0. meteo_var3d_nc (:,:, t , precip_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , precip_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , precip_nc_index )) !write(*,*) t,sum(meteo_var3d_nc(:,:,t,Hflux_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) & !    ,sum(meteo_var4d_nc(:,:,surface_level_nc,t,hmix_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) enddo endif !Approximate density of air used (1.2 kg/m&#94;3 +/- 10%) meteo_var3d_nc (:,:,:, ustar_nc_index ) = sqrt ( sqrt ( meteo_var3d_nc (:,:,:, uw_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, vw_nc_index ) ** 2 ) / 1.2 ) where ( meteo_var3d_nc (:,:,:, ustar_nc_index ). lt . ustar_min ) meteo_var3d_nc (:,:,:, ustar_nc_index ) = ustar_min !do t=dim_length_meteo_nc(time_dim_nc_index),0,-1 !     write(*,*) t,sum(meteo_var3d_nc(:,:,t,ustar_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) & !        ,sum(meteo_var3d_nc(:,:,t,uw_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) & !        ,sum(meteo_var3d_nc(:,:,t,vw_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) !enddo !Approximate temperature (273 +/- 10%) !Have inserted the correct temperature now meteo_var3d_nc (:,:,:, invL_nc_index ) = meteo_var3d_nc (:,:,:, Hflux_nc_index ) * 0.4 * 9.8 / 1.2 / 100 4. / meteo_var3d_nc (:,:,:, t2m_nc_index ) / meteo_var3d_nc (:,:,:, ustar_nc_index ) ** 3 !Limit stable L to lowest_stable_L and to lowest_unstable_L (negative number) for unstable. where ( meteo_var3d_nc (:,:,:, invL_nc_index ). lt . 1.0 / lowest_unstable_L ) meteo_var3d_nc (:,:,:, invL_nc_index ) = 1.0 / lowest_unstable_L where ( meteo_var3d_nc (:,:,:, invL_nc_index ). gt . 1.0 / lowest_stable_L ) meteo_var3d_nc (:,:,:, invL_nc_index ) = 1.0 / lowest_stable_L !Put the 10 m wind vectors as the lowest grid level !H_meteo=val_dim_meteo_nc(surface_level_nc,z_dim_nc_index) H_meteo = 1 0. write ( unit_logfile , '(A,f8.2)' ) ' Alternative meteo: setting lowest meteo grid height = ' , H_meteo meteo_var3d_nc (:,:,:, ugrid_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, u10_nc_index ) meteo_var3d_nc (:,:,:, vgrid_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, v10_nc_index ) meteo_var3d_nc (:,:,:, FF10_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, FF10_nc_index ) if ( sum ( abs ( meteo_var3d_nc (:,:,:, FF10_nc_index ))). eq . 0 ) then !Calculate wind speed if it can't read it meteo_var3d_nc (:,:,:, FF10_nc_index ) = sqrt ( meteo_var3d_nc (:,:,:, ugrid_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, vgrid_nc_index ) ** 2 ) else meteo_var3d_nc (:,:,:, FF10_nc_index ) = sqrt ( meteo_var3d_nc (:,:,:, u10_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, v10_nc_index ) ** 2 ) endif !Smooth the boundary layer height (running mean) and set minimum meteo_var3d_nc (:,:,:, hmix_nc_index ) = 0. do j = 2 , dim_length_meteo_nc ( y_dim_nc_index ) - 1 do i = 2 , dim_length_meteo_nc ( x_dim_nc_index ) - 1 do jj =- 1 , 1 do ii =- 1 , 1 meteo_var3d_nc ( i , j ,:, hmix_nc_index ) = meteo_var3d_nc ( i , j ,:, hmix_nc_index ) + meteo_var4d_nc ( i + ii , j + jj , surface_level_nc ,:, hmix_nc_index ) / 9. !if (ii.ne.0.and.jj.ne.0) then !    var3d_nc(i,j,:,hmix_nc_index,allsource_index)=var3d_nc(i,j,:,hmix_nc_index,allsource_index)-var3d_nc(i+ii,j+jj,:,hmix_nc_index,traffic_index)/8. !endif enddo enddo enddo enddo where ( meteo_var3d_nc (:,:,:, hmix_nc_index ). lt . hmix_min ) meteo_var3d_nc (:,:,:, hmix_nc_index ) = hmix_min where ( meteo_var3d_nc (:,:,:, hmix_nc_index ). gt . hmix_max ) meteo_var3d_nc (:,:,:, hmix_nc_index ) = hmix_max where ( meteo_var3d_nc (:,:,:, ustar_nc_index ). lt . ustar_min ) meteo_var3d_nc (:,:,:, ustar_nc_index ) = ustar_min !do t=dim_length_nc(time_dim_nc_index),2,-1 !    write(*,*) t,sum(var3d_nc(:,:,t,hmix_nc_index,allsource_nc_index))/dim_length_nc(x_dim_nc_index)/dim_length_nc(y_dim_nc_index) !enddo write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( logz0_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), logz0_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), logz0_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( ustar_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ustar_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ustar_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( Hflux_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), Hflux_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), Hflux_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( invL_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), invL_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), invL_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( ugrid_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ugrid_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ugrid_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( vgrid_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), vgrid_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), vgrid_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( FF10_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), FF10_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), FF10_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( hmix_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), hmix_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), hmix_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( t2m_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), t2m_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), t2m_nc_index )) !If no logz0 available. Set to log(0.1) !For urban areas a value of 0.3 is used !where (var3d_nc(:,:,:,logz0_nc_index,:).eq.0.0) var3d_nc(:,:,:,logz0_nc_index,:)=log(0.3) if ( replace_z0 . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing z0 everywhere with: ' , replace_z0 meteo_var3d_nc (:,:,:, logz0_nc_index ) = log ( replace_z0 ) endif if ( replace_invL . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing inverse L everywhere with: ' , replace_invL meteo_var3d_nc (:,:,:, invL_nc_index ) = replace_invL endif if ( replace_hmix . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing HMIX everywhere with: ' , replace_hmix meteo_var3d_nc (:,:,:, hmix_nc_index ) = replace_hmix endif if ( FF_scale . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rescaling wind fields everywhere with factor: ' , FF_scale meteo_var3d_nc (:,:,:, ustar_nc_index ) = meteo_var3d_nc (:,:,:, ustar_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, FF10_nc_index ) = meteo_var3d_nc (:,:,:, FF10_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, inv_FF10_nc_index ) = meteo_var3d_nc (:,:,:, inv_FF10_nc_index ) / FF_scale meteo_var3d_nc (:,:,:, ugrid_nc_index ) = meteo_var3d_nc (:,:,:, ugrid_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, vgrid_nc_index ) = meteo_var3d_nc (:,:,:, vgrid_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, inv_FFgrid_nc_index ) = meteo_var3d_nc (:,:,:, inv_FFgrid_nc_index ) / FF_scale meteo_var3d_nc (:,:,:, ugrid_nc_index ) = meteo_var3d_nc (:,:,:, ugrid_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, vgrid_nc_index ) = meteo_var3d_nc (:,:,:, vgrid_nc_index ) * FF_scale endif if ( FF10_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Offsetting 10 m wind fields everywhere with a value: ' , FF10_offset meteo_var3d_nc (:,:,:, FF10_nc_index ) = meteo_var3d_nc (:,:,:, FF10_nc_index ) + FF10_offset endif if ( DD_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rotating wind fields everywhere with a value: ' , DD_offset if (. not . allocated ( temp_meteo_var3d_nc )) allocate ( temp_meteo_var3d_nc ( valid_dim_length_meteo_nc ( x_dim_nc_index ), valid_dim_length_meteo_nc ( y_dim_nc_index ), valid_dim_length_meteo_nc ( time_dim_nc_index ), 2 )) temp_meteo_var3d_nc (:,:,:, 1 ) = meteo_var3d_nc (:,:,:, ugrid_nc_index ) * cos ( DD_offset / 18 0. * 3.14159 ) + meteo_var3d_nc (:,:,:, vgrid_nc_index ) * sin ( DD_offset / 18 0. * 3.14159 ) temp_meteo_var3d_nc (:,:,:, 2 ) =- meteo_var3d_nc (:,:,:, ugrid_nc_index ) * sin ( DD_offset / 18 0. * 3.14159 ) + meteo_var3d_nc (:,:,:, vgrid_nc_index ) * cos ( DD_offset / 18 0. * 3.14159 ) meteo_var3d_nc (:,:,:, ugrid_nc_index ) = temp_meteo_var3d_nc (:,:,:, 1 ) meteo_var3d_nc (:,:,:, vgrid_nc_index ) = temp_meteo_var3d_nc (:,:,:, 2 ) endif !Set the magnitude of the gridded wind fields. Should probably be done after subgridding? meteo_var3d_nc (:,:,:, FFgrid_nc_index ) = sqrt ( meteo_var3d_nc (:,:,:, ugrid_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, vgrid_nc_index ) ** 2 ) !Check meteo time which comes in seconds since 1970. Converts to days. if ( use_alternative_meteorology_flag ) then date_num_temp = val_dim_meteo_nc ( 1 , time_dim_nc_index ) / 360 0. / 2 4. + 3 0. / 2 4. / 360 0. call number_to_date ( date_num_temp , date_array , ref_year_meteo ) write ( unit_logfile , '(a,i6)' ) ' Time dimension meteo: ' , dim_length_meteo_nc ( time_dim_nc_index ) write ( unit_logfile , '(a,6i6)' ) ' Date start meteo = ' , date_array !date_num_temp=dble(ceiling(val_dim_meteo_nc(dim_length_meteo_nc(time_dim_nc_index),time_dim_nc_index)/3600.))/24. date_num_temp = val_dim_meteo_nc ( dim_length_meteo_nc ( time_dim_nc_index ), time_dim_nc_index ) / 360 0. / 2 4. + 3 0. / 2 4. / 360 0. call number_to_date ( date_num_temp , date_array , ref_year_meteo ) write ( unit_logfile , '(a,6i6)' ) ' Date end meteo =   ' , date_array !write(*,*) start_time_meteo_nc_index,valid_dim_length_meteo_nc(time_dim_nc_index) endif !do t=1,dim_length_meteo_nc(time_dim_nc_index) !    date_num_temp=val_dim_meteo_nc(t,time_dim_nc_index)/3600./24.+0.1/24. !    call number_to_date(date_num_temp,date_array,ref_year_meteo) !    write(unit_logfile,'(a,i4,6i6,f12.4)') ' Date end meteo =   ',t,date_array,date_num_temp !enddo !stop if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_meteo_var3d_nc )) deallocate ( temp_meteo_var3d_nc ) if ( allocated ( meteo_var4d_nc )) deallocate ( meteo_var4d_nc ) end subroutine uEMEP_read_meteo_nc","tags":"","loc":"proc/uemep_read_meteo_nc.html"},{"title":"uEMEP_subgrid_EMEP – uEMEP","text":"public  subroutine uEMEP_subgrid_EMEP() Arguments None Source Code subroutine uEMEP_subgrid_EMEP integer i , j integer ii , jj , tt , iii , jjj real , allocatable :: weighting_nc (:,:,:,:), weighting_subgrid (:,:,:,:,:) real , allocatable :: total_weighting_nc (:,:,:,:,:), proxy_weighting_nc (:,:,:,:,:) real , allocatable :: area_weighting_nc (:,:,:,:,:,:) integer i_nc_start , i_nc_end , j_nc_start , j_nc_end integer i_start , i_end , j_start , j_end , t_start , t_end real xpos_min , xpos_max , ypos_min , ypos_max real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_min2 , xpos_max2 , ypos_min2 , ypos_max2 real xpos_min3 , xpos_max3 , ypos_min3 , ypos_max3 real xpos_area_min2 , xpos_area_max2 , ypos_area_min2 , ypos_area_max2 integer i_nc , j_nc integer emep_subsource real , allocatable :: nonlocal_correction (:,:,:) real , allocatable :: nonlocal_correction_average (:,:) integer i_source integer ii_nc , jj_nc , ii_w , jj_w integer :: n_weight = 3 , ii_w0 = 2 , jj_w0 = 2 integer weighting_subgrid_dim ( 2 , n_source_index ) integer i_cross , j_cross integer , allocatable :: crossreference_weighting_to_emep_subgrid (:,:,:,:) integer i_w_c , j_w_c integer i_nc_c , j_nc_c integer count integer ii_start , ii_end , jj_start , jj_end integer iii_start , iii_end , jjj_start , jjj_end real xpos_limit , ypos_limit real xpos_limit2 , ypos_limit2 real xpos_subgrid , ypos_subgrid real xpos_emission_subgrid , ypos_emission_subgrid real xpos_integral_subgrid , ypos_integral_subgrid real EMEP_grid_interpolation_size_sqr integer :: tt_dim = 1 integer ii_nc_w0 , jj_nc_w0 , iii_nc_w , jjj_nc_w integer ii_nc_w , jj_nc_w real weighting_val , weighting_val3 integer i_pollutant , i_loop integer i_sp , ii_sp real , allocatable :: EMEP_local_contribution (:,:,:,:) real , allocatable :: EMEP_local_contribution_from_in_region (:,:,:,:) integer n_weight_nc_x , n_weight_nc_y real dgrid_lf_offset_x , dgrid_lf_offset_y real amod_temp real EMEP_grid_interpolation_size_saved real local_fraction_grid_size_scaling_temp real weight_check real xpos_lf_area_min , xpos_lf_area_max , ypos_lf_area_min , ypos_lf_area_max logical :: first_interpolate_lf = . false . logical :: set_lf_offset_to_0 = . true . integer lf_size_index real , allocatable :: temp_subgrid (:,:,:,:) real , allocatable :: temp_comp_EMEP_subgrid (:,:) real , allocatable :: temp_species_EMEP_subgrid (:,:,:) real , allocatable :: temp_EMEP (:,:,:,:,:,:) real , allocatable :: temp_EMEP_from_in_region (:,:,:,:,:,:) real , allocatable :: temp_species_EMEP (:,:,:,:,:) real , allocatable :: temp_comp_EMEP (:,:,:,:) real distance_grid_x , distance_grid_y integer temp_count character ( len = :), allocatable :: fmt write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Distributing EMEP concentrations to subgrids  (uEMEP_subgrid_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !Initialise subgrids to be written to subgrid (:,:,:, emep_subgrid_index ,:,:) = 0 subgrid (:,:,:, emep_frac_subgrid_index ,:,:) = 0 subgrid (:,:,:, emep_local_subgrid_index ,:,:) = 0 subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) = 0 comp_EMEP_subgrid (:,:,:,:) = 0 orig_EMEP_subgrid (:,:,:,:) = 0 if ( save_emep_species . or . save_seasalt ) species_EMEP_subgrid (:,:,:,:,:) = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source )) then write ( unit_logfile , '(2A)' ) 'Calculating for EMEP source: ' , trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) endif if ( save_EMEP_source ( i_source )) then write ( unit_logfile , '(2A)' ) 'Saving for EMEP source: ' , trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) endif enddo !Check if the additional EMEP calculation is to be carried out and set parameters EMEP_grid_interpolation_size_saved = EMEP_grid_interpolation_size lc_local_nc_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_grid_interpolation ) local_fraction_grid_size_scaling_temp = local_fraction_grid_size_scaling lf_size_index = 1 if ( calculate_EMEP_additional_grid_flag ) then EMEP_grid_interpolation_size = EMEP_additional_grid_interpolation_size local_fraction_grid_size_scaling_temp = local_fraction_additional_grid_size_scaling lc_local_nc_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_additional_grid_interpolation ) lf_size_index = 2 write ( unit_logfile , '(A,i)' ) 'Calculating additional EMEP concentrations to subgrids, index:' , lc_local_nc_index else write ( unit_logfile , '(A,i)' ) 'Calculating EMEP concentrations to subgrids, index:' , lc_local_nc_index endif !Set value used later EMEP_grid_interpolation_size_sqr = EMEP_grid_interpolation_size * EMEP_grid_interpolation_size !Time dimension when external time loop is used tt_dim = 1 !Allocate nonlocal_correction if (. not . allocated ( nonlocal_correction )) allocate ( nonlocal_correction ( tt_dim , n_source_index , n_pollutant_loop )) if (. not . allocated ( nonlocal_correction_average )) allocate ( nonlocal_correction_average ( n_source_index , n_pollutant_loop )) !There are no subsources in EMEP emep_subsource = 1 !Initialise a diagnostic check variable for the weighting nonlocal_correction_average = 0. !Save the original EMEP directly to subgrid for comparison and visualisation purposes on the target subgrid write ( unit_logfile , '(A)' ) 'Calculating original EMEP subgrid using nearest neighbour interpolation' do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then ii = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !Nearest neighbour interpolate the EMEP compounds to subgrid if ( ii . ge . 1. and . ii . le . dim_length_nc ( x_dim_nc_index ). and . jj . ge . 1. and . jj . le . dim_length_nc ( y_dim_nc_index )) then do i_pollutant = 1 , n_emep_pollutant_loop do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) !write(*,*) trim(pollutant_file_str(pollutant_compound_loop_index(i_pollutant,i_loop))) orig_EMEP_subgrid ( i , j ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_var3d_nc ( ii , jj ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) enddo enddo endif endif enddo enddo !Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. if ( EMEP_grid_interpolation_flag . eq . 0. or . EMEP_grid_interpolation_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using nearest neighbour interpolation' jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !Window does not extend outside the grid, since it is centred on the EMEP grid if ( EMEP_grid_interpolation_size . le . 1 ) then jj_start = 0 ii_start = 0 jj_end = 0 ii_end = 0 endif write ( unit_logfile , '(A,4i)' ) 'LF loop (ii_start,ii_end,jj_start,jj_end): ' , ii_start , ii_end , jj_start , jj_end ii_nc_w0 = xdist_centre_nc jj_nc_w0 = ydist_centre_nc !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) n_weight_nc_x = xdist_centre_nc * 2 - 1 n_weight_nc_y = ydist_centre_nc * 2 - 1 !Set the size of the region surounding the target grid that is searched xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !Do the calculation everywhere when EMEP_grid_interpolation_flag=5 since it uses the subgrid values later if ( use_subgrid ( i , j , allsource_index ). or . EMEP_grid_interpolation_flag . eq . 5 ) then i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) if ( i_nc . ge . 1. and . i_nc . le . dim_length_nc ( x_dim_nc_index ). and . j_nc . ge . 1. and . j_nc . le . dim_length_nc ( y_dim_nc_index )) then !Read from the local fraction file subgrid ( i , j ,:, emep_subgrid_index ,:,:) = var3d_nc ( i_nc , j_nc ,:, conc_nc_index , 1 : n_source_index ,:) !subgrid(i,j,:,emep_local_subgrid_index,:,:)=var3d_nc(i_nc,j_nc,:,local_nc_index,:,:) !Centre of grid xpos_subgrid = var1d_nc ( i_nc , lon_nc_index ) ypos_subgrid = var1d_nc ( j_nc , lat_nc_index ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit !Set the offset to the centre of the local fraction grid when using larger local fraction grids !Requires knowledge of the total EMEP grid index so uses dim_start_nc amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !dgrid_lf_offset_x=0 !dgrid_lf_offset_y=0 !Calculate the local fraction contribution from within the moving window, limited on the edges. subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = 0 weight_check = 0 do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_nc_w = ii + ii_nc_w0 jj_nc_w = jj + jj_nc_w0 ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index ) & . and . ii_nc_w . ge . 1. and . ii_nc_w . le . n_weight_nc_x . and . jj_nc_w . ge . 1. and . jj_nc_w . le . n_weight_nc_y ) then xpos_lf_area_min = var1d_nc ( i_nc , lon_nc_index ) + ( ii - 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp xpos_lf_area_max = var1d_nc ( i_nc , lon_nc_index ) + ( ii + 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_min = var1d_nc ( j_nc , lat_nc_index ) + ( jj - 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_max = var1d_nc ( j_nc , lat_nc_index ) + ( jj + 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp !Set the edges to an EMEP grid surounding the EMEP grid being assessed !xpos_min=max(xpos_area_min,var1d_nc(ii_nc,lon_nc_index)-dgrid_nc(lon_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_x*dgrid_nc(lon_nc_index)*local_fraction_grid_size_scaling_temp) !xpos_max=min(xpos_area_max,var1d_nc(ii_nc,lon_nc_index)+dgrid_nc(lon_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_x*dgrid_nc(lon_nc_index)*local_fraction_grid_size_scaling_temp) !ypos_min=max(ypos_area_min,var1d_nc(jj_nc,lat_nc_index)-dgrid_nc(lat_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_y*dgrid_nc(lat_nc_index)*local_fraction_grid_size_scaling_temp) !ypos_max=min(ypos_area_max,var1d_nc(jj_nc,lat_nc_index)+dgrid_nc(lat_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_y*dgrid_nc(lat_nc_index)*local_fraction_grid_size_scaling_temp) xpos_min = max ( xpos_area_min , xpos_lf_area_min ) xpos_max = min ( xpos_area_max , xpos_lf_area_max ) ypos_min = max ( ypos_area_min , ypos_lf_area_min ) ypos_max = min ( ypos_area_max , ypos_lf_area_max ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_val = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val = 0. endif !weighting_val=1. weight_check = weight_check + weighting_val !write(*,'(2i,5f12.2,f12.4)') ii,jj,weighting_val,xpos_lf_area_min-xpos_subgrid,xpos_lf_area_max-xpos_subgrid & !    ,xpos_area_min-xpos_subgrid,xpos_area_max-xpos_subgrid,dgrid_lf_offset_x subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) & + lc_var3d_nc ( ii_nc_w , jj_nc_w , i_nc , j_nc ,:, lc_local_nc_index , 1 : n_source_index ,:) * weighting_val endif enddo enddo !write(*,*) 'Check: ',(subgrid(i,j,1,emep_local_subgrid_index,traffic_index,1)),(subgrid(i,j,1,emep_subgrid_index,allsource_index,1)) !Interpolate the other EMEP compounds as well to subgrid in the same way. Read from the normal EMEP file !comp_var3d_nc(ii,jj,:,pollutant_compound_loop_index(i_pollutant,i_loop)) do i_pollutant = 1 , n_emep_pollutant_loop do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) comp_EMEP_subgrid ( i , j ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_var3d_nc ( i_nc , j_nc ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) enddo enddo if ( save_emep_species . or . save_seasalt ) then do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index species_EMEP_subgrid ( i , j ,:, i_loop , i_sp ) = species_var3d_nc ( i_nc , j_nc ,:, i_loop , i_sp ) enddo enddo endif endif endif enddo enddo !Set the non-local for each source individually subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) = subgrid (:,:,:, emep_subgrid_index ,:,:) - subgrid (:,:,:, emep_local_subgrid_index ,:,:) if ( calculate_deposition_flag ) then subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) endif endif !Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. if ( EMEP_grid_interpolation_flag . eq . 6 ) then write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using method 6. First contribution to grid then area interpolation' if (. not . allocated ( temp_EMEP )) allocate ( temp_EMEP ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , n_pollutant_loop )) if (. not . allocated ( temp_comp_EMEP )) allocate ( temp_comp_EMEP ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_compound_index )) temp_EMEP = 0 temp_comp_EMEP = 0 if ( save_emep_species . or . save_seasalt ) then if (. not . allocated ( temp_species_EMEP )) allocate ( temp_species_EMEP ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_pmxx_sp_index , n_species_loop_index )) temp_species_EMEP = 0 endif !Set the extent of the LF grid to be assessed jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !Window does not extend outside the grid, since it is centred on the EMEP grid if ( EMEP_grid_interpolation_size . le . 1 ) then jj_start = 0 ii_start = 0 jj_end = 0 ii_end = 0 endif write ( unit_logfile , '(A,4i)' ) 'LF loop (ii_start,ii_end,jj_start,jj_end): ' , ii_start , ii_end , jj_start , jj_end ii_nc_w0 = xdist_centre_nc jj_nc_w0 = ydist_centre_nc !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) n_weight_nc_x = xdist_centre_nc * 2 - 1 n_weight_nc_y = ydist_centre_nc * 2 - 1 !Set the size of the region surounding the target grid that is searched xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp !Set the size of the region for the area interpoaltion xpos_limit2 = dgrid_nc ( lon_nc_index ) / 2. ypos_limit2 = dgrid_nc ( lat_nc_index ) / 2. !Limits for the area interpolation jjj_start =- 1 iii_start =- 1 jjj_end = 1 iii_end = 1 !Loop through the EMEP grids and create the local contribution in the EMEP grid do j_nc = 1 , dim_length_nc ( y_dim_nc_index ) do i_nc = 1 , dim_length_nc ( x_dim_nc_index ) !i_nc=crossreference_target_to_emep_subgrid(i,j,x_dim_index) !j_nc=crossreference_target_to_emep_subgrid(i,j,y_dim_index) !if (i_nc.ge.1.and.i_nc.le.dim_length_nc(x_dim_nc_index).and.j_nc.ge.1.and.j_nc.le.dim_length_nc(y_dim_nc_index)) then !Read from the local fraction file temp_EMEP ( i_nc , j_nc ,:, emep_subgrid_index , 1 : n_source_index ,:) = var3d_nc ( i_nc , j_nc ,:, conc_nc_index , 1 : n_source_index ,:) !Centre of EMEP grid in lat lon or local coordinates xpos_subgrid = var1d_nc ( i_nc , lon_nc_index ) ypos_subgrid = var1d_nc ( j_nc , lat_nc_index ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit !Set the offset to the centre of the local fraction grid when using larger local fraction grids !Requires knowledge of the total EMEP grid index so uses dim_start_nc amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !Calculate the local fraction contribution to the EMEP grid centre, limited on the edges. temp_EMEP ( i_nc , j_nc ,:, emep_local_subgrid_index ,:,:) = 0 weight_check = 0 do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_nc_w = ii + ii_nc_w0 jj_nc_w = jj + jj_nc_w0 ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index ) & . and . ii_nc_w . ge . 1. and . ii_nc_w . le . n_weight_nc_x . and . jj_nc_w . ge . 1. and . jj_nc_w . le . n_weight_nc_y ) then xpos_lf_area_min = var1d_nc ( i_nc , lon_nc_index ) + ( ii - 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp xpos_lf_area_max = var1d_nc ( i_nc , lon_nc_index ) + ( ii + 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_min = var1d_nc ( j_nc , lat_nc_index ) + ( jj - 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_max = var1d_nc ( j_nc , lat_nc_index ) + ( jj + 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min = max ( xpos_area_min , xpos_lf_area_min ) xpos_max = min ( xpos_area_max , xpos_lf_area_max ) ypos_min = max ( ypos_area_min , ypos_lf_area_min ) ypos_max = min ( ypos_area_max , ypos_lf_area_max ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_val = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val = 0. endif !weighting_val=1. weight_check = weight_check + weighting_val !write(*,'(2i,5f12.2,f12.4)') ii,jj,weighting_val,xpos_lf_area_min-xpos_subgrid,xpos_lf_area_max-xpos_subgrid & !    ,xpos_area_min-xpos_subgrid,xpos_area_max-xpos_subgrid,dgrid_lf_offset_x temp_EMEP ( i_nc , j_nc ,:, emep_local_subgrid_index , 1 : n_source_index ,:) = temp_EMEP ( i_nc , j_nc ,:, emep_local_subgrid_index , 1 : n_source_index ,:) & + lc_var3d_nc ( ii_nc_w , jj_nc_w , i_nc , j_nc ,:, lc_local_nc_index , 1 : n_source_index ,:) * weighting_val endif enddo enddo !write(*,*) 'Check: ',(temp_EMEP(i_nc,j_nc,1,emep_local_subgrid_index,traffic_index,1)),(temp_EMEP(i_nc,j_nc,1,emep_subgrid_index,allsource_index,1)) !Interpolate the other EMEP compounds as well to subgrid in the same way. Read directly from the normal EMEP file !do i_pollutant=1,n_emep_pollutant_loop !do i_loop=1,n_pollutant_compound_loop(i_pollutant) !    temp_comp_EMEP(i_nc,j_nc,:,pollutant_compound_loop_index(i_pollutant,i_loop))=comp_var3d_nc(i_nc,j_nc,:,pollutant_compound_loop_index(i_pollutant,i_loop)) !enddo !enddo temp_comp_EMEP ( i_nc , j_nc ,:,:) = comp_var3d_nc ( i_nc , j_nc ,:,:) if ( save_emep_species . or . save_seasalt ) then temp_species_EMEP ( i_nc , j_nc ,:,:,:) = species_var3d_nc ( i_nc , j_nc ,:,:,:) !do i_sp=1,n_species_loop_index !ii_sp=species_loop_index(i_sp) !do i_loop=1,n_pmxx_sp_index !    temp_species_EMEP(i_nc,j_nc,:,i_loop,i_sp)=species_var3d_nc(i_nc,j_nc,:,i_loop,i_sp) !enddo !enddo endif !endif !endif enddo enddo subgrid (:,:,:, emep_local_subgrid_index ,:,:) = 0 comp_EMEP_subgrid = 0 species_EMEP_subgrid = 0 !Loop through the subgrids and allocate the temp_EMEP grids using area weighting do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then !Assumes it is never on the edge of the EMEP grid as it is not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Are xpos_limit2 in the same coordinates? xpos_area_min2 = xpos_subgrid - xpos_limit2 xpos_area_max2 = xpos_subgrid + xpos_limit2 ypos_area_min2 = ypos_subgrid - ypos_limit2 ypos_area_max2 = ypos_subgrid + ypos_limit2 !Limit the region. This will still allow an EMEP contribution from half a grid away !Same limit is NOT applied on the emissions in the moving window so inconsistent !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max if ( limit_emep_grid_interpolation_region_to_calculation_region ) then xpos_area_min = max ( xpos_area_min , subgrid_proj_min ( x_dim_index ) - xpos_subgrid - xpos_limit2 ) xpos_area_max = min ( xpos_area_max , subgrid_proj_max ( x_dim_index ) - xpos_subgrid + xpos_limit2 ) ypos_area_min = max ( ypos_area_min , subgrid_proj_min ( y_dim_index ) - ypos_subgrid - ypos_limit2 ) ypos_area_max = min ( ypos_area_max , subgrid_proj_max ( y_dim_index ) - ypos_subgrid + ypos_limit2 ) endif !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max !Set the offset to the centre of the local fraction grid when using larger local fraction grids amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !Loop through the +1, -1 grids do jj = jjj_start , jjj_end do ii = iii_start , iii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min2 = max ( xpos_area_min2 , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max2 = min ( xpos_area_max2 , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min2 = max ( ypos_area_min2 , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max2 = min ( ypos_area_max2 , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Calculate area weighting if ( xpos_max2 . gt . xpos_min2 . and . ypos_max2 . gt . ypos_min2 ) then weighting_val = ( ypos_max2 - ypos_min2 ) * ( xpos_max2 - xpos_min2 ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_val = 0. endif !write(*,*) i,j,ii_nc,jj_nc,weighting_val,temp_EMEP(ii_nc,jj_nc,1,emep_local_subgrid_index,1,1) !Area weighting (interpolated) EMEP concentrations, independent of where it comes from subgrid ( i , j ,:, emep_subgrid_index , 1 : n_source_index ,:) = subgrid ( i , j ,:, emep_subgrid_index , 1 : n_source_index ,:) + temp_EMEP ( ii_nc , jj_nc ,:, emep_subgrid_index , 1 : n_source_index ,:) * weighting_val subgrid ( i , j ,:, emep_local_subgrid_index , 1 : n_source_index ,:) = subgrid ( i , j ,:, emep_local_subgrid_index , 1 : n_source_index ,:) + temp_EMEP ( ii_nc , jj_nc ,:, emep_local_subgrid_index , 1 : n_source_index ,:) * weighting_val !var3d_nc(ii_nc,jj_nc,tt,conc_nc_index,1:n_source_index,:)*weighting_val !do i_pollutant=1,n_emep_pollutant_loop !do i_loop=1,n_pollutant_compound_loop(i_pollutant) !    comp_EMEP_subgrid(i,j,:,pollutant_compound_loop_index(i_pollutant,i_loop))=comp_EMEP_subgrid(i,j,:,pollutant_compound_loop_index(i_pollutant,i_loop))+temp_comp_EMEP(ii_nc,jj_nc,:,pollutant_compound_loop_index(i_pollutant,i_loop))*weighting_val !               ! +comp_var3d_nc(ii_nc,jj_nc,tt,pollutant_compound_loop_index(i_pollutant,i_loop))*weighting_val !enddo !enddo comp_EMEP_subgrid ( i , j ,:,:) = comp_EMEP_subgrid ( i , j ,:,:) + temp_comp_EMEP ( ii_nc , jj_nc ,:,:) * weighting_val if ( save_emep_species . or . save_seasalt ) then species_EMEP_subgrid ( i , j ,:,:,:) = species_EMEP_subgrid ( i , j ,:,:,:) + temp_species_EMEP ( ii_nc , jj_nc ,:,:,:) * weighting_val !do i_sp=1,n_species_loop_index !ii_sp=species_loop_index(i_sp) !do i_loop=1,n_pmxx_sp_index !    species_EMEP_subgrid(i,j,:,i_loop,i_sp)=species_EMEP_subgrid(i,j,:,i_loop,i_sp)+temp_species_EMEP(ii_nc,jj_nc,:,i_loop,i_sp)*weighting_val !       ! +species_var3d_nc(ii_nc,jj_nc,tt,i_loop,i_sp)*weighting_val !enddo !enddo endif endif enddo enddo endif enddo enddo !Set the non-local for each source individually subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) = subgrid (:,:,:, emep_subgrid_index ,:,:) - subgrid (:,:,:, emep_local_subgrid_index ,:,:) if ( calculate_deposition_flag ) then subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) endif if ( allocated ( temp_EMEP )) deallocate ( temp_EMEP ) if ( allocated ( temp_comp_EMEP )) deallocate ( temp_comp_EMEP ) if ( allocated ( temp_species_EMEP )) deallocate ( temp_species_EMEP ) if ( allocated ( temp_EMEP_from_in_region )) deallocate ( temp_EMEP_from_in_region ) endif !Areal interpolation of the subgrid nearest neighbour calculations EMEP_grid_interpolation_flag=0 !Do not use, very slow if ( EMEP_grid_interpolation_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'Interpolating uEMEP local subgrid nearest neighbour contributions using area weighted interpolation' if (. not . allocated ( temp_subgrid )) allocate ( temp_subgrid ( subgrid_dim ( t_dim_index ), n_subgrid_index , n_source_index , n_pollutant_loop )) if (. not . allocated ( temp_comp_EMEP_subgrid )) allocate ( temp_comp_EMEP_subgrid ( subgrid_dim ( t_dim_index ), n_compound_index )) if (. not . allocated ( temp_species_EMEP_subgrid )) allocate ( temp_species_EMEP_subgrid ( subgrid_dim ( t_dim_index ), n_pmxx_sp_index , n_species_loop_index )) !Set the loop sizes for the local area interpolation jjj_start =- 1 iii_start =- 1 jjj_end = 1 iii_end = 1 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !Do this calculation everywhere !if (use_subgrid(i,j,allsource_index)) then if ( EMEP_projection_type . eq . LL_projection_index ) then distance_grid_x = 11100 0. * dgrid_nc ( lon_nc_index ) * cos ( lat_subgrid ( i , j ) * pi / 18 0. ) distance_grid_y = 11100 0. * dgrid_nc ( lat_nc_index ) else !Assumed LCC or PS distance_grid_x = dgrid_nc ( lon_nc_index ) distance_grid_y = dgrid_nc ( lat_nc_index ) endif xpos_limit = distance_grid_x / 2. ypos_limit = distance_grid_y / 2. jj_start =- int (( ypos_limit ) / subgrid_delta ( y_dim_index )) ii_start =- int (( xpos_limit ) / subgrid_delta ( x_dim_index )) jj_end =+ int (( ypos_limit ) / subgrid_delta ( y_dim_index )) ii_end =+ int (( xpos_limit ) / subgrid_delta ( x_dim_index )) !Initialise arrays temp_subgrid (:, emep_subgrid_index ,:,:) = 0 temp_subgrid (:, emep_frac_subgrid_index ,:,:) = 0 temp_subgrid (:, emep_local_subgrid_index ,:,:) = 0 temp_subgrid (:, emep_nonlocal_subgrid_index ,:,:) = 0 temp_comp_EMEP_subgrid (:,:) = 0 temp_species_EMEP_subgrid (:,:,:) = 0 temp_count = 0 !write(*,*) i,j,ii_end,jj_end jjj_start = max ( 1 , j + jj_start ) iii_start = max ( 1 , i + ii_start ) jjj_end = min ( subgrid_dim ( y_dim_index ), j + jj_end ) iii_end = min ( subgrid_dim ( x_dim_index ), i + ii_end ) temp_subgrid (:,:,:,:) = sum ( sum ( subgrid ( iii_start : iii_end , jjj_start : jjj_end ,:,:,:,:), 1 ), 1 ) temp_comp_EMEP_subgrid (:,:) = sum ( sum ( comp_EMEP_subgrid ( iii_start : iii_end , jjj_start : jjj_end ,:,:), 1 ), 1 ) temp_species_EMEP_subgrid (:,:,:) = sum ( sum ( species_EMEP_subgrid ( iii_start : iii_end , jjj_start : jjj_end ,:,:,:), 1 ), 1 ) temp_count = ( iii_end - iii_start + 1 ) * ( jjj_end - jjj_start + 1 ) if ( temp_count . gt . 0 ) then subgrid ( i , j ,:, emep_subgrid_index ,:,:) = temp_subgrid (:, emep_subgrid_index ,:,:) / temp_count subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = temp_subgrid (:, emep_local_subgrid_index ,:,:) / temp_count subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) = temp_subgrid (:, emep_nonlocal_subgrid_index ,:,:) / temp_count comp_EMEP_subgrid ( i , j ,:,:) = temp_comp_EMEP_subgrid (:,:) / temp_count species_EMEP_subgrid ( i , j ,:,:,:) = temp_species_EMEP_subgrid (:,:,:) / temp_count else subgrid ( i , j ,:, emep_subgrid_index ,:,:) = 0 subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = 0 subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) = 0 species_EMEP_subgrid ( i , j ,:,:,:) = 0 endif !endif enddo enddo if ( allocated ( temp_subgrid )) deallocate ( temp_subgrid ) if ( allocated ( temp_comp_EMEP_subgrid )) deallocate ( temp_comp_EMEP_subgrid ) if ( allocated ( temp_species_EMEP_subgrid )) deallocate ( temp_species_EMEP_subgrid ) endif !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) !Loop through the time and the subgrids do tt = t_start , t_end !Quick calculation of area weighting, no edge effects. Does not need to change with time !This is done also if there is moving window weighting later as it is used for the nonlocal contribution !This is the old version no longer in use if ( EMEP_grid_interpolation_flag . eq . - 1. or .( EMEP_grid_interpolation_flag . gt . 1. and . EMEP_grid_interpolation_flag . lt . 5 )) then if ( tt . eq . t_start ) write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using area weighted interpolation (obsolete version)' !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) if ( tt . eq . t_start ) write ( unit_logfile , * ) 'Weighting grid dimensions and centres: ' , n_weight , ii_w0 , jj_w0 if (. not . allocated ( weighting_nc )) allocate ( weighting_nc ( n_weight , n_weight , tt_dim , n_source_index )) !EMEP grid weighting for interpolation. Does not need a source index for area weighting if (. not . allocated ( area_weighting_nc )) allocate ( area_weighting_nc ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_weight , n_weight , tt_dim , n_source_index )) !EMEP grid weighting for area interpolation !Initialise arrays subgrid (:,:, tt , emep_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_frac_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_local_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_nonlocal_subgrid_index ,:,:) = 0 comp_EMEP_subgrid (:,:, tt ,:) = 0 species_EMEP_subgrid (:,:, tt ,:,:) = 0 !Cover the search area necessary for the surounding EMEP grids jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !jj_start=-1-ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !ii_start=-1-ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !jj_end=1+ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !ii_end=1+ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !Set the size of the region surounding the target grid that is searched xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then !Assumes it is never on the edge of the EMEP grid as it is not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !These are the subgrid positions projected to the EMEP projection xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit weighting_nc (:,:, tt_dim ,:) = 0. do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min = max ( xpos_area_min , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max = min ( xpos_area_max , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min = max ( ypos_area_min , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max = min ( ypos_area_max , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii_w , jj_w , tt_dim ,:) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / EMEP_grid_interpolation_size_sqr else weighting_nc ( ii_w , jj_w , tt_dim ,:) = 0. endif do i_pollutant = 1 , n_emep_pollutant_loop subgrid ( i , j , tt , emep_local_subgrid_index ,:, i_pollutant ) = subgrid ( i , j , tt , emep_local_subgrid_index ,:, i_pollutant ) & + var3d_nc ( ii_nc , jj_nc , tt , local_nc_index , 1 : n_source_index , i_pollutant ) * weighting_nc ( ii_w , jj_w , tt_dim ,:) subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:, i_pollutant ) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:, i_pollutant ) & + ( var3d_nc ( ii_nc , jj_nc , tt , conc_nc_index , 1 : n_source_index , i_pollutant ) - var3d_nc ( ii_nc , jj_nc , tt , local_nc_index , 1 : n_source_index , i_pollutant )) * weighting_nc ( ii_w , jj_w , tt_dim ,:) enddo do i_pollutant = 1 , n_emep_pollutant_loop !write(*,*) var3d_nc(ii_nc,jj_nc,tt,local_nc_index,:,i_pollutant) !Interpolate the other EMEP compounds as well to subgrid do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) & + comp_var3d_nc ( ii_nc , jj_nc , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) * weighting_nc ( ii_w , jj_w , tt_dim , allsource_index ) enddo enddo if ( save_emep_species . or . save_seasalt ) then do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) = species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) & + species_var3d_nc ( ii_nc , jj_nc , tt , i_loop , i_sp ) * weighting_nc ( ii_w , jj_w , tt_dim , allsource_index ) enddo enddo endif endif enddo enddo !Calculate the nonlocal correction, weighting for grids beyond the central grid nonlocal_correction ( tt_dim ,:,:) = 0. do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then if ( jj . ne . 0. or . ii . ne . 0 ) then !First weight is emission, the second is area do i_pollutant = 1 , n_emep_pollutant_loop nonlocal_correction ( tt_dim ,:, i_pollutant ) = nonlocal_correction ( tt_dim ,:, i_pollutant ) & - lc_var3d_nc ( ii_w0 , jj_w0 , ii_nc , jj_nc , tt , lc_local_nc_index , 1 : n_source_index , i_pollutant ) * weighting_nc ( ii_w , jj_w , tt_dim ,:) * weighting_nc ( ii_w0 , jj_w0 , tt_dim ,:) & - lc_var3d_nc ( ii_w , jj_w , i_nc , j_nc , tt , lc_local_nc_index , 1 : n_source_index , i_pollutant ) * weighting_nc ( ii_w0 , jj_w0 , tt_dim ,:) * weighting_nc ( ii_w , jj_w , tt_dim ,:) enddo endif endif enddo enddo !Place the EMEP values in the target subgrid subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) + nonlocal_correction ( tt_dim ,:,:) subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) - nonlocal_correction ( tt_dim ,:,:) subgrid ( i , j , tt , emep_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) + subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) !Take the already calculated nonlocal depositions to be the fraction of the nonlocal/total EMEP values if ( calculate_deposition_flag ) then subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) endif !Put the area weighting in the larger array for use later in the emission proxy weighting (if needed) area_weighting_nc ( i , j ,:,:, tt_dim ,:) = weighting_nc (:,:, tt_dim ,:) !For diagnostics only nonlocal_correction_average = nonlocal_correction_average + nonlocal_correction ( tt_dim ,:,:) !write(*,*) subgrid(i,j,tt,emep_nonlocal_subgrid_index,allsource_index,:) endif enddo !write(*,*) 'Subgrid EMEP area interpolation: ',j,' of ',subgrid_dim(2) enddo if ( tt . eq . t_end ) then nonlocal_correction_average = nonlocal_correction_average / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) do i_pollutant = 1 , n_emep_pollutant_loop write ( fmt , '(A,I0,A)' ), '(' , n_source_index , 'es12.4)' write ( unit_logfile , fmt ) 'Nonlocal correction for area weighting (' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ') = ' , nonlocal_correction_average (:, i_pollutant ) enddo endif endif !This does not work very well for the additional and reigon contributions. Use 6 instead if ( EMEP_grid_interpolation_flag . eq . 1 ) then if ( tt . eq . t_start ) write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using area weighted interpolation v2' !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) ii_nc_w0 = xdist_centre_nc jj_nc_w0 = ydist_centre_nc n_weight_nc_x = xdist_centre_nc * 2 - 1 n_weight_nc_y = ydist_centre_nc * 2 - 1 n_weight_nc_x = dim_length_nc ( xdist_dim_nc_index ) n_weight_nc_y = dim_length_nc ( ydist_dim_nc_index ) if ( tt . eq . t_start ) write ( unit_logfile , '(a,3i)' ) 'Weighting grid dimensions and centres: ' , n_weight , ii_w0 , jj_w0 if ( tt . eq . t_start ) write ( unit_logfile , '(a,4i)' ) 'EMEP local fraction grid dimensions and centres: ' , n_weight_nc_x , n_weight_nc_y , ii_nc_w0 , jj_nc_w0 !if (.not.allocated(EMEP_local_contribution)) allocate (EMEP_local_contribution(n_weight_nc_x,n_weight_nc_y,n_source_index,n_emep_pollutant_loop)) if (. not . allocated ( EMEP_local_contribution )) allocate ( EMEP_local_contribution ( n_weight_nc_x , n_weight_nc_y , n_source_index , n_pollutant_loop )) !Initialise arrays subgrid (:,:, tt , emep_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_frac_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_local_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_nonlocal_subgrid_index ,:,:) = 0 comp_EMEP_subgrid (:,:, tt ,:) = 0 species_EMEP_subgrid (:,:, tt ,:,:) = 0 EMEP_local_contribution = 0 !Cover the search area necessary for the surounding EMEP grids jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !Set the loop sizes for the local area interpolation jjj_start =- 1 iii_start =- 1 jjj_end = 1 iii_end = 1 !Set the size of the region surounding the target grid that is searched in the LF grid xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp xpos_limit2 = dgrid_nc ( lon_nc_index ) / 2. ypos_limit2 = dgrid_nc ( lat_nc_index ) / 2. !Recheck this! if ( tt . eq . t_start ) write ( unit_logfile , '(a,4i)' ) 'Loop sizes: ' , jj_start , jj_end , ii_start , ii_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then !Assumes it is never on the edge of the EMEP grid as it is not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Set the edges of the search area surounding the target grid xpos_area_min =- xpos_limit xpos_area_max =+ xpos_limit ypos_area_min =- ypos_limit ypos_area_max =+ ypos_limit xpos_area_min2 = xpos_subgrid - xpos_limit2 xpos_area_max2 = xpos_subgrid + xpos_limit2 ypos_area_min2 = ypos_subgrid - ypos_limit2 ypos_area_max2 = ypos_subgrid + ypos_limit2 !Limit the region. This will still allow an EMEP contribution from half a grid away !Same limit is NOT applied on the emissions in the moving window so inconsistent !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max if ( limit_emep_grid_interpolation_region_to_calculation_region ) then xpos_area_min = max ( xpos_area_min , subgrid_proj_min ( x_dim_index ) - xpos_subgrid - xpos_limit2 ) xpos_area_max = min ( xpos_area_max , subgrid_proj_max ( x_dim_index ) - xpos_subgrid + xpos_limit2 ) ypos_area_min = max ( ypos_area_min , subgrid_proj_min ( y_dim_index ) - ypos_subgrid - ypos_limit2 ) ypos_area_max = min ( ypos_area_max , subgrid_proj_max ( y_dim_index ) - ypos_subgrid + ypos_limit2 ) endif !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max !Set the offset to the centre of the local fraction grid when using larger local fraction grids amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp !First create an interpolated grid around the x,y position for the species and the compounds EMEP_local_contribution = 0 do jj = jjj_start , jjj_end do ii = iii_start , iii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min2 = max ( xpos_area_min2 , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max2 = min ( xpos_area_max2 , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min2 = max ( ypos_area_min2 , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max2 = min ( ypos_area_max2 , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Calculate area weighting if ( xpos_max2 . gt . xpos_min2 . and . ypos_max2 . gt . ypos_min2 ) then weighting_val = ( ypos_max2 - ypos_min2 ) * ( xpos_max2 - xpos_min2 ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_val = 0. endif !write(*,*) ii,jj,weighting_val,(ypos_max2-ypos_min2),(xpos_max2-xpos_min2) !Area weighting (interpolated) EMEP concentrations, independent of where it comes from subgrid ( i , j , tt , emep_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_subgrid_index , 1 : n_source_index ,:) + var3d_nc ( ii_nc , jj_nc , tt , conc_nc_index , 1 : n_source_index ,:) * weighting_val do i_pollutant = 1 , n_emep_pollutant_loop do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) & + comp_var3d_nc ( ii_nc , jj_nc , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) * weighting_val enddo enddo if ( save_emep_species . or . save_seasalt ) then do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) = species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) & + species_var3d_nc ( ii_nc , jj_nc , tt , i_loop , i_sp ) * weighting_val enddo enddo endif if ( first_interpolate_lf ) then !Set the area surrounding the multi LF grid, centred on 0 xpos_lf_area_min = ( ii - 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp xpos_lf_area_max = ( ii + 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_min = ( jj - 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_max = ( jj + 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp xpos_min3 = max ( xpos_area_min , xpos_lf_area_min ) xpos_max3 = min ( xpos_area_max , xpos_lf_area_max ) ypos_min3 = max ( ypos_area_min , ypos_lf_area_min ) ypos_max3 = min ( ypos_area_max , ypos_lf_area_max ) !Calculate area weighting LF grid if ( xpos_max3 . gt . xpos_min3 . and . ypos_max3 . gt . ypos_min3 ) then weighting_val3 = ( ypos_max3 - ypos_min3 ) * ( xpos_max3 - xpos_min3 ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val3 = 0. endif else weighting_val3 = weighting_val endif !write(*,*) ii,jj,ii_nc,jj_nc,weighting_val3 EMEP_local_contribution (:,:,:,:) = EMEP_local_contribution (:,:,:,:) + lc_var3d_nc (:,:, ii_nc , jj_nc , tt , lc_local_nc_index , 1 : n_source_index ,:) * weighting_val3 endif enddo enddo !Set the offset to the centre of the local fraction grid when using larger local fraction grids !Requires knowledge of the total EMEP grid index so uses dim_start_nc amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp !write(*,*) dim_start_nc(x_dim_nc_index)-1+i_nc,dim_start_nc(y_dim_nc_index)-1+j_nc,amod_temp,dgrid_lf_offset_x,dgrid_lf_offset_y if ( first_interpolate_lf ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !Still need to change the dispersion routines for distance calculated and the size of the domain read in by EMEP and the other emissions !Calculate the local contribution within the moving window area do jjj = jj_start , jj_end do iii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 iii_nc_w = iii + ii_nc_w0 jjj_nc_w = jjj + jj_nc_w0 !Put in a limit if ( iii_nc_w . ge . 1. and . iii_nc_w . le . n_weight_nc_x . and . jjj_nc_w . ge . 1. and . jjj_nc_w . le . n_weight_nc_y ) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min = max ( xpos_area_min ,( iii + dgrid_lf_offset_x - 1 / 2. ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ) xpos_max = min ( xpos_area_max ,( iii + dgrid_lf_offset_x + 1 / 2. ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ) ypos_min = max ( ypos_area_min ,( jjj + dgrid_lf_offset_y - 1 / 2. ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ) ypos_max = min ( ypos_area_max ,( jjj + dgrid_lf_offset_y + 1 / 2. ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_val = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val = 0. endif !write(*,*) iii_nc_w,jjj_nc_w,weighting_val subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) + EMEP_local_contribution ( iii_nc_w , jjj_nc_w , 1 : n_source_index ,:) * weighting_val !write(*,*) iii,jjj,weighting_val,EMEP_local_contribution(iii_nc_w,jjj_nc_w,traffic_nc_index,allsource_index) endif enddo enddo !Place the EMEP values in the target subgrid !subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)=subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)+nonlocal_correction(tt_dim,:,:) subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_subgrid_index ,:,:) - subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) !subgrid(i,j,tt,emep_subgrid_index,:,:)=subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)+subgrid(i,j,tt,emep_local_subgrid_index,:,:) !write(*,*) i,j,sum(subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)) !Take the already calculated nonlocal depositions to be the fraction of the nonlocal/total EMEP values if ( calculate_deposition_flag ) then subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) endif endif enddo enddo endif !Loop through subgrid and carry out a subgrid weighted moving window interpolation using emissions. Not used anymore if ( EMEP_grid_interpolation_flag . gt . 1. and . EMEP_grid_interpolation_flag . lt . 5 ) then nonlocal_correction_average = 0. !n_weight is already set in the previous call if ( tt . eq . t_start ) write ( unit_logfile , '(A,2i)' ) 'Calculating EMEP local subgrid contribution using moving window interpolation method ' , EMEP_grid_interpolation_flag if (. not . allocated ( total_weighting_nc )) allocate ( total_weighting_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), tt_dim , n_source_index , n_pollutant_loop )) !EMEP grid weighting for interpolation if (. not . allocated ( proxy_weighting_nc )) allocate ( proxy_weighting_nc ( n_weight , n_weight , tt_dim , n_source_index , n_pollutant_loop )) !EMEP grid weighting for interpolation !Set the index offset for the local contribution i_w_c = 1 + floor ( n_weight * . 5 ) j_w_c = 1 + floor ( n_weight * . 5 ) subgrid (:,:, tt , emep_local_subgrid_index ,:,:) = 0 !Emission moving window only works properly when the emission and subgrids are the same !Emission moving window adds all the subsource emissions since EMEP does not understand subsources !This means that combine_emission_subsources_during_dispersion must be set to true whenever using the redistribution of EMEP !Emission weighting if ( EMEP_grid_interpolation_flag . eq . 2 ) then if (. not . allocated ( weighting_subgrid )) allocate ( weighting_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), tt_dim , n_source_index , n_pollutant_loop )) if (. not . allocated ( crossreference_weighting_to_emep_subgrid )) allocate ( crossreference_weighting_to_emep_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) weighting_subgrid (:,:, tt_dim ,:,:) = emission_subgrid (:,:, tt ,:,:) weighting_subgrid_dim (:,:) = emission_subgrid_dim ( 1 : 2 ,:) crossreference_weighting_to_emep_subgrid = crossreference_emission_to_emep_subgrid endif if ( EMEP_grid_interpolation_flag . eq . 3 ) then !Aggregated emissions first on integral grid to increase speed if (. not . allocated ( weighting_subgrid )) allocate ( weighting_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), tt_dim , n_source_index , n_pollutant_loop )) if (. not . allocated ( crossreference_weighting_to_emep_subgrid )) allocate ( crossreference_weighting_to_emep_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 , n_source_index )) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then crossreference_weighting_to_emep_subgrid (:,:,:, i_source ) = crossreference_integral_to_emep_subgrid weighting_subgrid_dim (:, i_source ) = integral_subgrid_dim ( 1 : 2 ) endif enddo weighting_subgrid (:,:, tt_dim ,:,:) = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_cross = crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) j_cross = crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) weighting_subgrid ( i_cross , j_cross , tt_dim , i_source ,:) = weighting_subgrid ( i_cross , j_cross , tt_dim , i_source ,:) + emission_subgrid ( i , j , tt , i_source ,:) enddo enddo endif enddo endif !Integral proxy weighting if ( EMEP_grid_interpolation_flag . eq . 4 ) then !Aggregated proxy on integral grid to increase speed if (. not . allocated ( weighting_subgrid )) allocate ( weighting_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( crossreference_weighting_to_emep_subgrid )) allocate ( crossreference_weighting_to_emep_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 , n_source_index )) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then crossreference_weighting_to_emep_subgrid (:,:,:, i_source ) = crossreference_integral_to_emep_subgrid weighting_subgrid_dim (:, i_source ) = integral_subgrid_dim ( 1 : 2 ) endif enddo !Set the weighting subgrid to the sum of all subsource integral emissions weighting_subgrid (:,:, tt_dim ,:,:) = integral_subgrid (:,:, tt , hsurf_integral_subgrid_index ,:,:) endif !Calculate weighting sum for each EMEP grid. total_weighting_nc = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , weighting_subgrid_dim ( y_dim_index , i_source ) do i = 1 , weighting_subgrid_dim ( x_dim_index , i_source ) i_nc = crossreference_weighting_to_emep_subgrid ( i , j , x_dim_index , i_source ) j_nc = crossreference_weighting_to_emep_subgrid ( i , j , y_dim_index , i_source ) total_weighting_nc ( i_nc , j_nc , tt_dim , i_source ,:) = total_weighting_nc ( i_nc , j_nc , tt_dim , i_source ,:) + weighting_subgrid ( i , j , tt_dim , i_source ,:) !write(*,*) i_source,i,j,i_nc,j_nc,weighting_subgrid(i,j,:,i_source) enddo enddo endif enddo nonlocal_correction_average = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then !Calculate the proxy weighting in the nearest emep grids for each subgrid do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then proxy_weighting_nc = 0. xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit if ( EMEP_grid_interpolation_flag . eq . 2 ) then i_cross = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) j_cross = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) i_nc_c = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc_c = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !Limit the loop so that it doesn't go over more than necessary subgrids and does not go outside the domain i_start = max ( 1 , i_cross - emission_subgrid_loop_index ( x_dim_index , i_source )) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i_cross + emission_subgrid_loop_index ( x_dim_index , i_source )) j_start = max ( 1 , j_cross - emission_subgrid_loop_index ( y_dim_index , i_source )) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j_cross + emission_subgrid_loop_index ( y_dim_index , i_source )) do jj = j_start , j_end do ii = i_start , i_end xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , i_source ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , i_source ) if ( abs ( xpos_subgrid - xpos_emission_subgrid ). le . xpos_limit & . and . abs ( ypos_subgrid - ypos_emission_subgrid ). le . ypos_limit ) then i_nc = crossreference_emission_to_emep_subgrid ( ii , jj , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( ii , jj , y_dim_index , i_source ) proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) = proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) + weighting_subgrid ( ii , jj , tt_dim , i_source ,:) !write(*,*) tt, proxy_weighting_nc(i_nc-i_nc_c+i_w_c,j_nc-j_nc_c+j_w_c,tt_dim,i_source), weighting_subgrid(ii,jj,tt_dim,i_source) endif enddo enddo !endif elseif ( EMEP_grid_interpolation_flag . eq . 3. or . EMEP_grid_interpolation_flag . eq . 4 ) then !Find the cross reference to the integral grid from the target grid i_cross = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) i_nc_c = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc_c = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) i_start = max ( 1 , i_cross - integral_subgrid_loop_index ( x_dim_index )) i_end = min ( integral_subgrid_dim ( x_dim_index ), i_cross + integral_subgrid_loop_index ( x_dim_index )) j_start = max ( 1 , j_cross - integral_subgrid_loop_index ( y_dim_index )) j_end = min ( integral_subgrid_dim ( y_dim_index ), j_cross + integral_subgrid_loop_index ( y_dim_index )) do jj = j_start , j_end do ii = i_start , i_end xpos_integral_subgrid = xproj_integral_subgrid ( ii , jj ) ypos_integral_subgrid = yproj_integral_subgrid ( ii , jj ) if ( abs ( xpos_subgrid - xpos_integral_subgrid ). le . xpos_limit & . and . abs ( ypos_subgrid - ypos_integral_subgrid ). le . ypos_limit ) then i_nc = crossreference_integral_to_emep_subgrid ( ii , jj , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( ii , jj , y_dim_index ) proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) = proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) + weighting_subgrid ( ii , jj , tt_dim , i_source ,:) endif enddo enddo endif i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) i_nc_start = max ( 1 + i_nc - i_w_c , i_nc - 1 - floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) i_nc_end = min ( dim_length_nc ( x_dim_nc_index ) + i_nc - i_w_c , i_nc + 1 + floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_start = max ( 1 + j_nc - j_w_c , j_nc - 1 - floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_end = min ( dim_length_nc ( y_dim_nc_index ) + j_nc - j_w_c , j_nc + 1 + floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) i_nc_start = max ( 1 + i_nc - i_w_c , i_nc - 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) i_nc_end = min ( dim_length_nc ( x_dim_nc_index ) + i_nc - i_w_c , i_nc + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_start = max ( 1 + j_nc - j_w_c , j_nc - 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_end = min ( dim_length_nc ( y_dim_nc_index ) + j_nc - j_w_c , j_nc + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end do i_pollutant = 1 , n_emep_pollutant_loop if ( total_weighting_nc ( ii , jj , tt_dim , i_source , i_pollutant ). ne . 0. ) then proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) = proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) / total_weighting_nc ( ii , jj , tt_dim , i_source , i_pollutant ) / EMEP_grid_interpolation_size_sqr !write(*,*)  tt,proxy_weighting_nc(ii-i_nc+i_w_c,jj-j_nc+j_w_c,tt_dim,i_source) else proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) = 0. endif if ( proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ). gt . 1 ) write ( * , '(A,8i6,f12.2)' ) 'WEIGHTING>1: ' , i_pollutant , tt , i , j , ii , jj , ii - i_nc , jj - j_nc , proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) enddo enddo enddo !Add up the contributing weights do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) & + var3d_nc ( ii , jj , tt , local_nc_index , i_source ,:) * proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source ,:) enddo enddo !Subtract the additional local emissions from the nonlocal using the new scheme nonlocal_correction ( tt_dim , i_source ,:) = 0. !           do jj=-1-floor((EMEP_grid_interpolation_size-1.)*0.5),+1+floor((EMEP_grid_interpolation_size-1.)*0.5) !           do ii=-1-floor((EMEP_grid_interpolation_size-1.)*0.5),+1+floor((EMEP_grid_interpolation_size-1.)*0.5) do jj =- 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ), + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) do ii =- 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ), + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 if ( jj . ne . 0. or . ii . ne . 0 ) then !First weight is emission, the second is area nonlocal_correction ( tt_dim , i_source ,:) = nonlocal_correction ( tt_dim , i_source ,:) & - lc_var3d_nc ( ii_w0 , jj_w0 , ii_nc , jj_nc , tt , lc_local_nc_index , i_source ,:) * proxy_weighting_nc ( ii + i_w_c , jj + j_w_c , tt_dim , i_source ,:) * area_weighting_nc ( i , j , ii_w0 , jj_w0 , tt_dim , i_source ) & - lc_var3d_nc ( ii_w , jj_w , i_nc , j_nc , tt , lc_local_nc_index , i_source ,:) * proxy_weighting_nc ( ii + i_w_c , jj + j_w_c , tt_dim , i_source ,:) * area_weighting_nc ( i , j , ii_w , jj_w , tt_dim , i_source ) endif enddo enddo subgrid ( i , j , tt , emep_nonlocal_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index , i_source ,:) + nonlocal_correction ( tt_dim , i_source ,:) subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) - nonlocal_correction ( tt_dim , i_source ,:) subgrid ( i , j , tt , emep_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index , i_source ,:) + subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) !Averaged over time for diagnostic purposes only nonlocal_correction_average ( i_source ,:) = nonlocal_correction_average ( i_source ,:) + nonlocal_correction ( tt_dim , i_source ,:) endif !use subgrid enddo enddo endif !End if calculate_source enddo !End source loop if ( tt . eq . t_end ) then nonlocal_correction_average = nonlocal_correction_average / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) do i_pollutant = 1 , n_emep_pollutant_loop write ( fmt , '(A,I0,A)' ) '(' , n_source_index , 'es12.4)' write ( unit_logfile , fmt ) 'Nonlocal correction for proxy weighting (' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ') = ' , nonlocal_correction_average (:, i_pollutant ) enddo endif endif if ( mod ( j , 1 ). eq . 0 ) write ( * , '(a,i5,a,i5)' ) 'Gridding EMEP for hour ' , tt , ' of ' , subgrid_dim ( t_dim_index ) enddo !End time loop !Create the all source version of the local and nonlocal contribution after calculating all the source contributions !The nonlocal contribution uses the difference between the local and total, here the total is based on the area interpolation. Is this correct? subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:) = 0. subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) = 0. subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index ,:) = 0. !-subgrid(:,:,:,emep_subgrid_index,allsource_index,:) count = 0 do i_source = 1 , n_source_index !do i_source=1,n_source_calculate_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). and . i_source . ne . allsource_index ) then !Check values for local and totals for each source !write(*,*) trim(source_file_str(i_source)) do i_pollutant = 1 , n_emep_pollutant_loop if ( minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , i_source , i_pollutant )). lt . 0.0 ) then write ( unit_logfile , '(A,A,f12.4,A)' ) 'WARNING: Min nonlocal source less than 0 for ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , i_source , emep_subsource )), ' Setting to 0 and adding to local' endif enddo !Set any negative nonlocal to 0 and add the value back into the local. Indicates a problem with the moving window method do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) where ( subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source ,:). lt . 0. ) subgrid ( i , j ,:, emep_local_subgrid_index , i_source ,:) = subgrid ( i , j ,:, emep_local_subgrid_index , i_source ,:) - subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source ,:) subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source ,:) = 0. endwhere enddo enddo !Add the local subgrid sources together to get an allsource local contribution subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:) = subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:) + subgrid (:,:,:, emep_local_subgrid_index , i_source ,:) subgrid (:,:,:, emep_subgrid_index , i_source ,:) = subgrid (:,:,:, emep_nonlocal_subgrid_index , i_source ,:) + subgrid (:,:,:, emep_local_subgrid_index , i_source ,:) do i_pollutant = 1 , n_pollutant_loop !write(*,'(a,2i,3f12.1)')'Sum  (subgrid_index,i_source,comp_EMEP,original): ',i_source,i_pollutant,sum(subgrid(:,:,:,emep_subgrid_index,i_source,i_pollutant)),sum(comp_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))),sum(orig_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))) enddo !Add up the total EMEP for all source (will be averaged with count) subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) = subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) + subgrid (:,:,:, emep_subgrid_index , i_source ,:) count = count + 1 do i_pollutant = 1 , n_pollutant_loop if ( minval ( subgrid (:,:,:, emep_subgrid_index , i_source , i_pollutant )). lt . 0.0 ) then write ( unit_logfile , '(A,A,f12.4)' ) 'ERROR: Min total source less than 0 for ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( pollutant_loop_index ( i_pollutant )))), minval ( subgrid (:,:,:, emep_subgrid_index , i_source , i_pollutant )) stop endif enddo endif enddo !Set the allsource nonlocal value to the average of the remainder. This can be negative if ( count . gt . 0 ) then subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index ,:) = ( subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) / real ( count ) - subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:)) !write(*,*) calculate_EMEP_additional_grid_flag,sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,:)) !stop endif do i_pollutant = 1 , n_emep_pollutant_loop if ( minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant )). lt . 0.0 ) then write ( unit_logfile , '(A,f12.4,A)' ) 'WARNING: Min nonlocal allsource less than 0 with ' // trim ( source_file_str ( allsource_index )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant )), ' Setting to 0' endif enddo !Remove any negative values. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) where ( subgrid ( i , j ,:, emep_nonlocal_subgrid_index , allsource_index ,:). lt . 0. ) subgrid ( i , j ,:, emep_nonlocal_subgrid_index , allsource_index ,:) = 0. endwhere enddo enddo !write(*,'(a,2f12.1)')'Sum (local,nonlocal): ',sum(subgrid(:,:,:,emep_local_subgrid_index,allsource_index,:)), sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,:)) !Add up the sources and calculate fractions do i_pollutant = 1 , n_emep_pollutant_loop !write(*,'(a,i,f12.1)')'Sum before  (emep_subgrid allsource): ',i_pollutant,sum(subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)) enddo subgrid (:,:,:, emep_subgrid_index ,:,:) = subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) + subgrid (:,:,:, emep_local_subgrid_index ,:,:) do i_pollutant = 1 , n_emep_pollutant_loop !write(*,'(a,i,f12.1)')'Sum after (emep_subgrid allsource): ',i_pollutant,sum(subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)) enddo subgrid (:,:,:, emep_frac_subgrid_index ,:,:) = subgrid (:,:,:, emep_local_subgrid_index ,:,:) / subgrid (:,:,:, emep_subgrid_index ,:,:) do i_pollutant = 1 , n_emep_pollutant_loop if ( minval ( subgrid (:,:,:, emep_subgrid_index , allsource_index ,:)). lt . 0.0 ) then write ( unit_logfile , '(A,f12.4)' ) 'ERROR: Minimum total allsource less than 0 with ' // trim ( source_file_str ( allsource_index )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), minval ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) stop endif enddo !Check if the additional EMEP calculation is to be carried out and set parameters EMEP_grid_interpolation_size = EMEP_grid_interpolation_size_saved if ( calculate_EMEP_additional_grid_flag ) then subgrid (:,:,:, emep_additional_local_subgrid_index ,:,:) = subgrid (:,:,:, emep_local_subgrid_index ,:,:) subgrid (:,:,:, emep_additional_nonlocal_subgrid_index ,:,:) = subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) endif if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) if ( allocated ( area_weighting_nc )) deallocate ( area_weighting_nc ) if ( allocated ( total_weighting_nc )) deallocate ( total_weighting_nc ) if ( allocated ( proxy_weighting_nc )) deallocate ( proxy_weighting_nc ) if ( allocated ( weighting_subgrid )) deallocate ( weighting_subgrid ) if ( allocated ( crossreference_weighting_to_emep_subgrid )) deallocate ( crossreference_weighting_to_emep_subgrid ) if ( allocated ( nonlocal_correction )) deallocate ( nonlocal_correction ) if ( allocated ( nonlocal_correction_average )) deallocate ( nonlocal_correction_average ) if ( allocated ( EMEP_local_contribution )) deallocate ( EMEP_local_contribution ) if ( allocated ( EMEP_local_contribution_from_in_region )) deallocate ( EMEP_local_contribution_from_in_region ) end subroutine uEMEP_subgrid_EMEP","tags":"","loc":"proc/uemep_subgrid_emep.html"},{"title":"uEMEP_subgrid_EMEP_from_in_region – uEMEP","text":"public  subroutine uEMEP_subgrid_EMEP_from_in_region() Arguments None Source Code subroutine uEMEP_subgrid_EMEP_from_in_region ! contribution to centre of each EMEP cell from in-region, within MW and outside MW, for each region real , allocatable :: EMEP_local_from_in_region (:, :, :, :, :, :) ! (x,y,region,t,source,pollutant) real , allocatable :: EMEP_semilocal_from_in_region (:, :, :, :, :, :) ! (x,y,region,t,source,pollutant) ! arrays for accumulating data for a single EMEP cell of the above arrays (is this actually faster than accumulating directly in the big arrays????) real , allocatable :: temp_EMEP_local_from_in_region (:, :, :, :) real , allocatable :: temp_EMEP_semilocal_from_in_region (:, :, :, :) ! additional increment for the centre of each EMEP cell, for each region real , allocatable :: EMEP_additional_increment_from_in_region (:, :, :, :, :, :) ! (x,y,region,t,source,pollutant) ! additional increment for a single EMEP cell, for each region, to be accumulated real , allocatable :: temp_EMEP_additional_increment_from_in_region (:, :, :, :) ! (region,t,source,pollutant) ! additional increment of a single big LF grid to a single receptor EMEP grid (before weighing by region) real , allocatable :: EMEP_additional_increment_current_lfgrid (:, :, :) ! (t,source,pollutant) ! weighting of the additional increment, for each region real , allocatable :: weights_EMEP_additional_increment_current_lfgrid (:) ! (region) ! weighting of an LF cell for local and semilocal contribution real weighting_value_local , weighting_value_semilocal ! indexers for looping integer i , j ! target subgrids integer ii , jj ! EMEP grids integer i_dist , j_dist ! LF dimensions integer iiii , jjjj ! small LF grids within a big LF grid integer i_sub , j_sub ! subsamples of an EMEP grid integer i_region ! region dimension integer i_source ! source dimension ! indexers for determining positioning of additional LF grids integer ii_start , jj_start ! additinoal indexers integer iii , jjj integer iii_nc , jjj_nc ! displacement distances in LF grids (whole grids) integer x_dist , y_dist integer xdist_big , ydist_big integer xdist_small , ydist_small integer xdist_small_first , ydist_small_first integer idist_small , jdist_small integer max_x_dist , max_y_dist ! indexers for the location of a 1x1 LF grid cell in the EMEP grid integer iiii_nc , jjjj_nc ! indexers for the location of a 1x1 LF grid cell in the extended EMEP grid integer iiii_extended , jjjj_extended ! indexers for finding local contributions in LF array integer lc_index , lc_additional_index ! counters integer counter , counter_local , counter_semilocal ! variables to hold a region index integer current_region_index ! fractional position of uEMEP subgrid within an EMEP grid real ii_frac_target , jj_frac_target ! location of subgrid in EMEP's coordinate system real x_temp , y_temp ! distance between target subgrid and an EMEP grid centre or EMEP subsample location real x_dist_target , y_dist_target ! half-size of the moving window real n_EMEP_grids_to_edge_of_moving_window ! fraction of an EMEP grid that is in the correct region real current_EMEP_region_fraction ! weighting for area interpolation real weighting_val , weight_check write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '=====================================================================================================' write ( unit_logfile , '(A)' ) 'Calculation local and semilocal from-in-region EMEP contributions to subgrids (uEMEP_subgrid_EMEP_from_in_region)' write ( unit_logfile , '(A)' ) '=====================================================================================================' write ( unit_logfile , '(A,8I8)' ) 'dims: (x_emep,y_emep,reg,time,source,pollutant,xdist,ydist) = ' , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop , dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ) ! ************************************************ ! PART 1: Calculate contributions to the EMEP grid ! ************************************************ ! Indices in lc_var3d_nc to find the normal and additional local contributions lc_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_grid_interpolation ) lc_additional_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_additional_grid_interpolation ) ! distance in x or y (EMEP grid) from receptor subgrid to edge of moving window, in units of EMEP grids ! (normally whole number, but not if EMEP_grid_interpolation_size is odd number) n_EMEP_grids_to_edge_of_moving_window = EMEP_grid_interpolation_size * 0.5 write ( unit_logfile , '(A,f8.1)' ) 'n_EMEP_grids_to_edge_of_moving_window=' , n_EMEP_grids_to_edge_of_moving_window ! Calculate local and semilocal contributions to centre of all EMEP grids write ( unit_logfile , '(A)' ) 'Allocating arrays for calculating in-region local and semilocal contribution to the EMEP grid' ! Allocate arrays allocate ( EMEP_local_from_in_region ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) EMEP_local_from_in_region = 0.0 allocate ( EMEP_semilocal_from_in_region ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) EMEP_semilocal_from_in_region = 0.0 allocate ( temp_EMEP_local_from_in_region ( n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( temp_EMEP_semilocal_from_in_region ( n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) ! Loop over all EMEP cells and calculate local and semilocal contributions when moving window is centered at the centre of the cell do ii = 1 , dim_length_nc ( x_dim_nc_index ) do jj = 1 , dim_length_nc ( y_dim_nc_index ) temp_EMEP_local_from_in_region = 0.0 temp_EMEP_semilocal_from_in_region = 0.0 ! Loop over all (small) LF contribution cells to this EMEP cell do i_dist = 1 , dim_length_nc ( xdist_dim_nc_index ) do j_dist = 1 , dim_length_nc ( ydist_dim_nc_index ) ! number of grids displaced relative to the receptor grid cell x_dist = i_dist - xdist_centre_nc y_dist = j_dist - ydist_centre_nc ! index in the netcdf file of this cell iiii_nc = ii + x_dist jjjj_nc = jj + y_dist ! index in the extended EMEP grid of this cell iiii_extended = iiii_nc + ngrid_extended_margin jjjj_extended = jjjj_nc + ngrid_extended_margin ! Check if this cell is covered by the extended grid. If not, assume it is completely outside all regions if (. not . ( iiii_extended >= 1 . and . iiii_extended <= nx_EMEP_extended . and . jjjj_extended >= 1 . and . jjjj_extended <= ny_EMEP_extended )) then cycle end if ! Loop over all regions do i_region = 1 , n_regions ! get fraction of the LF grid that is in the region current_region_index = regionindex_loop_index ( i_region ) current_EMEP_region_fraction = regionfraction_per_EMEP_extended_grid ( iiii_extended , jjjj_extended , i_region ) ! Determine the weights to use for this LF cell ! for local, the weight is the area fraction that is in the region and inside the moving window ! for semilocal, the weight is the area fraction that is in the region but outside the moving window if ( current_EMEP_region_fraction <= 0 ) then ! No part of this EMEP grid is within the region cycle else if ( abs ( x_dist ) <= n_EMEP_grids_to_edge_of_moving_window - 1 . and . abs ( y_dist ) <= n_EMEP_grids_to_edge_of_moving_window - 1 ) then ! this LF grid is sure to be completely within the moving window weighting_value_local = current_EMEP_region_fraction weighting_value_semilocal = 0.0 else if ( abs ( x_dist ) >= n_EMEP_grids_to_edge_of_moving_window + 1 . or . abs ( y_dist ) >= n_EMEP_grids_to_edge_of_moving_window + 1 ) then ! this LF grid is sure to be completely outside the moving window weighting_value_local = 0.0 weighting_value_semilocal = current_EMEP_region_fraction else ! this LF grid might be partly covered by the moving window ! -> we must go through all subsamples of that grid to find the overlap between region and moving window counter_local = 0 ! count the subsample grids inside-moving-window & in-region counter_semilocal = 0 ! count the subsample grids outside-moving-window & in-region do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid ! first check if this subsample is in the region if ( EMEP_extended_subsample_region_id ( i_sub , j_sub , iiii_extended , jjjj_extended ) == current_region_index ) then ! deduce x- and y-distance (in number of EMEP grids) from this subsample location to the midpoint of the receptor grid-cell x_dist_target = x_dist + ( i_sub - 0.5 ) / n_subsamples_per_EMEP_grid - 0.5 y_dist_target = y_dist + ( j_sub - 0.5 ) / n_subsamples_per_EMEP_grid - 0.5 ! use these distances to determine whether the subsample is inside the moving window if ( abs ( x_dist_target ) <= n_EMEP_grids_to_edge_of_moving_window . and . abs ( y_dist_target ) <= n_EMEP_grids_to_edge_of_moving_window ) then ! this subsample is inside the moving window counter_local = counter_local + 1 else ! this subsample is outside the moving window counter_semilocal = counter_semilocal + 1 end if end if end do end do ! Divide counters by total number of subsamples per EMEP grid to get the area fraction weighting_value_local = counter_local * 1.0 / n_subsamples_per_EMEP_grid ** 2 weighting_value_semilocal = counter_semilocal * 1.0 / n_subsamples_per_EMEP_grid ** 2 end if temp_EMEP_local_from_in_region ( i_region ,:,:,:) = temp_EMEP_local_from_in_region ( i_region ,:,:,:) + lc_var3d_nc ( i_dist , j_dist , ii , jj ,:, lc_index , 1 : n_source_index ,:) * weighting_value_local temp_EMEP_semilocal_from_in_region ( i_region ,:,:,:) = temp_EMEP_semilocal_from_in_region ( i_region ,:,:,:) + lc_var3d_nc ( i_dist , j_dist , ii , jj ,:, lc_index , 1 : n_source_index ,:) * weighting_value_semilocal end do ! i_region = 1, n_regions end do end do EMEP_local_from_in_region ( ii , jj ,:,:,:,:) = temp_EMEP_local_from_in_region EMEP_semilocal_from_in_region ( ii , jj ,:,:,:,:) = temp_EMEP_semilocal_from_in_region end do end do ! Deallocate temporary arrays deallocate ( temp_EMEP_local_from_in_region ) deallocate ( temp_EMEP_semilocal_from_in_region ) ! Calculate the additional incremental contribution to each EMEP grid for each region ! NB: we let the interpolation domain extend to the very edge of the LF data, not limited by the EMEP_additional_grid_interpolation_size (this is only used to check >0 to determine whether we should calculate it or not) if ( EMEP_additional_grid_interpolation_size > 0.0 ) then write ( unit_logfile , '(A)' ) 'Allocating arrays for additional increment calculation' allocate ( EMEP_additional_increment_from_in_region ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( temp_EMEP_additional_increment_from_in_region ( n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( EMEP_additional_increment_current_lfgrid ( subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( weights_EMEP_additional_increment_current_lfgrid ( n_regions )) write ( unit_logfile , '(A)' ) 'Calculating additional increment to all EMEP grids' ! Use the starting position of the read in EMEP file to initialise the starting point ii_start = mod ( dim_start_EMEP_nc ( x_dim_nc_index ) - 1 , local_fraction_grid_size ( 2 )) jj_start = mod ( dim_start_EMEP_nc ( y_dim_nc_index ) - 1 , local_fraction_grid_size ( 2 )) ! Deduce the max distance (+/-) we have LF data for max_x_dist = ( dim_length_nc ( xdist_dim_nc_index ) - 1 ) / 2 max_y_dist = ( dim_length_nc ( ydist_dim_nc_index ) - 1 ) / 2 ! Loop over all EMEP grids EMEP_additional_increment_from_in_region = 0.0 do ii = 1 , dim_length_nc ( x_dim_nc_index ) do jj = 1 , dim_length_nc ( y_dim_nc_index ) ! Initialize the additional increment of this EMEP cell to zero temp_EMEP_additional_increment_from_in_region = 0.0 ! EMEP grid index of bottom-left-corner-cell of the additional grid associated with that EMEP grid iii = int (( ii - 1 + ii_start ) / local_fraction_grid_size ( 2 )) * local_fraction_grid_size ( 2 ) + 1 - ii_start jjj = int (( jj - 1 + jj_start ) / local_fraction_grid_size ( 2 )) * local_fraction_grid_size ( 2 ) + 1 - jj_start ! Loop over all big (additional) LF grids that give contributions to the EMEP grid do i_dist = 1 , dim_length_nc ( xdist_dim_nc_index ) do j_dist = 1 , dim_length_nc ( ydist_dim_nc_index ) ! Initialize additional increment to the total additional contribution from EMEP from this cell (all times, sources and pollutants) EMEP_additional_increment_current_lfgrid = lc_var3d_nc ( i_dist , j_dist , ii , jj ,:, lc_additional_index , 1 : n_source_index ,:) ! the x_dist and y_dist of this big LF grid (..., -1, 0, 1, ...) xdist_big = i_dist - xdist_centre_nc ydist_big = j_dist - ydist_centre_nc ! deduce what is the xdist and ydist in the 1x1 LF grid of the lower-left EMEP cell falling within this big LF grid xdist_small_first = iii - ii + xdist_big * local_fraction_grid_size ( 2 ) ydist_small_first = jjj - jj + ydist_big * local_fraction_grid_size ( 2 ) ! loop over all EMEP grids contained within this big LF grid ! Reset weights and counter weights_EMEP_additional_increment_current_lfgrid = 0.0 counter = 0 ! count the grids not covered by the small LF grid do iiii = 1 , local_fraction_grid_size ( 2 ) do jjjj = 1 , local_fraction_grid_size ( 2 ) ! Deduce the xdist and ydist of this EMEP grid in the small LF domain xdist_small = xdist_small_first - 1 + iiii ydist_small = ydist_small_first - 1 + jjjj ! and corresponding index in the LF array idist_small = xdist_small + xdist_centre_nc jdist_small = ydist_small + ydist_centre_nc if ( abs ( xdist_small ) > max_x_dist . or . abs ( ydist_small ) > max_y_dist ) then ! This grid is NOT covered by 1x1 LF data, so add its region coverage to the weight ! find index in the normal EMEP grid iiii_nc = ii + xdist_small jjjj_nc = jj + ydist_small ! find corresponding index in the extended EMEP grid of region fractions iiii_extended = iiii_nc + ngrid_extended_margin jjjj_extended = jjjj_nc + ngrid_extended_margin ! check if this is within the extended region mask grid if ( iiii_extended >= 1 . and . iiii_extended <= nx_EMEP_extended . and . jjjj_extended >= 1 . and . jjjj_extended <= ny_EMEP_extended ) then weights_EMEP_additional_increment_current_lfgrid = weights_EMEP_additional_increment_current_lfgrid + regionfraction_per_EMEP_extended_grid ( iiii_extended , jjjj_extended , :) end if ! NB: If the cell is is outside the extended EMEP grid, it is considered to be outside all the regions. If the extended grid size is set properly, this should never be the case for the receptor EMEP grids (ii,jj) that overlap with the target grid. counter = counter + 1 else ! The grid is covered by 1x1 LF data: subtract the 1x1 LF from the additional increment EMEP_additional_increment_current_lfgrid = EMEP_additional_increment_current_lfgrid - lc_var3d_nc ( idist_small , jdist_small , ii , jj ,:, lc_index , 1 : n_source_index ,:) end if end do end do ! ensure the additional increment is not smaller than zero where ( EMEP_additional_increment_current_lfgrid < 0.0 ) EMEP_additional_increment_current_lfgrid = 0.0 ! normalize the weights by the number of grids ! NB: if counter = 0, then the weights are zero so we can go to next LF source grid if ( counter > 0 ) then ! normalize weights by the number of cells summed over weights_EMEP_additional_increment_current_lfgrid = weights_EMEP_additional_increment_current_lfgrid / counter ! For each region, multiply the additional increment by the weight calculated for that region ! and accumulate this in the array for the total additional increment (to be accumulated over all the big LF cells) do i_region = 1 , n_regions temp_EMEP_additional_increment_from_in_region ( i_region ,:,:,:) = temp_EMEP_additional_increment_from_in_region ( i_region ,:,:,:) + EMEP_additional_increment_current_lfgrid * weights_EMEP_additional_increment_current_lfgrid ( i_region ) end do end if end do end do ! The additional increment has now been accumulated over all xdist and ydist source grids and weighted for each region ! So now it can be inserted into the main array EMEP_additional_increment_from_in_region ( ii , jj ,:,:,:,:) = temp_EMEP_additional_increment_from_in_region end do end do EMEP_semilocal_from_in_region = EMEP_semilocal_from_in_region + EMEP_additional_increment_from_in_region deallocate ( temp_EMEP_additional_increment_from_in_region ) deallocate ( EMEP_additional_increment_current_lfgrid ) deallocate ( weights_EMEP_additional_increment_current_lfgrid ) deallocate ( EMEP_additional_increment_from_in_region ) end if ! ***************************************** ! PART 2: Interpolate to the target subgrid ! ***************************************** write ( unit_logfile , '(A)' ) 'Allocating arrays for in-region local and semilocal contribution to the target grid' ! Allocate the arrays for holding the results and initialize them to zero if ( allocated ( subgrid_EMEP_local_from_in_region )) deallocate ( subgrid_EMEP_local_from_in_region ) allocate ( subgrid_EMEP_local_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) subgrid_EMEP_local_from_in_region = 0.0 if ( allocated ( subgrid_EMEP_semilocal_from_in_region )) deallocate ( subgrid_EMEP_semilocal_from_in_region ) allocate ( subgrid_EMEP_semilocal_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) subgrid_EMEP_semilocal_from_in_region = 0.0 write ( unit_logfile , '(A)' ) 'Interpolating local and semilocal contribution from-in-region to the target subgrid' ! go through all target subgrids and interpolate the EMEP contributions calculated above do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) ! Find position along the region dimension of this region index if ( subgrid_region_index ( i , j ) > 0 ) then i_region = regionindex_loop_back_index ( subgrid_region_index ( i , j )) else ! this subgrid is not in any region, so keep it as 0 cycle end if ! Find which EMEP grid the current subgrid is in ii = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) ! Find out where in this EMEP grid we are in EMEP grid coordinates ! E.g. (0,0) for lower-left corner and (1,1) for upper right corner call LL2PROJ ( lon_subgrid ( i , j ), lat_subgrid ( i , j ), x_temp , y_temp , EMEP_projection_attributes , EMEP_projection_type ) ! fractional position inside the EMEP grid (center is (0,0), lower-left corner is (-0.5,-0.5), upper-right corner is (+0.5,+0.5)) ii_frac_target = ( x_temp - var1d_nc ( ii , x_dim_nc_index )) / dgrid_nc ( x_dim_nc_index ) jj_frac_target = ( y_temp - var1d_nc ( jj , y_dim_nc_index )) / dgrid_nc ( y_dim_nc_index ) ! verify that this is within 0-1 (if not, crossreference has gone wrong...) if ( ii_frac_target < - 0.5 . or . ii_frac_target > 0.5 . or . jj_frac_target < - 0.5 . or . jj_frac_target > 0.5 ) then write ( unit_logfile , '(A,2I12)' ) 'Something went wrong with locating target subgrid within EMEP grid!' , ii_frac_target , jj_frac_target stop end if ! Interpolate to the target grid if ( EMEP_grid_interpolation_flag == 0 ) then ! No interpolation: just pick the value of the EMEP cell we are in subgrid_EMEP_local_from_in_region ( i , j ,:,:,:) = EMEP_local_from_in_region ( ii , jj , i_region ,:,:,:) subgrid_EMEP_semilocal_from_in_region ( i , j ,:,:,:) = EMEP_semilocal_from_in_region ( ii , jj , i_region ,:,:,:) else if ( EMEP_grid_interpolation_flag == 6 ) then ! Use area-weighted interpolation weight_check = 0.0 ! loop over a 3x3 EMEP cell domain centered at the closest EMEP cell to the target subgrid do iii = - 1 , 1 do jjj = - 1 , 1 iii_nc = ii + iii jjj_nc = jj + jjj ! verify the EMEP grid covers this index if (. not . ( iii_nc >= 1 . and . iii_nc <= dim_length_nc ( x_dim_nc_index ) . and . jjj_nc >= 1 . and . jjj_nc <= dim_length_nc ( y_dim_nc_index ))) then write ( unit_logfile , '(A)' ) 'ERROR: EMEP grid did not go far enough out to allow area interpolation to the target grid!' stop end if ! calculate the weighting value as the area fraction of an EMEP cell centered at the target subgrid that falls within this EMEP cell x_dist_target = iii - ii_frac_target y_dist_target = jjj - jj_frac_target weighting_val = max ( 0.0 , ( 1.0 - abs ( x_dist_target ))) * max ( 0.0 , ( 1.0 - abs ( y_dist_target ))) weight_check = weight_check + weighting_val ! use this weighting for the data at this EMEP cell if ( weighting_val > 0 ) then subgrid_EMEP_local_from_in_region ( i , j ,:,:,:) = subgrid_EMEP_local_from_in_region ( i , j ,:,:,:) + EMEP_local_from_in_region ( iii_nc , jjj_nc , i_region ,:,:,:) * weighting_val subgrid_EMEP_semilocal_from_in_region ( i , j ,:,:,:) = subgrid_EMEP_semilocal_from_in_region ( i , j ,:,:,:) + EMEP_semilocal_from_in_region ( iii_nc , jjj_nc , i_region ,:,:,:) * weighting_val end if end do end do else write ( unit_logfile , '(A,I0)' ) 'ERROR: uEMEP_subgrid_EMEP_from_in_region is not implemented for EMEP_grid_interpolation_flag =' , EMEP_grid_interpolation_flag stop end if end do end do deallocate ( EMEP_local_from_in_region ) deallocate ( EMEP_semilocal_from_in_region ) ! Set allsources to be the sum of only the sources we calculate for subgrid_EMEP_local_from_in_region (:,:,:, allsource_index ,:) = 0 subgrid_EMEP_semilocal_from_in_region (:,:,:, allsource_index ,:) = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). and . i_source . ne . allsource_index ) then subgrid_EMEP_local_from_in_region (:,:,:, allsource_index ,:) = subgrid_EMEP_local_from_in_region (:,:,:, allsource_index ,:) + subgrid_EMEP_local_from_in_region (:,:,:, i_source ,:) subgrid_EMEP_semilocal_from_in_region (:,:,:, allsource_index ,:) = subgrid_EMEP_semilocal_from_in_region (:,:,:, allsource_index ,:) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source ,:) end if end do end subroutine uEMEP_subgrid_EMEP_from_in_region","tags":"","loc":"proc/uemep_subgrid_emep_from_in_region.html"},{"title":"uEMEP_read_weekly_shipping_asi_data – uEMEP","text":"public  subroutine uEMEP_read_weekly_shipping_asi_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_weekly_shipping_asi_data use uEMEP_definitions implicit none integer i character ( 256 ) temp_str1 integer unit_in logical :: exists real totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t integer , allocatable :: count_subgrid (:,:,:) integer i_pollutant integer a ( 6 ) character ( 256 ) format_temp , week_of_year_str double precision date_num , date_num_start integer week_of_year , ship_week , ship_counts logical nxtdat_flag real ship_delta_x , ship_delta_y real lat_ship , lon_ship write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading weekly shipping asi data  (uEMEP_read_weekly_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. t = 1 allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 !Determine week of year approximately using date string. Needs proper function format_temp = 'yyyymmdd' call datestr_to_date ( config_date_str , format_temp , a ) date_num = date_to_number ( a , ref_year_meteo ) a ( 2 ) = 1 ; a ( 3 ) = 1 ; a ( 4 ) = 1 ; date_num_start = date_to_number ( a , ref_year_meteo ) week_of_year = 1 + int (( date_num - date_num_start ) / 7. ) week_of_year = max ( min ( week_of_year , 52 ), 1 ) !write(*,*) week_of_year write ( week_of_year_str , '(i2)' ) week_of_year write ( unit_logfile , '(a)' ) 'Week of year: ' // trim ( ADJUSTL ( week_of_year_str )) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) // '_week_' // trim ( ADJUSTL ( week_of_year_str )) // '.txt' !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 !Skip over lines starting with # call nxtdat ( unit_in , nxtdat_flag ) !Read data read ( unit_in , * ) temp_str1 , ship_delta_x read ( unit_in , * ) temp_str1 , ship_delta_y read ( unit_in , * ) temp_str1 , ship_week read ( unit_in , * ) temp_str1 , ship_counts !Skip header read ( unit_in , * ) temp_str1 do i = 1 , ship_counts read ( unit_in , * ) x_ship , y_ship , totalnoxemission , totalparticulatematteremission !Special case when saving emissions, convert to either latlon or lambert if ( save_emissions_for_EMEP ( shipping_index )) then call PROJ2LL ( x_ship , y_ship , lon_ship , lat_ship , projection_attributes , projection_type ) ! call utm2ll_modern(1, utm_zone,y_ship,x_ship,lat_ship,lon_ship) if ( EMEP_projection_type . eq . LL_projection_index ) then x_ship = lon_ship y_ship = lat_ship elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) endif endif i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if ( i_ship_index . ge . 1. and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ship_index . ge . 1. and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( totalnoxemission . gt . 0. and . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalnoxemission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 elseif ( totalparticulatematteremission . gt . 0. and .( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index )) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalparticulatematteremission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 endif enddo endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts = ' , ship_counts do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission (g/hr) ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo close ( unit_in ) deallocate ( count_subgrid ) end subroutine uEMEP_read_weekly_shipping_asi_data","tags":"","loc":"proc/uemep_read_weekly_shipping_asi_data.html"},{"title":"uEMEP_read_monthly_and_daily_shipping_asi_data – uEMEP","text":"public  subroutine uEMEP_read_monthly_and_daily_shipping_asi_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_monthly_and_daily_shipping_asi_data use uEMEP_definitions implicit none integer i character ( 256 ) temp_str1 integer unit_in logical :: exists real totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t , tt integer , allocatable :: count_subgrid (:,:,:) integer i_pollutant integer a ( 6 ) character ( 256 ) format_temp , month_of_year_str integer month_of_year , ship_month , ship_counts logical nxtdat_flag real ship_delta_x , ship_delta_y real lat_ship , lon_ship real daily_cycle ( 24 ) integer i_ship_range , j_ship_range integer date_array ( 6 ) double precision date_num_temp write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading monthly shipping asi data  (uEMEP_read_monthly_and_daily_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. daily_cycle = 1. t = 1 allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 !Determine week of year approximately using date string. Needs proper function format_temp = 'yyyymmdd' call datestr_to_date ( config_date_str , format_temp , a ) !date_num=date_to_number(a,ref_year_meteo) !a(2)=1;a(3)=1;a(4)=1; !date_num_start=date_to_number(a,ref_year_meteo) !week_of_year=1+int((date_num-date_num_start)/7.) month_of_year = a ( 2 ) ! write(*,*) month_of_year write ( month_of_year_str , '(i0.2)' ) month_of_year write ( unit_logfile , '(a)' ) 'Month of year: ' // trim ( ADJUSTL ( month_of_year_str )) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) // '_' // trim ( ADJUSTL ( month_of_year_str )) // '.txt' !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 !Skip over lines starting with # call nxtdat ( unit_in , nxtdat_flag ) !Read data read ( unit_in , * ) temp_str1 , ship_delta_x read ( unit_in , * ) temp_str1 , ship_delta_y read ( unit_in , * ) temp_str1 , ship_month read ( unit_in , * ) temp_str1 , ship_counts !Skip header read ( unit_in , * ) temp_str1 do i = 1 , ship_counts read ( unit_in , * ) x_ship , y_ship , totalnoxemission , totalparticulatematteremission !Special case when saving emissions, convert to either latlon or lambert if ( save_emissions_for_EMEP ( shipping_index )) then call PROJ2LL ( x_ship , y_ship , lon_ship , lat_ship , projection_attributes , projection_type ) ! call utm2ll_modern(1, utm_zone,y_ship,x_ship,lat_ship,lon_ship) if ( EMEP_projection_type . eq . LL_projection_index ) then x_ship = lon_ship y_ship = lat_ship elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) endif endif i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if ( i_ship_index . ge . 1. and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ship_index . ge . 1. and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( totalnoxemission . gt . 0. and . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalnoxemission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 elseif ( totalparticulatematteremission . gt . 0. and .( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index )) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalparticulatematteremission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 endif enddo endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts for monthly mean = ' , ship_counts do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission (g/hr) ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo close ( unit_in ) !Now read in the daily cycle data for the same month and applyt it to the emission grid !Read in as utm33 pathfilename_ship ( 2 ) = trim ( pathname_ship ( 2 )) // trim ( filename_ship ( 2 )) // '_' // trim ( ADJUSTL ( month_of_year_str )) // '.txt' !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 2 )) stop endif count_subgrid = 0 !Set the emission time profile to the default of 1 emission_time_profile_subgrid (:,:,:, source_index ,:) = 1. !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 2 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 2 )) rewind ( unit_in ) subsource_index = 1 !Skip over lines starting with # call nxtdat ( unit_in , nxtdat_flag ) !Read data read ( unit_in , * ) temp_str1 , ship_delta_x read ( unit_in , * ) temp_str1 , ship_delta_y read ( unit_in , * ) temp_str1 , ship_month read ( unit_in , * ) temp_str1 , ship_counts !Skip header read ( unit_in , * ) temp_str1 do i = 1 , ship_counts !read(unit_in,'(2f16.1,24f8.2)') x_ship,y_ship,(daily_cycle(t),t=1,24) read ( unit_in , * ) x_ship , y_ship ,( daily_cycle ( t ), t = 1 , 24 ) !write(*,'(i,2f16.1,24f8.2)') i,x_ship,y_ship,(daily_cycle(t),t=1,24) !Convert to EMEP coordinates if it is to be saved. emission grids are already in the EMEP coordinate system if ( save_emissions_for_EMEP ( shipping_index )) then call PROJ2LL ( x_ship , y_ship , lon_ship , lat_ship , projection_attributes , projection_type ) ! call utm2ll_modern(1, utm_zone,y_ship,x_ship,lat_ship,lon_ship) call lb2lambert2_uEMEP ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) endif i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) i_ship_range = floor ( ship_delta_x / emission_subgrid_delta ( x_dim_index , source_index ) / 2. ) j_ship_range = floor ( ship_delta_y / emission_subgrid_delta ( x_dim_index , source_index ) / 2. ) !Add to subgrid if ( i_ship_index . ge . 1 + i_ship_range . and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) - i_ship_range & . and . j_ship_index . ge . 1 + j_ship_range . and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index ) - j_ship_range ) then !do i_pollutant=1,n_pollutant_loop do t = 1 , dim_length_nc ( time_dim_nc_index ) date_num_temp = val_dim_nc ( t , time_dim_nc_index ) call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) tt = date_array ( 4 ) if ( tt . eq . 0 ) tt = 24 !write(*,'(4i,f6.2)') i,t,date_array(4),tt,daily_cycle(tt) emission_time_profile_subgrid ( i_ship_index - i_ship_range : i_ship_index + i_ship_range , j_ship_index - j_ship_range : j_ship_index + j_ship_range , t , source_index ,:) = daily_cycle ( tt ) enddo count_subgrid ( i_ship_index , j_ship_index ,:) = count_subgrid ( i_ship_index , j_ship_index ,:) + 1 !enddo endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts for daily cycle = ' , ship_counts write ( unit_logfile , '(A,I)' ) 'Shipping grids found for daily cycle = ' , sum ( count_subgrid (:,:, 1 )) close ( unit_in ) deallocate ( count_subgrid ) end subroutine uEMEP_read_monthly_and_daily_shipping_asi_data","tags":"","loc":"proc/uemep_read_monthly_and_daily_shipping_asi_data.html"},{"title":"uEMEP_read_shipping_asi_data – uEMEP","text":"public  subroutine uEMEP_read_shipping_asi_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_shipping_asi_data !Reads in the original ais raw data use uEMEP_definitions implicit none character ( 2048 ) temp_str character ( 256 ) temp_str1 integer unit_in logical :: exists integer count , index_val real ddlatitude , ddlongitude , totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t integer , allocatable :: count_subgrid (:,:,:) real , allocatable :: temp1_subgrid (:,:), temp2_subgrid (:,:), temp3_subgrid (:,:) integer i_pollutant integer :: io write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading shipping asi data  (uEMEP_read_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. t = 1 allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 allocate ( temp1_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp2_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp3_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) if ( use_aggregated_shipping_emissions_flag ) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // 'Aggregated_' // trim ( filename_ship ( 1 )) !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 !Read header ddlatitude;ddlongitude;totalnoxemission;totalparticulatematteremission;fk_vessellloydstype;fk_ais_norwegianmainvesselcategory;date;time read ( unit_in , '(A)' ) temp_str !write(*,*) trim(temp_str) count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit ddlatitude = 0. ; ddlongitude = 0. ; totalnoxemission = 0. ; totalparticulatematteremission = 0. !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlatitude !write (*,*) ddlatitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlongitude !write (*,*) ddlongitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) !write(*,*) index_val,trim(temp_str1),trim(temp_str) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalnoxemission !write (*,*) totalnoxemission index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalparticulatematteremission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !temp_str1=temp_str !if (len(temp_str1).gt.0) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission if ( totalnoxemission . gt . 0. or . totalparticulatematteremission . gt . 0 ) then !Convert to EMEP coordinates if it is to be saved. emission grids are already in the EMEP coordinate system !This will not work for lat lon as it is now written but will never be called either if ( save_emissions_for_EMEP ( shipping_index )) then if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ship , y_ship , ddlongitude , ddlatitude , EMEP_projection_attributes ) !elseif (EMEP_projection_type.eq.LL_projection_index) then !lon_ship=ddlongitude !lat_ship=ddlatitude elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ship , y_ship , ddlongitude , ddlatitude , EMEP_projection_attributes ) endif else !Convert lat lon to utm coords if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_ship , y_ship , ddlongitude , ddlatitude , projection_attributes ) endif endif !Find the grid index it belongs to i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !(x_subgrid(i,j)-subgrid_min(1))/+subgrid_delta(1)+1=i !Add to subgrid if ( i_ship_index . ge . 1. and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ship_index . ge . 1. and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( totalnoxemission . gt . 0. and . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalnoxemission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 elseif ( totalparticulatematteremission . gt . 0. and .( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index )) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalparticulatematteremission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 endif enddo endif endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts = ' , count do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo close ( unit_in ) deallocate ( count_subgrid ) deallocate ( temp1_subgrid , temp2_subgrid , temp3_subgrid ) end subroutine uEMEP_read_shipping_asi_data","tags":"","loc":"proc/uemep_read_shipping_asi_data.html"},{"title":"uEMEP_read_netcdf_shipping_latlon – uEMEP","text":"public  subroutine uEMEP_read_netcdf_shipping_latlon() Uses uEMEP_definitions netcdf Arguments None Source Code subroutine uEMEP_read_netcdf_shipping_latlon use uEMEP_definitions use netcdf implicit none integer status_nc integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc real delta_shipping_nc ( num_dims_shipping_nc ) integer dim_id_nc ( num_dims_shipping_nc ) integer dim_length_shipping_nc ( num_dims_shipping_nc ) integer dim_start_shipping_nc ( num_dims_shipping_nc ) integer source_index logical reduce_shipping_region_flag real temp_lon ( 4 ), temp_lat ( 4 ), temp_x ( 4 ), temp_y ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max real temp_delta ( num_dims_shipping_nc ) real correct_lon ( 2 ) real temp_scale integer i_ship logical :: exists !Temporary reading rvariables real , allocatable :: shipping_nc_dp (:,:,:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: temp_var2d_nc_dp (:,:) source_index = shipping_nc_index !Set the filename pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_ship ( 1 )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_ship ( 1 )) status_nc = NF90_OPEN ( pathfilename_ship ( 1 ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the (lon,lat) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_shipping_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_shipping_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_shipping_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_shipping_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_shipping_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of shipping dimensions (lon,lat): ' , dim_length_shipping_nc !Reduce the size of the grid to the heating emission grid size reduce_shipping_region_flag = . true . if ( reduce_shipping_region_flag ) then write ( unit_logfile , '(A)' ) 'Reducing shipping domain for reading' !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 temp_x = temp_lon ; temp_y = temp_lat do i = 1 , 4 !write(*,*) i,temp_x(i),temp_y(i) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo write ( unit_logfile , '(A,2f12.2)' ) 'Min: ' , temp_x_min , temp_y_min write ( unit_logfile , '(A,2f12.2)' ) 'Max: ' , temp_x_max , temp_y_max !Read the lon and lat values to get the delta and size. Put in temporary array !Allocate the temporary arrays for lat,lon and shipping if (. not . allocated ( temp_var2d_nc_dp )) allocate ( temp_var2d_nc_dp ( max ( dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index )), num_dims_shipping_nc )) !x and y dim_start_shipping_nc = 1 do i = 1 , num_dims_shipping_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_shipping_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var2d_nc_dp ( 1 : dim_length_shipping_nc ( i ), i ), start = ( / dim_start_shipping_nc ( i ) / ), count = ( / dim_length_shipping_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_shipping_nc = temp_var2d_nc_dp ( 2 ,:) - temp_var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Shipping grid delta (degrees): ' , delta_shipping_nc !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = delta_shipping_nc ( 1 ) temp_delta ( 2 ) = delta_shipping_nc ( 2 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max !Increase the region by 5 grids to be certain i_temp_min = max ( 1 , i_temp_min - 5 ) i_temp_max = min ( dim_length_shipping_nc ( x_dim_nc_index ), i_temp_max + 5 ) j_temp_min = max ( 1 , j_temp_min - 5 ) j_temp_max = min ( dim_length_shipping_nc ( y_dim_nc_index ), j_temp_max + 5 ) dim_length_shipping_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_shipping_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_shipping_nc ( x_dim_nc_index ) = i_temp_min dim_start_shipping_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading shipping i grids: ' , i_temp_min , i_temp_max , dim_length_shipping_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading shipping j grids: ' , j_temp_min , j_temp_max , dim_length_shipping_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading shipping lon grids (min,max): ' , temp_var2d_nc_dp ( i_temp_min , x_dim_nc_index ), temp_var2d_nc_dp ( i_temp_max , x_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading shipping lat grids (min,max): ' , temp_var2d_nc_dp ( j_temp_min , y_dim_nc_index ), temp_var2d_nc_dp ( j_temp_max , y_dim_nc_index ) !endif endif if ( i_temp_min . ge . i_temp_max . or . j_temp_min . ge . j_temp_max ) then !No shipping data available write ( unit_logfile , '(A)' ) ' WARNING: No shipping data available in this region. Setting to 0' proxy_emission_subgrid (:,:, source_index ,:) = 0. else if (. not . allocated ( shipping_nc_dp )) allocate ( shipping_nc_dp ( dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index ), num_var_shipping_nc )) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index )), num_dims_shipping_nc )) !x and y !Read the lon and lat values to get the delta do i = 1 , num_dims_shipping_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_shipping_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_shipping_nc ( i ), i ), start = ( / dim_start_shipping_nc ( i ) / ), count = ( / dim_length_shipping_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_shipping_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Shipping grid delta (degrees): ' , delta_shipping_nc !write(*,*) var2d_nc_dp(1,1),var2d_nc_dp(dim_length_shipping_nc(x_dim_nc_index),1) !write(*,*) var2d_nc_dp(1,2),var2d_nc_dp(dim_length_shipping_nc(y_dim_nc_index),2) !Read the shipping data do i_ship = 1 , num_var_shipping_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_shipping_nc ( i_ship ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , shipping_nc_dp (:,:, i_ship ), start = ( / dim_start_shipping_nc ( x_dim_nc_index ), dim_start_shipping_nc ( y_dim_nc_index ) / ), count = ( / dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Shipping variable min and max: ' , trim ( var_name_nc_temp ), minval ( shipping_nc_dp (:,:, i_ship )), maxval ( shipping_nc_dp (:,:, i_ship )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo !Loop through the shipping data and put it in the shipping emission grid !Interpolate to the shipping grid in lat lon coordinates !Temporary emissions cutoff i_ship = 1 where ( shipping_nc_dp . lt . min_proxy_emission_shipping_value ) shipping_nc_dp = 0. write ( unit_logfile , '(2a,2f12.2)' ) 'Shipping min and max: ' , trim ( var_name_nc_temp ), minval ( shipping_nc_dp (:,:, i_ship )), maxval ( shipping_nc_dp (:,:, i_ship )) proxy_emission_subgrid (:,:, source_index ,:) = 0. do j = 1 , emission_subgrid_dim ( y_dim_nc_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_nc_index , source_index ) !Project the centre position to lat lon call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = 1. / cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !Interpolate on same grid then scale, equivalent to interpolating density and then recalculating proxy_emission_subgrid ( i , j , source_index ,:) = area_weighted_extended_vectorgrid_interpolation_function ( & real ( var2d_nc_dp ( 1 : dim_length_shipping_nc ( x_dim_nc_index ), x_dim_nc_index )) * correct_lon ( 1 ), real ( var2d_nc_dp ( 1 : dim_length_shipping_nc ( y_dim_nc_index ), y_dim_nc_index )) & , shipping_nc_dp (:,:, i_ship ), dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index ) & , delta_shipping_nc * correct_lon , temp_lon ( 1 ) * correct_lon ( 1 ), temp_lat ( 1 ), delta_shipping_nc * correct_lon ) temp_scale = ( temp_delta ( 1 ) * correct_lon ( 1 ) * temp_delta ( 2 ) * correct_lon ( 2 )) / ( delta_shipping_nc ( 1 ) * correct_lon ( 1 ) * delta_shipping_nc ( 2 ) * correct_lon ( 2 )) proxy_emission_subgrid ( i , j , source_index ,:) = proxy_emission_subgrid ( i , j , source_index ,:) * temp_scale if ( isnan ( proxy_emission_subgrid ( i , j , source_index , 1 ))) then write ( * , * ) 'Stopping, nan in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_shipping_nc , temp_delta , temp_lon stop endif if ( proxy_emission_subgrid ( i , j , source_index , 1 ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_shipping_nc , temp_delta , temp_lon stop endif enddo enddo endif !No shipping data available if ( allocated ( shipping_nc_dp )) deallocate ( shipping_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_var2d_nc_dp )) deallocate ( temp_var2d_nc_dp ) end subroutine uEMEP_read_netcdf_shipping_latlon","tags":"","loc":"proc/uemep_read_netcdf_shipping_latlon.html"},{"title":"match_string_multi_val – uEMEP","text":"private  subroutine match_string_multi_val(match_str, unit_in, unit_output, val, n_val) Arguments Type Intent Optional Attributes Name character(len=*) :: match_str integer :: unit_in integer :: unit_output real :: val (n_val) integer :: n_val Source Code subroutine match_string_multi_val ( match_str , unit_in , unit_output , val , n_val ) !Finds a leading string and returns all the integer variables that follows it !Tab delimitted before and free format after implicit none integer n_val real val ( n_val ) character ( * ) match_str character ( 256 ) temp_str1 , temp_str2 , temp_str integer unit_in , unit_output integer index_val character ( len = :), allocatable :: fmt val =- 99 9. temp_str1 = '' temp_str2 = 'Not available' rewind ( unit_in ) do while ( index ( temp_str1 , match_str ). eq . 0 ) read ( unit_in , '(a)' , end = 10 ) temp_str index_val = index ( temp_str , achar ( 9 )) temp_str1 = temp_str ( 1 : index_val - 1 ) temp_str = temp_str ( index_val + 1 :) index_val = index ( temp_str , achar ( 9 )) !if (index_val.gt.0) then !    temp_str2=temp_str(1:index_val-1) !else !    temp_str2=temp_str !endif end do if ( LEN ( trim ( temp_str )). gt . 0 ) then read ( temp_str , * ) val ( 1 : n_val ) else goto 15 endif if ( unit_output . ge . 0 ) then write ( fmt , '(A,I0,A)' ) '(A40,A3' , n_val , 'es10.2)' write ( unit_output , fmt ) trim ( match_str ), ' = ' , val endif return 10 write ( unit_output , * ) 'WARNING: No match found to \"' // trim ( match_str ) // '\" in input files. Set to -999' return 15 write ( unit_output , * ) 'WARNING: No values for \"' // trim ( match_str ) // '\" in input files' end subroutine match_string_multi_val","tags":"","loc":"proc/match_string_multi_val.html"},{"title":"uEMEP_preaggregate_shipping_asi_data – uEMEP","text":"public  subroutine uEMEP_preaggregate_shipping_asi_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_preaggregate_shipping_asi_data !This routine aggregates shipping data in space and time !Reads in ASI data from standard files and aggregates in UTM33 100 m grids !Writes the data out again in standard ASI format !This routine is called if the flag 'preaggregate_shipping_asi_data_flag' is set to true use uEMEP_definitions implicit none character ( 1024 ) temp_str character ( 256 ) temp_str1 integer unit_in logical :: exists integer count , index_val real ddlatitude , ddlongitude , totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t integer ship_i_dim_index , ship_j_dim_index , ship_x_dim_index , ship_y_dim_index , ship_lat_dim_index , ship_lon_dim_index , ship_count_dim_index , ship_pm_dim_index , ship_nox_dim_index parameter ( ship_i_dim_index = 1 , ship_j_dim_index = 2 , ship_count_dim_index = 3 ) parameter ( ship_x_dim_index = 1 , ship_y_dim_index = 2 , ship_lat_dim_index = 3 , ship_lon_dim_index = 4 , ship_pm_dim_index = 5 , ship_nox_dim_index = 6 ) integer max_ship_dim_index parameter ( max_ship_dim_index = 500000 ) integer ship_index ( max_ship_dim_index , 3 ) real ship_value ( max_ship_dim_index , 6 ) integer ship_index_count , i_count logical found_index real :: ship_delta = 25 0. integer :: i_ship_min = 1000000 , i_ship_max =- 1000000 , j_ship_min = 1000000 , j_ship_max =- 1000000 integer i_ship_dim_min , i_ship_dim_max , j_ship_dim_min , j_ship_dim_max parameter ( i_ship_dim_min =- 400 , i_ship_dim_max = 4500 , j_ship_dim_min = 25000 , j_ship_dim_max = 32000 ) integer ship_array_index ( i_ship_dim_min : i_ship_dim_max , j_ship_dim_min : j_ship_dim_max ) logical :: havbase_data_type = . false . integer :: io if (. not . calculate_aggregated_shipping_emissions_flag ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Aggregating shipping asi data  (uEMEP_preaggregate_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. t = 1 pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif ship_index_count = 0 ship_value = 0. ship_index = 0 ship_array_index = 0 !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 havbase_data_type = . true . !Read header old: ddlatitude;ddlongitude;totalnoxemission;totalparticulatematteremission;fk_vessellloydstype;fk_ais_norwegianmainvesselcategory;date;time !Read header new: mmsi;date_time_utc;lat;lon;lloydstype;norvesselcategory;sizegroupgrosston;vesselname;imonumber;dist_nextpoint;sec_nextpoint;fuelconsumption;me_fuelquality;co2emission;so2emission;particulatematteremission;noxemission;nmvocemission;ch4emission;n2oemission;coemission;blackcarbonemission;organiccarbonemission read ( unit_in , '(A)' ) temp_str write ( * , * ) trim ( temp_str ) count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !read(unit_in,*) temp_str !write(*,*) trim(temp_str) ddlatitude = 0. ; ddlongitude = 0. ; totalnoxemission = 0. ; totalparticulatematteremission = 0. if ( havbase_data_type ) then !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip mmsi index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip date_time_utc index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ddlatitude !Read an entry index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ddlongitude !Read an entry index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip lloydstype index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip norvesselcategory index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip sizegroupgrosston index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip vesselname index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip imonumber index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip dist_nextpoint index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip sec_nextpoint index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip fuelconsumption index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip me_fuelquality index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip co2emission index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip so2emission index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalparticulatematteremission !Read an entry index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalnoxemission !Read an entry else !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlatitude !write (*,*) ddlatitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlongitude !write (*,*) ddlongitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) !write(*,*) index_val,trim(temp_str1),trim(temp_str) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalnoxemission !write (*,*) totalnoxemission index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalparticulatematteremission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !temp_str1=temp_str !if (len(temp_str1).gt.0) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) endif !write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission count = count + 1 if ( mod ( count , 10000 ). eq . 0 ) write ( * , '(2i12,2f12.2,2e12.2)' ) count , ship_index_count , ddlatitude , ddlongitude , totalnoxemission , totalparticulatematteremission if ( totalnoxemission . gt . 0. or . totalparticulatematteremission . gt . 0 ) then !Convert lat lon to utm coords if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_ship , y_ship , ddlongitude , ddlatitude , projection_attributes ) endif !Find the grid index it belongs to. This assumes a minimum UTM grid at 0 so the index can be negative !Not certain if this 0.5 is correct i_ship_index = floor (( x_ship - 0 ) / ship_delta + 0.5 ) j_ship_index = floor (( y_ship - 0 ) / ship_delta + 0.5 ) i_ship_min = min ( i_ship_index , i_ship_min ) i_ship_max = max ( i_ship_index , i_ship_max ) j_ship_min = min ( j_ship_index , j_ship_min ) j_ship_max = max ( j_ship_index , j_ship_max ) if ( i_ship_index . lt . i_ship_dim_min . or . i_ship_index . gt . i_ship_dim_max . or . j_ship_index . lt . j_ship_dim_min . or . j_ship_index . gt . j_ship_dim_max ) then write ( * , * ) i_ship_dim_min , i_ship_dim_max , j_ship_dim_min , j_ship_dim_max write ( * , * ) i_ship_index , j_ship_index stop endif i_count = ship_array_index ( i_ship_index , j_ship_index ) if ( i_count . eq . 0 ) then ship_index_count = ship_index_count + 1 ship_array_index ( i_ship_index , j_ship_index ) = ship_index_count i_count = ship_index_count endif ship_index ( i_count , ship_count_dim_index ) = ship_index ( i_count , ship_count_dim_index ) + 1 if ( totalparticulatematteremission . gt . 0. and .. not . isnan ( totalparticulatematteremission )) ship_value ( i_count , ship_pm_dim_index ) = ship_value ( i_count , ship_pm_dim_index ) + totalparticulatematteremission if ( totalnoxemission . gt . 0. and .. not . isnan ( totalnoxemission )) ship_value ( i_count , ship_nox_dim_index ) = ship_value ( i_count , ship_nox_dim_index ) + totalnoxemission ship_index ( i_count , ship_i_dim_index ) = i_ship_index ship_index ( i_count , ship_j_dim_index ) = j_ship_index ship_value ( i_count , ship_x_dim_index ) = ( ship_index ( i_count , ship_i_dim_index ) + . 5 ) * ship_delta ship_value ( i_count , ship_y_dim_index ) = ( ship_index ( i_count , ship_j_dim_index ) + . 5 ) * ship_delta call PROJ2LL ( ship_value ( i_count , ship_x_dim_index ), ship_value ( i_count , ship_y_dim_index ), ship_value ( i_count , ship_lon_dim_index ), ship_value ( i_count , ship_lat_dim_index ), projection_attributes , projection_type ) call utm2ll ( 1 , utm_zone , ship_value ( i_count , ship_y_dim_index ), ship_value ( i_count , ship_x_dim_index ), ship_value ( i_count , ship_lat_dim_index ), ship_value ( i_count , ship_lon_dim_index )) !if (mod(count,10000).eq.0) write(*,'(2i,2f,2e)') count,ship_index_count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission !if (mod(count,10000).eq.0) write(*,'(3i12,4f14.4,2es14.5)') count,i_count,ship_index(i_count,ship_count_dim_index),ship_value(i_count,ship_y_dim_index),ship_value(i_count,ship_x_dim_index),ship_value(i_count,ship_lat_dim_index),ship_value(i_count,ship_lon_dim_index),ship_value(i_count,ship_pm_dim_index),ship_value(i_count,ship_nox_dim_index) !write(*,*) ship_index_count,x_ship,y_ship !write(*,*) i_count,i_ship_index,j_ship_index !write(*,*) ship_index(i_count,ship_i_dim_index),ship_index(i_count,ship_j_dim_index),ship_index(i_count,ship_count_dim_index) endif !Determine if the grid has been found before and add to it if ( 1. eq . 2 ) then if (( totalnoxemission . gt . 0. or . totalparticulatematteremission . gt . 0 )) then found_index = . false . do i_count = 1 , ship_index_count if ( ship_index ( i_count , ship_i_dim_index ). eq . i_ship_index . and . ship_index ( i_count , ship_j_dim_index ). eq . j_ship_index ) then ship_index ( i_count , ship_count_dim_index ) = ship_index ( i_count , ship_count_dim_index ) + 1 ship_value ( i_count , ship_pm_dim_index ) = ship_value ( i_count , ship_pm_dim_index ) + totalparticulatematteremission ship_value ( i_count , ship_nox_dim_index ) = ship_value ( i_count , ship_nox_dim_index ) + totalnoxemission found_index = . true . exit endif enddo if (. not . found_index ) then ship_index_count = ship_index_count + 1 i_count = ship_index_count ship_index ( i_count , ship_i_dim_index ) = i_ship_index ship_index ( i_count , ship_j_dim_index ) = j_ship_index ship_index ( i_count , ship_count_dim_index ) = 1 ship_value ( i_count , ship_pm_dim_index ) = totalparticulatematteremission ship_value ( i_count , ship_nox_dim_index ) = totalnoxemission endif !write(*,*) count,ship_index_count endif endif enddo write ( unit_logfile , '(A,2I)' ) 'Shipping counts = ' , count , ship_index_count close ( unit_in ) !Calculate the x,y, lat,lon of the centre of the valid grids !do i_count=1,ship_index_count !ship_value(i_count,ship_x_dim_index)=(ship_index(i_count,ship_i_dim_index)+.5)*ship_delta !ship_value(i_count,ship_y_dim_index)=(ship_index(i_count,ship_j_dim_index)+.5)*ship_delta !call utm2ll_modern(1,utm_zone,ship_value(i_count,ship_y_dim_index),ship_value(i_count,ship_x_dim_index),ship_value(i_count,ship_lat_dim_index),ship_value(i_count,ship_lon_dim_index)) !enddo !Save the data in the same format as previously provided pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // 'Aggregated_' // trim ( filename_ship ( 1 )) !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'unknown' ) write ( unit_logfile , '(a)' ) ' Writing to aggregated shipping file ' // trim ( pathfilename_ship ( 1 )) write ( unit_in , '(a)' ) 'ddlatitude;ddlongitude;totalnoxemission;totalparticulatematteremission;fk_vessellloydstype;fk_ais_norwegianmainvesselcategory;date;time' do i_count = 1 , ship_index_count if ( ship_index ( i_count , ship_count_dim_index ). gt . 1 ) then write ( unit_in , '(f14.5,a1,f14.5,a1,e12.2,a1,e12.2,a4)' ) ship_value ( i_count , ship_lat_dim_index ), ';' , ship_value ( i_count , ship_lon_dim_index ), ';' , ship_value ( i_count , ship_nox_dim_index ), ';' , ship_value ( i_count , ship_pm_dim_index ), ';;;;' endif enddo close ( unit_in ) !Max and min array dimensions found write ( * , * ) i_ship_min , i_ship_max , j_ship_min , j_ship_max stop end subroutine uEMEP_preaggregate_shipping_asi_data","tags":"","loc":"proc/uemep_preaggregate_shipping_asi_data.html"},{"title":"uEMEP_read_EMEP – uEMEP","text":"public  subroutine uEMEP_read_EMEP() Uses uEMEP_definitions netcdf Arguments None Source Code subroutine uEMEP_read_EMEP use uEMEP_definitions use netcdf implicit none integer i , j , k , t integer ii , jj , iii , jjj logical exists integer status_nc !Error message integer id_nc integer dim_id_nc ( num_dims_nc ) character ( 256 ) dimname_temp , var_name_nc_temp , var_name_nc_temp2 , unit_name_nc_temp integer var_id_nc integer i_file , i_source , i_conc , i_dim integer temp_num_dims integer temp_start_time_nc_index , temp_end_time_nc_index integer i_loop integer valid_dim_length_nc ( num_dims_nc ) !dimensions of file 1 integer surface_level_nc_2 real temp_lat ( 4 ), temp_lon ( 4 ) real temp_y ( 4 ), temp_x ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max double precision temp_var1d_nc_dp ( 2 , 2 ) real temp_delta ( 2 ) real H_emep_temp integer n_file double precision date_num_temp , date_num_2000 integer date_array ( 6 ) double precision scale_factor_nc integer i_pollutant , p_loop , p_loop_index integer DMT_start_time_nc_index , DMT_end_time_nc_index , DMT_dim_length_nc logical nonzero_wind_notfound integer i_sp , ii_sp , pmxx_sp_index integer i_depo !Temporary reading variables double precision , allocatable :: var1d_nc_dp (:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: var3d_nc_dp (:,:,:) double precision , allocatable :: var4d_nc_dp (:,:,:,:) !Temporary files for rotating wind field and PM real , allocatable :: temp_var4d_nc (:,:,:,:,:) real , allocatable :: temp_var3d_nc (:,:,:) !Temporary PM arrays for reading in PM10 real , allocatable :: pm_var4d_nc (:,:,:,:,:,:,:) real , allocatable :: pm_var3d_nc (:,:,:,:,:,:) real , allocatable :: pm_lc_var4d_nc (:,:,:,:,:,:,:,:,:) real , allocatable :: species_temp_var3d_nc (:,:,:) !NOTE: temporary for nh3 false is not on logical :: use_comp_temporary = . false . logical :: EMEP_region_outside_domain = . false . real EMEP_grid_interpolation_size_temp real mean_phi_temp , mean_invL_temp integer phi_count write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading EMEP data (uEMEP_read_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !This if statement is already specified in uEMEP_define_subgrid and is not necessary here if ( hourly_calculations ) then temp_start_time_nc_index = start_time_nc_index temp_end_time_nc_index = end_time_nc_index else temp_start_time_nc_index = 1 temp_end_time_nc_index = 1 endif if ( use_single_time_loop_flag ) then temp_start_time_nc_index = start_time_nc_index + t_loop - 1 temp_end_time_nc_index = temp_start_time_nc_index endif !Presettng the surface level to 1. Valid when there is no inverting of layers surface_level_nc = EMEP_surface_level_nc surface_level_nc_2 = EMEP_surface_level_nc_2 write ( unit_logfile , '(A,I0)' ) ' Surface level base set to: ' , surface_level_nc write ( unit_logfile , '(A,I0)' ) ' Surface level local_contribution set to: ' , surface_level_nc_2 if ( allocated ( val_dim_nc )) deallocate ( val_dim_nc ) if ( allocated ( unit_dim_nc )) deallocate ( unit_dim_nc ) if ( allocated ( var1d_nc )) deallocate ( var1d_nc ) if ( allocated ( var2d_nc )) deallocate ( var2d_nc ) if ( allocated ( var3d_nc )) deallocate ( var3d_nc ) if ( allocated ( var4d_nc )) deallocate ( var4d_nc ) if ( allocated ( comp_var3d_nc )) deallocate ( comp_var3d_nc ) if ( allocated ( comp_var4d_nc )) deallocate ( comp_var4d_nc ) if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( lc_var3d_nc )) deallocate ( lc_var3d_nc ) if ( allocated ( lc_var4d_nc )) deallocate ( lc_var4d_nc ) if ( allocated ( DMT_EMEP_grid_nc )) deallocate ( DMT_EMEP_grid_nc ) !Daily mean temperature if ( allocated ( species_var3d_nc )) deallocate ( species_var3d_nc ) if ( allocated ( depo_var3d_nc )) deallocate ( depo_var3d_nc ) if ( allocated ( temp_var3d_nc )) deallocate ( temp_var3d_nc ) !Loop through the EMEP files containing the data n_file = 2 do i_file = 1 , n_file !Temporary fix. Must remove !if (i_file.eq.2) dim_name_nc(z_dim_nc_index)='klevel' !Set the filename pathfilename_EMEP ( i_file ) = trim ( pathname_EMEP ( i_file )) // trim ( filename_EMEP ( i_file )) !Test existence of the filename. If does not exist then stop inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_EMEP ( i_file )) status_nc = NF90_OPEN ( pathfilename_EMEP ( i_file ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) write ( unit_logfile , '(A,I0)' ) 'ERROR opening netcdf file: ' , status_nc EMEP_projection_type = LL_projection_index !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'projection_lambert' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) status_nc = nf90_get_att ( id_nc , var_id_nc , 'standard_parallel' , EMEP_projection_attributes ( 1 : 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_central_meridian' , EMEP_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , EMEP_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , EMEP_projection_attributes ( 5 )) EMEP_projection_type = LCC_projection_index !Reset names of the x,y coordinates dim_name_nc ( x_dim_nc_index ) = 'i' dim_name_nc ( y_dim_nc_index ) = 'j' var_name_nc ( lon_nc_index ,:, allsource_index ) = 'lon' var_name_nc ( lat_nc_index ,:, allsource_index ) = 'lat' write ( unit_logfile , '(A,5f12.2)' ) 'Reading lambert_conformal_conic projection. ' , EMEP_projection_attributes ( 1 : 5 ) if ( EMEP_projection_attributes ( 1 ). ne . EMEP_projection_attributes ( 4 ). or . EMEP_projection_attributes ( 2 ). ne . EMEP_projection_attributes ( 4 )) then use_alternative_LCC_projection_flag = . true . write ( unit_logfile , '(A,l)' ) 'Using alternative lambert_conformal_conic projection: ' , use_alternative_LCC_projection_flag else use_alternative_LCC_projection_flag = . false . endif !Always set to true use_alternative_LCC_projection_flag = . true . endif !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'Polar_Stereographic' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) EMEP_projection_attributes = 0. status_nc = nf90_get_att ( id_nc , var_id_nc , 'straight_vertical_longitude_from_pole' , EMEP_projection_attributes ( 1 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , EMEP_projection_attributes ( 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_easting' , EMEP_projection_attributes ( 3 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 3 ) = 0. status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_northing' , EMEP_projection_attributes ( 4 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 4 ) = 0. status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , EMEP_projection_attributes ( 5 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 5 ) = 6.370e6 status_nc = nf90_get_att ( id_nc , var_id_nc , 'scale_factor_at_projection_origin' , EMEP_projection_attributes ( 6 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 6 ) = 1. EMEP_projection_type = PS_projection_index !Reset names of the x,y coordinates dim_name_nc ( x_dim_nc_index ) = 'i' dim_name_nc ( y_dim_nc_index ) = 'j' var_name_nc ( lon_nc_index ,:, allsource_index ) = 'lon' var_name_nc ( lat_nc_index ,:, allsource_index ) = 'lat' write ( unit_logfile , '(A,6f12.2)' ) 'Reading Polar_Stereographic: ' , EMEP_projection_attributes ( 1 : 6 ) endif !Find the (x,y,z,time,xdist,ydist) dimensions of the file do i_dim = 1 , num_dims_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(3A,I0)' ) 'No dimension information available for ' , trim ( dim_name_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_nc ( i_dim ) = 1 endif enddo if ( subgrid_dim ( t_dim_index ). gt . dim_length_nc ( time_dim_nc_index )) then write ( unit_logfile , '(A,2I0)' ) 'ERROR: Specified time dimensions are greater than EMEP netcdf dimensions. Stopping ' , subgrid_dim ( t_dim_index ), dim_length_nc ( time_dim_nc_index ) stop endif write ( unit_logfile , '(A,6I0)' ) ' Size of dimensions (x,y,z,t,xdist,ydist): ' , dim_length_nc dim_length_EMEP_nc = dim_length_nc dim_start_nc ( time_dim_nc_index ) = temp_start_time_nc_index dim_length_nc ( time_dim_nc_index ) = min ( dim_length_nc ( time_dim_nc_index ), subgrid_dim ( t_dim_index )) write ( unit_logfile , '(A,6I0)' ) ' New size of dimensions (x,y,z,t,xdist,ydist): ' , dim_length_nc if ( mod ( dim_length_nc ( xdist_dim_nc_index ), 2 ). ne . 1. or . mod ( dim_length_nc ( ydist_dim_nc_index ), 2 ). ne . 1 ) then write ( unit_logfile , '(A,2I0)' ) ' ERROR: Even sized dimensions for local contribution. Must be odd: ' , dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ) stop endif if ( i_file . eq . 2 ) then xdist_centre_nc = 1 + dim_length_nc ( xdist_dim_nc_index ) / 2 ydist_centre_nc = 1 + dim_length_nc ( ydist_dim_nc_index ) / 2 write ( unit_logfile , '(A,2I0)' ) ' Centre index of local contribution dimensions: ' , xdist_centre_nc , ydist_centre_nc endif !Calculate the necessary extent of the EMEP grid region and only read these grids if ( reduce_EMEP_region_flag ) then !EMEP_grid_interpolation_size_temp=max(EMEP_grid_interpolation_size*local_fraction_grid_size_scaling,EMEP_additional_grid_interpolation_size_original*local_fraction_additional_grid_size_scaling) EMEP_grid_interpolation_size_temp = EMEP_grid_interpolation_size * local_fraction_grid_size_scaling write ( unit_logfile , '(A,f12.2)' ) 'Reducing EMEP domain. EMEP grid interpolation size is now = ' , EMEP_grid_interpolation_size_temp !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(init_subgrid_min(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(1),temp_lon(1)) !    call RDM2LL(init_subgrid_max(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(2),temp_lon(2)) !    call RDM2LL(init_subgrid_max(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(3),temp_lon(3)) !    call RDM2LL(init_subgrid_min(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(4),temp_lon(4)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(1),temp_lon(1)) !    call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(2),temp_lon(2)) !    call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(3),temp_lon(3)) !    call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(4),temp_lon(4)) !endif !This did not work because it was almost all of the grid and because the min and max lat lon did not cover all stations !if (read_EMEP_only_once_flag.and.use_multiple_receptor_grids_flag) then !    temp_lat(1)=minval(lat_receptor(1:n_receptor_in));temp_lon(1)=minval(lon_receptor(1:n_receptor_in)) !    temp_lat(2)=maxval(lat_receptor(1:n_receptor_in));temp_lon(2)=maxval(lon_receptor(1:n_receptor_in)) !    temp_lat(3)=maxval(lat_receptor(1:n_receptor_in));temp_lon(3)=minval(lon_receptor(1:n_receptor_in)) !    temp_lat(4)=minval(lat_receptor(1:n_receptor_in));temp_lon(4)=maxval(lon_receptor(1:n_receptor_in)) !    write(*,*) temp_lat !    write(*,*) temp_lon !endif temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 if ( EMEP_projection_type . eq . LCC_projection_index ) then !Convert lat lon corners to lambert do i = 1 , 4 !if (use_alternative_LCC_projection_flag) then call lb2lambert2_uEMEP ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), EMEP_projection_attributes ) !else !    call lb2lambert_uEMEP(temp_x(i),temp_y(i),temp_lon(i),temp_lat(i),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) !endif !call lb2lambert_uEMEP(temp_x(i),temp_y(i),temp_lon(i),temp_lat(i),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) enddo !write(*,*) temp_x !write(*,*) temp_y elseif ( EMEP_projection_type . eq . PS_projection_index ) then !Convert lat lon corners to Polar Stereo do i = 1 , 4 call LL2PS_spherical ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), EMEP_projection_attributes ) enddo elseif ( EMEP_projection_type . eq . LL_projection_index ) then !Set lat lon corners if EMEP is in lat lon temp_x = temp_lon ; temp_y = temp_lat else !Otherwise assume the same coordinate system temp_x ( 1 ) = init_subgrid_min ( x_dim_index ); temp_y ( 1 ) = init_subgrid_min ( y_dim_index ) temp_x ( 2 ) = init_subgrid_max ( x_dim_index ); temp_y ( 2 ) = init_subgrid_min ( y_dim_index ) temp_x ( 3 ) = init_subgrid_min ( x_dim_index ); temp_y ( 3 ) = init_subgrid_max ( y_dim_index ) temp_x ( 4 ) = init_subgrid_max ( x_dim_index ); temp_y ( 4 ) = init_subgrid_max ( y_dim_index ) endif do i = 1 , 4 !write(*,*) temp_x(i),temp_y(i) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo !Read in the first 2 x and y position values from the nc file to get min values and delta values !write(*,*) temp_x_min,temp_x_max,temp_y_min,temp_y_max !Save these values, min and max extent of the calculation grid in emep coordinates, for possible use later if ( limit_emep_grid_interpolation_region_to_calculation_region ) then subgrid_proj_min ( y_dim_index ) = temp_y_min subgrid_proj_max ( y_dim_index ) = temp_y_max subgrid_proj_min ( x_dim_index ) = temp_x_min subgrid_proj_max ( x_dim_index ) = temp_x_max endif status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_nc ( x_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 1 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_nc ( y_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 2 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_name_nc_temp ) if ( trim ( unit_name_nc_temp ). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' temp_var1d_nc_dp = temp_var1d_nc_dp * 100 0. endif !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = temp_var1d_nc_dp ( 1 , 2 ) - temp_var1d_nc_dp ( 1 , 1 ) temp_delta ( 2 ) = temp_var1d_nc_dp ( 2 , 2 ) - temp_var1d_nc_dp ( 2 , 1 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size_temp i_temp_min = 1 + floor (( temp_x_min - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) i_temp_min = 1 + floor (( temp_x_min - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + ceiling (( temp_x_max - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + ceiling (( temp_y_max - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max i_temp_min = max ( 1 , i_temp_min - 1 - ceiling ( 1. * EMEP_grid_interpolation_size_temp )) i_temp_max = min ( dim_length_nc ( x_dim_nc_index ), i_temp_max + 1 + ceiling ( 1. * EMEP_grid_interpolation_size_temp )) j_temp_min = max ( 1 , j_temp_min - 1 - ceiling ( 1. * EMEP_grid_interpolation_size_temp )) j_temp_max = min ( dim_length_nc ( y_dim_nc_index ), j_temp_max + 1 + ceiling ( 1. * EMEP_grid_interpolation_size_temp )) dim_length_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_nc ( x_dim_nc_index ) = i_temp_min dim_start_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I0)' ) ' Reading EMEP i grids: ' , i_temp_min , i_temp_max , dim_length_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I0)' ) ' Reading EMEP j grids: ' , j_temp_min , j_temp_max , dim_length_nc ( y_dim_nc_index ) dim_start_EMEP_nc = dim_start_nc !endif endif if ( dim_length_nc ( x_dim_nc_index ). lt . 1. or . dim_length_nc ( y_dim_nc_index ). lt . 1 ) then write ( unit_logfile , '(A,2I0)' ) ' WARNING: Selected EMEP region dimensions are less than 1 (i,j): ' , dim_length_nc write ( unit_logfile , '(A)' ) ' Setting to 1 but this selected region is invalid and should not be calculated ' write ( unit_logfile , '(A)' ) ' This can happen if a receptor is outside the EMEP domain' dim_length_nc = 1 dim_start_nc ( x_dim_nc_index ) = 1 dim_start_nc ( y_dim_nc_index ) = 1 EMEP_region_outside_domain = . true . endif !Allocate the nc arrays for reading if (. not . allocated ( val_dim_nc )) allocate ( val_dim_nc ( maxval ( dim_length_nc ), num_dims_nc )) !x, y, z and time dimension values if (. not . allocated ( unit_dim_nc )) allocate ( unit_dim_nc ( num_dims_nc )) !x, y, z and time dimension values if (. not . allocated ( var1d_nc )) allocate ( var1d_nc ( maxval ( dim_length_nc ), num_dims_nc )) !x, y, z and time maximum dimensions if (. not . allocated ( var2d_nc )) allocate ( var2d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 2 )) !Lat and lon if (. not . allocated ( var3d_nc )) then allocate ( var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , n_pollutant_loop )) var3d_nc = 0. endif if (. not . allocated ( var4d_nc )) then allocate ( var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , n_pollutant_loop )) var4d_nc = 0. endif if (. not . allocated ( comp_var3d_nc )) then allocate ( comp_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_compound_nc_index )) comp_var3d_nc = 0. endif if (. not . allocated ( comp_var4d_nc )) then allocate ( comp_var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_compound_nc_index )) comp_var4d_nc = 0. endif if (. not . allocated ( var1d_nc_dp )) allocate ( var1d_nc_dp ( maxval ( dim_length_nc ))) if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) !Lat and lon if (. not . allocated ( temp_var3d_nc )) allocate ( temp_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ))) !Lat and lon !if (.not.allocated(var3d_nc_dp)) allocate (var3d_nc_dp(dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(time_dim_nc_index))) !allocate (var4d_nc_dp(dim_length_nc(x_index),dim_length_nc(y_index),1,dim_length_nc(time_index))) if ( calculate_deposition_flag ) then if (. not . allocated ( depo_var3d_nc )) then allocate ( depo_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_landuse_index , n_pollutant_loop )) depo_var3d_nc = 0 endif endif if ( save_emep_species . or . save_seasalt ) then if (. not . allocated ( species_var3d_nc )) then allocate ( species_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_pmxx_sp_index , n_species_loop_index )) species_var3d_nc = 0 endif if (. not . allocated ( species_temp_var3d_nc )) allocate ( species_temp_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ))) endif if ( i_file . eq . 2. and .. not . allocated ( lc_var3d_nc )) then allocate ( lc_var3d_nc ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_lc_var_nc , n_source_nc_index , n_pollutant_loop )) lc_var3d_nc = 0. endif if ( i_file . eq . 2. and .. not . allocated ( lc_var4d_nc )) then allocate ( lc_var4d_nc ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 1 , dim_length_nc ( time_dim_nc_index ), num_lc_var_nc , n_source_nc_index , n_pollutant_loop )) lc_var4d_nc = 0. endif if ( i_file . eq . 2. and .. not . allocated ( pm_lc_var4d_nc )) then allocate ( pm_lc_var4d_nc ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 1 , dim_length_nc ( time_dim_nc_index ), num_lc_var_nc , n_source_nc_index , 2 )) pm_lc_var4d_nc = 0. endif if (. not . allocated ( pm_var4d_nc )) then allocate ( pm_var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , 2 )) pm_var4d_nc = 0. endif if (. not . allocated ( pm_var3d_nc )) then allocate ( pm_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , 2 )) pm_var3d_nc = 0. endif if (. not . allocated ( temp_var4d_nc ). and . i_file . eq . 1 ) then allocate ( temp_var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), 2 )) temp_var4d_nc = 0. endif !write(*,*) x_dim_nc_index,y_dim_nc_index !write(*,*) shape(var1d_nc_dp) !write(*,*) dim_length_nc !Read in the dimensions and check values of the dimensions. Not necessary but diagnostic do i = 1 , num_dims_nc status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_nc ( i )), var_id_nc ) !write(*,*) id_nc, trim(dim_name_nc(i)), var_id_nc(i),dim_length_nc(i) var1d_nc_dp = 0. !write(*,*) 'HERE',i,dim_start_nc(i),dim_length_nc(i) unit_dim_nc ( i ) = '' if ( status_nc . EQ . NF90_NOERR ) then status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_dim_nc ( i )) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var1d_nc_dp ( 1 : dim_length_nc ( i )), start = ( / dim_start_nc ( i ) / ), count = ( / dim_length_nc ( i ) / )); var1d_nc ( 1 : dim_length_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_nc ( i ))) !write(*,*) id_nc, trim(dim_name_nc(i)), var_id_nc,dim_length_nc(i),status_nc !Use the first file to give valid time stamps if ( i_file . eq . 1. and . i . eq . time_dim_nc_index ) then val_dim_nc ( 1 : dim_length_nc ( i ), i ) = ( var1d_nc_dp ( 1 : dim_length_nc ( i ))) valid_dim_length_nc ( i ) = dim_length_nc ( i ) elseif ( i_file . ne . 1. and . i . ne . time_dim_nc_index ) then val_dim_nc ( 1 : dim_length_nc ( i ), i ) = ( var1d_nc_dp ( 1 : dim_length_nc ( i ))) valid_dim_length_nc ( i ) = dim_length_nc ( i ) endif !write(*,*) val_dim_nc(1:dim_length_nc(i),i),trim(unit_dim_nc(i)) else var1d_nc ( 1 : dim_length_nc ( i ), i ) = 0. val_dim_nc ( 1 : dim_length_nc ( i ), i ) = 0. endif !Convert from meters to km for AROME data if necessary if (( i . eq . x_dim_nc_index . or . i . eq . y_dim_nc_index ). and . trim ( unit_dim_nc ( i )). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' val_dim_nc ( 1 : dim_length_nc ( i ), i ) = val_dim_nc ( 1 : dim_length_nc ( i ), i ) * 100 0. var1d_nc ( 1 : dim_length_nc ( i ), i ) = var1d_nc ( 1 : dim_length_nc ( i ), i ) * 100 0. endif if ( i . eq . time_dim_nc_index ) then !write(unit_logfile,'(3A,2i12)') ' ',trim(dim_name_nc(i)),' (min, max in hours): ' & !    ,minval(int((var1d_nc(1:dim_length_nc(i),i)-var1d_nc(dim_start_nc(i),i))/3600.+.5)+1) & !    ,maxval(int((var1d_nc(1:divar1d_ncm_length_nc(i),i)-var1d_nc(dim_start_nc(i),i))/3600.+.5)+1) else write ( unit_logfile , '(3A,2f12.2)' ) ' ' , trim ( dim_name_nc ( i )), ' (min, max): ' & , minval ( var1d_nc ( 1 : dim_length_nc ( i ), i )), maxval ( var1d_nc ( 1 : dim_length_nc ( i ), i )) endif enddo !Loop through the pollutants. do p_loop = 1 , n_emep_pollutant_loop + 1 !Set the compound index for this pollutant if ( p_loop . le . n_emep_pollutant_loop ) then i_pollutant = pollutant_loop_index ( p_loop ) p_loop_index = p_loop else !Special case to read in meteo data that is defined as the all_nc_index i_pollutant = all_nc_index !Put the meteo data in the first pollutant index always p_loop_index = meteo_p_loop_index endif !Loop through the sources do i_source = 1 , n_source_nc_index !write(*,*) i_source,trim(source_file_str(i_source)),uEMEP_to_EMEP_sector(i_source),calculate_source(i_source),calculate_EMEP_source(i_source) if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . save_EMEP_source ( i_source ). or . i_source . eq . allsource_index . or .( i_source . eq . extrasource_nc_index . and . use_alternative_ppm_variable_for_lf )) then !var_name_nc(num_var_nc,n_compound_nc_index,n_source_nc_index) !Loop through the variables do i = 1 , num_var_nc !write(*,*) i,trim(var_name_nc(i)) !if (i.eq.frac_nc_index) var_name_nc_temp=var_name_nc(i,i_pollutant,i_source) !if (i.eq.conc_nc_index) var_name_nc_temp=var_name_nc(i,i_pollutant,i_source) !Identify the variable name and ID in the nc file var_name_nc_temp = var_name_nc ( i , i_pollutant , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) !write(*,*) 'Status1: ',status_nc,var_id_nc,trim(var_name_nc_temp),i_source !Exception for pm10: read pmco and pm25 !if ((i.eq.conc_nc_index.or.i.eq.frac_nc_index.or.i.eq.emis_nc_index).and.i_pollutant.eq.pm10_nc_index) then if (( i . eq . conc_nc_index . or .( i . ge . min_frac_nc_loop_index . and . i . le . max_frac_nc_loop_index ). or . i . eq . emis_nc_index ). and . i_pollutant . eq . pm10_nc_index ) then ! check if at least one of them exists ! if pmco exists, use it for var_id_nc, if not use pm25 var_name_nc_temp = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . ne . NF90_NOERR ) then var_name_nc_temp = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) end if !write(*,*) '-------------------',trim(var_name_nc_temp),status_nc endif !If a variable name is found in the file then go further if ( status_nc . eq . NF90_NOERR ) then scale_factor_nc = 1. !Find the dimensions of the variable (temp_num_dims) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) !write(*,*) temp_num_dims,status_nc if ( temp_num_dims . eq . 2. and . i_file . eq . 1 ) then !Read latitude and longitude data into a 2d grid if available. Only lat lon is 2d? Only read for file 1 assuming file 2 is the same. Problem if not if ( i . eq . lat_nc_index . or . i . eq . lon_nc_index ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ); var2d_nc (:,:, i ) = real ( var2d_nc_dp ) write ( unit_logfile , '(A,i3,A,2A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( var2d_nc (:,:, i )), maxval ( var2d_nc (:,:, i )) endif elseif ( temp_num_dims . eq . 3. and . i_file . eq . 1. and . i . eq . emis_nc_index . and . i_pollutant . eq . pm10_nc_index . and . i_source . ne . extrasource_nc_index ) then var_name_nc_temp2 = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var3d_nc (:,:,:, i , i_source , 1 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var3d_nc (:,:,:, i , i_source , 1 )), maxval ( pm_var3d_nc (:,:,:, i , i_source , 1 )) write ( unit_logfile , '(2A,f16.4)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var3d_nc (:,:,:, i , i_source , 1 )) / ( size ( pm_var3d_nc , 1 ) * size ( pm_var3d_nc , 2 ) * size ( pm_var3d_nc , 4 )) end if var_name_nc_temp2 = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var3d_nc (:,:,:, i , i_source , 2 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var3d_nc (:,:,:, i , i_source , 2 )), maxval ( pm_var3d_nc (:,:,:, i , i_source , 2 )) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var3d_nc (:,:,:, i , i_source , 2 )) / ( size ( pm_var3d_nc , 1 ) * size ( pm_var3d_nc , 2 ) * size ( pm_var3d_nc , 4 )), size ( pm_var3d_nc , 1 ), size ( pm_var3d_nc , 2 ), size ( pm_var3d_nc , 4 ) end if var3d_nc (:,:,:, i , i_source , p_loop_index ) = pm_var3d_nc (:,:,:, i , i_source , 1 ) + pm_var3d_nc (:,:,:, i , i_source , 2 ) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc ( i , pm10_nc_index , i_source )), sum ( var3d_nc (:,:,:, i , i_source , p_loop_index )) / ( size ( var3d_nc , 1 ) * size ( var3d_nc , 2 ) * size ( var3d_nc , 4 )), size ( var3d_nc , 1 ), size ( var3d_nc , 2 ), size ( var3d_nc , 4 ) elseif ( temp_num_dims . eq . 3. and . i_file . eq . 1 ) then !write(*,'(6i)') dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),temp_start_time_nc_index,dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var3d_nc (:,:,:, i , i_source , p_loop_index ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) !write(*,*) status_nc write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( var3d_nc (:,:,:, i , i_source , p_loop_index )), maxval ( var3d_nc (:,:,:, i , i_source , p_loop_index )) !if (i.eq.emis_nc_index) write(*,*) 'HERE',sum(var3d_nc(:,:,:,i,i_source,p_loop_index)),i_source,p_loop_index elseif ( temp_num_dims . eq . 4 ) then if ( i_file . eq . 2. and . i . eq . ZTOP_nc_index ) then !Don't try to read elseif ( i . eq . conc_nc_index . and . i_pollutant . eq . pm10_nc_index . and . i_source . ne . extrasource_nc_index ) then var_name_nc_temp2 = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var4d_nc (:,:, dim_start_nc ( z_dim_nc_index ): dim_start_nc ( z_dim_nc_index ) + dim_length_nc ( z_dim_nc_index ) - 1 ,:, i , i_source , 1 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var4d_nc (:,:,:,:, i , i_source , 1 )), maxval ( pm_var4d_nc (:,:,:,:, i , i_source , 1 )) write ( unit_logfile , '(2A,f16.4)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var4d_nc (:,:, 1 ,:, i , i_source , 1 )) / ( size ( pm_var4d_nc , 1 ) * size ( pm_var4d_nc , 2 ) * size ( pm_var4d_nc , 4 )) end if var_name_nc_temp2 = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var4d_nc (:,:, dim_start_nc ( z_dim_nc_index ): dim_start_nc ( z_dim_nc_index ) + dim_length_nc ( z_dim_nc_index ) - 1 ,:, i , i_source , 2 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var4d_nc (:,:,:,:, i , i_source , 2 )), maxval ( pm_var4d_nc (:,:,:,:, i , i_source , 2 )) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var4d_nc (:,:, 1 ,:, i , i_source , 2 )) / ( size ( pm_var4d_nc , 1 ) * size ( pm_var4d_nc , 2 ) * size ( pm_var4d_nc , 4 )), size ( pm_var4d_nc , 1 ), size ( pm_var4d_nc , 2 ), size ( pm_var4d_nc , 4 ) end if var4d_nc (:,:,:,:, i , i_source , p_loop_index ) = pm_var4d_nc (:,:,:,:, i , i_source , 1 ) + pm_var4d_nc (:,:,:,:, i , i_source , 2 ) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc ( i , pm10_nc_index , i_source )), sum ( var4d_nc (:,:,:,:, i , i_source , p_loop_index )) / ( size ( var4d_nc , 1 ) * size ( var4d_nc , 2 ) * size ( var4d_nc , 4 )), size ( var4d_nc , 1 ), size ( var4d_nc , 2 ), size ( var4d_nc , 4 ) else status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var4d_nc (:,:, dim_start_nc ( z_dim_nc_index ): dim_start_nc ( z_dim_nc_index ) + dim_length_nc ( z_dim_nc_index ) - 1 ,:, i , i_source , p_loop_index ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) !var4d_nc(:,:,:,:,i,i_source)=real(temp_var4d_nc(:,:,:,:)) write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( var4d_nc (:,:,:,:, i , i_source , p_loop_index )), maxval ( var4d_nc (:,:,:,:, i , i_source , p_loop_index )) !if (i.eq.precip_nc_index) then !    write(*,*) maxval(var4d_nc(:,:,:,:,i,i_source,p_loop_index)) !    stop !endif endif !write(*,*) shape(var4d_nc) !write(*,*) dim_start_nc(z_dim_nc_index),dim_length_nc(z_dim_nc_index) !write(*,*) maxval(var4d_nc(:,:,1,1,i,i_source)),maxval(var4d_nc(:,:,1,2,i,i_source)) elseif ( temp_num_dims . eq . 6. and . i_file . eq . 2 ) then !if (i.eq.frac_nc_index.and.i_pollutant.eq.pm10_nc_index) then lc_frac_nc_index = convert_frac_to_lc_frac_loop_index ( i ) !write(*,*) i,lc_frac_nc_index if ( i . ge . min_frac_nc_loop_index . and . i . le . max_frac_nc_loop_index . and . i_pollutant . eq . pm10_nc_index ) then var_name_nc_temp2 = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 1 ), start = ( / 1 , 1 , dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2I0,3A,2f16.4)' ) ' Reading: ' , i , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 1 )), maxval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 1 )) end if var_name_nc_temp2 = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 2 ), start = ( / 1 , 1 , dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2I0,3A,2f16.4)' ) ' Reading: ' , i , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 2 )), maxval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 2 )) end if !Not used but calculated for writing !lc_var4d_nc(:,:,:,:,:,:,lc_frac_nc_index,i_source,p_loop_index)=pm_lc_var4d_nc(:,:,:,:,:,:,lc_frac_nc_index,i_source,1)+pm_lc_var4d_nc(:,:,:,:,:,:,lc_frac_nc_index,i_source,2) else status_nc = NF90_GET_VAR ( id_nc , var_id_nc , lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , p_loop_index ), start = ( / 1 , 1 , dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2I0,3A,2f16.4)' ) ' Reading: ' , i , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , p_loop_index )), maxval ( lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , p_loop_index )) endif !write(*,*) shape(lc_var4d_nc) !write(*,*) maxval(lc_var4d_nc(3,3,:,:,:,1,lc_frac_nc_index,i_source)),maxval(lc_var4d_nc(3,3,:,:,:,2,lc_frac_nc_index,i_source)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot find a correct dimension for: ' , trim ( var_name_nc_temp ) endif else !write(unit_logfile,'(8A,8A)') ' Cannot read: ',trim(var_name_nc_temp) endif enddo !Variable loop endif enddo !Source loop !Loop through the additional compounds that are in the base file !if (i_file.eq.1) then i_source = allsource_index !i=conc_nc_index do i_loop = 1 , n_pollutant_compound_loop ( p_loop ) i_conc = pollutant_compound_loop_index ( p_loop , i_loop ) var_name_nc_temp = comp_name_nc ( i_conc ) !write(*,*) p_loop,i_conc,i_source,trim(var_name_nc_temp) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) !write(*,*) 'Status1: ',status_nc,id_nc,var_id_nc,trim(var_name_nc_temp) !If a variable name is found in the file then go further if ( status_nc . eq . NF90_NOERR ) then !Find the dimensions of the variable (temp_num_dims) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) if ( temp_num_dims . eq . 3 ) then if ( i_file . eq . 1 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:, surface_level_nc ,:, i_conc ) = temp_var3d_nc (:,:,:) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 1: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )), maxval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )) !write(*,*) comp_var4d_nc(:,:,1,:,i_conc) elseif ( i_file . eq . 2 ) then !In case the comp data is in the uEMEP file then read it here with no vertical extent status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:, surface_level_nc ,:, i_conc ) = temp_var3d_nc (:,:,:) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 2: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )), maxval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )) endif endif if ( temp_num_dims . eq . 4 ) then if ( i_file . eq . 1 ) then !write(*,'(4i)') dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index !write(*,'(4i)') dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , comp_var4d_nc (:,:,:,:, i_conc ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:,:,:, i_conc ) = comp_var4d_nc (:,:,:,:, i_conc ) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 1: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:,:,:, i_conc )), maxval ( comp_var4d_nc (:,:,:,:, i_conc )) elseif ( i_file . eq . 2 ) then !In case the comp data is in the uEMEP file then read it here with no vertical extent status_nc = NF90_GET_VAR ( id_nc , var_id_nc , comp_var4d_nc (:,:, 1 ,:, i_conc ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), 1 , temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 1 , dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:, 1 ,:, i_conc ) = comp_var4d_nc (:,:, 1 ,:, i_conc ) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 2: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:, 1 ,:, i_conc )), maxval ( comp_var4d_nc (:,:, 1 ,:, i_conc )) endif endif else write ( unit_logfile , '(8A,8A)' ) ' Cannot read compound: ' , trim ( var_name_nc_temp ) endif enddo !pollutant enddo !compound loop !endif if ( calculate_deposition_flag . and . i_file . eq . 1 ) then write ( unit_logfile , '(A)' ) ' Reading deposition velocity data from EMEP (cm/s) and converting to m/s: ' do i_depo = 1 , n_landuse_index do p_loop = 1 , n_emep_pollutant_loop i_pollutant = pollutant_loop_index ( p_loop ) var_name_nc_temp = deposition_name_nc ( i_depo , i_pollutant ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , depo_var3d_nc (:,:,:, i_depo , p_loop ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading deposition velocity: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( depo_var3d_nc (:,:,:, i_depo , p_loop )), maxval ( depo_var3d_nc (:,:,:, i_depo , p_loop )) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else !write(unit_logfile,'(8A,8A)') ' Cannot read deposition velocity: ',trim(var_name_nc_temp) endif enddo enddo !Converting to m/s depo_var3d_nc = depo_var3d_nc / 10 0. endif !Loop through the species if (( save_emep_species . or . save_seasalt ). and . i_file . eq . 1 ) then write ( unit_logfile , '(A)' ) ' Reading species data from EMEP: ' do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) if ( ii_sp . eq . sp_soa_index ) then !Read a and b soa species_temp_var3d_nc = 0. pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_asoa_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , sp_asoa_index ) = species_temp_var3d_nc (:,:,:) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_bsoa_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , sp_bsoa_index ) = species_temp_var3d_nc (:,:,:) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pmxx_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) endif if ( ii_sp . eq . sp_sia_index ) then !Read pm10 sia but currently not using. Use the sum of PM2.5 + 0.73*NO3_course instead. This is done at the end of the sia reading pmxx_sp_index = pm10_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_sia_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Read course NO3 pmxx_sp_index = pmco_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_no3_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Set to 0 species_var3d_nc (:,:,:, pm25_sp_index , sp_sia_index ) = 0. !Read pm25(fine) no3 pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_no3_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Read so4 and add to no3 pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_so4_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Read nh4 and add to so4 and no3 pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_nh4_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Add up the species species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) !+ 0.27*species_var3d_nc(:,:,:,pmco_sp_index,i_sp) !Not PM2.5 but PMfine species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) !0.73*species_var3d_nc(:,:,:,pmco_sp_index,i_sp) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm25_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(species_name_nc(pm25_sp_index,i_sp)),sum(species_var3d_nc(:,:,:,pm25_sp_index,i_sp))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(species_name_nc(pm10_sp_index,i_sp)),sum(species_var3d_nc(:,:,:,pm10_sp_index,i_sp))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) endif if ( ii_sp . eq . sp_dust_index ) then !Read dust do pmxx_sp_index = 1 , n_pmxx_sp_index if ( pmxx_sp_index . eq . pm25_sp_index . or . pmco_sp_index . eq . pmxx_sp_index ) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_dust_sah_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_dust_wb_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pmxx_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif if ( ii_sp . eq . sp_seasalt_index ) then !Read seasalt do pmxx_sp_index = 1 , n_pmxx_sp_index if ( pmxx_sp_index . eq . pm25_sp_index . or . pmco_sp_index . eq . pmxx_sp_index ) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_seasalt_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif if ( ii_sp . eq . sp_ffire_index ) then !Read fire pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_ffire_bc_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_ffire_rem_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pmxx_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) endif if ( ii_sp . eq . sp_ppm_index ) then !Read ppm do pmxx_sp_index = 1 , n_pmxx_sp_index if ( pmxx_sp_index . eq . pm25_sp_index . or . pm10_sp_index . eq . pmxx_sp_index ) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_ppm_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif endif enddo endif if ( ii_sp . eq . sp_water_index ) then !Read water pm25 only pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_water_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Set water in pm10 the same as pm25 species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) endif !Should there be 0.27*NO3 here for PM2.5? Check naming!! if ( ii_sp . eq . sp_pm_index ) then !Read total pm do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_pm_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo endif if ( save_emep_OP_species ) then if ( ii_sp . eq . sp_BBOA_index ) then !Read total pm do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_FFIRE_OM_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_FFIRE_BC_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_FFIRE_REM_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif !write(*,*) i_sp,ii_sp,n_species_loop_index,size(species_var3d_nc,5) if ( ii_sp . eq . sp_BBOA_RES_index ) then !Read total pm do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_POM_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_NEW_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_AGE_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_REM_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif endif !species_name_nc(pm10_sp_index,sp_BBOA_index)='pm10_EMEP_BBOA' !species_name_nc(pm25_sp_index,sp_BBOA_index)='pm25_EMEP_BBOA' !species_name_nc(pmco_sp_index,sp_BBOA_index)='pmco_EMEP_BBOA' !species_name_nc(pm10_sp_index,sp_BBOA_RES_index)='pm10_EMEP_BBOA_RES' !species_name_nc(pm25_sp_index,sp_BBOA_RES_index)='pm25_EMEP_BBOA_RES' !species_name_nc(pmco_sp_index,sp_BBOA_RES_index)='pmco_EMEP_BBOA_RES' !species_name_nc(pm25_sp_index,sp_POM_RES_in_index)='SURF_ug_POM_F_RES' !species_name_nc(pm25_sp_index,sp_EC_RES_NEW_in_index)='SURF_ug_EC_F_RES_NEW' !species_name_nc(pm25_sp_index,sp_EC_RES_AGE_in_index)='SURF_ug_EC_F_RES_AGE' !species_name_nc(pm25_sp_index,sp_REM_RES_in_index)='SURF_ug_REMPPM25_RES' !species_name_nc(pm25_sp_index,sp_FFIRE_OM_in_index)='SURF_ug_FFIRE_OM' !species_name_nc(pm25_sp_index,sp_FFIRE_BC_in_index)='SURF_ug_FFIRE_BC' !species_name_nc(pm25_sp_index,sp_FFIRE_REM_in_index)='SURF_ug_FFIRE_REMPPM25' !species_name_nc(pmco_sp_index,sp_EC_RES_in_index)='SURF_ug_EC_C_RES' !species_name_nc(pmco_sp_index,sp_POM_RES_in_index)='SURF_ug_POM_C_RES' !species_name_nc(pmco_sp_index,sp_REM_RES_in_index)='SURF_ug_REMPPM_C_RES' !species_name_nc(pmco_sp_index,sp_FFIRE_in_index)='SURF_ug_FFIRE_C' enddo !sp_index !Derive SOA from the other species. Based on using PMFINE as the pm25 total if ( save_emep_species . and . derive_SOA_from_other_species ) then species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index ) = & species_var3d_nc (:,:,:, pm25_sp_index , sp_pm_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_sia_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_seasalt_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_dust_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_ffire_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_ppm_index ) species_var3d_nc (:,:,:, pm10_sp_index , sp_soa_index ) = species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index ) species_var3d_nc (:,:,:, pm10_sp_index , sp_asoa_index ) = species_var3d_nc (:,:,:, pm25_sp_index , sp_asoa_index ) species_var3d_nc (:,:,:, pm10_sp_index , sp_bsoa_index ) = species_var3d_nc (:,:,:, pm25_sp_index , sp_bsoa_index ) var_name_nc_temp = species_name_nc ( pm25_sp_index , sp_soa_index ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Calculating species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )) where ( species_var3d_nc (:,:,:,:, sp_soa_index ). le . 0 ) species_var3d_nc (:,:,:,:, sp_soa_index ) = 0 write ( unit_logfile , '(A,2A,2f16.4)' ) ' Limitting species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )) !SURF_ug_SOA=SURF_ug_PMFINE- SURF_ug_SO4- SURF_ug_NO3_F- SURF_ug_NH4_F- SURF_ug_SEASALT_F- SURF_ug_DUST_SAH_F- SURF_ug_DUST_WB_F- SURF_ug_FFIRE_REMPPM25- SURF_ug_FFIRE_BC- SURF_ug_PPM2.5 endif !Calculate the total of the parts by adding all and subtracting the total !Do not so this when only using sea salt if ( save_emep_species ) then write ( unit_logfile , '(A)' ) ' Cross check average of species' do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) if ( i_sp . ne . sp_pm_index ) then !Do not include the total here write ( unit_logfile , '(A,2A,2f16.4)' ) ' Average of species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (pm25, pm10): ' , & sum ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )) endif enddo species_temp_var3d_nc (:,:,:) = sum ( species_var3d_nc (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) write ( unit_logfile , '(A,2A,4f16.4)' ) ' Average of: ' , 'pm25' , ' (sum species, total pm, D3, SURF): ' , & sum ( species_temp_var3d_nc (:,:,:)) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( species_var3d_nc (:,:,:, pm25_sp_index , sp_pm_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( comp_var4d_nc (:,:, surface_level_nc ,:, pm25_nc_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( var3d_nc (:,:,:, conc_nc_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )) species_temp_var3d_nc (:,:,:) = sum ( species_var3d_nc (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) write ( unit_logfile , '(A,2A,4f16.4)' ) ' Average of: ' , 'pm10' , ' (sum species, total pm, D3, SURF): ' , & sum ( species_temp_var3d_nc (:,:,:)) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( species_var3d_nc (:,:,:, pm10_sp_index , sp_pm_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( comp_var4d_nc (:,:, surface_level_nc ,:, pm10_nc_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( var3d_nc (:,:,:, conc_nc_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )) endif endif !Read in 2m temperature over the whole period to get the daily average for home heating if ( use_RWC_emission_data ) then DMT_start_time_nc_index = start_time_nc_index DMT_end_time_nc_index = end_time_nc_index DMT_dim_length_nc = DMT_end_time_nc_index - DMT_start_time_nc_index + 1 if (. not . allocated ( DMT_EMEP_grid_nc )) allocate ( DMT_EMEP_grid_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), DMT_dim_length_nc )) if ( calculate_source ( heating_index ). and . i_file . eq . 1 ) then var_name_nc_temp = var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc , start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), DMT_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), DMT_dim_length_nc / )) write ( unit_logfile , '(3A,2f16.4)' ) ' Reading: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc ), maxval ( DMT_EMEP_grid_nc ) DMT_EMEP_grid_nc (:,:, 1 ) = sum ( DMT_EMEP_grid_nc , 3 ) / DMT_dim_length_nc - 27 3.13 write ( unit_logfile , '(3A,2f16.4,a,i0)' ) ' Calculating mean: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc (:,:, 1 )), maxval ( DMT_EMEP_grid_nc (:,:, 1 )), ' over this number of time steps: ' , DMT_dim_length_nc endif endif status_nc = NF90_CLOSE ( id_nc ) enddo !End file loop !Set the correct time dimensions to the first file value dim_length_nc ( time_dim_nc_index ) = valid_dim_length_nc ( time_dim_nc_index ) !Set the grid spacing if ( EMEP_projection_type . eq . LL_projection_index ) then dgrid_nc ( lon_nc_index ) = var1d_nc ( 2 , x_dim_nc_index ) - var1d_nc ( 1 , x_dim_nc_index ) dgrid_nc ( lat_nc_index ) = var1d_nc ( 2 , y_dim_nc_index ) - var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing (lon,lat): ' , dgrid_nc ( lon_nc_index ), dgrid_nc ( lat_nc_index ) else dgrid_nc ( lon_nc_index ) = var1d_nc ( 2 , x_dim_nc_index ) - var1d_nc ( 1 , x_dim_nc_index ) dgrid_nc ( lat_nc_index ) = var1d_nc ( 2 , y_dim_nc_index ) - var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing (x,y) in meters: ' , dgrid_nc ( lon_nc_index ), dgrid_nc ( lat_nc_index ) ! endif !EMEP emissions for traffic do not differentiate between exhaust and nonexhaust !Place the read PM2.5 emissions also into the exhaust emissions. If PM10 is higher then these are then the non-exhaust emissions !This only needs to be done when the EMEP emissions are used and distributed using a proxy but we do it in general anyway !if (local_subgrid_method_flag.eq.3) then !write(unit_logfile,'(A,2es12.2)') ' In: Filling the EMEP exhaust emissions with PM25 emissions ',sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))=var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index)) !write(unit_logfile,'(A,2es12.2)') ' Out: Filling the EMEP exhaust emissions with PM25 emissions ',sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))=var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index)) !var4d_nc(:,:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))=var4d_nc(:,:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index)) !write(unit_logfile,'(A,2es12.2)') ' 3D Filling the EMEP exhaust concentrations with PM25 emissions ',sum(var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !write(unit_logfile,'(A,2es12.2)') ' 4D Filling the EMEP exhaust emissions with PM25 emissions ',sum(var4d_nc(:,:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var4d_nc(:,:,:,:,,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !endif if ( use_alternative_ppm_variable_for_lf ) then write ( unit_logfile , '(4A)' ) ' Replacing variable ' , trim ( var_name_nc ( conc_nc_index , pm25_nc_index , allsource_nc_index )), ' with ' , trim ( var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index )) write ( unit_logfile , '(4A)' ) ' Replacing variable ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , allsource_nc_index )), ' with ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index )) write ( unit_logfile , '(A,f12.3)' ) ' LF PPM2.5 before correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 2 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) write ( unit_logfile , '(A,f12.3)' ) ' LF PPMCO  before correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 1 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) if ( alternative_ppm_variable_for_lf_dim . eq . 4 ) then var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) = var4d_nc (:,:, surface_level_nc ,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,2)=var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm25_nc_index)) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,1)=var4d_nc(:,:,surface_level_nc,:,conc_nc_index,extrasource_nc_index,pollutant_loop_back_index(pm10_nc_index)) !var4d_nc(:,:,:,:,conc_nc_index,allsource_nc_index,pmco_nc_index)=var4d_nc(:,:,:,:,conc_nc_index,extrasource_nc_index,pmco_nc_index) ! write(unit_logfile,'(4A)')' Replacing variable ',trim(var_name_nc(conc_nc_index,pm10_nc_index,allsource_nc_index)),' with ',trim(var_name_nc(conc_nc_index,pm10_nc_index,extrasource_nc_index)) var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) + var4d_nc (:,:, surface_level_nc ,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) elseif ( alternative_ppm_variable_for_lf_dim . eq . 3 ) then var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) = var3d_nc (:,:,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,2)=var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm25_nc_index)) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,1)=var3d_nc(:,:,:,conc_nc_index,extrasource_nc_index,pollutant_loop_back_index(pm10_nc_index)) !var4d_nc(:,:,:,:,conc_nc_index,allsource_nc_index,pmco_nc_index)=var4d_nc(:,:,:,:,conc_nc_index,extrasource_nc_index,pmco_nc_index) ! write(unit_logfile,'(4A)')' Replacing variable ',trim(var_name_nc(conc_nc_index,pm10_nc_index,allsource_nc_index)),' with ',trim(var_name_nc(conc_nc_index,pm10_nc_index,extrasource_nc_index)) !var4d_nc(:,:,surface_level_nc,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm10_nc_index))=var3d_nc(:,:,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm25_nc_index))+var3d_nc(:,:,:,conc_nc_index,extrasource_nc_index,pollutant_loop_back_index(pm10_nc_index)) !var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm10_nc_index))=pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,2)+pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,1) var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = var3d_nc (:,:,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) + var3d_nc (:,:,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) else write ( unit_logfile , '(4A)' ) ' Not replacing variable ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , allsource_nc_index )), ' with ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index )) endif write ( unit_logfile , '(A,f12.3)' ) ' LF PPM2.5 after correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 2 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) write ( unit_logfile , '(A,f12.3)' ) ' LF PPMCO  after correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 1 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) endif !Transfer all source values to all the sources for use in source looping later do i_source = 1 , n_source_nc_index !if (calculate_source(i_source).and.i_source.ne.allsource_nc_index) then if ( i_source . ne . allsource_nc_index ) then var3d_nc (:,:,:, conc_nc_index , i_source ,:) = var3d_nc (:,:,:, conc_nc_index , allsource_nc_index ,:) var4d_nc (:,:,:,:, conc_nc_index , i_source ,:) = var4d_nc (:,:,:,:, conc_nc_index , allsource_nc_index ,:) pm_var4d_nc (:,:,:,:, conc_nc_index , i_source ,:) = pm_var4d_nc (:,:,:,:, conc_nc_index , allsource_nc_index ,:) endif enddo !Transfer local contribution 4d to 3d since this is the only one currently used !write(*,*) shape(var4d_nc) !write(*,*) surface_level_nc lc_var3d_nc = lc_var4d_nc (:,:,:,:, surface_level_nc_2 ,:,:,:,:) !var3d_nc(:,:,:,conc_nc_index,:)=var4d_nc(:,:,surface_level_nc,:,conc_nc_index,:) !Don't do this because if 3d is read then it is obliterated !if (sum(var3d_nc(:,:,:,conc_nc_index,:,:)).eq.0) then var3d_nc (:,:,:, conc_nc_index ,:,:) = var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:,:) !Changed tis from surface_level_nc_2 to surface_level_nc under lf changes !endif !if (sum(comp_var3d_nc(:,:,:,:)).eq.0) then comp_var3d_nc (:,:,:,:) = comp_var4d_nc (:,:, surface_level_nc ,:,:) !endif if ( allocated ( lc_var4d_nc )) deallocate ( lc_var4d_nc ) if ( allocated ( comp_var4d_nc )) deallocate ( comp_var4d_nc ) !Adjust the depositions to be total depositions and not just, for example, N do i_pollutant = 1 , n_emep_pollutant_loop var3d_nc (:,:,:, drydepo_nc_index ,:, i_pollutant ) = var3d_nc (:,:,:, drydepo_nc_index ,:, i_pollutant ) * depo_scale_nc ( pollutant_loop_index ( i_pollutant )) var3d_nc (:,:,:, wetdepo_nc_index ,:, i_pollutant ) = var3d_nc (:,:,:, wetdepo_nc_index ,:, i_pollutant ) * depo_scale_nc ( pollutant_loop_index ( i_pollutant )) enddo !Use average lowest level grid thickness H_emep_temp = sum ( var4d_nc (:,:, surface_level_nc ,:, ZTOP_nc_index , allsource_index , meteo_p_loop_index )) / dim_length_nc ( x_dim_nc_index ) / dim_length_nc ( y_dim_nc_index ) / dim_length_nc ( time_dim_nc_index ) if ( H_emep_temp . ne . 0 ) then H_emep = H_emep_temp write ( unit_logfile , '(A,f8.2)' ) ' Using model depth info. Setting lowest level depth = ' , H_emep else write ( unit_logfile , '(A,f8.2)' ) ' No model depth info available. Setting lowest level depth = ' , H_emep endif H_meteo = H_emep / 2. write ( unit_logfile , '(A,f8.2)' ) ' Setting lowest meteo grid height = ' , H_meteo !var3d_nc(:,:,:,conc_nc_index,:,:)=var4d_nc(:,:,surface_level_nc,:,conc_nc_index,:,:) !For nh3 only use the comp value not the value in the local fraction file !NOTE: TEMPORARY if ( use_comp_temporary ) then write ( * , * ) 'WARNING: TEMPORARALLY USING COMP FOR LF SOURCE SCALING FOR NH3' , pollutant_loop_back_index ( nh3_nc_index ), nh3_nc_index do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . i_source . eq . allsource_index ) then var3d_nc (:,:,:, conc_nc_index , i_source , pollutant_loop_back_index ( nh3_nc_index )) = comp_var3d_nc (:,:,:, nh3_nc_index ) endif enddo endif !At the moment the local contribution based on fraction. Convert to local contributions here !Remove this if we read local contributions in a later version do j = 1 , dim_length_nc ( ydist_dim_nc_index ) do i = 1 , dim_length_nc ( xdist_dim_nc_index ) do p_loop = 1 , n_pollutant_loop !do lc_local_nc_index=minval(lc_local_nc_loop_index),maxval(lc_local_nc_loop_index) do ii = 1 , n_local_fraction_grids lc_local_nc_index = lc_local_nc_loop_index ( ii ) lc_frac_nc_index = lc_frac_nc_loop_index ( ii ) !lc_frac_nc_index=convert_local_to_fraction_loop_index(lc_local_nc_index) !write(*,*) lc_local_nc_index,lc_frac_nc_index if ( pollutant_loop_index ( p_loop ). eq . pm10_nc_index ) then lc_var3d_nc ( i , j ,:,:,:, lc_local_nc_index ,:, p_loop ) = pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, 1 ) * pm_lc_var4d_nc ( i , j ,:,:, surface_level_nc_2 ,:, lc_frac_nc_index ,:, 1 ) & + pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, 2 ) * pm_lc_var4d_nc ( i , j ,:,:, surface_level_nc_2 ,:, lc_frac_nc_index ,:, 2 ) elseif ( pollutant_loop_index ( p_loop ). eq . pm25_nc_index ) then lc_var3d_nc ( i , j ,:,:,:, lc_local_nc_index ,:, p_loop ) = pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, 2 ) * pm_lc_var4d_nc ( i , j ,:,:, surface_level_nc_2 ,:, lc_frac_nc_index ,:, 2 ) else lc_var3d_nc ( i , j ,:,:,:, lc_local_nc_index ,:, p_loop ) = var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, p_loop ) * lc_var3d_nc ( i , j ,:,:,:, lc_frac_nc_index ,:, p_loop ) !This was before, so it used the D3 value, but not the surface value. D3 is not always read !lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop)=max(lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop),var3d_nc(:,:,:,conc_nc_index,:,p_loop)*lc_var3d_nc(i,j,:,:,:,lc_frac_nc_index,:,p_loop)) !Choose the max of the 3d and 4d values, so chooses one or the other !lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop)=pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,:,2)*lc_var3d_nc(i,j,:,:,:,lc_frac_nc_index,:,p_loop) !write(*,*) sum(lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop)),sum(var3d_nc(:,:,:,conc_nc_index,:,p_loop)),sum(lc_var3d_nc(i,j,:,:,:,lc_frac_nc_index,:,p_loop)) endif enddo enddo enddo enddo !Take account of the fact that the GNFR emissions can be version 13 or 19 !In which case traffic is split into 4 and power is split into 2 !This is valid only for the local fraction sources if ( use_GNFR19_emissions_from_EMEP_flag ) then write ( unit_logfile , '(3A,f16.4)' ) ' Aggregating GNFR19 to GNFR13 or GNFR14' !Reset these flags so they are no longer calculated as EMEP contributions after being read !calculate_EMEP_source(traffic_exhaust_nc_index)=.false. !calculate_EMEP_source(traffic_nonexhaust_nc_index)=.false. do lc_local_nc_index = minval ( lc_local_nc_loop_index ), maxval ( lc_local_nc_loop_index ) !No allocation of exhaust emissions to PM10 because only course is read !Is this correct? Removing. PM10 should have been set earlier lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index , pollutant_loop_back_index ( pm25_nc_index )) lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index , pollutant_loop_back_index ( pm25_nc_index )) lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index , pollutant_loop_back_index ( pm25_nc_index )) !Put all source into traffic lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_nc_index ,:) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_nonexhaust_nc_index ,:) !Put the three exhaust into traffic. If exhaust not included then it will be 0 !lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm25_nc_index))=lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_gasoline_nc_index,pollutant_loop_back_index(pm25_nc_index)) & !                                                            +lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_diesel_nc_index,pollutant_loop_back_index(pm25_nc_index)) & !                                                            +lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_gas_nc_index,pollutant_loop_back_index(pm25_nc_index)) !lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm10_nc_index))=lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm25_nc_index)) lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_exhaust_nc_index ,:) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index ,:) !Special case for PM10 because traffic exhaust is not read for PM10 !lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm10_nc_index))=lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm25_nc_index)) !Aggregate the two public powers lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_nc_index ,:) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_point_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_area_nc_index ,:) enddo do lc_local_nc_index = minval ( lc_local_nc_loop_index ), maxval ( lc_local_nc_loop_index ) write ( unit_logfile , '(A,i0,a,f16.4)' ) 'Mean exhaust PM2.5 EMEP contribution centre lc grid: ' , lc_local_nc_index , ' ' & , sum ( lc_var3d_nc ( xdist_centre_nc , ydist_centre_nc ,:,:,:, lc_local_nc_index , traffic_exhaust_nc_index , pollutant_loop_back_index ( pm25_nc_index ))) / ( size ( lc_var3d_nc , 3 ) * size ( lc_var3d_nc , 4 ) * size ( lc_var3d_nc , 5 )) write ( unit_logfile , '(A,i0,a,f16.4)' ) 'Mean nonexhaust PM2.5 EMEP contribution centre lc grid: ' , lc_local_nc_index , ' ' & , sum ( lc_var3d_nc ( xdist_centre_nc , ydist_centre_nc ,:,:,:, lc_local_nc_index , traffic_nonexhaust_nc_index , pollutant_loop_back_index ( pm25_nc_index ))) / ( size ( lc_var3d_nc , 3 ) * size ( lc_var3d_nc , 4 ) * size ( lc_var3d_nc , 5 )) enddo !else !    do lc_local_nc_index=minval(lc_local_nc_loop_index),maxval(lc_local_nc_loop_index) !    lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_nc_index,pollutant_loop_back_index(pmex_nc_index))=0 !    enddo endif !With GNFR19 add up all the traffic emissions and put them in the traffic emissions, according to the use of all or all_totals if ( use_GNFR19_emissions_from_EMEP_flag ) then if ( pollutant_index . eq . all_totals_nc_index ) write ( unit_logfile , '(A)' ) 'Aggregating exhaust and non-exhaust traffic emissions when using GNFR19: ' if ( pollutant_index . eq . all_nc_index ) write ( unit_logfile , '(A)' ) 'Aggregating exhaust and non-exhaust traffic emissions seperately when using GNFR19: ' !Aggregate exhaust emissions var3d_nc (:,:,:, emis_nc_index , traffic_exhaust_nc_index ,:) = var3d_nc (:,:,:, emis_nc_index , traffic_gasoline_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_diesel_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_gas_nc_index ,:) !Aggregating total emissions var3d_nc (:,:,:, emis_nc_index , traffic_nc_index ,:) = var3d_nc (:,:,:, emis_nc_index , traffic_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_exhaust_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_nonexhaust_nc_index ,:) !Aggregating public power emissions var3d_nc (:,:,:, emis_nc_index , publicpower_nc_index ,:) = var3d_nc (:,:,:, emis_nc_index , publicpower_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , publicpower_point_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , publicpower_area_nc_index ,:) endif !Scale the read in voc emissions so they are split into benzene if ( extract_benzene_from_voc_emissions ) then write ( unit_logfile , '(A)' ) 'Converting VOC emissions to Benzene emissions: ' do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . save_EMEP_source ( i_source )) then var3d_nc (:,:,:, emis_nc_index , i_source , pollutant_loop_back_index ( c6h6_nc_index )) = benzene_split_voc_in_GNFR_sectors ( uEMEP_to_EMEP_sector ( i_source )) * var3d_nc (:,:,:, emis_nc_index , i_source , pollutant_loop_back_index ( c6h6_nc_index )) write ( unit_logfile , '(A,i4,a,a,a,f12.3)' ) 'GNFR Source=' , uEMEP_to_EMEP_sector ( i_source ), ' , uEMEP source= ' , trim ( source_file_str ( i_source )), ' , split(%)= ' , benzene_split_voc_in_GNFR_sectors ( uEMEP_to_EMEP_sector ( i_source )) * 10 0. endif enddo endif !Check output for PM10. Not needed anymore !do i_source=1,n_source_index !    if (calculate_source(i_source).or.calculate_EMEP_source(i_source).or.save_EMEP_source(i_source)) then !    do lc_local_nc_index=minval(lc_local_nc_loop_index),maxval(lc_local_nc_loop_index) !        p_loop=pollutant_loop_back_index(pm10_nc_index) !        write(unit_logfile,'(3A,f16.4)') ' Average local contribution of: ',trim(var_name_nc(conc_nc_index,pm10_nc_index,allsource_index)),' '//trim(source_file_str(i_source)), & !        sum(lc_var3d_nc(xdist_centre_nc,ydist_centre_nc,:,:,:,lc_local_nc_index,i_source,p_loop))/(size(lc_var3d_nc,3)*size(lc_var3d_nc,4)*size(lc_var3d_nc,5)) !    enddo !    endif !enddo if ( allocated ( pm_lc_var4d_nc )) deallocate ( pm_lc_var4d_nc ) if ( allocated ( pm_var4d_nc )) deallocate ( pm_var4d_nc ) if ( allocated ( pm_var3d_nc )) deallocate ( pm_var3d_nc ) !Set the local grid contribution for the individual grid !write(*,*) shape(lc_var4d_nc) !write(*,*) shape(var4d_nc) !Commented out as these are not used? !Reset these variables to what they would be with 1 EMEP grid !Not necessary once the rest of the code is adapted to the loop data frac_nc_index = num_var_nc_start + 1 lc_frac_nc_index = 1 local_nc_index = num_var_nc_start + n_local_fraction_grids + 1 lc_local_nc_index = n_local_fraction_grids + 1 !This is no longer in use, but just in case set the variables to the first EMEP LC grid var3d_nc (:,:,:, frac_nc_index ,:,:) = lc_var3d_nc ( xdist_centre_nc , ydist_centre_nc ,:,:,:, lc_frac_nc_index ,:,:) var3d_nc (:,:,:, local_nc_index ,:,:) = var3d_nc (:,:,:, conc_nc_index ,:,:) * var3d_nc (:,:,:, frac_nc_index ,:,:) !write(*,*) minval(var4d_nc(:,:,:,:,local_nc_index,:)),maxval(var4d_nc(:,:,:,:,local_nc_index,:)) !write(*,*) minval(var4d_nc(:,:,:,:,frac_nc_index,:)),maxval(var4d_nc(:,:,:,:,frac_nc_index,:)) !write(*,*) minval(var3d_nc(:,:,:,frac_nc_index,:)),maxval(var3d_nc(:,:,:,frac_nc_index,:)) !write(*,*) minval(var4d_nc(:,:,:,:,conc_nc_index,:)),maxval(var4d_nc(:,:,:,:,conc_nc_index,:)) !write(*,*) minval(var3d_nc(:,:,:,conc_nc_index,:)),maxval(var3d_nc(:,:,:,conc_nc_index,:)) !write(*,*) minval(var3d_nc(:,:,:,inv_FF10_nc_index,allsource_index)),maxval(var3d_nc(:,:,:,inv_FF10_nc_index,allsource_index)) !write(*,*) minval(var3d_nc(:,:,:,FF10_nc_index,allsource_index)),maxval(var3d_nc(:,:,:,FF10_nc_index,allsource_index)) where ( var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ). lt . ustar_min ) var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ) = ustar_min !Test for 0 wind speed components if valid if (. not . EMEP_region_outside_domain ) then do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) do t = 1 , dim_length_nc ( time_dim_nc_index ) if ( var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. . and . var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. ) then write ( unit_logfile , '(a,3i0)' ) 'Zero wind fields at (i,j,t): ' , i , j , t !Search for the nearest non double zero value k = 0 nonzero_wind_notfound = . true . do while ( k . lt . 2 0. and . nonzero_wind_notfound ) k = k + 1 do ii =- k , k do jj =- k , k iii = i + ii jjj = j + jj iii = min ( max ( 1 , iii ), dim_length_nc ( x_dim_nc_index )) jjj = min ( max ( 1 , jjj ), dim_length_nc ( y_dim_nc_index )) if ( var4d_nc ( iii , jjj , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ). ne . 0. & . or . var4d_nc ( iii , jjj , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ). ne . 0. ) then nonzero_wind_notfound = . false . var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = var4d_nc ( iii , jjj , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ) var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = var4d_nc ( iii , jjj , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) !write(unit_logfile,'(a,4i,2f10.2)') 'Wind found for (i,j,t): ',k,i,j,t,var4d_nc(i,j,surface_level_nc,t,ugrid_nc_index,allsource_nc_index,meteo_p_loop_index),var4d_nc(i,j,surface_level_nc,t,vgrid_nc_index,allsource_nc_index,meteo_p_loop_index) endif enddo enddo enddo if ( nonzero_wind_notfound ) then write ( unit_logfile , '(a,4i0,2f10.2)' ) 'Wind not found for (loop,i,j,t): ' , k , i , j , t , var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ), var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) else write ( unit_logfile , '(a,4i0,2f10.2)' ) 'Wind found for (loop,i,j,t): ' , k , i , j , t , var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ), var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) endif endif enddo enddo enddo do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) do t = 1 , dim_length_nc ( time_dim_nc_index ) if ( var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. . and . var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. ) then write ( unit_logfile , '(a,3i0)' ) 'ERROR: Found zero wind fields in both components (i,j,t). Stopping: ' , i , j , t stop endif enddo enddo enddo endif !If no logz0 available. Set to log(0.1) !For urban areas a value of 0.3 is used where ( var3d_nc (:,:,:, logz0_nc_index ,:, meteo_p_loop_index ). eq . 0.0 ) var3d_nc (:,:,:, logz0_nc_index ,:, meteo_p_loop_index ) = log ( 0.3 ) if ( replace_z0 . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing z0 everywhere with: ' , replace_z0 var3d_nc (:,:,:, logz0_nc_index ,:, meteo_p_loop_index ) = log ( replace_z0 ) endif if ( replace_invL . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing inverse L everywhere with: ' , replace_invL var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ) = replace_invL endif if ( replace_hmix . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing HMIX everywhere with: ' , replace_hmix var3d_nc (:,:,:, hmix_nc_index ,:, meteo_p_loop_index ) = replace_hmix endif if ( use_phi_for_invL ) then phi_count = 0 mean_phi_temp = 0 mean_invL_temp = 0 do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) do t = 1 , dim_length_nc ( time_dim_nc_index ) call TROENKz_invL_from_phi ( z_invL , var3d_nc ( i , j , t , phi_nc_index , allsource_nc_index , meteo_p_loop_index ), var3d_nc ( i , j , t , invL_nc_index , allsource_nc_index , meteo_p_loop_index )) phi_count = phi_count + 1 mean_phi_temp = mean_phi_temp + var3d_nc ( i , j , t , phi_nc_index , allsource_nc_index , meteo_p_loop_index ) mean_invL_temp = mean_invL_temp + var3d_nc ( i , j , t , invL_nc_index , allsource_nc_index , meteo_p_loop_index ) enddo enddo enddo mean_phi_temp = mean_phi_temp / phi_count mean_invL_temp = mean_invL_temp / phi_count write ( unit_logfile , '(A,2f8.4)' ) ' Using phi instead of invL. Mean phi and invL: ' , mean_phi_temp , mean_invL_temp endif !Limit stable L to lowest_stable_L and to lowest_unstable_L (negative number) for unstable. where ( var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ). lt . 1.0 / lowest_unstable_L ) var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ) = 1.0 / lowest_unstable_L where ( var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ). gt . 1.0 / lowest_stable_L ) var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ) = 1.0 / lowest_stable_L where ( var3d_nc (:,:,:, hmix_nc_index ,:, meteo_p_loop_index ). lt . hmix_min ) var3d_nc (:,:,:, hmix_nc_index ,:, meteo_p_loop_index ) = hmix_min !Limit Jd as well in case there is something wrong where ( var4d_nc (:,:,:,:, J_nc_index ,:,:). lt . 0 ) var4d_nc (:,:,:,:, J_nc_index ,:,:) = 0. if ( J_scale . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Scaling J(NO2) everywhere with: ' , J_scale var4d_nc (:,:,:,:, J_nc_index ,:,:) = var4d_nc (:,:,:,:, J_nc_index ,:,:) * J_scale endif !Correct the inverse of the wind speed for the factor 0.2 used to create it in EMEP write ( unit_logfile , '(A)' ) ' Correcting inverse wind speed to account for the 0.2 m/s offset: ' var3d_nc (:,:,:, inv_FF10_nc_index ,:,:) = var3d_nc (:,:,:, inv_FF10_nc_index ,:,:) / ( 1. - 0.2 * var3d_nc (:,:,:, inv_FF10_nc_index ,:,:)) var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:) = var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:) / ( 1. - 0.2 * var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:)) var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:) = var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:) / ( 1. - 0.2 * var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:)) where ( var3d_nc (:,:,:, inv_FF10_nc_index ,:,:). gt . 4.5 ) var3d_nc (:,:,:, inv_FF10_nc_index ,:,:) = 4.5 !Set the limit so that FF can not be less than 0.2222 where ( var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:). gt . 4.5 ) var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:) = 4.5 !Set the limit so that FF can not be less than 0.2222 where ( var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:). gt . 4.5 ) var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:) = 4.5 !Set the limit so that FF can not be less than 0.2222 if ( FF_scale . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rescaling wind fields everywhere with factor: ' , FF_scale var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, inv_FF10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, inv_FF10_nc_index ,:, meteo_p_loop_index ) / FF_scale var3d_nc (:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, u10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, u10_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, v10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, v10_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) / FF_scale var4d_nc (:,:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) = var4d_nc (:,:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var4d_nc (:,:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) = var4d_nc (:,:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) = var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) / FF_scale endif if ( FF10_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Offsetting 10 m wind fields everywhere with a value: ' , FF10_offset var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) + FF10_offset endif if ( DD_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rotating wind fields everywhere with a value: ' , DD_offset !Make use of the spare source index parts of the array for the conversion temp_var4d_nc = 0 temp_var4d_nc (:,:,:,:, 1 ) = var4d_nc (:,:,:,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) + var4d_nc (:,:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) temp_var4d_nc (:,:,:,:, 2 ) =- var4d_nc (:,:,:,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) + var4d_nc (:,:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) var4d_nc (:,:,:,:, ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:,:, 1 ) var4d_nc (:,:,:,:, vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:,:, 2 ) temp_var4d_nc = 0 temp_var4d_nc (:,:,:, 1 , 1 ) = var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) + var3d_nc (:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) temp_var4d_nc (:,:,:, 1 , 2 ) =- var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) + var3d_nc (:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) var3d_nc (:,:,:, u10_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:, 1 , 1 ) var3d_nc (:,:,:, v10_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:, 1 , 2 ) endif !Set the magnitude of the gridded wind fields. Should probably be done after subgridding? var4d_nc (:,:,:,:, FFgrid_nc_index , allsource_index , meteo_p_loop_index ) = sqrt ( var4d_nc (:,:,:,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) ** 2 + var4d_nc (:,:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) ** 2 ) !Will override the read in FF10 if it is available if ( sum ( abs ( var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ))). ne . 0. and . sum ( abs ( var3d_nc (:,:,:, v10_nc_index , allsource_index , meteo_p_loop_index ))). ne . 0 ) then wind_vectors_10m_available = . true . var3d_nc (:,:,:, FF10_nc_index , allsource_index , meteo_p_loop_index ) = sqrt ( var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ) ** 2 + var3d_nc (:,:,:, v10_nc_index , allsource_index , meteo_p_loop_index ) ** 2 ) endif write ( unit_logfile , '(A,L)' ) ' 10 m wind vectors available: ' , wind_vectors_10m_available !Check EMEP time date_num_temp = dble ( ceiling ( val_dim_nc ( 1 , time_dim_nc_index ) * 2 4. )) / 2 4. call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) write ( unit_logfile , '(a,i6)' ) ' Time dimension EMEP:  ' , dim_length_nc ( time_dim_nc_index ) write ( unit_logfile , '(a,6i6)' ) ' Date start EMEP =  ' , date_array date_num_temp = dble ( ceiling ( val_dim_nc ( dim_length_nc ( time_dim_nc_index ), time_dim_nc_index ) * 2 4. )) / 2 4. call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) write ( unit_logfile , '(a,6i6)' ) ' Date end EMEP =    ' , date_array !Test and correct dates if ( 1. eq . 1 ) then if (. not . allocated ( time_seconds_output )) allocate ( time_seconds_output ( dim_length_nc ( time_dim_nc_index ))) do t = 1 , dim_length_nc ( time_dim_nc_index ) date_num_temp = dble ( ceiling ( val_dim_nc ( t , time_dim_nc_index ) * 2 4. )) / 2 4. date_num_temp = val_dim_nc ( t , time_dim_nc_index ) + 0.55 / 2 4. !Add a bit over half an hour to compensate for average of time call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) !write(unit_logfile,'(a,i4,6i6,d)') ' Date EMEP =   ',t,date_array,date_num_temp date_array ( 5 : 6 ) = 0 !Set minutes and hours to 0 date_num_temp = date_to_number ( date_array , ref_year_EMEP ) call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) !write(unit_logfile,'(a,i4,6i6,d)') ' Date EMEP =   ',t,date_array,date_num_temp !val_dim_nc(t,time_dim_nc_index)=ceiling(date_num_temp*dble(24.)*dble(3600.))/dble(24.)/dble(3600.) date_num_temp = date_num_temp + dble ( 0.01 ) / dble ( 2 4. ) / dble ( 360 0. ) !Add 0.01 of a second to avoid any rounding off errors call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) !write(unit_logfile,'(a,i4,6i6,d)') ' Date EMEP =   ',t,date_array,date_num_temp val_dim_nc ( t , time_dim_nc_index ) = date_num_temp !Convert to seconds since 2000 date_array = 0 date_array ( 1 ) = 2000 ; date_array ( 2 ) = 1 ; date_array ( 3 ) = 1 date_num_2000 = date_to_number ( date_array , ref_year_EMEP ) time_seconds_output ( t ) = int (( date_num_temp - date_num_2000 ) * 24 * 3600 , kind = 4 ) unit_dim_nc ( time_dim_nc_index ) = \"seconds since 2000-1-1 0:0:0\" ;; enddo !stop endif !Test for Ceclius or Kelvin if ( maxval ( var3d_nc (:,:,:, t2m_nc_index ,:, meteo_p_loop_index )). lt . 150 ) then write ( unit_logfile , '(a,f12.2)' ) 'WARNING: Temperature appears to be in Celcius. Converting to Kelvin. Max temperature is: ' , maxval ( var3d_nc (:,:,:, T2m_nc_index ,:, meteo_p_loop_index )) var3d_nc (:,:,:, t2m_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, T2m_nc_index ,:, meteo_p_loop_index ) + 27 3.13 endif !Deallocate temporary arrays if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( var3d_nc_dp )) deallocate ( var3d_nc_dp ) if ( allocated ( var4d_nc_dp )) deallocate ( var4d_nc_dp ) if ( allocated ( temp_var4d_nc )) deallocate ( temp_var4d_nc ) if ( allocated ( temp_var3d_nc )) deallocate ( temp_var3d_nc ) if ( allocated ( species_temp_var3d_nc )) deallocate ( species_temp_var3d_nc ) !Shift the EMEP grid to the west by 0.1 degrees. Portugal test !var1d_nc(:,x_dim_nc_index)=var1d_nc(:,x_dim_nc_index)-0.1 end subroutine uEMEP_read_EMEP","tags":"","loc":"proc/uemep_read_emep.html"},{"title":"uEMEP_read_RWC_heating_data – uEMEP","text":"public  subroutine uEMEP_read_RWC_heating_data() Uses uEMEP_definitions netcdf Arguments None Source Code subroutine uEMEP_read_RWC_heating_data use uEMEP_definitions use netcdf implicit none logical exists logical nxtdat_flag integer source_index character ( 256 ) header_str ( 5 ) integer count , count_grid integer unit_in integer RWC_pm25_index , RWC_pm10_index , RWC_nox_index parameter ( RWC_pm25_index = 1 , RWC_pm10_index = 2 , RWC_nox_index = 3 ) integer RWC_HDD5_index , RWC_HDD8_index , RWC_HDD11_index , RWC_HDD15_index parameter ( RWC_HDD5_index = 1 , RWC_HDD8_index = 2 , RWC_HDD11_index = 3 , RWC_HDD15_index = 4 ) integer * 8 ssb_id real x_ssb , y_ssb , lon_ssb , lat_ssb integer i_ssb_index , j_ssb_index integer :: threshold_index = 0 real :: f_easting = 2.e6 real :: ssb_dx = 25 0. , ssb_dy = 25 0. integer RWC_compound_index real sum_RWC_grid_emission ( 3 ) real sum_RWC_grid_height ( 3 ) integer :: subsource_index = 1 real emission_scaling ( 3 ) logical :: read_file_with_nox_and_kommune_number = . true . integer :: n_region_max , n_region_back_max parameter ( n_region_max = 1000 , n_region_back_max = 10000 ) integer :: region_scaling_id ( n_region_max ) = 0 real total_emissions ( n_compound_nc_index ) integer region_scaling_id_back_index ( n_region_back_max ) real , allocatable :: region_heating_scaling (:,:) integer n_region , k , k_index integer , allocatable :: count_subgrid (:,:) real , allocatable :: emission_properties_subgrid_sigz00_temp (:,:) integer :: io integer i_pollutant if ( filename_heating ( RWC_heating_index ). eq . '' ) then write ( unit_logfile , '(A)' ) 'WARNING: No RWC heating data file available. Will not use RWC data' return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading RWC heating data  (uEMEP_read_RWC_heating_data)' write ( unit_logfile , '(A)' ) '================================================================' !threshold_index=RWC_HDD15_index if ( HDD_threshold_value . eq . 15 ) then threshold_index = RWC_HDD15_index elseif ( HDD_threshold_value . eq . 11 ) then threshold_index = RWC_HDD11_index elseif ( HDD_threshold_value . eq . 8 ) then threshold_index = RWC_HDD8_index elseif ( HDD_threshold_value . eq . 5 ) then threshold_index = RWC_HDD5_index else write ( unit_logfile , '(A,i6)' ) 'HDD_threshold_value is not valid. Stopping. ' , HDD_threshold_value stop endif write ( unit_logfile , '(A,2i6)' ) 'HDD_threshold_value and index = ' , HDD_threshold_value , threshold_index if ( read_RWC_file_with_extra_HDD ) write ( unit_logfile , '(A,L)' ) 'read_RWC_file_with_extra_HDD = ' , read_RWC_file_with_extra_HDD if ( read_RWC_file_with_extra_HDD_and_height ) write ( unit_logfile , '(A,L)' ) 'read_RWC_file_with_extra_HDD_and_height = ' , read_RWC_file_with_extra_HDD_and_height subsource_index = 1 !Emission scaling for nox compared to pm25. emission_scaling = 1. emission_scaling ( RWC_nox_index ) = emission_factor ( nox_index , heating_index , subsource_index ) / emission_factor ( pm25_index , heating_index , subsource_index ) write ( unit_logfile , '(A,f12.4,2es12.2)' ) 'NOx/PM2.5 emission ratio =' , emission_scaling ( RWC_nox_index ), emission_factor ( nox_index , heating_index , subsource_index ), emission_factor ( pm25_index , heating_index , subsource_index ) source_index = heating_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. !Read in the data in the first g_loop and t_loop if ( first_g_loop ) then !if (g_loop.eq.1) then pathfilename_heating ( RWC_heating_index ) = trim ( pathname_heating ( RWC_heating_index )) // trim ( filename_heating ( RWC_heating_index )) !Test existence of the heating filename. If does not exist then stop inquire ( file = trim ( pathfilename_heating ( RWC_heating_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: RWC file does not exist: ' , trim ( pathfilename_heating ( RWC_heating_index )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_heating ( RWC_heating_index ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening RWC heating file ' // trim ( pathfilename_heating ( RWC_heating_index )) rewind ( unit_in ) !read (unit_in,'(a)') header_str(1) ! read (unit_in,'(a)') header_str(2) !read (unit_in,'(a)') header_str(3) !write(*,*) header_str(1:3) call nxtdat ( unit_in , nxtdat_flag ) !Read number of grids read ( unit_in , '(i)' ) n_RWC_grids write ( unit_logfile , '(A,i)' ) 'Number of RWC grids =' , n_RWC_grids !Allocate the arrays in the first g_loop and t_loop allocate ( RWC_grid_emission ( n_RWC_grids , 3 )) allocate ( RWC_grid_HDD ( n_RWC_grids , 4 )) allocate ( RWC_grid_id ( n_RWC_grids )) allocate ( RWC_grid_height ( n_RWC_grids , 2 )) allocate ( RWC_region_id ( n_RWC_grids )) !Read header      SSBID    PM25_2016    PM10_2016       HDD_11       HDD_15 read ( unit_in , * ) header_str ! write(unit_logfile,'(6A24)') 'Headers: ',trim(header_str(1)),trim(header_str(2)),trim(header_str(3)),trim(header_str(4)),trim(header_str(5)) count = 0 RWC_grid_emission = 0. if ( read_RWC_file_with_extra_HDD_and_height ) then !Read new version do count = count + 1 read ( unit_in , * , iostat = io ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_emission ( count , RWC_nox_index ), RWC_grid_HDD ( count , RWC_HDD5_index ), RWC_grid_HDD ( count , RWC_HDD8_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ), RWC_grid_height ( count , 1 ), RWC_grid_height ( count , 2 ), RWC_region_id ( count ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(i,9es,i)') RWC_grid_id(count),RWC_grid_emission(count,RWC_pm25_index),RWC_grid_emission(count,RWC_pm10_index),RWC_grid_emission(count,RWC_nox_index),RWC_grid_HDD(count,RWC_HDD5_index),RWC_grid_HDD(count,RWC_HDD8_index),RWC_grid_HDD(count,RWC_HDD11_index),RWC_grid_HDD(count,RWC_HDD15_index),RWC_grid_height(count,1),RWC_grid_height(count,2),RWC_region_id(count) if ( count == n_RWC_grids ) then exit end if enddo elseif ( read_RWC_file_with_extra_HDD ) then !Read new version do count = count + 1 read ( unit_in , * , iostat = io ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_emission ( count , RWC_nox_index ), RWC_grid_HDD ( count , RWC_HDD5_index ), RWC_grid_HDD ( count , RWC_HDD8_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ), RWC_region_id ( count ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(i,5es,i)') RWC_grid_id(count),RWC_grid_emission(count,RWC_pm25_index),RWC_grid_emission(count,RWC_pm10_index),RWC_grid_emission(count,RWC_nox_index),RWC_grid_HDD(count,RWC_HDD11_index),RWC_grid_HDD(count,RWC_HDD15_index),RWC_region_id(count) enddo elseif ( read_file_with_nox_and_kommune_number ) then !Read new version do count = count + 1 read ( unit_in , * , iostat = io ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_emission ( count , RWC_nox_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ), RWC_region_id ( count ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(i,5es,i)') RWC_grid_id(count),RWC_grid_emission(count,RWC_pm25_index),RWC_grid_emission(count,RWC_pm10_index),RWC_grid_emission(count,RWC_nox_index),RWC_grid_HDD(count,RWC_HDD11_index),RWC_grid_HDD(count,RWC_HDD15_index),RWC_region_id(count) enddo else !Read old version do count = count + 1 !read(unit_in,'(i,4es)') RWC_grid_id(count),RWC_grid_val(count,1:4) read ( unit_in , * ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(2i,4es)') count,RWC_grid_id(count),RWC_grid_val(count,1:4) RWC_grid_emission ( count , RWC_nox_index ) = RWC_grid_emission ( count , RWC_pm25_index ) * emission_scaling ( RWC_nox_index ) RWC_region_id ( count ) = 1 enddo endif !For annual calculations use the provided emissions in g/year without any HDD if ( annual_calculations ) then RWC_grid_HDD = 1. endif if ( count . ne . n_RWC_grids ) then write ( unit_logfile , '(A,2i)' ) 'ERROR: Total number of RWC grids in file is not the same as given. Stopping: ' , n_RWC_grids , count stop endif write ( unit_logfile , '(A,i)' ) 'Total number of RWC grids read =' , count write ( unit_logfile , '(A,3f12.2)' ) 'Total emissions PM2.5, PM10 and NOX (tonne/year) =' , sum ( RWC_grid_emission (:, RWC_pm25_index )) / 1.e6 , sum ( RWC_grid_emission (:, RWC_pm10_index )) / 1.e6 , sum ( RWC_grid_emission (:, RWC_nox_index )) / 1.e6 endif !Read in regional scaling data if available pathfilename_region_heating_scaling = trim ( inpath_region_heating_scaling ) // trim ( infile_region_heating_scaling ) !Test existence of the filename. If does not exist then use default inquire ( file = trim ( pathfilename_region_heating_scaling ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' WARNING: Regional heating scaling data file does not exist and no scaling will be applied: ' , trim ( pathfilename_region_heating_scaling ) n_region = 1 region_scaling_id_back_index = n_region allocate ( region_heating_scaling ( n_region , n_compound_nc_index )) region_heating_scaling = 1. else unit_in = 20 open ( unit_in , file = pathfilename_region_heating_scaling , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening regional scaling heating file: ' // trim ( pathfilename_region_heating_scaling ) !Skip over header lines starting with * rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !Read the data read ( unit_in , * , ERR = 10 ) n_region write ( unit_logfile , '(a,i)' ) ' Number of regions read: ' , n_region if ( allocated ( region_heating_scaling )) deallocate ( region_heating_scaling ) allocate ( region_heating_scaling ( n_region , n_compound_nc_index )) call nxtdat ( unit_in , nxtdat_flag ) do k = 1 , n_region read ( unit_in , * , ERR = 10 ) & k_index , region_scaling_id ( k ), & total_emissions ( pm25_index ), total_emissions ( pm10_index ), total_emissions ( nox_index ), & region_heating_scaling ( k , pm25_nc_index ), region_heating_scaling ( k , pm10_nc_index ), region_heating_scaling ( k , nox_nc_index ) !write(*,'(2i,3es10.2,3f10.3)')  & !    k_index,region_scaling_id(k), & !    total_emissions(pm25_index),total_emissions(pm10_index),total_emissions(nox_index), & !    region_heating_scaling(k,pm25_nc_index),region_heating_scaling(k,pm10_nc_index),region_heating_scaling(k,nox_nc_index) !Set a back referencing value for speed. Note the region_scaling_id cannot be larger than the hardcoded dimensions region_scaling_id_back_index ( region_scaling_id ( k )) = k enddo close ( unit_in , status = 'keep' ) endif !Put the data into the subgrid for all g_loop calls if ( allocated ( count_subgrid )) deallocate ( count_subgrid ) allocate ( count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) count_subgrid = 0 count_grid = 0 sum_RWC_grid_emission = 0 sum_RWC_grid_height = 0 if ( read_RWC_file_with_extra_HDD_and_height ) then !Set the existing heights to 0 as these will be replaced emission_properties_subgrid (:,:, emission_h_index , source_index ) = 0 endif if ( read_RWC_file_with_extra_HDD_and_height ) then !Set the existing heights to 0 as these will be replaced if ( allocated ( emission_properties_subgrid_sigz00_temp )) deallocate ( emission_properties_subgrid_sigz00_temp ) allocate ( emission_properties_subgrid_sigz00_temp ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) emission_properties_subgrid_sigz00_temp = 0. endif do count = 1 , n_RWC_grids ssb_id = RWC_grid_id ( count ) x_ssb = ssb_id / 10000000 - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. !Convert to EMEP coordinates. SSB data always in UTM coordinates if ( save_emissions_for_EMEP ( heating_index )) then call utm2ll ( 1 , utm_zone , y_ssb , x_ssb , lat_ssb , lon_ssb ) if ( EMEP_projection_type . eq . LL_projection_index ) then x_ssb = lon_ssb y_ssb = lat_ssb elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ssb , y_ssb , lon_ssb , lat_ssb , EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ssb , y_ssb , lon_ssb , lat_ssb , EMEP_projection_attributes ) endif endif k = region_scaling_id_back_index ( RWC_region_id ( count )) if ( k . lt . 1. or . k . gt . n_region ) then write ( unit_logfile , '(A,4i)' ) ' ERROR: Region index out of bounds, stopping: ' , count , RWC_region_id ( count ), k , n_region stop endif !Find the grid index it belongs to i_ssb_index = 1 + floor (( x_ssb - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ssb_index = 1 + floor (( y_ssb - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then !write(*,*) x_ssb,y_ssb,emission_subgrid_delta(x_dim_index,source_index),i_ssb_index,j_ssb_index !Set the proxy emssion subgrid. This will be multiplied by the hdd later in the read_time_profiles routine do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then RWC_compound_index = RWC_pm10_index proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) & + RWC_grid_emission ( count , RWC_compound_index ) / RWC_grid_HDD ( count , threshold_index ) * region_heating_scaling ( k , pm10_nc_index ) sum_RWC_grid_emission ( RWC_compound_index ) = sum_RWC_grid_emission ( RWC_compound_index ) + RWC_grid_emission ( count , RWC_compound_index ) elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then RWC_compound_index = RWC_pm25_index proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) & + RWC_grid_emission ( count , RWC_compound_index ) / RWC_grid_HDD ( count , threshold_index ) * region_heating_scaling ( k , pm25_nc_index ) sum_RWC_grid_emission ( RWC_compound_index ) = sum_RWC_grid_emission ( RWC_compound_index ) + RWC_grid_emission ( count , RWC_compound_index ) elseif ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then RWC_compound_index = RWC_nox_index proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) & + RWC_grid_emission ( count , RWC_compound_index ) / RWC_grid_HDD ( count , threshold_index ) * region_heating_scaling ( k , nox_nc_index ) sum_RWC_grid_emission ( RWC_compound_index ) = sum_RWC_grid_emission ( RWC_compound_index ) + RWC_grid_emission ( count , RWC_compound_index ) endif enddo if ( read_RWC_file_with_extra_HDD_and_height ) then !Replace the existing height that is given by h_emis emission_properties_subgrid ( i_ssb_index , j_ssb_index , emission_h_index , source_index ) = emission_properties_subgrid ( i_ssb_index , j_ssb_index , emission_h_index , source_index ) + RWC_grid_height ( count , 1 ) sum_RWC_grid_height ( 1 ) = sum_RWC_grid_height ( 1 ) + RWC_grid_height ( count , 1 ) !Add additional standard deviation to the pre-existing value based on variability within the sub-grid !emission_properties_subgrid(i_ssb_index,j_ssb_index,emission_sigz00_index,source_index)=sqrt(emission_properties_subgrid(i_ssb_index,j_ssb_index,emission_sigz00_index,source_index)**2+RWC_grid_height(count,2)**2) emission_properties_subgrid_sigz00_temp ( i_ssb_index , j_ssb_index ) = emission_properties_subgrid_sigz00_temp ( i_ssb_index , j_ssb_index ) + RWC_grid_height ( count , 2 ) ** 2 sum_RWC_grid_height ( 2 ) = sum_RWC_grid_height ( 2 ) + RWC_grid_height ( count , 2 ) ** 2 sum_RWC_grid_height ( 3 ) = sum_RWC_grid_height ( 3 ) + emission_properties_subgrid_sigz00_temp ( i_ssb_index , j_ssb_index ) endif !write(*,*) count,i_ssb_index,j_ssb_index,emission_subgrid_dim(x_dim_index,source_index),emission_subgrid_dim(y_dim_index,source_index) count_subgrid ( i_ssb_index , j_ssb_index ) = count_subgrid ( i_ssb_index , j_ssb_index ) + 1 count_grid = count_grid + 1 endif enddo !It is assumed that it is possible that more than one ssb_grid can be found in a subgrid, so the total becomes the mean, no weighted avraging if ( read_RWC_file_with_extra_HDD_and_height ) then where ( count_subgrid . gt . 0 ) emission_properties_subgrid (:,:, emission_h_index , source_index ) = emission_properties_subgrid (:,:, emission_h_index , source_index ) / count_subgrid !where(count_subgrid.gt.0) emission_properties_subgrid(:,:,emission_sigz00_index,source_index)=emission_properties_subgrid(:,:,emission_sigz00_index,source_index)/count_subgrid where ( count_subgrid . gt . 0 ) emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) = sqrt ( emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) ** 2 + emission_properties_subgrid_sigz00_temp / count_subgrid ) endif write ( unit_logfile , '(A,i)' ) 'Number of RWC grid placements in emission subgrid =' , count_grid do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then RWC_compound_index = RWC_pm10_index write ( unit_logfile , '(A,f12.2)' ) 'Total subgrid RWC emissions for ' // trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // ' (tonne/year) =' , sum_RWC_grid_emission ( RWC_compound_index ) / 1.e6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then RWC_compound_index = RWC_pm25_index write ( unit_logfile , '(A,f12.2)' ) 'Total subgrid RWC emissions for ' // trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // ' (tonne/year) =' , sum_RWC_grid_emission ( RWC_compound_index ) / 1.e6 elseif ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then RWC_compound_index = RWC_nox_index write ( unit_logfile , '(A,f12.2)' ) 'Total subgrid RWC emissions for ' // trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // ' (tonne/year) =' , sum_RWC_grid_emission ( RWC_compound_index ) / 1.e6 endif enddo if ( read_RWC_file_with_extra_HDD_and_height ) then write ( unit_logfile , '(A,f12.2)' ) 'Average heating emission height for replaced values = ' , sum_RWC_grid_height ( 1 ) / count_grid write ( unit_logfile , '(A,f12.2)' ) 'Average heating emission height total standard deviation = ' , sqrt ( sum_RWC_grid_height ( 3 ) / count_grid ) write ( unit_logfile , '(A,f12.2)' ) 'Additional RMS average heating emission height standard deviation = ' , sqrt ( sum_RWC_grid_height ( 2 ) / count_grid ) endif if ( allocated ( region_heating_scaling )) deallocate ( region_heating_scaling ) if ( allocated ( count_subgrid )) deallocate ( count_subgrid ) return 10 write ( unit_logfile , '(A)' ) 'ERROR reading scaling heating file' stop end subroutine uEMEP_read_RWC_heating_data","tags":"","loc":"proc/uemep_read_rwc_heating_data.html"},{"title":"uEMEP_redistribute_local_source – uEMEP","text":"public  subroutine uEMEP_redistribute_local_source(source_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer :: source_index Source Code subroutine uEMEP_redistribute_local_source ( source_index ) use uEMEP_definitions implicit none integer i , j integer source_index integer ii , jj , tt integer integral_counter real sum_integral ( n_pollutant_loop ) integer i_start , i_end , j_start , j_end , t_start , t_end integer emep_subsource integer i_cross_integral , j_cross_integral real xpos_limit , ypos_limit real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_integral_subgrid , ypos_integral_subgrid integer i_pollutant !allocate (sum_integral(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (scaling_factor_traffic_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (traffic_redistributed_local_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar if ( local_subgrid_method_flag . ne . 1 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Redistribute local source using EMEP concentrations (uEMEP_redistribute_local_source)' write ( unit_logfile , '(A)' ) '================================================================' !No subsources for the emep related arrays emep_subsource = 1 write ( unit_logfile , '(2A)' ) 'Calculating the scaling factor and local contribution at each subgrid for ' , trim ( source_file_str ( source_index )) xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) do tt = t_start , t_end !Calculate the mean concentration of the integral values for each subgrid point do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then sum_integral = 0. integral_counter = 0 i_cross_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) xpos_integral_subgrid = xproj_subgrid ( i , j ) ypos_integral_subgrid = yproj_subgrid ( i , j ) !Use the wind direction to move the target area downwind if ( use_downwind_position_flag . and . hourly_calculations ) then !Use the same area as for non upwind i_start = max ( 1 , i_cross_integral - integral_subgrid_loop_index ( x_dim_index )) i_end = min ( integral_subgrid_dim ( x_dim_index ), i_cross_integral + integral_subgrid_loop_index ( x_dim_index )) j_start = max ( 1 , j_cross_integral - integral_subgrid_loop_index ( y_dim_index )) j_end = min ( integral_subgrid_dim ( y_dim_index ), j_cross_integral + integral_subgrid_loop_index ( y_dim_index )) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit else i_start = max ( 1 , i_cross_integral - integral_subgrid_loop_index ( x_dim_index )) i_end = min ( integral_subgrid_dim ( x_dim_index ), i_cross_integral + integral_subgrid_loop_index ( x_dim_index )) j_start = max ( 1 , j_cross_integral - integral_subgrid_loop_index ( y_dim_index )) j_end = min ( integral_subgrid_dim ( y_dim_index ), j_cross_integral + integral_subgrid_loop_index ( y_dim_index )) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit endif !write(*,*) i_start-i_cross_integral,i_end-i_cross_integral,j_start-j_cross_integral,j_end-j_cross_integral !Calculate the average grid concentration at each integral subgrid based on proxy integral do jj = j_start , j_end do ii = i_start , i_end xpos_integral_subgrid = xproj_integral_subgrid ( ii , jj ) ypos_integral_subgrid = yproj_integral_subgrid ( ii , jj ) if ( xpos_integral_subgrid . ge . xpos_area_min . and . xpos_integral_subgrid . le . xpos_area_max & . and . ypos_integral_subgrid . ge . ypos_area_min . and . ypos_integral_subgrid . le . ypos_area_max ) then !do i_pollutant=1,n_pollutant_loop sum_integral (:) = sum_integral (:) + integral_subgrid ( ii , jj , tt , hsurf_average_subgrid_index , source_index ,:) !write(*,*) ii,jj,integral_subgrid(ii,jj,tt,hsurf_average_subgrid_index,source_index,1) !enddo integral_counter = integral_counter + 1 !write(*,*) i,j,ii-i_cross_integral,jj-j_cross_integral endif enddo enddo !Calculate scaling factor do i_pollutant = 1 , n_pollutant_loop if ( sum_integral ( i_pollutant ). ne . 0 ) then subgrid ( i , j , tt , scaling_factor_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) / sum_integral ( i_pollutant ) * integral_counter else subgrid ( i , j , tt , scaling_factor_subgrid_index , source_index , i_pollutant ) = 0. endif !write(*,*) i_pollutant,subgrid(i,j,tt,proxy_subgrid_index,source_index,i_pollutant),sum_integral(i_pollutant) if ( isnan ( subgrid ( i , j , tt , scaling_factor_subgrid_index , source_index , i_pollutant ))) write ( * , * ) i , j , sum_integral ( i_pollutant ), integral_counter if ( isnan ( subgrid ( i , j , tt , emep_local_subgrid_index , source_index , i_pollutant ))) write ( * , * ) 'L' , i , j , sum_integral ( i_pollutant ), integral_counter enddo endif enddo !write(*,*) 'Redistribution',j,' of ',subgrid_dim(2) enddo write ( * , * ) 'Redistribution time ' , tt , ' of ' , subgrid_dim ( t_dim_index ) enddo do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(i,A,f12.4)' ) i_pollutant , ' Max scaling factor for pollutant  =' , maxval ( subgrid (:,:,:, scaling_factor_subgrid_index , source_index , i_pollutant )) write ( unit_logfile , '(i,A,f12.4)' ) i_pollutant , ' Mean scaling factor for pollutant =' , sum ( subgrid (:,:,:, scaling_factor_subgrid_index , source_index , i_pollutant )) & / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) enddo !Calculate redistributed subgrid source concentrations subgrid (:,:,:, local_subgrid_index , source_index ,:) = subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) * subgrid (:,:,:, emep_local_subgrid_index , source_index ,:) end subroutine uEMEP_redistribute_local_source","tags":"","loc":"proc/uemep_redistribute_local_source.html"},{"title":"uEMEP_disperse_local_source – uEMEP","text":"public  subroutine uEMEP_disperse_local_source(source_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer :: source_index Source Code subroutine uEMEP_disperse_local_source ( source_index ) use uEMEP_definitions implicit none integer source_index !allocate (sum_integral(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (scaling_factor_traffic_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (traffic_redistributed_local_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar if ( local_subgrid_method_flag . ne . 2. and . local_subgrid_method_flag . ne . 3. and . local_subgrid_method_flag . ne . 4 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Redistribute local source using dispersion (uEMEP_disperse_local_source)' write ( unit_logfile , '(A)' ) '================================================================' !do subsource_index=1,n_subsource(source_index) !Calculate redistributed subgrid source concentrations subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) = 1. subgrid (:,:,:, local_subgrid_index , source_index ,:) = subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) * subgrid (:,:,:, proxy_subgrid_index , source_index ,:) if ( trace_emissions_from_in_region ) then subgrid_local_from_in_region (:,:,:, source_index ,:) = subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) * subgrid_proxy_from_in_region (:,:,:, source_index ,:) end if !enddo !Subsource loop end subroutine uEMEP_disperse_local_source","tags":"","loc":"proc/uemep_disperse_local_source.html"},{"title":"uEMEP_combine_local_source – uEMEP","text":"public  subroutine uEMEP_combine_local_source() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_combine_local_source use uEMEP_definitions implicit none integer source_index integer i_pollutant integer i , j integer i_sp real sum_temp ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !if (interpolate_subgrids_flag) then !write(unit_logfile,'(a)') 'Interpolate routines not currently active. Doing nothing' !call uEMEP_interpolate_auto_subgrid !return !stop !call uEMEP_interpolate_subgrids !call uEMEP_linear_interpolate_subgrids !call uEMEP_bilinear_interpolate_subgrids !Remember to reset the use_subgrids val and logical so that everything will be used in the end !endif write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Combining the local and nonlocal contributions at each subgrid' write ( unit_logfile , '(a)' ) '--------------------------' !Calculate redistributed subgrid allsource concentrations subgrid (:,:,:, local_subgrid_index , allsource_index ,:) = 0. do source_index = 1 , n_source_index if ( calculate_source ( source_index ). and . source_index . ne . allsource_index ) then subgrid (:,:,:, local_subgrid_index , allsource_index ,:) = subgrid (:,:,:, local_subgrid_index , allsource_index ,:) + subgrid (:,:,:, local_subgrid_index , source_index ,:) endif !Add the selected EMEP local sources to this as well, if they are not already included in the subgrid downscaling if ( calculate_EMEP_source ( source_index ). and .. not . calculate_source ( source_index ). and . source_index . ne . allsource_index ) then subgrid (:,:,:, local_subgrid_index , allsource_index ,:) = subgrid (:,:,:, local_subgrid_index , allsource_index ,:) + subgrid (:,:,:, emep_local_subgrid_index , source_index ,:) !write(*,*) source_index,sum(subgrid(:,:,:,emep_local_subgrid_index,source_index,:)),sum(subgrid(:,:,:,local_subgrid_index,allsource_index,:)),sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,:)) endif enddo if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then do i_pollutant = 1 , n_pollutant_loop !If the compound is PM2.5 or PM10 then add the non PPM part to the non-local if ( pollutant_loop_index ( i_pollutant ). eq . pm25_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_index ) then write ( unit_logfile , '(A,A)' ) 'Pollutant: ' , trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_nc_index )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM NONLOCAL ADDITIONAL: ' , sum (( subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN ADD REST NONLOCAL ADDITIONAL: ' , sum (( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) endif !subgrid(:,:,:,total_subgrid_index,allsource_index,i_pollutant)=subgrid(:,:,:,local_subgrid_index,allsource_index,i_pollutant)+subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant) enddo endif do i_pollutant = 1 , n_pollutant_loop !If the compound is PM2.5 or PM10 then add the non PPM part to the non-local if ( pollutant_loop_index ( i_pollutant ). eq . pm25_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_index ) then write ( unit_logfile , '(A,A)' ) 'Pollutant: ' , trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_nc_index )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM NONLOCAL: ' , mean_mask ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM LOCAL: ' , mean_mask ( subgrid (:,:,:, emep_local_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_local_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM TOTAL: ' , mean_mask ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN COMP PM TOTAL: ' , mean_mask ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((comp_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN COMP PM ORIGINAL: ' , mean_mask ( orig_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((orig_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN ADD REST NONLOCAL: ' , mean_mask ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((comp_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))-subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN NEW PM NONLOCAL: ' , mean_mask ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) if ( sum ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )). lt . 0 ) write ( unit_logfile , '(A)' ) 'WARNING!!!: PPM EMEP is more than total EMEP PM. Negative non PPM contributions.' endif subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) = subgrid (:,:,:, local_subgrid_index , allsource_index , i_pollutant ) + subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) enddo do i_pollutant = 1 , n_pollutant_loop !Place the results in the compound results !do i_loop=1,n_pollutant_compound_loop(i_pollutant) comp_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) = subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) !enddo !write(*,'(2i,4f16.2)') i_pollutant,pollutant_loop_index(i_pollutant)& !    ,sum(subgrid(:,:,:,total_subgrid_index,allsource_index,i_pollutant))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index)& !    ,sum(subgrid(:,:,:,local_subgrid_index,allsource_index,i_pollutant))& !    ,sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant))& !    ,sum(comp_subgrid(:,:,:,pollutant_loop_index(i_pollutant))) enddo !Replace the species PPM with the actual species PPM used in the local fraction and then replace this with the nonlocal part. !Only works for the complete group of species if ( save_emep_species ) then !Replace the primary species value with the one used in the calculations for consistency write ( unit_logfile , '(A)' ) 'ppm read from surf and read emep. Difference should just be deposition' write ( unit_logfile , '(A,2f12.2)' ) 'PPM25 (init_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,2f12.2)' ) 'PPM10 (init_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A)' ) 'pm surf init species and summed species should be the same. comp should be different (difference between SURF and SURF_rh50)' write ( unit_logfile , '(A,3f12.2)' ) 'PM25 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,3f12.2)' ) 'PM10 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) !The remaining species will not, most likely, be normalised with the total. This is done here but the total ppm is kept !Something weird is going on here. Need to check !Normalise the species surface values with the total grid values to account for any difference du to deposition and water !Because t can have dimension 1 and 'sum' function does not think it is a dimension anymore then need to do the sum over the time loop. This turned out to not be the case so they are the same if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) endif do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 enddo if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) endif do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 enddo write ( unit_logfile , '(A)' ) 'sum_sp should be the same as comp after scaling, init should be unchanged' write ( unit_logfile , '(A,3f12.2)' ) 'PM25 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,3f12.2)' ) 'PM10 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) !Replace the ppm values in the species with the emep read version !This is not correct. emep_subgrid_index,allsource_index is the sum of all local and nonlocal sources, so a larger number than the primary. !This will lead to negative values set to 0. So comment out this line (21.03.2022) !species_EMEP_subgrid(:,:,:,pm25_sp_index,sp_ppm_index)=subgrid(:,:,:,emep_subgrid_index,allsource_index,pollutant_loop_back_index(pm25_nc_index)) !species_EMEP_subgrid(:,:,:,pm10_sp_index,sp_ppm_index)=subgrid(:,:,:,emep_subgrid_index,allsource_index,pollutant_loop_back_index(pm10_nc_index)) !Normalise the species other than ppm again after subtracting the ppm !This should not change anything if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index - 1 ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index - 1 ), 4 ) endif do i_sp = 1 , sp_ppm_index - 1 species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm25_nc_index ) - species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 enddo if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index - 1 ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index - 1 ), 4 ) endif do i_sp = 1 , sp_ppm_index - 1 species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm10_nc_index ) - species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 enddo !Remove the primary based on the local contribution. species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ) - subgrid (:,:,:, emep_local_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index )) species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ) - subgrid (:,:,:, emep_local_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index )) where ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ). lt . 0. or . isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ))) species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ) = 0 where ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ). lt . 0. or . isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ))) species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ) = 0 !Normalise again after the subtraction to the nonlocal contribution (21.03.2022) sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) & * ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 enddo if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) endif do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) & * ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 enddo write ( unit_logfile , '(A)' ) 'init_sp should be the same as before, sum_sp should be the same as nonlocal, comp should be larger' write ( unit_logfile , '(A,4f12.2)' ) 'PM25 (init_sp,sum_sp,comp,nonlocal)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,4f12.2)' ) 'PM10 (init_sp,sum_sp,comp,nonlocal)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) endif !Only show results where all the subgrids and all sources are valid !This is temporary if ( interpolate_subgrids_flag ) then do source_index = 1 , n_source_index if ( calculate_source ( source_index )) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if (. not . use_subgrid ( i , j , source_index )) then !subgrid(i,j,:,total_subgrid_index,allsource_index,:)=NODATA_value !subgrid(i,j,:,total_subgrid_index,source_index,:)=NODATA_value !comp_subgrid(i,j,:,:)=NODATA_value endif enddo enddo endif enddo endif end subroutine uEMEP_combine_local_source","tags":"","loc":"proc/uemep_combine_local_source.html"},{"title":"uEMEP_subgrid_meteo_EMEP – uEMEP","text":"public  subroutine uEMEP_subgrid_meteo_EMEP() Arguments None Source Code subroutine uEMEP_subgrid_meteo_EMEP () !========================================================================== !   uEMEP_subgrid_meteo_EMEP !   Bruce Rolstad Denby !   MET Norway ! !   This routine interpolates EMEP meteo data to the integral subgrid !   using either nearest neighbour EMEP_meteo_grid_interpolation_flag=0 !   or area weighted interpolation EMEP_meteo_grid_interpolation_flag=1 !   It also generates cos and sin wind field data for dispersion modelling !========================================================================== ! Local variables integer :: i , j integer :: ii , jj , iii , jjj real , allocatable :: weighting_nc (:,:) integer :: t_start , t_end real :: xpos_min , xpos_max , ypos_min , ypos_max real :: xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max integer :: i_nc , j_nc real :: angle_utm , angle_lcc , angle_utm2 real , allocatable :: u_utm (:), v_utm (:), th (:), ff (:) real :: dlatx , dlaty real :: xpos_limit , ypos_limit real :: xpos_integral_subgrid , ypos_integral_subgrid write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Interpolating meteo data to subgrids (uEMEP_subgrid_meteo_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' if ( . not . allocated ( u_utm )) allocate ( u_utm ( dim_length_nc ( time_dim_nc_index ))) if ( . not . allocated ( v_utm )) allocate ( v_utm ( dim_length_nc ( time_dim_nc_index ))) if ( . not . allocated ( th )) allocate ( th ( dim_length_nc ( time_dim_nc_index ))) if ( . not . allocated ( ff )) allocate ( ff ( dim_length_nc ( time_dim_nc_index ))) ! Set the last meteo data to be the previous for the external time loop before updating if ( use_single_time_loop_flag ) then if ( t_loop . gt . start_time_loop_index ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, 1 ,:) end if end if ! Initialise all meteo subgrid fields meteo_subgrid = 0.0 ! Set the time dimensions for transfering the alternative meteorology which has a time index that starts at 0 t_start = 1 t_end = subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,I4)' ) 'Setting EMEP subgrid meteo data using method ' , EMEP_meteo_grid_interpolation_flag ! Loop through the integral subgrid and find those subgrids within EMEP grids and allocate values directly from EMEP grids. Nearest neighbour if ( EMEP_meteo_grid_interpolation_flag . eq . 0 ) then do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, FFgrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, FFgrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, u10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, u10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, v10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, v10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, FF10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, FF10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, kz_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, kz_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, hmix_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, hmix_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, logz0_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, logz0_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, invL_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, invL_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, inv_FFgrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, inv_FFgrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, inv_FF10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, inv_FF10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, ustar_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, ustar_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, J_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, J_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, t2m_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, t2m_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, precip_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, precip_nc_index , allsource_index , meteo_p_loop_index ) if ( use_alternative_meteorology_flag ) then i_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) meteo_subgrid ( i , j , t_start : t_end , ugrid_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , ugrid_nc_index ) meteo_subgrid ( i , j , t_start : t_end , vgrid_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , vgrid_nc_index ) meteo_subgrid ( i , j , t_start : t_end , u10_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , u10_nc_index ) meteo_subgrid ( i , j , t_start : t_end , v10_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , v10_nc_index ) meteo_subgrid ( i , j , t_start : t_end , FFgrid_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , FFgrid_nc_index ) meteo_subgrid ( i , j , t_start : t_end , FF10_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , FF10_nc_index ) meteo_subgrid ( i , j , t_start : t_end , hmix_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , hmix_nc_index ) meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , logz0_nc_index ) meteo_subgrid ( i , j , t_start : t_end , invL_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , invL_nc_index ) !meteo_subgrid(i,j,t_start:t_end,inv_FFgrid_subgrid_index)=meteo_var3d_nc(i_nc,j_nc,,t_start:t_end,inv_FFgrid_nc_index) !meteo_subgrid(i,j,t_start:t_end,inv_FF10_subgrid_index)=meteo_var3d_nc(i_nc,j_nc,t_start:t_end,inv_FF10_nc_index) meteo_subgrid ( i , j , t_start : t_end , ustar_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , ustar_nc_index ) meteo_subgrid ( i , j , t_start : t_end , t2m_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , t2m_nc_index ) meteo_subgrid ( i , j , t_start : t_end , precip_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , precip_nc_index ) end if ! Not properly implemented. Always false if ( use_alternative_z0_flag ) then meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , logz0_nc_index ) end if end do end do end if ! Area weighted interpolation of meteorology to integral grid if ( EMEP_meteo_grid_interpolation_flag . ge . 1 ) then xpos_limit = dgrid_nc ( lon_nc_index ) / 2.0 ypos_limit = dgrid_nc ( lat_nc_index ) / 2.0 allocate ( weighting_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid. Something wrong if it fails i_nc = crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) xpos_integral_subgrid = xproj_integral_subgrid ( i , j ) ypos_integral_subgrid = yproj_integral_subgrid ( i , j ) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit do jjj = j_nc - 1 , j_nc + 1 do iii = i_nc - 1 , i_nc + 1 ii = max ( 1 , iii ) ii = min ( dim_length_nc ( x_dim_nc_index ), iii ) jj = max ( 1 , jjj ) jj = min ( dim_length_nc ( y_dim_nc_index ), jjj ) xpos_min = max ( xpos_area_min , var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2.0 ) xpos_max = min ( xpos_area_max , var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2.0 ) ypos_min = max ( ypos_area_min , var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2.0 ) ypos_max = min ( ypos_area_max , var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2.0 ) ! Determine the area intersection of the EMEP grid and an EMEP grid size centred on the integral subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii , jj ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii , jj ) = 0.0 end if meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) = meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) = meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, FFgrid_subgrid_index ) = meteo_subgrid ( i , j ,:, FFgrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, FFgrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, kz_subgrid_index ) = meteo_subgrid ( i , j ,:, kz_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, kz_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, hmix_subgrid_index ) = meteo_subgrid ( i , j ,:, hmix_subgrid_index ) + var3d_nc ( ii , jj ,:, hmix_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, u10_subgrid_index ) = meteo_subgrid ( i , j ,:, u10_subgrid_index ) + var3d_nc ( ii , jj ,:, u10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, v10_subgrid_index ) = meteo_subgrid ( i , j ,:, v10_subgrid_index ) + var3d_nc ( ii , jj ,:, v10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, FF10_subgrid_index ) = meteo_subgrid ( i , j ,:, FF10_subgrid_index ) + var3d_nc ( ii , jj ,:, FF10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, logz0_subgrid_index ) = meteo_subgrid ( i , j ,:, logz0_subgrid_index ) + var3d_nc ( ii , jj ,:, logz0_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, invL_subgrid_index ) = meteo_subgrid ( i , j ,:, invL_subgrid_index ) + var3d_nc ( ii , jj ,:, invL_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, inv_FFgrid_subgrid_index ) = meteo_subgrid ( i , j ,:, inv_FFgrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, inv_FFgrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, inv_FF10_subgrid_index ) = meteo_subgrid ( i , j ,:, inv_FF10_subgrid_index ) + var3d_nc ( ii , jj ,:, inv_FF10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, ustar_subgrid_index ) = meteo_subgrid ( i , j ,:, ustar_subgrid_index ) + var3d_nc ( ii , jj ,:, ustar_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, J_subgrid_index ) = meteo_subgrid ( i , j ,:, J_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, J_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, t2m_subgrid_index ) = meteo_subgrid ( i , j ,:, t2m_subgrid_index ) + var3d_nc ( ii , jj ,:, t2m_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, precip_subgrid_index ) = meteo_subgrid ( i , j ,:, precip_subgrid_index ) + var3d_nc ( ii , jj ,:, precip_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) end do end do end do end do if ( use_alternative_meteorology_flag . or . use_alternative_z0_flag ) then if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) allocate ( weighting_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ))) xpos_limit = meteo_dgrid_nc ( lon_nc_index ) / 2.0 ypos_limit = meteo_dgrid_nc ( lat_nc_index ) / 2.0 if ( use_alternative_meteorology_flag ) then meteo_subgrid (:,:,:, ugrid_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, vgrid_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, FFgrid_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, hmix_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, FF10_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, logz0_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, invL_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, ustar_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, t2m_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, precip_subgrid_index ) = 0.0 end if if ( use_alternative_z0_flag ) then meteo_subgrid (:,:,:, logz0_subgrid_index ) = 0.0 end if do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) xpos_integral_subgrid = meteo_nc_xproj_integral_subgrid ( i , j ) ypos_integral_subgrid = meteo_nc_yproj_integral_subgrid ( i , j ) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit do jj = j_nc - 1 , j_nc + 1 do ii = i_nc - 1 , i_nc + 1 xpos_min = max ( xpos_area_min , meteo_var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2.0 ) xpos_max = min ( xpos_area_max , meteo_var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2.0 ) ypos_min = max ( ypos_area_min , meteo_var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2.0 ) ypos_max = min ( ypos_area_max , meteo_var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2.0 ) ! Determine the area intersection of the EMEP grid and an EMEP grid size centred on the integral subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii , jj ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii , jj ) = 0.0 end if if ( use_alternative_meteorology_flag ) then meteo_subgrid ( i , j , t_start : t_end , ugrid_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , ugrid_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , ugrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , vgrid_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , vgrid_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , vgrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , FFgrid_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , FFgrid_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , FFgrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , hmix_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , hmix_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , hmix_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , u10_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , u10_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , ugrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , v10_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , v10_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , vgrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , FF10_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , FF10_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , FF10_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , logz0_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , invL_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , invL_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , invL_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , ustar_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , ustar_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , ustar_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , t2m_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , t2m_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , t2m_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , precip_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , precip_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , precip_nc_index ) * weighting_nc ( ii , jj ) end if if ( use_alternative_z0_flag ) then meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , logz0_nc_index ) * weighting_nc ( ii , jj ) end if end do end do end do end do end if end if ! Rotate wind fields if necessary and define cos and sin of the wind direction do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) ! Adjust wind direction to utm projection. ! First determine rotation for grids that are not lat lon ! Will fail for 90 degree rotations though this should never be the case if ( EMEP_projection_type . ne . LL_projection_index ) then dlatx = var2d_nc ( i_nc + 1 , j_nc , lat_nc_index ) - var2d_nc ( i_nc - 1 , j_nc , lat_nc_index ) dlaty = var2d_nc ( i_nc , j_nc + 1 , lat_nc_index ) - var2d_nc ( i_nc , j_nc - 1 , lat_nc_index ) angle_lcc = atan ( dlatx / dlaty ) else angle_lcc = 0.0 end if if ( use_alternative_meteorology_flag ) then ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) ! Adjust wind direction to utm projection. ! First determine rotation for grids that are not lat lon ! Will fail for 90 degree rotations though this should never be the case if ( meteo_nc_projection_type . ne . LL_projection_index ) then dlatx = meteo_var2d_nc ( i_nc + 1 , j_nc , lat_nc_index ) - meteo_var2d_nc ( i_nc - 1 , j_nc , lat_nc_index ) dlaty = meteo_var2d_nc ( i_nc , j_nc + 1 , lat_nc_index ) - meteo_var2d_nc ( i_nc , j_nc - 1 , lat_nc_index ) angle_lcc = atan ( dlatx / dlaty ) else angle_lcc = 0.0 end if end if ! Rotation from lat lon grid to UTM grid. No alternatives if ( projection_type . eq . UTM_projection_index ) then angle_utm2 = atan ( tan (( lon_integral_subgrid ( i , j ) - utm_lon0 ) / 18 0.0 * pi ) * sin ( lat_integral_subgrid ( i , j ) / 18 0.0 * pi )) else if ( projection_type . eq . LTM_projection_index ) then angle_utm2 = atan ( tan (( lon_integral_subgrid ( i , j ) - ltm_lon0 ) / 18 0.0 * pi ) * sin ( lat_integral_subgrid ( i , j ) / 18 0.0 * pi )) else angle_utm2 = 0.0 end if ! Sum the angles (Triple check this is correct in regard to signs) angle_utm = angle_utm2 + angle_lcc ! Rotate u_utm = meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) * cos ( angle_utm ) + meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) * sin ( angle_utm ) v_utm = - meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) * sin ( angle_utm ) + meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) * cos ( angle_utm ) meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) = u_utm meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) = v_utm ! Create cos and sin's of the lowest level wind direction for efficient use in the dispersion equations if ( wind_vectors_10m_available ) then ff = sqrt ( meteo_subgrid ( i , j ,:, v10_subgrid_index ) * meteo_subgrid ( i , j ,:, v10_subgrid_index ) + meteo_subgrid ( i , j ,:, u10_subgrid_index ) * meteo_subgrid ( i , j ,:, u10_subgrid_index )) meteo_subgrid ( i , j ,:, sin_subgrid_index ) = meteo_subgrid ( i , j ,:, v10_subgrid_index ) / ff meteo_subgrid ( i , j ,:, cos_subgrid_index ) = meteo_subgrid ( i , j ,:, u10_subgrid_index ) / ff else ff = sqrt ( meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) * meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) + meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) * meteo_subgrid ( i , j ,:, ugrid_subgrid_index )) meteo_subgrid ( i , j ,:, sin_subgrid_index ) = meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) / ff meteo_subgrid ( i , j ,:, cos_subgrid_index ) = meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) / ff end if ! In case where no wind. Hopefully this never happens where ( ff . eq . 0.0 ) meteo_subgrid ( i , j ,:, sin_subgrid_index ) = 0.0 meteo_subgrid ( i , j ,:, cos_subgrid_index ) = 1.0 end where end do end do ! Set the last meteo data to be the current for the first value of the external time loop if ( use_single_time_loop_flag ) then if ( t_loop . eq . start_time_loop_index ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, 1 ,:) end if end if if ( allocated ( u_utm )) deallocate ( u_utm ) if ( allocated ( v_utm )) deallocate ( v_utm ) if ( allocated ( th )) deallocate ( th ) if ( allocated ( ff )) deallocate ( ff ) if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) end subroutine uEMEP_subgrid_meteo_EMEP","tags":"","loc":"proc/uemep_subgrid_meteo_emep.html"},{"title":"uEMEP_auto_subgrid – uEMEP","text":"public  subroutine uEMEP_auto_subgrid() uEMEP model uEMEP_auto_subgrid\nAutomatically creates a grid dependent on the distance to source Arguments None Source Code subroutine uEMEP_auto_subgrid () !! uEMEP model uEMEP_auto_subgrid !! Automatically creates a grid dependent on the distance to source integer :: i , j , k integer :: i_source integer :: t real :: max_use_subgrid_size ( n_source_index ) real :: use_subgrid_range ( n_source_index ) integer :: use_subgrid_step integer :: use_emission_subgrid_space integer :: i_cross , j_cross integer :: i_start , i_end , j_start , j_end integer :: i_start_k , i_end_k , j_start_k , j_end_k real :: sum_emission ! Exit if emission positions are not to be used and if one of the other auto positions is to be used if ( . not . use_emission_positions_for_auto_subgrid_flag ( allsource_index ) . and . ( use_population_positions_for_auto_subgrid_flag . or . use_receptor_positions_for_auto_subgrid_flag )) then return end if ! Exit and fill subgrid if none of the auto subgrids are to be used if ( . not . use_emission_positions_for_auto_subgrid_flag ( allsource_index ) . and . . not . use_population_positions_for_auto_subgrid_flag . and . . not . use_receptor_positions_for_auto_subgrid_flag ) then use_subgrid = . true . return end if write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Setting subgrids automatically (uEMEP_auto_subgrid)' write ( unit_logfile , '(A)' ) '================================================================' ! Set all subgrids to do not use use_subgrid_val = 0 use_subgrid_interpolation_index = - 1 ! Set time index used for emissions to 1, so only tests for the first hour if there are emissions t = 1 ! Set the maximum grid size max_use_subgrid_size = max_interpolation_subgrid_size use_subgrid_range = 8.0 use_subgrid_range ( traffic_index ) = 4.0 use_subgrid_range ( shipping_index ) = 1 2.0 n_use_subgrid_levels = 0 ! Sets the auto gridding if ( subgrid_delta ( x_dim_index ) . eq . 10 0.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 5 use_subgrid_step_delta ( 3 ) = 10 use_subgrid_step_delta ( 4 ) = 20 if ( max_interpolation_subgrid_size . eq . 25 0.0 ) n_use_subgrid_levels = 1 if ( max_interpolation_subgrid_size . eq . 50 0.0 ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 100 0.0 ) n_use_subgrid_levels = 3 if ( max_interpolation_subgrid_size . eq . 200 0.0 ) n_use_subgrid_levels = 4 use_subgrid_range ( traffic_index ) = 6.0 else if ( subgrid_delta ( x_dim_index ) . eq . 2 5.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 4 use_subgrid_step_delta ( 3 ) = 10 use_subgrid_step_delta ( 4 ) = 20 use_subgrid_step_delta ( 5 ) = 40 use_subgrid_step_delta ( 5 ) = 80 if ( max_interpolation_subgrid_size . eq . 25 0.0 ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 50 0.0 ) n_use_subgrid_levels = 3 if ( max_interpolation_subgrid_size . eq . 100 0.0 ) n_use_subgrid_levels = 4 if ( max_interpolation_subgrid_size . eq . 200 0.0 ) n_use_subgrid_levels = 5 use_subgrid_range ( traffic_index ) = 4.0 else if ( subgrid_delta ( x_dim_index ) . eq . 5 0.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 4 use_subgrid_step_delta ( 3 ) = 10 use_subgrid_step_delta ( 4 ) = 20 use_subgrid_step_delta ( 5 ) = 40 if ( max_interpolation_subgrid_size . eq . 25 0.0 ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 50 0.0 ) n_use_subgrid_levels = 3 if ( max_interpolation_subgrid_size . eq . 100 0.0 ) n_use_subgrid_levels = 4 if ( max_interpolation_subgrid_size . eq . 200 0.0 ) n_use_subgrid_levels = 5 use_subgrid_range ( traffic_index ) = 6.0 else if ( subgrid_delta ( x_dim_index ) . eq . 25 0.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 4 use_subgrid_step_delta ( 3 ) = 8 if ( max_interpolation_subgrid_size . eq . 25 0. ) n_use_subgrid_levels = 0 if ( max_interpolation_subgrid_size . eq . 50 0. ) n_use_subgrid_levels = 1 if ( max_interpolation_subgrid_size . eq . 100 0. ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 200 0. ) n_use_subgrid_levels = 3 use_subgrid_range ( traffic_index ) = 8.0 else write ( unit_logfile , '(a,f12.2)' ) 'When auto gridding target grid sizes must be either 25, 50, 100 or 250 metres. Stopping because target grid size is:' , subgrid_delta ( x_dim_index ) stop end if if ( n_use_subgrid_levels ( allsource_index ). eq . 0 ) then write ( unit_logfile , '(a,f12.2)' ) 'When auto gridding maximum grid sizes must be either 250, 500, 1000 or 2000 metres. Stopping because max grid size is:' , max_interpolation_subgrid_size stop 1 end if ! Set the number of levels to match this do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( * , * ) 'Using auto subgrid for source ' , trim ( source_file_str ( i_source )), use_emission_positions_for_auto_subgrid_flag ( i_source ) end if end do do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . use_emission_positions_for_auto_subgrid_flag ( i_source )) then write ( unit_logfile , '(a,2f10.1,i10)' ) trim ( source_file_str ( i_source )) // ': maximum use subgrid size (m), grid range and number of levels: ' , & max_use_subgrid_size ( i_source ), use_subgrid_range ( i_source ), n_use_subgrid_levels ( i_source ) ! Fill the interpolation index with the highest level do k = n_use_subgrid_levels ( i_source ), 0 , - 1 use_subgrid_step = 2 ** k use_subgrid_step = use_subgrid_step_delta ( k ) use_emission_subgrid_space = floor ( use_subgrid_step / sqrt ( emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) & / subgrid_delta ( x_dim_index ) / subgrid_delta ( y_dim_index )) / 2.0 * use_subgrid_range ( i_source )) use_emission_subgrid_space = max ( 1 , use_emission_subgrid_space ) do j = 1 , subgrid_dim ( y_dim_index ), use_subgrid_step do i = 1 , subgrid_dim ( x_dim_index ), use_subgrid_step i_cross = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) j_cross = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) ! Search in the neighbourhood and find the sum of the emissions i_start = max ( 1 , i_cross - use_emission_subgrid_space ) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i_cross + use_emission_subgrid_space ) j_start = max ( 1 , j_cross - use_emission_subgrid_space ) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j_cross + use_emission_subgrid_space ) sum_emission = sum ( proxy_emission_subgrid ( i_start : i_end , j_start : j_end , i_source ,:)) ! Select those with emission sums > 0 but always include the coarsest level everywhere if ( sum_emission . gt . 0. . or . k . eq . n_use_subgrid_levels ( i_source )) then use_subgrid_val ( i , j , i_source ) = 1 ! Label the grids for interpolation later i_start_k = max ( 1 , i - use_subgrid_step / 2 ) i_end_k = min ( subgrid_dim ( x_dim_index ), i + use_subgrid_step / 2 ) j_start_k = max ( 1 , j - use_subgrid_step / 2 ) j_end_k = min ( subgrid_dim ( y_dim_index ), j + use_subgrid_step / 2 ) use_subgrid_interpolation_index ( i_start_k : i_end_k , j_start_k : j_end_k , i_source ) = k end if end do end do end do use_subgrid_val (:,:, allsource_index ) = use_subgrid_val (:,:, allsource_index ) + use_subgrid_val (:,:, i_source ) ! Check do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid_interpolation_index ( i , j , i_source ) . lt . 0 ) write ( * , * ) i , j , use_subgrid_interpolation_index ( i , j , i_source ) end do end do end if end do use_subgrid_val = min ( 1 , use_subgrid_val ) ! Convert values to logical do i_source = 1 , n_source_index if ( use_emission_positions_for_auto_subgrid_flag ( i_source )) then if ( calculate_source ( i_source ) . or . i_source . eq . allsource_index ) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid_val ( i , j , i_source ) . gt . 0 ) then use_subgrid ( i , j , i_source ) = . true . else use_subgrid ( i , j , i_source ) = . false . end if end do end do end if else ! If not to be auto gridded then set use to true use_subgrid (:,:, i_source ) = . true . end if end do do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . use_emission_positions_for_auto_subgrid_flag ( i_source )) then write ( unit_logfile , '(a,2i10,f6.1)' ) 'Number of calculation subgrids for ' // trim ( source_file_str ( i_source )) // ' (number, total, percent):' , & sum ( use_subgrid_val (:,:, i_source )), subgrid_dim ( 1 ) * subgrid_dim ( 2 ), sum ( use_subgrid_val (:,:, i_source )) * 10 0.0 / ( subgrid_dim ( 1 ) * subgrid_dim ( 2 )) end if end do end subroutine uEMEP_auto_subgrid","tags":"","loc":"proc/uemep_auto_subgrid.html"},{"title":"uEMEP_interpolate_auto_subgrid – uEMEP","text":"public  subroutine uEMEP_interpolate_auto_subgrid() Arguments None Source Code subroutine uEMEP_interpolate_auto_subgrid () ! This is the corresponding routine for interpolating the auto selected data integer :: xdim , ydim real :: delta ( 2 ) real :: xval , yval real :: xgrid ( 3 , 3 ), ygrid ( 3 , 3 ), zgrid ( 3 , 3 ) integer :: i , j , k , ii , jj integer :: i_source , i_pollutant , t integer :: i_in ( 3 ), j_in ( 3 ) integer :: use_subgrid_step write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Interpolating auto grid (uEMEP_interpolate_auto_subgrid)' write ( unit_logfile , '(A)' ) '================================================================' xdim = 3 ydim = 3 do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . i_source . ne . allsource_index . and . use_emission_positions_for_auto_subgrid_flag ( i_source )) then ! Only interpolate for chosen sources that have been auto gridded based on emissions do k = n_use_subgrid_levels ( i_source ), 1 , - 1 use_subgrid_step = use_subgrid_step_delta ( k ) delta = use_subgrid_step * subgrid_delta do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) xval = x_subgrid ( i , j ) yval = y_subgrid ( i , j ) ! Only do the interpolation if it is the right interpolation_index, it is inside the region and it is not a valid subgrid ! TODO: use a logical flag here? ! if (use_subgrid_interpolation_index(i,j,i_source).eq.k.and.use_subgrid_val(i,j,i_source).ne.outside_interpolation_region_index.and..not.use_subgrid_val(i,j,i_source)) then ! Do it everywhere in the grid if ( use_subgrid_interpolation_index ( i , j , i_source ) . eq . k . and . use_subgrid_val ( i , j , i_source ) . ne . & outside_interpolation_region_index . and . . not . use_subgrid ( i , j , i_source )) then i_in ( 2 ) = floor ( real ( i - 1 ) / use_subgrid_step + 0.5 ) * use_subgrid_step + 1 i_in ( 2 ) = min ( subgrid_dim ( x_dim_index ), max ( 1 , i_in ( 2 ))) i_in ( 1 ) = i_in ( 2 ) - use_subgrid_step i_in ( 3 ) = i_in ( 2 ) + use_subgrid_step j_in ( 2 ) = floor ( real ( j - 1 ) / use_subgrid_step + 0.5 ) * use_subgrid_step + 1 j_in ( 2 ) = min ( subgrid_dim ( y_dim_index ), max ( 1 , j_in ( 2 ))) j_in ( 1 ) = j_in ( 2 ) - use_subgrid_step j_in ( 3 ) = j_in ( 2 ) + use_subgrid_step if ( i_in ( 1 ) . lt . 1 ) i_in ( 1 ) = i_in ( 2 ) if ( j_in ( 1 ) . lt . 1 ) j_in ( 1 ) = j_in ( 2 ) if ( i_in ( 3 ) . gt . subgrid_dim ( x_dim_index )) i_in ( 3 ) = i_in ( 2 ) if ( j_in ( 3 ) . gt . subgrid_dim ( y_dim_index )) j_in ( 3 ) = j_in ( 2 ) do t = 1 , subgrid_dim ( t_dim_index ) do i_pollutant = 1 , n_pollutant_loop do jj = 1 , 3 do ii = 1 , 3 xgrid ( ii , jj ) = x_subgrid ( i_in ( 2 ), j_in ( 2 )) + ( ii - 2 ) * delta ( 1 ) ygrid ( ii , jj ) = y_subgrid ( i_in ( 2 ), j_in ( 2 )) + ( jj - 2 ) * delta ( 2 ) zgrid ( ii , jj ) = subgrid ( i_in ( ii ), j_in ( jj ), t , proxy_subgrid_index , i_source , i_pollutant ) if ( i_in ( ii ) . lt . 1 . or . i_in ( ii ) . gt . subgrid_dim ( x_dim_index ) . or . j_in ( jj ) . lt . 1 . or . j_in ( jj ) . gt . subgrid_dim ( y_dim_index )) then zgrid ( ii , jj ) = subgrid ( i_in ( 2 ), j_in ( 2 ), t , proxy_subgrid_index , i_source , i_pollutant ) else if ( use_subgrid_val ( i_in ( ii ), j_in ( jj ), i_source ). eq . outside_interpolation_region_index ) then zgrid ( ii , jj ) = subgrid ( i_in ( 2 ), j_in ( 2 ), t , proxy_subgrid_index , i_source , i_pollutant ) end if end do end do subgrid ( i , j , t , proxy_subgrid_index , i_source , i_pollutant ) = area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) ! Travel time interpolation as well do jj = 1 , 3 do ii = 1 , 3 zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( ii ), j_in ( jj ), t , 1 , i_pollutant ) if ( i_in ( ii ) . lt . 1 . or . i_in ( ii ) . gt . subgrid_dim ( x_dim_index ) . or . j_in ( jj ) . lt . 1 . or . j_in ( jj ) . gt . subgrid_dim ( y_dim_index )) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 1 , i_pollutant ) else if ( use_subgrid_val ( i_in ( ii ), j_in ( jj ), i_source ) . eq . outside_interpolation_region_index ) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 1 , i_pollutant ) end if end do end do traveltime_subgrid ( i , j , t , 1 , i_pollutant ) = area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) do jj = 1 , 3 do ii = 1 , 3 zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( ii ), j_in ( jj ), t , 2 , i_pollutant ) if ( i_in ( ii ) . lt . 1 . or . i_in ( ii ) . gt . subgrid_dim ( x_dim_index ) . or . j_in ( jj ) . lt . 1 . or . j_in ( jj ) . gt . subgrid_dim ( y_dim_index )) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 2 , i_pollutant ) else if ( use_subgrid_val ( i_in ( ii ), j_in ( jj ), i_source ) . eq . outside_interpolation_region_index ) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 2 , i_pollutant ) end if end do end do traveltime_subgrid ( i , j , t , 2 , i_pollutant ) = area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) end do end do end if end do end do end do end if end do ! Reset the use_subgrid values so chemistry and exposure happens everywhere but not outside the region use_subgrid (:,:, allsource_index ) = . true . where ( use_subgrid_val (:,:, allsource_index ) . eq . outside_region_index ) use_subgrid (:,:, allsource_index ) = . false . end subroutine uEMEP_interpolate_auto_subgrid","tags":"","loc":"proc/uemep_interpolate_auto_subgrid.html"},{"title":"uEMEP_region_mask – uEMEP","text":"public  subroutine uEMEP_region_mask() Arguments None Source Code subroutine uEMEP_region_mask () ! This routine defines use_subgrid_val=2 for regions outside the selected region. This can be used to control the interpolation routine ! It also sets use_subgrid=.false. outside the region so that no calculations are made there either character ( 256 ) :: temp_name , temp_str , temp_str1 integer , allocatable :: tile_municipality_subgrid (:,:,:) integer :: municipality_id real :: x_ssb , f_easting , ssb_dx , y_ssb , ssb_dy integer :: count integer ( kind = 8 ) :: ssb_id integer :: i , j , k , i_range , j_range , i_range_interp , j_range_interp , i_tile , j_tile logical :: exists integer :: unit_in integer :: index_val integer :: i_source character ( 256 ) :: region_number_str integer , parameter :: n_search = 5 character ( 16 ) :: search_str ( n_search ) real :: search_delta ( n_search ) integer :: temp_search integer :: io search_str = [ '_1000m' , '_500m ' , '_250m ' , '_100m ' , '_50m  ' ] search_delta = [ 100 0.0 , 50 0.0 , 25 0.0 , 10 0.0 , 5 0.0 ] write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Masking region (uEMEP_region_mask)' write ( unit_logfile , '(A)' ) '================================================================' if ( . not . allocated ( tile_municipality_subgrid )) allocate ( tile_municipality_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) tile_municipality_subgrid = 0 i_source = allsource_index ! Search file name to define the grid size ssb_dx = 0.0 ; ssb_dy = 0.0 do k = 1 , n_search temp_search = index ( filename_population ( municipality_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality data with resolution ' // trim ( adjustl ( search_str ( k ))) end if end do if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( municipality_index )) stop 1 end if region_number_str = '' write ( region_number_str , * ) region_index region_number_str = trim ( region_number_str ) // '_' ! Read in SSB file containing gridded municipality ids f_easting = 2.0e6 pathfilename_population ( municipality_index ) = trim ( pathname_population ( municipality_index )) // trim ( adjustl ( region_number_str )) // trim ( filename_population ( municipality_index )) ! Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( municipality_index )), exist = exists ) if ( . not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Masking region SSB file with municipality IDs does not exist: ' , trim ( pathfilename_population ( municipality_index )) stop 1 end if temp_name = pathfilename_population ( municipality_index ) ! Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB municipality file ' // trim ( temp_name ) rewind ( unit_in ) ! Read header SSBID0250M;kommunenum read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 i_range = ceiling ( ssb_dx / subgrid_delta ( x_dim_index ) / 2.0 ) + 1 j_range = ceiling ( ssb_dy / subgrid_delta ( y_dim_index ) / 2.0 ) + 1 i_range_interp = ceiling ( ssb_dx / subgrid_delta ( x_dim_index ) / 2.0 + max_interpolation_subgrid_size / subgrid_delta ( x_dim_index )) + 1 j_range_interp = ceiling ( ssb_dy / subgrid_delta ( y_dim_index ) / 2.0 + max_interpolation_subgrid_size / subgrid_delta ( y_dim_index )) + 1 do ssb_id = 0 ; municipality_id = 0 ! Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit index_val = index ( temp_str , ';' , back = . false .) temp_str1 = temp_str ( 1 : index_val - 1 ) temp_str = temp_str ( index_val + 1 :) if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id read ( temp_str , * ) municipality_id ! If this ssb municipality grid has the correct ID then find the target grid that matches it if ( municipality_id . eq . region_id ) then count = count + 1 !Convert id to grid centre coordinates that are already in UTM33 for SSB data x_ssb = floor ( ssb_id / 1000000 0.0 ) - f_easting + ssb_dx / 2.0 y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2.0 ! Find the tile this ssb grid is in i_tile = 1 + floor (( x_ssb - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) ! New definition j_tile = 1 + floor (( y_ssb - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) !New definition do j = j_tile - j_range , j_tile + j_range do i = i_tile - i_range , i_tile + i_range ! Make sure i and j are inside a valid range if ( i . ge . 1 . and . i . le . subgrid_dim ( x_dim_index ) . and . j . ge . 1 . and . j . le . subgrid_dim ( y_dim_index )) then ! Find the target subgrid within the ssb grid and the region if ( x_subgrid ( i , j ) . ge . x_ssb - ssb_dx / 2.0 . and . x_subgrid ( i , j ) . lt . x_ssb + ssb_dx / 2.0 . and . & y_subgrid ( i , j ) . ge . y_ssb - ssb_dy / 2.0 . and . y_subgrid ( i , j ) . lt . y_ssb + ssb_dy / 2.0 ) then !If there is a target subgrid within this range then allocate the mask value if it is not the correct region_id tile_municipality_subgrid ( i , j , 1 ) = 1 end if end if end do end do do j = j_tile - j_range_interp , j_tile + j_range_interp do i = i_tile - i_range_interp , i_tile + i_range_interp ! Make sure i and j are inside a valid range if ( i . ge . 1 . and . i . le . subgrid_dim ( x_dim_index ) . and . j . ge . 1 . and . j . le . subgrid_dim ( y_dim_index )) then ! Find the target subgrid within the ssb grid and the region if ( x_subgrid ( i , j ) . ge . x_ssb - ssb_dx / 2.0 - max_interpolation_subgrid_size . and . x_subgrid ( i , j ) . le . x_ssb + ssb_dx / 2.0 + max_interpolation_subgrid_size . and . & y_subgrid ( i , j ) . ge . y_ssb - ssb_dy / 2.0 - max_interpolation_subgrid_size . and . y_subgrid ( i , j ) . le . y_ssb + ssb_dy / 2.0 + max_interpolation_subgrid_size ) then ! If there is a target subgrid within this range then allocate the mask value if it is not the correct region_id tile_municipality_subgrid ( i , j , 2 ) = 1 end if end if end do end do end if end do close ( unit_in ) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i , j , 2 ) . eq . 0 ) then use_subgrid_val ( i , j ,:) = outside_interpolation_region_index use_subgrid ( i , j ,:) = . false . end if if ( tile_municipality_subgrid ( i , j , 1 ) . eq . 0 ) then use_subgrid_val ( i , j ,:) = outside_region_index end if end do end do if ( allocated ( tile_municipality_subgrid )) deallocate ( tile_municipality_subgrid ) end subroutine uEMEP_region_mask","tags":"","loc":"proc/uemep_region_mask.html"},{"title":"uEMEP_region_mask_new – uEMEP","text":"public  subroutine uEMEP_region_mask_new() Arguments None Source Code subroutine uEMEP_region_mask_new () ! Variables used for reading the region mask netcdf file ! help-parameters for reading the file character ( 256 ) pathfilename_region_mask logical exists integer status_nc integer id_nc , var_id_nc , x_dim_id_nc , y_dim_id_nc integer temp_num_dims ! projection of the region mask integer region_mask_projection_type double precision region_mask_projection_attributes ( 10 ) ! the x and y coordinates real , allocatable :: x_values_regionmask (:) real , allocatable :: y_values_regionmask (:) ! the region ID data themselves integer , allocatable :: region_mask (:, :) ! assumed names for dimensions of the region mask file character ( 256 ) x_dim_name_regionmask , y_dim_name_regionmask , dimname_temp ! length of dimensions of the region mask integer nx_regionmask , ny_regionmask ! grid spacing of the region mask (to be verified is constant!) real dx_regionmask , dy_regionmask ! subset needed to read from the region mask file real x_min , x_max , y_min , y_max integer x_min_index , x_max_index , y_min_index , y_max_index ! grid dimension looping indices integer i , j , ii , jj , i_sub , j_sub , i_source ! variables used for defining the extended EMEP grid integer max_lf_distance integer ii_nc , jj_nc ! Variables used when applying the region mask to the EMEP and uEMEP grids ! x and y value of current location in the region mask projection real x_location , y_location ! index of closest grid-cell in the region mask to the current location integer x_index , y_index ! grid resolution in EMEP real dx_emep , dy_emep ! x and y value of midpoint of an EMEP grid and of subsamples of the EMEP grid real x_emepmid , y_emepmid real x_emepsub , y_emepsub ! corresponding lon and lat real lon_emepsub , lat_emepsub ! current location in emission subgrid (x and y in uEMEP projection, longitude and latitude) real x_emis , y_emis , lon_emis , lat_emis ! Additional variables used for creating list of regions, calculating fraction of EMEP cells in each region and setting the use_subgrid array integer i_region integer , allocatable :: temp_regionindex_loop_index (:) integer counter integer current_region_index , previous_region_index , region_select logical outofbounds_warning_has_been_printed if (. not . ( trace_emissions_from_in_region . or . use_region_select_and_mask_flag )) then return end if write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Creating region mask arrays (uEMEP_region_mask_new)' write ( unit_logfile , '(A)' ) '================================================================' ! Ensure arrays are not already allocated if ( allocated ( subgrid_region_index )) then deallocate ( subgrid_region_index ) end if if ( allocated ( regionindex_loop_index )) then deallocate ( regionindex_loop_index ) end if if ( allocated ( emission_subgrid_region_index )) then deallocate ( emission_subgrid_region_index ) end if if ( allocated ( EMEP_extended_subsample_region_id )) then deallocate ( EMEP_extended_subsample_region_id ) end if if ( allocated ( regionfraction_per_EMEP_extended_grid )) then deallocate ( regionfraction_per_EMEP_extended_grid ) end if ! Read the region mask netcdf file (implementation based on uEMEP_read_EMEP) ! determine full filename pathfilename_region_mask = trim ( pathname_region_mask ) // trim ( filename_region_mask ) !Test existence of the region mask file. If does not exist then stop inquire ( file = trim ( pathfilename_region_mask ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_region_mask ) write ( unit_logfile , '(A)' ) '  STOPPING' stop end if !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_region_mask ) status_nc = NF90_OPEN ( pathfilename_region_mask , nf90_nowrite , id_nc ) if ( status_nc /= NF90_NOERR ) write ( unit_logfile , '(A,I0)' ) 'ERROR opening netcdf file: ' , status_nc ! Initialize projection type to longitude-latitude region_mask_projection_type = LL_projection_index ! Check if it is a UTM projection status_nc = NF90_INQ_VARID ( id_nc , 'projection_utm' , var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_central_meridian' , region_mask_projection_attributes ( 2 )) ! calculate the UTM zone region_mask_projection_attributes ( 1 ) = ( region_mask_projection_attributes ( 2 ) + 180 + 3 ) / 6 ! verify this is an exact UTM zone if ( abs ( region_mask_projection_attributes ( 1 ) - floor ( region_mask_projection_attributes ( 1 ) + 0.1 )) > 1e-6 ) then write ( unit_logfile , '(3A,f,A)' ) ' ERROR during reading of attributes for \"projection_utm\" in file ' , trim ( pathfilename_region_mask ), ': \"longitude_of_central_meridian\" = ' , region_mask_projection_attributes ( 2 ), ', which does not correspond to a UTM zone.' ! IS THIS STRING FORMATTED CORRECTLY? stop end if region_mask_projection_type = UTM_projection_index x_dim_name_regionmask = 'x' y_dim_name_regionmask = 'y' write ( unit_logfile , '(A,f3.0)' ) 'Region mask file has projection UTM zone ' , region_mask_projection_attributes ( 1 ) end if if ( region_mask_projection_type == LL_projection_index ) then x_dim_name_regionmask = 'lon' y_dim_name_regionmask = 'lat' write ( unit_logfile , '(A)' ) 'Assuming region mask file is in lon-lat, since it is variable projection_utm was not found. Other projections than UTM are not implemented' end if !Read dimensions of the file (x,y) ! x status_nc = NF90_INQ_DIMID ( id_nc , x_dim_name_regionmask , x_dim_id_nc ) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , x_dim_id_nc , dimname_temp , nx_regionmask ) if ( status_nc /= NF90_NOERR ) then write ( unit_logfile , '(A,I0)' ) 'ERROR: Reading of x dimension failed with status: ' , status_nc stop end if ! y status_nc = NF90_INQ_DIMID ( id_nc , y_dim_name_regionmask , y_dim_id_nc ) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , y_dim_id_nc , dimname_temp , ny_regionmask ) if ( status_nc /= NF90_NOERR ) then write ( unit_logfile , '(A,I0)' ) 'Reading of y dimension failed with status: ' , status_nc stop end if write ( unit_logfile , '(A,I0,A,I0)' ) ' Dimensions of full region mask (x,y): ' , nx_regionmask , ' ' , ny_regionmask ! Verify the dimensions are at least 2x2 if (. not . ( nx_regionmask > 1 . and . ny_regionmask > 1 )) then write ( unit_logfile , '(A)' ) 'ERROR: Dimensions of regionmask are not at least 2x2' stop end if ! Allocate memory for the full coordinates of the region mask allocate ( x_values_regionmask ( nx_regionmask )) allocate ( y_values_regionmask ( ny_regionmask )) ! NB: should I set these arrays to 0 before they are read from file? ! Read coordinate values ! x status_nc = NF90_INQ_VARID ( id_nc , trim ( x_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , x_values_regionmask ) else write ( unit_logfile , '(A)' ) 'Error while reading x values from region mask' stop end if ! y status_nc = NF90_INQ_VARID ( id_nc , trim ( y_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , y_values_regionmask ) else write ( unit_logfile , '(A)' ) 'Error while reading y values from region mask' stop end if ! Determine grid spacing and verify it is constant dx_regionmask = x_values_regionmask ( 2 ) - x_values_regionmask ( 1 ) do i = 2 , nx_regionmask if (. not . ( x_values_regionmask ( i ) - x_values_regionmask ( i - 1 ) == dx_regionmask )) then write ( unit_logfile , '(A)' ) 'Not constant spacing in x coordinate in region mask' stop end if end do dy_regionmask = y_values_regionmask ( 2 ) - y_values_regionmask ( 1 ) do i = 2 , ny_regionmask if (. not . ( y_values_regionmask ( i ) - y_values_regionmask ( i - 1 ) == dy_regionmask )) then write ( unit_logfile , '(A)' ) 'Not constant spacing in y coordinate in region mask' stop end if end do ! Determine required subset of region mask to read (in the projection coordinates of the target grid) write ( unit_logfile , '(A)' ) 'Determining the subset of the region mask needed' ! First initialize both min and max value to the first value in the target subgrid write ( unit_logfile , '(A)' ) 'Checking target subgrid' call LL2PROJ ( lon_subgrid ( 1 , 1 ), lat_subgrid ( 1 , 1 ), x_min , y_min , region_mask_projection_attributes , region_mask_projection_type ) x_max = x_min y_max = y_min ! Go through the target grid cells to update the range of x and y values do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) call LL2PROJ ( lon_subgrid ( i , j ), lat_subgrid ( i , j ), x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) x_min = min ( x_min , x_location ) x_max = max ( x_max , x_location ) y_min = min ( y_min , y_location ) y_max = max ( y_max , y_location ) end do end do ! If tracing in-region contributions, go through all cells to be traced from and update required range of x and y values if ( trace_emissions_from_in_region ) then ! Emission subgrid write ( unit_logfile , '(A)' ) 'Checking emission subgrids' do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) ! get location in uEMEP projection of this emission subgrid x_emis = x_emission_subgrid ( i , j , i_source ) y_emis = y_emission_subgrid ( i , j , i_source ) ! transform to the region mask projection call PROJ2LL ( x_emis , y_emis , lon_emis , lat_emis , projection_attributes , projection_type ) call LL2PROJ ( lon_emis , lat_emis , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! update min and max x_min = min ( x_min , x_location ) x_max = max ( x_max , x_location ) y_min = min ( y_min , y_location ) y_max = max ( y_max , y_location ) end do end do end if end do ! Extended EMEP grid for region masking of the EMEP LF data write ( unit_logfile , '(A)' ) 'Checking extended EMEP grid' ! Determine how large the extended EMEP grid must be ! We assume the reduced EMEP grid is just big enough to cover the 'normal' LF contributions to the target grid if ( EMEP_additional_grid_interpolation_size > 0.0 ) then ! We want to calculate additional. So we need to increase the grid to ensure it covers additial contributions to the target grid ! First, calculate the max nr of LF cells that the source can be away from edge of target grid max_lf_distance = 1 + int ( max ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index )) / 2 ) ! - assuming reduced EMEP grid already covers the small local fraction domain, this is the number of EMEP grid-cells we need to add to all sides in the extended grid ngrid_extended_margin = ( local_fraction_grid_size ( 2 ) - local_fraction_grid_size ( 1 )) * max_lf_distance write ( unit_logfile , '(A,2I6)' ) '  reduced EMEP grid dimensions: nx,ny =' , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2I6)' ) \"  max_lf_distance, ngrid_extended_margin =\" , max_lf_distance , ngrid_extended_margin ! Size of extended EMEP grid nx_EMEP_extended = dim_length_nc ( x_dim_nc_index ) + 2 * ngrid_extended_margin ny_EMEP_extended = dim_length_nc ( y_dim_nc_index ) + 2 * ngrid_extended_margin write ( unit_logfile , '(A,2I6)' ) '  -> extended EMEP grid dimensions: nx,ny =' , nx_EMEP_extended , ny_EMEP_extended else ! We don't calculate additional. Then the extended EMEP grid can be the same size as the reduced EMEP grid ngrid_extended_margin = 0 nx_EMEP_extended = dim_length_nc ( x_dim_nc_index ) ny_EMEP_extended = dim_length_nc ( y_dim_nc_index ) end if ! Determine spacing in EMEP grid (NB: maybe this is alredy available somewhere?) ! NB: I will not verify it is constant, but I will assume it is dx_emep = var1d_nc ( 2 , x_dim_nc_index ) - var1d_nc ( 1 , x_dim_nc_index ) dy_emep = var1d_nc ( 2 , y_dim_nc_index ) - var1d_nc ( 1 , y_dim_nc_index ) ! loop over the extended EMEP grid to update range of x and y values we need from region mask do ii = 1 , nx_EMEP_extended do jj = 1 , ny_EMEP_extended ! calculate the corresponding index in the normal EMEP grid ii_nc = ii - ngrid_extended_margin jj_nc = jj - ngrid_extended_margin ! -> deduce EMEP projection coordinate values at centre of this EMEP grid x_emepmid = var1d_nc ( 1 , x_dim_nc_index ) + dx_emep * ( ii_nc - 1 ) y_emepmid = var1d_nc ( 1 , y_dim_nc_index ) + dy_emep * ( jj_nc - 1 ) ! go through all subsamples of this EMEP grid do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid ! EMEP projection coordinate value at this subsample of the EMEP grid x_emepsub = x_emepmid - dx_emep / 2 + ( i_sub - 0.5 ) * dx_emep / n_subsamples_per_EMEP_grid y_emepsub = y_emepmid - dy_emep / 2 + ( j_sub - 0.5 ) * dy_emep / n_subsamples_per_EMEP_grid ! calculate longitude and latitude from the EMEP projection call PROJ2LL ( x_emepsub , y_emepsub , lon_emepsub , lat_emepsub , EMEP_projection_attributes , EMEP_projection_type ) ! calculate projection coordinates in the region mask grid call LL2PROJ ( lon_emepsub , lat_emepsub , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! update min and max x_min = min ( x_min , x_location ) x_max = max ( x_max , x_location ) y_min = min ( y_min , y_location ) y_max = max ( y_max , y_location ) end do end do end do end do end if ! Determine the subset of the region mask we need to read based on the range of x and y to use it for x_min_index = nint (( x_min - x_values_regionmask ( 1 )) / dx_regionmask ) x_max_index = nint ( 1 + ( x_max - x_values_regionmask ( 1 )) / dx_regionmask ) y_min_index = nint (( y_min - y_values_regionmask ( 1 )) / dy_regionmask ) y_max_index = nint ( 1 + ( y_max - y_values_regionmask ( 1 )) / dy_regionmask ) ! ensure we don't go outside the boundaries of the region mask x_min_index = max ( x_min_index , 1 ) x_max_index = min ( x_max_index , nx_regionmask ) y_min_index = max ( y_min_index , 1 ) y_max_index = min ( y_max_index , ny_regionmask ) ! Update region mask dimensions based on this subset nx_regionmask = x_max_index - x_min_index + 1 ny_regionmask = y_max_index - y_min_index + 1 write ( unit_logfile , '(A)' ) 'Required subset of region mask (in region mask projection):' write ( unit_logfile , '(A,2e12.4,2i7)' ) '  x_min, x_max, x_min_index, x_max_index =' , x_min , x_max , x_min_index , x_max_index write ( unit_logfile , '(A,2e12.4,2i7)' ) '  y_min, y_max, y_min_index, x_max_index =' , y_min , y_max , y_min_index , y_max_index write ( unit_logfile , '(A,2i7)' ) '-> Dimensions of subset of region mask to be read (x,y):' , nx_regionmask , ny_regionmask ! Read region mask coordinates again, selecting only the required subset deallocate ( x_values_regionmask ) deallocate ( y_values_regionmask ) allocate ( x_values_regionmask ( nx_regionmask )) allocate ( y_values_regionmask ( ny_regionmask )) ! x status_nc = NF90_INQ_VARID ( id_nc , trim ( x_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , x_values_regionmask , start = ( / x_min_index / ), count = ( / nx_regionmask / )) else write ( unit_logfile , '(A)' ) 'Error while reading x values from region mask' stop end if ! y status_nc = NF90_INQ_VARID ( id_nc , trim ( y_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , y_values_regionmask , start = ( / y_min_index / ), count = ( / ny_regionmask / )) else write ( unit_logfile , '(A)' ) 'Error while reading y values from region mask' stop end if ! Read the mask itself allocate ( region_mask ( nx_regionmask , ny_regionmask )) status_nc = NF90_INQ_VARID ( id_nc , trim ( varname_region_mask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) ! NB: the following line fails if the region_mask subset is bigger than ca. 1 million elements when runnning interactively, but not as a qsub job (fix by increasing 'ulimit -s', e.g. 'ulimit -s unlimited') status_nc = NF90_GET_VAR ( id_nc , var_id_nc , region_mask , start = ( / x_min_index , y_min_index / ), count = ( / nx_regionmask , ny_regionmask / )) write ( unit_logfile , '(A,i3,A,2A,2i16)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( varname_region_mask ), ' (min, max): ' , minval ( region_mask ), maxval ( region_mask ) else write ( unit_logfile , '(A)' ) 'Could not read region mask values from file' stop end if ! verify that no region index values in the file are negative or higher than the max allowed value if ( minval ( region_mask ) < 0 ) then write ( unit_logfile , '(A)' ) 'Found negative values of region index in file' // trim ( pathfilename_region_mask ) // '. This is not allowed' stop end if if ( maxval ( region_mask ) > maxvalue_region_index ) then write ( unit_logfile , '(A,i0,A,i0)' ) 'Max value of region index in file ' // trim ( pathfilename_region_mask ) // ' is' , maxval ( region_mask ), ', which is higher than the max allowed value: maxvalue_region_index=' , maxvalue_region_index stop end if ! Close the region mask netcdf file status_nc = NF90_CLOSE ( id_nc ) write ( unit_logfile , '(A)' ) 'Done reading region mask.' ! Determine region ID of each cell of the uEMEP target subgrid write ( unit_logfile , '(A)' ) 'Calculating region mask for the target grid' ! Allocate array for region mask on uEMEP target subgrid and initialize to 0 (no region) allocate ( subgrid_region_index ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) subgrid_region_index = 0 ! Set region ID of each target subgrid outofbounds_warning_has_been_printed = . false . do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) ! calculate x- and y- position in the region mask projection call LL2PROJ ( lon_subgrid ( i , j ), lat_subgrid ( i , j ), x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! Determine index in the region mask grid for this location x_index = nint ( 1 + ( x_location - x_values_regionmask ( 1 )) / dx_regionmask ) y_index = nint ( 1 + ( y_location - y_values_regionmask ( 1 )) / dy_regionmask ) ! Verify that this index is inside the region mask grid and has a positive region ID if ( x_index >= 1 . and . x_index <= nx_regionmask . and . y_index >= 1 . and . y_index <= ny_regionmask ) then subgrid_region_index ( i , j ) = region_mask ( x_index , y_index ) else ! this receptor location is not within the region mask grid if (. not . outofbounds_warning_has_been_printed ) then write ( unit_logfile , '(A)' ) 'WARNING: The target subgrid extends outside the given region mask.' outofbounds_warning_has_been_printed = . true . end if end if !write(unit_logfile,'(A,2i12,2f12.4,2f12.2,2i12,i4)') 'i,j,lon_subgrid(i,j),lat_subgrid(i,j),x_location,y_location,x_index,y_index,region_index = ',i,j,lon_subgrid(i,j),lat_subgrid(i,j),x_location,y_location,x_index,y_index,subgrid_region_index(i,j) end do end do write ( unit_logfile , '(A)' ) 'Finding the regions occurring in the target grid' ! Determine which regions occur in the target grid ! (NB: We don't care about regions occurring only in the EMEP grid but not in the target grid!) allocate ( temp_regionindex_loop_index ( maxvalue_region_index )) temp_regionindex_loop_index = 0 regionindex_loop_back_index = 0 counter = 0 previous_region_index = - 1 do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) current_region_index = subgrid_region_index ( i , j ) if ( current_region_index > 0 . and . . not . current_region_index == previous_region_index ) then ! Region index is different from previous subgrid ! check if we have not already found it before if ( regionindex_loop_back_index ( current_region_index ) == 0 ) then ! new region ID found counter = counter + 1 temp_regionindex_loop_index ( counter ) = current_region_index regionindex_loop_back_index ( current_region_index ) = counter end if previous_region_index = current_region_index end if end do end do n_regions = counter allocate ( regionindex_loop_index ( n_regions )) regionindex_loop_index = temp_regionindex_loop_index ( 1 : n_regions ) deallocate ( temp_regionindex_loop_index ) write ( unit_logfile , '(A,I0)' ) 'Number of regions within target grid: ' , n_regions write ( unit_logfile , '(A,100I5)' ) 'index of these regions are (printing max 100): ' , regionindex_loop_index ! Determine which subgrid cells are inside the selected region ! and use this to set use_subgrid if ( use_region_select_and_mask_flag ) then ! Set 'use_subgrid' ! NB: This will override previously set values for this array use_subgrid = . false . region_select = region_index write ( unit_logfile , '(A,I0)' ) 'Setting \"use_subgrid\" based on where in the target grid the region index is' , region_select do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) if ( subgrid_region_index ( i , j ) == region_select ) then use_subgrid ( i , j ,:) = . true . else use_subgrid ( i , j ,:) = . false . end if end do end do end if if ( trace_emissions_from_in_region ) then ! Set region ID of the emission subgrids write ( unit_logfile , '(A)' ) 'Setting region ID of the emission subgrids' ! initialize to -1 (\"no-region\") allocate ( emission_subgrid_region_index ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) emission_subgrid_region_index = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) ! get location in uEMEP projection of this emission subgrid x_emis = x_emission_subgrid ( i , j , i_source ) y_emis = y_emission_subgrid ( i , j , i_source ) ! transform to the region mask projection call PROJ2LL ( x_emis , y_emis , lon_emis , lat_emis , projection_attributes , projection_type ) call LL2PROJ ( lon_emis , lat_emis , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! find nearest grid-cell in the region mask array to get the region ID of this emission subgrid x_index = nint ( 1 + ( x_location - x_values_regionmask ( 1 )) / dx_regionmask ) y_index = nint ( 1 + ( y_location - y_values_regionmask ( 1 )) / dy_regionmask ) ! Check if this location is inside the region mask grid if ( x_index >= 1 . and . x_index <= nx_regionmask . and . y_index >= 1 . and . y_index <= ny_regionmask ) then emission_subgrid_region_index ( i , j , i_source ) = region_mask ( x_index , y_index ) end if ! NB: contrary to the target grid, we will allow non-positive region ID in the emission subgrid, indicating \"no-region\", and we will also allow that the emision subgrid extends beyond the boundaries of the region mask file end do end do end if end do ! Set region ID of each subsample of the extended EMEP grid write ( unit_logfile , '(A)' ) 'Calculating region mask for subsamples of the (extended) EMEP grid' ! Allocate array for region subsamples and initialize to -1 (no region) allocate ( EMEP_extended_subsample_region_id ( n_subsamples_per_EMEP_grid , n_subsamples_per_EMEP_grid , nx_EMEP_extended , ny_EMEP_extended )) EMEP_extended_subsample_region_id = - 1 ! loop over the extended EMEP grid and fill subsample region ID do ii = 1 , nx_EMEP_extended do jj = 1 , ny_EMEP_extended ! calculate the corresponding index in the normal EMEP grid ii_nc = ii - ngrid_extended_margin jj_nc = jj - ngrid_extended_margin ! -> deduce EMEP projection coordinate values at centre of this EMEP grid x_emepmid = var1d_nc ( 1 , x_dim_nc_index ) + dx_emep * ( ii_nc - 1 ) y_emepmid = var1d_nc ( 1 , y_dim_nc_index ) + dy_emep * ( jj_nc - 1 ) ! go through all subsamples of this EMEP grid do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid ! EMEP projection coordinate value at this subsample of the EMEP grid x_emepsub = x_emepmid - dx_emep / 2 + ( i_sub - 0.5 ) * dx_emep / n_subsamples_per_EMEP_grid y_emepsub = y_emepmid - dy_emep / 2 + ( j_sub - 0.5 ) * dy_emep / n_subsamples_per_EMEP_grid ! calculate longitude and latitude from the EMEP projection call PROJ2LL ( x_emepsub , y_emepsub , lon_emepsub , lat_emepsub , EMEP_projection_attributes , EMEP_projection_type ) ! calculate projection coordinates in the region mask grid call LL2PROJ ( lon_emepsub , lat_emepsub , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! Determine index in the region mask grid for this location x_index = nint ( 1 + ( x_location - x_values_regionmask ( 1 )) / dx_regionmask ) y_index = nint ( 1 + ( y_location - y_values_regionmask ( 1 )) / dy_regionmask ) ! If this location is inside the region mask grid, then set the region ID if ( x_index >= 1 . and . x_index <= nx_regionmask . and . y_index >= 1 . and . y_index <= ny_regionmask ) then EMEP_extended_subsample_region_id ( i_sub , j_sub , ii , jj ) = region_mask ( x_index , y_index ) end if ! NB: if it is outside the region mask grid, the 'no-region' value -1 is kept end do end do end do end do write ( unit_logfile , '(A)' ) 'Calculating fraction of each cell in the (extended) EMEP grid that is in each region' ! Calculate the fraction of each EMEP grid (in the extended grid) that is within each region, by counting the subsamples allocate ( regionfraction_per_EMEP_extended_grid ( nx_EMEP_extended , ny_EMEP_extended , n_regions )) do ii = 1 , nx_EMEP_extended do jj = 1 , ny_EMEP_extended do i_region = 1 , n_regions current_region_index = regionindex_loop_index ( i_region ) counter = 0 do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid if ( EMEP_extended_subsample_region_id ( i_sub , j_sub , ii , jj ) == current_region_index ) then counter = counter + 1 end if end do end do regionfraction_per_EMEP_extended_grid ( ii , jj , i_region ) = counter * 1.0 / n_subsamples_per_EMEP_grid ** 2 end do end do end do end if !(trace_emissions_from_in_region) ! Deallocate the region mask deallocate ( region_mask ) deallocate ( x_values_regionmask ) deallocate ( y_values_regionmask ) end subroutine uEMEP_region_mask_new","tags":"","loc":"proc/uemep_region_mask_new.html"},{"title":"uEMEP_local_trajectory – uEMEP","text":"private  subroutine uEMEP_local_trajectory(x_r, y_r, x_emis, y_emis, t, traj_max_index, dr_traj, x_loc, y_loc, valid_traj) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name real :: x_r real :: y_r real :: x_emis real :: y_emis integer :: t integer :: traj_max_index real :: dr_traj real :: x_loc real :: y_loc logical :: valid_traj Source Code subroutine uEMEP_local_trajectory ( x_r , y_r , x_emis , y_emis , t , traj_max_index , dr_traj , x_loc , y_loc , valid_traj ) use uEMEP_definitions implicit none integer k real x_loc , y_loc !integer i_rec,j_rec,i_emis,j_emis integer t , traj_max_index !integer i_source real dr_traj real x_r , y_r , x_emis , y_emis real x_traj ( traj_max_index ), y_traj ( traj_max_index ) real distance_traj ( traj_max_index ), distance_intercept_traj ( traj_max_index ) real x_intercept_traj ( traj_max_index ), y_intercept_traj ( traj_max_index ), frac_length_traj ( traj_max_index ) logical exit_traj , valid_traj integer i_integral , j_integral !real x_r,y_r k = 1 !Set the initial trajectory position to the emission source !x_traj(k)=x_emission_subgrid(i_emis,j_emis,i_source) !y_traj(k)=y_emission_subgrid(i_emis,j_emis,i_source) x_traj ( k ) = x_emis y_traj ( k ) = y_emis !Set the position of the receptor !x_r=x_subgrid(i_rec,j_rec) !y_r=y_subgrid(i_rec,j_rec) !Set the distances for the initial emission grid !distance_traj(k)=sqrt((x_traj(k)-x_r)*(x_traj(k)-x_r)+(y_traj(k)-y_r)*(y_traj(k)-y_r)) !distance_intercept_traj(k)=distance_traj(k) distance_traj ( k ) = ( x_traj ( k ) - x_r ) * ( x_traj ( k ) - x_r ) + ( y_traj ( k ) - y_r ) * ( y_traj ( k ) - y_r ) distance_intercept_traj ( k ) = distance_traj ( k ) * distance_traj ( k ) y_loc = 0. x_loc = 0. exit_traj = . false . valid_traj = . false . do while (. not . exit_traj . and . k . lt . traj_max_index ) !Find what meteorological grid the trajectory point is in !i_integral=1+floor((x_traj(k)-integral_subgrid_min(x_dim_index))/(integral_subgrid_max(x_dim_index)-integral_subgrid_min(x_dim_index))*integral_subgrid_dim(x_dim_index)) !j_integral=1+floor((y_traj(k)-integral_subgrid_min(y_dim_index))/(integral_subgrid_max(y_dim_index)-integral_subgrid_min(y_dim_index))*integral_subgrid_dim(y_dim_index)) i_integral = 1 + floor (( x_traj ( k ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) j_integral = 1 + floor (( y_traj ( k ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) !Test to see if it is still in the grid if ( i_integral . ge . 1. and . i_integral . le . integral_subgrid_dim ( x_dim_index ). and . j_integral . ge . 1. and . j_integral . le . integral_subgrid_dim ( y_dim_index )) then !Account for at grid value if ( distance_traj ( k ). eq . 0 ) then exit_traj = . true . y_loc = 0. x_loc = 0. valid_traj = . true . endif k = k + 1 x_traj ( k ) = x_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , cos_subgrid_index ) y_traj ( k ) = y_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , sin_subgrid_index ) !distance_traj(k)=sqrt((x_traj(k)-x_r)*(x_traj(k)-x_r)+(y_traj(k)-y_r)*(y_traj(k)-y_r)) distance_traj ( k ) = ( x_traj ( k ) - x_r ) * ( x_traj ( k ) - x_r ) + ( y_traj ( k ) - y_r ) * ( y_traj ( k ) - y_r ) call distrl_sqr ( x_r , y_r , x_traj ( k - 1 ), y_traj ( k - 1 ), x_traj ( k ), y_traj ( k ), x_intercept_traj ( k ), y_intercept_traj ( k ), distance_intercept_traj ( k ), frac_length_traj ( k )) if ( distance_intercept_traj ( k ). lt . distance_traj ( k ). and . distance_intercept_traj ( k ). le . distance_traj ( k - 1 )) then exit_traj = . true . y_loc = distance_intercept_traj ( k ) x_loc = dr_traj * ( k - 2 ) + frac_length_traj ( k ) * dr_traj valid_traj = . true . !elseif (distance_intercept_traj(k).gt.distance_intercept_traj(k-1)) then !    valid_traj=.false. !    exit_traj=.true. !    k=k-1 endif else exit_traj = . true . valid_traj = . false . endif enddo y_loc = sqrt ( y_loc ) end subroutine uEMEP_local_trajectory","tags":"","loc":"proc/uemep_local_trajectory.html"},{"title":"uEMEP_calculate_all_trajectory – uEMEP","text":"public  subroutine uEMEP_calculate_all_trajectory(x_emis, y_emis, t, traj_max_index, dr_traj, x_traj, y_traj) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name real :: x_emis real :: y_emis integer :: t integer :: traj_max_index real :: dr_traj real :: x_traj (traj_max_index) real :: y_traj (traj_max_index) Source Code subroutine uEMEP_calculate_all_trajectory ( x_emis , y_emis , t , traj_max_index , dr_traj , x_traj , y_traj ) use uEMEP_definitions implicit none integer k !integer i_rec,j_rec,i_emis,j_emis integer t , traj_max_index !integer i_source real dr_traj real x_emis , y_emis real x_traj ( traj_max_index ), y_traj ( traj_max_index ) integer i_integral , j_integral logical exit_traj k = 1 !Set the initial trajectory position to the emission source x_traj ( k ) = x_emis y_traj ( k ) = y_emis exit_traj = . false . do while (. not . exit_traj . and . k . lt . traj_max_index ) !Find what meteorological grid the trajectory point is in i_integral = 1 + floor (( x_traj ( k ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) j_integral = 1 + floor (( y_traj ( k ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) !Test to see if it is still in the grid if ( i_integral . ge . 1. and . i_integral . le . integral_subgrid_dim ( x_dim_index ). and . j_integral . ge . 1. and . j_integral . le . integral_subgrid_dim ( y_dim_index )) then k = k + 1 x_traj ( k ) = x_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , cos_subgrid_index ) y_traj ( k ) = y_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , sin_subgrid_index ) else exit_traj = . true . endif enddo end subroutine uEMEP_calculate_all_trajectory","tags":"","loc":"proc/uemep_calculate_all_trajectory.html"},{"title":"uEMEP_minimum_distance_trajectory_fast – uEMEP","text":"public  subroutine uEMEP_minimum_distance_trajectory_fast(x_r, y_r, traj_max_index_in, dr_traj, x_traj, y_traj, x_loc, y_loc, valid_traj) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name real, intent(in) :: x_r real, intent(in) :: y_r integer, intent(in) :: traj_max_index_in real, intent(in) :: dr_traj real, intent(in) :: x_traj (*) real, intent(in) :: y_traj (*) real, intent(out) :: x_loc real, intent(out) :: y_loc logical, intent(out) :: valid_traj Source Code subroutine uEMEP_minimum_distance_trajectory_fast ( x_r , y_r , traj_max_index_in , dr_traj , x_traj , y_traj , x_loc , y_loc , valid_traj ) use uEMEP_definitions implicit none real , intent ( out ) :: x_loc , y_loc logical , intent ( out ) :: valid_traj real , intent ( in ) :: dr_traj real , intent ( in ) :: x_r , y_r integer , intent ( in ) :: traj_max_index_in !real, intent(in) ::  x_traj(traj_max_index_in),y_traj(traj_max_index_in) real , intent ( in ) :: x_traj ( * ), y_traj ( * ) integer k real distance_traj , distance_intercept_traj real x_intercept_traj , y_intercept_traj , frac_length_traj real distance_intercept_min k = 1 !return !Set the distances for the initial emission grid !distance_traj(k)=sqrt((x_traj(k)-x_r)*(x_traj(k)-x_r)+(y_traj(k)-y_r)*(y_traj(k)-y_r)) distance_traj = ( x_traj ( k ) - x_r ) * ( x_traj ( k ) - x_r ) + ( y_traj ( k ) - y_r ) * ( y_traj ( k ) - y_r ) !Leave the routine because the receptor is the same as the emission grid if ( distance_traj . eq . 0 ) then y_loc = 0. x_loc = 0. valid_traj = . true . return endif !distance_intercept_traj(k)=distance_traj(k) y_loc = 0. x_loc = 0. valid_traj = . false . distance_intercept_min = distance_traj do k = 2 , traj_max_index_in if ( x_traj ( k ). ne . NODATA_value ) then call distrl_sqr ( x_r , y_r , x_traj ( k - 1 ), y_traj ( k - 1 ), x_traj ( k ), y_traj ( k ), x_intercept_traj , y_intercept_traj , distance_intercept_traj , frac_length_traj ) if ( distance_intercept_traj . lt . distance_intercept_min ) then distance_intercept_min = distance_intercept_traj y_loc = distance_intercept_traj x_loc = dr_traj * ( k - 2 ) + frac_length_traj * dr_traj valid_traj = . true . endif endif enddo !Remove most of the results because they are upwind if ( x_loc . eq . 0. and . y_loc . gt . dr_traj ) then valid_traj = . false . endif y_loc = sqrt ( y_loc ) end subroutine uEMEP_minimum_distance_trajectory_fast","tags":"","loc":"proc/uemep_minimum_distance_trajectory_fast.html"},{"title":"date_to_number – uEMEP","text":"public  function date_to_number(date_array, ref_year) result(res) Returns a date number from an array with date and time Note: Some wrong dates (e.g., 2023-02-29) will still return a number which will be wrong! Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] integer, intent(in) :: ref_year Reference year Return Value real(kind=dp) Date number in seconds since ref_year Source Code function date_to_number ( date_array , ref_year ) result ( res ) !! Returns a date number from an array with date and time !! !! Note: Some wrong dates (e.g., 2023-02-29) will still return a number which will be wrong! integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer , intent ( in ) :: ref_year !! Reference year real ( dp ) :: res !! Date number in seconds since ref_year ! Local variables integer :: y , m integer :: daysinmonth ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] res = 0.0 if ( date_array ( 1 ) . gt . ref_year ) then ! Add up days in the year do y = ref_year , date_array ( 1 ) - 1 if ((( mod ( y , 4 ) . eq . 0 ) . and . ( mod ( y , 100 ) . ne . 0 )) . or . ( mod ( y , 400 ) . eq . 0 )) then daysinmonth ( 2 ) = 29 else daysinmonth ( 2 ) = 28 end if do m = 1 , 12 res = res + sngl ( real ( daysinmonth ( m ))) end do end do end if ! Add up days in the remaining months if ((( mod ( date_array ( 1 ), 4 ) . eq . 0 ) . and . ( mod ( date_array ( 1 ), 100 ) . ne . 0 )) . or . ( mod ( date_array ( 1 ), 400 ) . eq . 0 )) then daysinmonth ( 2 ) = 29 else daysinmonth ( 2 ) = 28 end if if ( date_array ( 2 ) . gt . 1 ) then do m = 1 , date_array ( 2 ) - 1 res = res + sngl ( real ( daysinmonth ( m ))) end do end if res = res + sngl ( real ( date_array ( 3 ))) - 1.0 res = res + sngl ( real ( date_array ( 4 ))) / 2 4.0 ! starts at 0 res = res + sngl ( real ( date_array ( 5 ))) / 2 4.0 / 6 0.0 ! starts at 0 res = res + sngl ( real ( date_array ( 6 ))) / 2 4.0 / 6 0.0 / 6 0.0 ! starts at 0 end function date_to_number","tags":"","loc":"proc/date_to_number.html"},{"title":"date_to_julian – uEMEP","text":"public  function date_to_julian(date_array, ref_year) result(res) Returns Julian day from an array with date and time Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] integer, intent(in) :: ref_year Reference year Return Value integer Julian day Source Code function date_to_julian ( date_array , ref_year ) result ( res ) !! Returns Julian day from an array with date and time integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer , intent ( in ) :: ref_year !! Reference year integer :: res !! Julian day ! Local variables integer :: b ( 6 ) b ( 1 ) = date_array ( 1 ) b ( 2 ) = 1 b ( 3 ) = 1 b ( 4 ) = 0 b ( 5 ) = 0 b ( 6 ) = 0 res = int ( date_to_number ( date_array , ref_year ) - date_to_number ( b , ref_year ) + 1 ) end function date_to_julian","tags":"","loc":"proc/date_to_julian.html"},{"title":"day_of_week – uEMEP","text":"public  function day_of_week(date_array) result(res) The subroutine calculates the day of week given current datetime,\nwhere DAYW = 1 corresponds to Monday and DAYW = 7 to Sunday. The\nalgorithm is based on the tables in \"Hvem Hva Hvor 1971\" (p. 121)\nand is valid for all years from 1800 to infinity Adapted from EPISODE code Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] Return Value integer Day of week [1-7] Source Code function day_of_week ( date_array ) result ( res ) !! The subroutine calculates the day of week given current datetime, !! where DAYW = 1 corresponds to Monday and DAYW = 7 to Sunday. The !! algorithm is based on the tables in \"Hvem Hva Hvor 1971\" (p. 121) !! and is valid for all years from 1800 to infinity !! !! Adapted from EPISODE code integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer :: res !! Day of week [1-7] ! Local variables integer :: jm ( 12 ) = [ 1 , 5 , 5 , 2 , 7 , 4 , 2 , 6 , 3 , 1 , 5 , 3 ] ! Column number for each month integer :: ir ! Row in HHH table for day of month integer :: jc ! Column in HHH table for month integer :: nt ! Number in HHH table for row ir and column jc integer :: jk ! Column in HHH table for year integer :: j4 , j100 , j400 ! Adjustment values for leap year logical :: leap ! If leap year then true else false integer :: daym , mnth , year ! Extract values from array daym = date_array ( 3 ) mnth = date_array ( 2 ) year = date_array ( 1 ) ! Calculate leap year or not leap = . false . if ( mod ( year , 4 ) . eq . 0 . and . . not . ( mod ( year , 100 ) . eq . 0 . and . mod ( year , 400 ) . ne . 0 )) leap = . true . ! Calculate row number for day of month ir = mod ( daym - 1 , 7 ) + 1 ! Calculate column number for month jc = jm ( mnth ) if ( leap . and . ( mnth . eq . 1 . or . mnth . eq . 2 )) jc = jc + 1 ! Calculate \"number\" in HHH table with row IR and column JC nt = mod ( ir + 7 - jc , 7 ) + 1 ! Calculate column number for year (adjusting for leap years) j4 = ( year - 1800 ) / 4 j100 = ( year - 1800 ) / 100 j400 = ( year - 1600 ) / 400 jk = mod ( year - 1800 + j4 - j100 + j400 + 3 - 1 , 7 ) + 1 ! Calculate day of week res = mod ( jk - 1 + nt - 1 , 7 ) + 1 end function day_of_week","tags":"","loc":"proc/day_of_week.html"},{"title":"summer_time_europe – uEMEP","text":"public  function summer_time_europe(date_array) result(summer_time) Returns true if supplied date is during summer time in Europe, else false Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] Return Value logical True if summer time, else false Source Code function summer_time_europe ( date_array ) result ( summer_time ) !! Returns true if supplied date is during summer time in Europe, else false integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] logical :: summer_time !! True if summer time, else false ! Local variables integer :: a ( 6 ), b_start ( 6 ), b_end ( 6 ) integer :: ref_year , year real ( dp ) :: datenum_start , datenum_end , datenum a = date_array ref_year = 2000 b_start = 0 b_end = 0 year = a ( 1 ) b_start ( 1 ) = a ( 1 ) b_start ( 2 ) = 3 b_start ( 3 ) = ( 31 - mod (((( 5 * year ) / 4 ) + 4 ), 7 )) b_start ( 4 ) = 1 b_end ( 1 ) = a ( 1 ) b_end ( 2 ) = 10 b_end ( 3 ) = ( 31 - mod (((( 5 * year ) / 4 ) + 1 ), 7 )) b_end ( 4 ) = 1 datenum_start = date_to_number ( b_start , ref_year ) datenum_end = date_to_number ( b_end , ref_year ) datenum = date_to_number ( a , ref_year ) summer_time = . false . if ( datenum . ge . datenum_start . and . datenum . lt . datenum_end ) summer_time = . true . end function summer_time_europe","tags":"","loc":"proc/summer_time_europe.html"},{"title":"number_to_date – uEMEP","text":"public  subroutine number_to_date(date_num, date_array, ref_year) Returns array with date and time from a date number 'date-num' can be any non-negative number. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: date_num Date number in seconds since ref_year integer, intent(out) :: date_array (6) Datetime [y,m,d,h,m,s] integer, intent(in) :: ref_year Reference year Source Code subroutine number_to_date ( date_num , date_array , ref_year ) !! Returns array with date and time from a date number !! !! 'date-num' can be any non-negative number. real ( dp ), intent ( in ) :: date_num !! Date number in seconds since ref_year integer , intent ( out ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer , intent ( in ) :: ref_year !! Reference year ! Local variables integer :: y , m , d real ( dp ) :: day_fraction integer :: day_int integer :: day_count , days_in_year integer :: rest_seconds integer :: daysinmonth ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ! Check that date number if positive if ( date_num < 0 ) then print \"(a)\" , \"ERROR! In number_to_date, 'date_num' must be >= 0.0\" stop 1 end if ! Set day fraction to the nearest second. Avoiding round off errors day_int = idint ( date_num ) day_fraction = date_num - day_int ! Determine hours, minutes and seconds date_array = 0 rest_seconds = int ( day_fraction * 2 4.0 * 360 0.0 + 0.5 ) ! Rounded off date_array ( 4 ) = int ( rest_seconds / 360 0.0 ) date_array ( 5 ) = int (( rest_seconds / 6 0.0 - date_array ( 4 ) * 6 0.0 )) date_array ( 6 ) = int (( rest_seconds - date_array ( 4 ) * 360 0.0 - date_array ( 5 ) * 6 0.0 )) ! Count up days keeping track of the year, month and day of month ! Determine year y = ref_year - 1 day_count = 0 do while ( day_count . le . day_int ) y = y + 1 days_in_year = 365 if ((( mod ( y , 4 ) . eq . 0 ) . and . ( mod ( y , 100 ) . ne . 0 )) . or . ( mod ( y , 400 ) . eq . 0 )) days_in_year = 366 ! Leap year day_count = day_count + days_in_year end do date_array ( 1 ) = y day_count = day_count - days_in_year ! Determine month given the year daysinmonth ( 2 ) = 28 if ((( mod ( date_array ( 1 ), 4 ) . eq . 0 ) . and . ( mod ( date_array ( 1 ), 100 ) . ne . 0 )) . or . ( mod ( date_array ( 1 ), 400 ) . eq . 0 )) daysinmonth ( 2 ) = 29 ! Leap month m = 0 do while ( day_count . le . day_int ) m = m + 1 day_count = day_count + daysinmonth ( m ) end do date_array ( 2 ) = m day_count = day_count - daysinmonth ( m ) ! Determine day d = 0 do while ( day_count . le . day_int ) d = d + 1 day_count = day_count + 1 end do date_array ( 3 ) = d end subroutine number_to_date","tags":"","loc":"proc/number_to_date.html"},{"title":"datestr_to_date – uEMEP","text":"public  subroutine datestr_to_date(date_str, format_str, date_array) Converts date string to a date array based on the format string Example:\n    call datestr_to_date(\"20190429123005\", \"yyyymmdd\", date_array_out)\nReturns:\n    date_arrat_out = [2019, 4, 29, 0, 0, 0] Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: date_str Date string [yyyymmddHHMMSS] character(len=*), intent(in) :: format_str Format string integer, intent(out) :: date_array (6) Datetime [y,m,d,h,m,s] Source Code subroutine datestr_to_date ( date_str , format_str , date_array ) !! Converts date string to a date array based on the format string !! !! Example: !!     call datestr_to_date(\"20190429123005\", \"yyyymmdd\", date_array_out) !! Returns: !!     date_arrat_out = [2019, 4, 29, 0, 0, 0] character ( * ), intent ( in ) :: date_str !! Date string [yyyymmddHHMMSS] character ( * ), intent ( in ) :: format_str !! Format string integer , intent ( out ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] ! Local variables integer :: pos ! Extract elements of the date string pos = index ( format_str , 'yyyy' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 3 ), * ) date_array ( 1 ) else date_array ( 1 ) = 0 end if pos = index ( format_str , 'mm' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 2 ) else date_array ( 2 ) = 0 end if pos = index ( format_str , 'dd' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 3 ) else date_array ( 3 ) = 0 end if pos = index ( format_str , 'HH' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 4 ) else date_array ( 4 ) = 0 end if pos = index ( format_str , 'MM' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 5 ) else date_array ( 5 ) = 0 end if pos = index ( format_str , 'SS' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 6 ) else date_array ( 6 ) = 0 end if end subroutine datestr_to_date","tags":"","loc":"proc/datestr_to_date.html"},{"title":"date_to_datestr – uEMEP","text":"public  subroutine date_to_datestr(date_array, format_str, date_str) Returns a date string based on (yyyy.mm.dd HH:MM:SS) from a date array Currently only accepts 'yyyymmddHH', 'yyymmdd' and 'yyyymm' as the format string. Example:\n    call date_to_datestr([2019, 4, 29, 30, 0, 0], \"yyyymmdd\", date_str)\nReturns:\n    date_str = \"20190429\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] character(len=*), intent(in) :: format_str Format string character(len=*), intent(out) :: date_str Date string Source Code subroutine date_to_datestr ( date_array , format_str , date_str ) !! Returns a date string based on (yyyy.mm.dd HH:MM:SS) from a date array !! !! Currently only accepts 'yyyymmddHH', 'yyymmdd' and 'yyyymm' as the format string. !! !! Example: !!     call date_to_datestr([2019, 4, 29, 30, 0, 0], \"yyyymmdd\", date_str) !! Returns: !!     date_str = \"20190429\" integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] character ( len =* ), intent ( in ) :: format_str !! Format string character ( len =* ), intent ( out ) :: date_str !! Date string ! Local variables integer :: pos date_str = format_str ! To avoid just putting in date parts e.g. mm or dd that might occurr in a string then it is required that at least two of the date ! strings are present, i.e. yyyy, mm and dd or HH, MM and SS if (( index ( format_str , 'yyyy' ) . gt . 0 . and . index ( format_str , 'mm' ) . gt . 0 ) . or . ( index ( format_str , 'yyyy' ) . gt . 0 & . and . index ( format_str , 'dd' ) . gt . 0 ) . or . ( index ( format_str , 'dd' ) . gt . 0 . and . index ( format_str , 'mm' ). gt . 0 ) & . or . ( index ( format_str , 'HH' ) . gt . 0 . and . index ( format_str , 'MM' ) . gt . 0 ) . or . ( index ( format_str , 'HH' ) . gt . 0 & . and . index ( format_str , 'SS' ) . gt . 0 ) . or . ( index ( format_str , 'MM' ) . gt . 0 . and . index ( format_str , 'SS' ) . gt . 0 )) then ! Do nothing but continue with routine as this is a valid format for date string substitution else ! Leave the routine return end if ! Now it only accepts the strings 'yyyymmddHH', 'yyyymmdd' and 'yyyymm' for replacement pos = index ( format_str , 'yyyymmddHH' ) if ( pos . gt . 0 ) then write ( date_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) if ( date_array ( 2 ) . gt . 9 ) then write ( date_str ( pos + 4 : pos + 5 ), '(i2)' ) date_array ( 2 ) else write ( date_str ( pos + 4 : pos + 5 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if if ( date_array ( 3 ) . gt . 9 ) then write ( date_str ( pos + 6 : pos + 7 ), '(i2)' ) date_array ( 3 ) else write ( date_str ( pos + 6 : pos + 7 ), '(a1,i1)' ) '0' , date_array ( 3 ) end if if ( date_array ( 4 ) . gt . 9 ) then write ( date_str ( pos + 8 : pos + 9 ), '(i2)' ) date_array ( 4 ) else write ( date_str ( pos + 8 : pos + 9 ), '(a1,i1)' ) '0' , date_array ( 4 ) end if return end if pos = index ( format_str , 'yyyymmdd' ) if ( pos . gt . 0 ) then write ( date_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) if ( date_array ( 2 ) . gt . 9 ) then write ( date_str ( pos + 4 : pos + 5 ), '(i2)' ) date_array ( 2 ) else write ( date_str ( pos + 4 : pos + 5 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if if ( date_array ( 3 ) . gt . 9 ) then write ( date_str ( pos + 6 : pos + 7 ), '(i2)' ) date_array ( 3 ) else write ( date_str ( pos + 6 : pos + 7 ), '(a1,i1)' ) '0' , date_array ( 3 ) end if return end if pos = index ( format_str , 'yyyymm' ) if ( pos . gt . 0 ) then write ( date_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) if ( date_array ( 2 ) . gt . 9 ) then write ( date_str ( pos + 4 : pos + 5 ), '(i2)' ) date_array ( 2 ) else write ( date_str ( pos + 4 : pos + 5 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if return end if end subroutine date_to_datestr","tags":"","loc":"proc/date_to_datestr.html"},{"title":"date_to_datestr_new – uEMEP","text":"private  subroutine date_to_datestr_new(date_array, in_format_str, out_a_str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] character(len=*), intent(in) :: in_format_str Format string character(len=*), intent(out) :: out_a_str Date string Source Code subroutine date_to_datestr_new ( date_array , in_format_str , out_a_str ) integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] character ( * ), intent ( in ) :: in_format_str !! Format string character ( * ), intent ( out ) :: out_a_str !! Date string ! Local variables integer :: pos ! Extract elements of the date string pos = index ( in_format_str , 'yyyy' ) if ( pos . gt . 0 ) then write ( out_a_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) end if pos = index ( in_format_str , 'mm' ) if ( pos . gt . 0 ) then if ( date_array ( 2 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 2 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if end if pos = index ( in_format_str , 'dd' ) if ( pos . gt . 0 ) then if ( date_array ( 3 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 3 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 3 ) end if end if pos = index ( in_format_str , 'HH' ) if ( pos . gt . 0 ) then if ( date_array ( 4 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 4 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 4 ) end if end if pos = index ( in_format_str , 'MM' ) if ( pos . gt . 0 ) then if ( date_array ( 5 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 5 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 5 ) end if end if pos = index ( in_format_str , 'SS' ) if ( pos . gt . 0 ) then if ( date_array ( 6 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 6 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 6 ) end if end if end subroutine date_to_datestr_new","tags":"","loc":"proc/date_to_datestr_new.html"},{"title":"date_to_datestr_bracket – uEMEP","text":"public  subroutine date_to_datestr_bracket(date_array, in_format_str, out_a_str) Converts a date array to a date string with brackets in format string format string brackets are '<' and '>'. Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] character(len=*), intent(in) :: in_format_str Format string character(len=*), intent(out) :: out_a_str Date string Source Code subroutine date_to_datestr_bracket ( date_array , in_format_str , out_a_str ) !! Converts a date array to a date string with brackets in format string !! !! format string brackets are '<' and '>'. integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] character ( * ), intent ( in ) :: in_format_str !! Format string character ( * ), intent ( out ) :: out_a_str !! Date string ! Local variables character ( 256 ) :: format_str , a_str integer :: pos1 , pos2 ! Only changes dates when they are inside '<.....>' ! Removes these once changed pos1 = index ( in_format_str , '<' ) pos2 = index ( in_format_str , '>' ) if ( pos1 . le . 0 . or . pos2 . le . 0 . or . pos1 + 1 . gt . pos2 - 1 ) then out_a_str = in_format_str return end if ! Reassign format_str to be just the text between <..> format_str = in_format_str ( pos1 + 1 : pos2 - 1 ) a_str = format_str ! Get the date string call date_to_datestr_new ( date_array , format_str , a_str ) ! Insert the a_str into out_a_str, removing the '<>' text if ( len_trim ( in_format_str ) . gt . pos2 ) then out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) // in_format_str ( pos2 + 1 :) else out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) end if end subroutine date_to_datestr_bracket","tags":"","loc":"proc/date_to_datestr_bracket.html"},{"title":"date_to_datestr_squarebracket – uEMEP","text":"public  subroutine date_to_datestr_squarebracket(date_array, in_format_str, out_a_str) Converts a date array to a date string with brackets in format string format string brackets are '<' and '>'. Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) character(len=*), intent(in) :: in_format_str character(len=*), intent(out) :: out_a_str Source Code subroutine date_to_datestr_squarebracket ( date_array , in_format_str , out_a_str ) !! Converts a date array to a date string with brackets in format string !! !! format string brackets are '<' and '>'. integer , intent ( in ) :: date_array ( 6 ) character ( * ), intent ( in ) :: in_format_str character ( * ), intent ( out ) :: out_a_str ! Local variables character ( 256 ) :: format_str , a_str integer :: pos1 , pos2 ! Only changes dates when they are inside '[.....]' ! Removes these once changed pos1 = index ( in_format_str , '[' ) pos2 = index ( in_format_str , ']' ) if ( pos1 . le . 0 . or . pos2 . le . 0 . or . pos1 + 1 . gt . pos2 - 1 ) then out_a_str = in_format_str return end if ! Reassign format_str to be just the text between <..> format_str = in_format_str ( pos1 + 1 : pos2 - 1 ) a_str = format_str ! Get date string call date_to_datestr_new ( date_array , format_str , a_str ) ! Insert the a_str into out_a_str, removing the '[]' text if ( len_trim ( in_format_str ) . gt . pos2 ) then out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) // in_format_str ( pos2 + 1 :) else out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) end if end subroutine date_to_datestr_squarebracket","tags":"","loc":"proc/date_to_datestr_squarebracket.html"},{"title":"get_sun_angles – uEMEP","text":"public  subroutine get_sun_angles(lat, lon, date_a, date_num, difutc_h, azimuth_ang, zenith_ang) Returns the azimuth and zenith angles Routine modified from NORTRIP Arguments Type Intent Optional Attributes Name real, intent(in) :: lat real, intent(in) :: lon integer, intent(in) :: date_a (6) real(kind=dp), intent(in) :: date_num real, intent(in) :: difutc_h real, intent(out) :: azimuth_ang real, intent(out) :: zenith_ang Source Code subroutine get_sun_angles ( lat , lon , date_a , date_num , difutc_h , azimuth_ang , zenith_ang ) !! Returns the azimuth and zenith angles !! !! Routine modified from NORTRIP real , intent ( in ) :: lat real , intent ( in ) :: lon integer , intent ( in ) :: date_a ( 6 ) real ( dp ), intent ( in ) :: date_num real , intent ( in ) :: difutc_h real , intent ( out ) :: azimuth_ang real , intent ( out ) :: zenith_ang ! Local variables real :: julian_day , time_s , dayang , dec , eqtime , solartime , hourang , azt , az real , parameter :: s0 = 136 7.0 real , parameter :: pi = 3.14159 / 18 0.0 integer :: ref_year = 2000 if ( date_a ( 1 ) . eq . 0 ) then julian_day = real ( date_num ) else julian_day = date_to_julian ( date_a , ref_year ) end if time_s = ( julian_day - 1 ) * 2 4.0 * 360 0.0 dayang = 36 0.0 / 36 5.0 * ( julian_day - 1.0 ) dec = 0.396 - 2 2.91 * cos ( pi * dayang ) + 4.025 * sin ( pi * dayang ) eqtime = ( 1.03 + 2 5.7 * cos ( pi * dayang ) - 44 0.0 * sin ( pi * dayang ) - 20 1.0 * cos ( 2.0 * pi * dayang ) - 56 2.0 * sin ( 2.0 * pi * dayang )) / secphour solartime = mod ( time_s + secpday + secphour * ( lon / 1 5.0 + difutc_h + eqtime ), secpday ) hourang = 1 5.0 * ( 1 2.0 - solartime / secphour ) ! Set zenith angle for atmospheric corrections azt = sin ( pi * dec ) * sin ( pi * lat ) + cos ( pi * dec ) * cos ( pi * lat ) * cos ( pi * hourang ) if ( abs ( azt ) . lt . 1.0 ) then az = acos ( azt ) / pi else az = 0.0 end if azimuth_ang = 18 0.0 - hourang zenith_ang = az end subroutine get_sun_angles","tags":"","loc":"proc/get_sun_angles.html"},{"title":"uEMEP_set_emission_factors – uEMEP","text":"public  subroutine uEMEP_set_emission_factors() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_emission_factors use uEMEP_definitions implicit none write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Setting emission factors (uEMEP_set_emission_factors)' write ( unit_logfile , '(A)' ) '================================================================' !Converts the emission units of the input data to a standard ug/s/subgrid emission_factor_conversion ( nox_index , traffic_index ,:) = emission_factor ( nox_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( nox_index , shipping_index ,:) = emission_factor ( nox_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) ![tonne/month]*(ug/ton)*(month/sec)=ug/sec. Only valid for the current AIS data which is a total. Should change emission_factor_conversion ( nox_index , heating_index ,:) = emission_factor ( nox_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( no2_index , traffic_index ,:) = emission_factor ( no2_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) emission_factor_conversion ( no2_index , shipping_index ,:) = emission_factor ( no2_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) emission_factor_conversion ( no2_index , heating_index ,:) = emission_factor ( no2_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( pm25_index , traffic_index ,:) = emission_factor ( pm25_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( pm25_index , shipping_index ,:) = emission_factor ( pm25_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) ![tonne/month]*(ug/kg)*(month/sec)=ug/sec emission_factor_conversion ( pm25_index , heating_index ,:) = emission_factor ( pm25_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( pm10_index , traffic_index ,:) = emission_factor ( pm10_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( pm10_index , shipping_index ,:) = emission_factor ( pm10_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) ![tonne/month]*(ug/kg)*(month/sec)=ug/sec emission_factor_conversion ( pm10_index , heating_index ,:) = emission_factor ( pm10_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( pmex_index , traffic_index ,:) = emission_factor ( pmex_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( nh3_index , agriculture_index ,:) = emission_factor ( nh3_index , agriculture_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![kg/yr]*(ug/kg)*(yr/sec)=ug/sec !Test for monthly data !emission_factor_conversion(nh3_index,agriculture_index,:)=emission_factor_conversion(nh3_index,agriculture_index,:)*1.06 if ( read_shipping_from_netcdf_flag ) then emission_factor_conversion (:, shipping_index ,:) = ( 1.e+6 ) / ( 360 0. ) ![g/hr]*(ug/sec)=ug/sec. elseif ( read_weekly_shipping_data_flag . or . read_monthly_and_daily_shipping_data_flag ) then !Convert from g/hour to ug/s emission_factor_conversion (:, shipping_index ,:) = ( 1.e+6 ) / ( 360 0. ) ![g/hr]*(ug/sec)=ug/sec. endif if ( use_RWC_emission_data ) then !Convert from g/h/subgrid to ug/s/subgrid emission_factor_conversion (:, heating_index ,:) = 1.e6 / 360 0. if ( annual_calculations ) then !Convert from g/yr/subgrid to ug/s/subgrid. Temporal profile will be set to 1. !Should also be in shipping. No because the original data is read in as g/hr emission_factor_conversion (:, heating_index ,:) = 1.e6 / 360 0. / 2 4. / 36 5. endif endif !Converts tonne per year to ug/s/subgrid emission_factor_conversion (:, industry_index ,:) = 1.e12 / ( 360 0. * 24 * 36 5. ) !In the case of RIVM data then emissions are already given in ug/s/subgrid if ( read_subgrid_emission_data ) then emission_factor_conversion (:,:,:) = 1.0 endif end subroutine uEMEP_set_emission_factors","tags":"","loc":"proc/uemep_set_emission_factors.html"},{"title":"uEMEP_convert_proxy_to_emissions – uEMEP","text":"public  subroutine uEMEP_convert_proxy_to_emissions() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_convert_proxy_to_emissions use uEMEP_definitions implicit none integer i_source , i_subsource integer tt real sum_emission_subgrid integer i_pollutant !Do not calculate emissions if EMEP emissions are to be used if ( local_subgrid_method_flag . eq . 3 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Converting proxy data to emissions (uEMEP_convert_proxy_to_emissions)' write ( unit_logfile , '(A)' ) '================================================================' !Set all emissions to the same constant emission value with emissions in ug/sec for all sources do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i_subsource = 1 do i_pollutant = 1 , n_pollutant_loop !Do not calculate for traffic if use_NORTRIP_emission_data=.true. and  use_NORTRIP_emission_pollutant=.false.). This is done in uEMEP_grid_roads if ( i_source . ne . traffic_index . or . read_subgrid_emission_data & . or .( i_source . eq . traffic_index . and .. not . use_NORTRIP_emission_data ) & . or .( i_source . eq . traffic_index . and . use_NORTRIP_emission_data . and .. not . use_NORTRIP_emission_pollutant ( pollutant_loop_index ( i_pollutant )))) then do tt = 1 , subgrid_dim ( t_dim_index ) emission_subgrid (:,:, tt , i_source , i_pollutant ) = proxy_emission_subgrid (:,:, i_source , i_pollutant ) & * emission_factor_conversion ( pollutant_loop_index ( i_pollutant ), i_source , i_subsource ) & * emission_time_profile_subgrid (:,:, tt , i_source , i_pollutant ) !write(*,*) sum(proxy_emission_subgrid(:,:,i_source,i_subsource)),emission_factor_conversion(compound_index,i_source,i_subsource),sum(emission_time_profile_subgrid(:,:,tt,i_source,i_subsource)) enddo endif sum_emission_subgrid = sum ( emission_subgrid (:,:,:, i_source , i_pollutant )) write ( unit_logfile , '(A,es12.2)' ) 'Sum of emissions for ' // trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' over period (kg)=' , sum_emission_subgrid * 360 0. / 1.e9 enddo endif enddo !Check NOx shipping !i_source=shipping_index !i_pollutant=pollutant_loop_back_index(nox_nc_index) !do tt=1,subgrid_dim(t_dim_index) !    write(unit_logfile,'(A,es12.2)') 'Sum of emissions per hour '//trim(source_file_str(i_source))//' '//trim(pollutant_file_str(pollutant_loop_index(i_pollutant)))//' over period (kg)=',sum(emission_subgrid(:,:,tt,i_source,i_pollutant))*3600./1.e9 !enddo end subroutine uEMEP_convert_proxy_to_emissions","tags":"","loc":"proc/uemep_convert_proxy_to_emissions.html"},{"title":"uEMEP_nox_emission_temperature – uEMEP","text":"public  subroutine uEMEP_nox_emission_temperature() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_nox_emission_temperature !Routine for doing the chemistry calculations in uEMEP use uEMEP_definitions implicit none integer t_start , t_end integer i , j , t integer i_cross , j_cross real :: ref_temperature1 =- 1 0. real :: ref_temperature2 = 1 0. real :: ref_scaling1 = 3. real :: ref_scaling2 = 1. real :: emission_scaling real :: temperature real :: emission_scaling_average , temperature_average integer :: emission_scaling_average_count real :: weighting_loop_sum real :: temperature_loop real :: weighting_loop real :: emission_scaling_loop real :: sigma_loop integer :: k !Do not correct if no traffic is to be calculated if (. not . calculate_source ( traffic_index )) then return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Using temperature dependency of NOx traffic emissions (uEMEP_nox_emission_temperature)' write ( unit_logfile , '(A)' ) '================================================================' if ( annual_calculations ) write ( unit_logfile , '(A)' ) 'Using temperature distribution to calculate the emissions scaling.' t_start = 1 t_end = subgrid_dim ( t_dim_index ) ref_temperature1 = traffic_nox_emission_temperature_ref_temperature ( 1 ) ref_temperature2 = traffic_nox_emission_temperature_ref_temperature ( 2 ) ref_scaling1 = traffic_nox_emission_temperature_ref_scaling ( 1 ) ref_scaling2 = traffic_nox_emission_temperature_ref_scaling ( 2 ) !Use the meteo model input from EMEP or alternative directly !This is so it will work for saving emissions for EMEP as well since the meteo and cross reference subgrids are not calculated emission_scaling_average = 0. emission_scaling_average_count = 0 temperature_average = 0 do t = t_start , t_end do j = 1 , emission_subgrid_dim ( y_dim_index , traffic_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , traffic_index ) if ( save_emissions_for_EMEP ( allsource_index )) then if ( allocated ( meteo_var1d_nc )) then !Need to cross reference the meteo grid to the emission grid as this is not done normally i_cross = 1 + floor (( x_emission_subgrid ( i , j , traffic_index ) - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) j_cross = 1 + floor (( y_emission_subgrid ( i , j , traffic_index ) - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) !Because the meteo grid can be smaller than the EMEP grid then need to limit it i_cross = min ( max ( 1 , i_cross ), dim_length_meteo_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_meteo_nc ( y_dim_nc_index )) else write ( unit_logfile , '(a)' ) 'No meteo data available for traffic temperature correction. Stopping.' stop endif else !Use the EMEP meteorology i_cross = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , traffic_index ) j_cross = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , traffic_index ) i_cross = min ( max ( 1 , i_cross ), dim_length_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_nc ( y_dim_nc_index )) endif !i_integral=crossreference_emission_to_integral_subgrid(i,j,x_dim_index,traffic_index) !j_integral=crossreference_emission_to_integral_subgrid(i,j,y_dim_index,traffic_index) if ( use_alternative_meteorology_flag ) then temperature = meteo_var3d_nc ( i_cross , j_cross , t , t2m_nc_index ) - 27 3.14 else temperature = var3d_nc ( i_cross , j_cross , t , t2m_nc_index , allsource_index , meteo_p_loop_index ) - 27 3.14 endif !temperature=meteo_subgrid(i_integral,j_integral,t,t2m_subgrid_index)-273.14 !If annual calculation then use a Gaussian temperature distribution based on Norwegian conditions with a sigma of 7 degrees !This is hardcoded awaiting the proper implementation in NORTRIP if ( annual_calculations ) then sigma_loop = 7. weighting_loop_sum = 0 emission_scaling = 0 do k =- 20 , 20 temperature_loop = temperature + k weighting_loop = exp ( - ( temperature_loop - temperature ) * ( temperature_loop - temperature ) / 2. / ( sigma_loop * sigma_loop )) weighting_loop_sum = weighting_loop_sum + weighting_loop emission_scaling_loop = ref_scaling1 + ( ref_scaling2 - ref_scaling1 ) * ( temperature_loop - ref_temperature1 ) / ( ref_temperature2 - ref_temperature1 ) emission_scaling_loop = max ( min ( emission_scaling_loop , ref_scaling1 ), ref_scaling2 ) emission_scaling = emission_scaling + emission_scaling_loop * weighting_loop !write(*,*) k,temperature_loop,weighting_loop,emission_scaling_loop enddo emission_scaling = emission_scaling / weighting_loop_sum else emission_scaling = ref_scaling1 + ( ref_scaling2 - ref_scaling1 ) * ( temperature - ref_temperature1 ) / ( ref_temperature2 - ref_temperature1 ) emission_scaling = max ( min ( emission_scaling , ref_scaling1 ), ref_scaling2 ) endif emission_scaling_average = emission_scaling_average + emission_scaling temperature_average = temperature_average + temperature emission_scaling_average_count = emission_scaling_average_count + 1 !subgrid(i,j,t,local_subgrid_index,traffic_index,pollutant_loop_back_index(nox_nc_index))=emission_scaling*subgrid(i,j,t,local_subgrid_index,traffic_index,pollutant_loop_back_index(nox_nc_index)) emission_subgrid ( i , j , t , traffic_index , pollutant_loop_back_index ( nox_nc_index )) = emission_scaling * emission_subgrid ( i , j , t , traffic_index , pollutant_loop_back_index ( nox_nc_index )) !write(*,'(3i,2f12.2)') i,j,t,temperature,emission_scaling enddo enddo enddo write ( unit_logfile , '(a,2f12.2)' ) 'Average emissions scaling factor and temperature for traffic NOx: ' , emission_scaling_average / emission_scaling_average_count , temperature_average / emission_scaling_average_count write ( unit_logfile , '(a,4f12.2)' ) 'Parameters ref_temperature1,ref_temperature2,ref_scaling1,ref_scaling2: ' , ref_temperature1 , ref_temperature2 , ref_scaling1 , ref_scaling2 end subroutine uEMEP_nox_emission_temperature","tags":"","loc":"proc/uemep_nox_emission_temperature.html"},{"title":"uEMEP_read_agriculture_rivm_data – uEMEP","text":"public  subroutine uEMEP_read_agriculture_rivm_data() Uses mod_rdm2ll uEMEP_definitions Do not use!! Arguments None Source Code subroutine uEMEP_read_agriculture_rivm_data use uEMEP_definitions use mod_rdm2ll , only : RDM2LL implicit none integer i , j character ( 256 ) temp_str , temp_str1 integer unit_in logical :: exists integer count , index_val real ddlatitude , ddlongitude , totalnh3emission real y_agriculture , x_agriculture integer i_agriculture_index , j_agriculture_index real nh3emission_scale , nh3_gridsize ( 2 ) integer i_range , j_range , i_file integer i_start , i_end , j_start , j_end logical , allocatable :: agriculture_emission_data_available (:,:) integer , allocatable :: agriculture_emission_emep_subgrid_count (:,:) integer iii , jjj integer source_index , subsource_index integer t integer :: io real x_temp ( 3 , 3 ), y_temp ( 3 , 3 ), z_temp ( 3 , 3 ) real temp_emission write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading agriculture rivm nh3 data  (uEMEP_read_agriculture_rivm_data)' write ( unit_logfile , '(A)' ) '================================================================' if (. not . save_emissions_for_EMEP ( agriculture_index )) then projection_type = RDM_projection_index endif source_index = agriculture_index n_subsource ( source_index ) = 1 !unit_conversion(source_index)=1. !Converts kg to mg t = 1 !Internal check allocate ( agriculture_emission_data_available ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) proxy_emission_subgrid (:,:, source_index ,:) = 0. agriculture_emission_data_available = . false . pathfilename_agriculture ( 1 ) = trim ( pathname_agriculture ( 1 )) // trim ( filename_agriculture ( 1 )) pathfilename_agriculture ( 2 ) = trim ( pathname_agriculture ( 2 )) // trim ( filename_agriculture ( 2 )) !Test existence of the agricultural files. If does not exist then stop inquire ( file = trim ( pathfilename_agriculture ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: agriculture file does not exist: ' , trim ( pathfilename_agriculture ( 1 )) stop endif inquire ( file = trim ( pathfilename_agriculture ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: agriculture file does not exist: ' , trim ( pathfilename_agriculture ( 2 )) stop endif !Open the file for reading do i_file = 1 , 2 unit_in = 20 open ( unit_in , file = pathfilename_agriculture ( i_file ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening agriculture file ' // trim ( pathfilename_agriculture ( i_file )) rewind ( unit_in ) !Read header x,y,emission read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) trim ( temp_str ) count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit ddlatitude = 0. ; ddlongitude = 0. ; totalnh3emission = 0. ; !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) x_agriculture !write (*,*) ddlatitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) y_agriculture !write (*,*) ddlongitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) !write(*,*) index_val,trim(temp_str1),trim(temp_str) !write(*,*) index_val,trim(temp_str) read ( temp_str , * ) totalnh3emission !write (*,*) trim(temp_str1),totalnh3emission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) totalparticulatematteremission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !temp_str1=temp_str !if (len(temp_str1).gt.0) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission count = count + 1 !Convert lat lon to utm coords call RDM2LL ( y_agriculture , x_agriculture , ddlatitude , ddlongitude ) if ( save_emissions_for_EMEP ( agriculture_index )) then if ( projection_type . eq . LL_projection_index ) then y_agriculture = ddlatitude x_agriculture = ddlongitude elseif ( projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_agriculture , y_agriculture , ddlongitude , ddlatitude , EMEP_projection_attributes ) elseif ( projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_agriculture , y_agriculture , ddlongitude , ddlatitude , EMEP_projection_attributes ) endif endif if ( mod ( count , 10000 ). eq . 0 ) write ( unit_logfile , '(i,5f12.4)' ) count , y_agriculture , x_agriculture , ddlatitude , ddlongitude , totalnh3emission !Find the grid index it belongs to i_agriculture_index = 1 + floor (( x_agriculture - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_agriculture_index = 1 + floor (( y_agriculture - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if ( i_file . eq . 1 ) then !Point sources go straight into the emission grid subsource_index = 1 nh3emission_scale = 1. i_start = i_agriculture_index ; i_end = i_agriculture_index ; j_start = j_agriculture_index ; j_end = j_agriculture_index ; proxy_emission_subgrid ( i_agriculture_index , j_agriculture_index , source_index , pollutant_loop_back_index ( nh3_nc_index )) = & proxy_emission_subgrid ( i_agriculture_index , j_agriculture_index , source_index , pollutant_loop_back_index ( nh3_nc_index )) & + totalnh3emission agriculture_emission_data_available ( i_agriculture_index , j_agriculture_index ) = . true . else !Area sources on 1 km grid if ( n_subsource ( source_index ). eq . 2 ) then subsource_index = 2 else subsource_index = 1 endif !h_emis(source_index,subsource_index)=3. nh3_gridsize (:) = 100 0. nh3emission_scale = emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index ) / ( nh3_gridsize ( x_dim_index ) * nh3_gridsize ( y_dim_index )) if ( save_emissions_for_EMEP ( agriculture_index )) then if ( projection_type . eq . LL_projection_index ) then !Approximate grid size in degrees nh3_gridsize ( x_dim_index ) = nh3_gridsize ( x_dim_index ) / 11057 0. / cos ( 3.14159 / 18 0. * y_agriculture ) nh3_gridsize ( y_dim_index ) = nh3_gridsize ( y_dim_index ) / 11057 0. nh3emission_scale = emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index ) & / ( nh3_gridsize ( x_dim_index ) * nh3_gridsize ( y_dim_index )) elseif ( projection_type . eq . LCC_projection_index ) then !Do nothing elseif ( projection_type . eq . PS_projection_index ) then !Do nothing endif endif !Set the loop range to be big enough i_range = floor ( nh3_gridsize ( x_dim_index ) / emission_subgrid_delta ( x_dim_index , source_index ) / 2. ) + 1 j_range = floor ( nh3_gridsize ( y_dim_index ) / emission_subgrid_delta ( y_dim_index , source_index ) / 2. ) + 1 i_start = i_agriculture_index - i_range ; i_end = i_agriculture_index + i_range j_start = j_agriculture_index - j_range ; j_end = j_agriculture_index + j_range !write(*,*) i_range,j_range,nh3_gridsize(x_dim_index),emission_subgrid_delta(x_dim_index,source_index) !write(*,*) i_start,i_end,j_start,j_end !Put emmissions into emission grids !Set up a 3 x 3 grid to interpolate from !write(*,*) count !write(*,*) x_agriculture,y_agriculture,nh3_gridsize(x_dim_index),nh3_gridsize(y_dim_index) !write(*,*) x_emission_subgrid(i_start,j_start,source_index),y_emission_subgrid(i_start,j_start,source_index),emission_subgrid_delta(:,source_index) x_temp ( 1 ,:) = x_agriculture - nh3_gridsize ( x_dim_index ); x_temp ( 2 ,:) = x_agriculture ; x_temp ( 3 ,:) = x_agriculture + nh3_gridsize ( x_dim_index ); y_temp (:, 1 ) = y_agriculture - nh3_gridsize ( y_dim_index ); y_temp (:, 2 ) = y_agriculture ; y_temp (:, 3 ) = y_agriculture + nh3_gridsize ( y_dim_index ); z_temp (:,:) = 0 ; z_temp ( 2 , 2 ) = totalnh3emission do i = i_start , i_end do j = j_start , j_end if ( i . gt . 1. and . i . lt . emission_subgrid_dim ( x_dim_index , source_index ). and . j . gt . 1. and . j . lt . emission_subgrid_dim ( y_dim_index , source_index )) then temp_emission = area_weighted_extended_interpolation_function ( x_temp , y_temp , z_temp , 3 , 3 , & nh3_gridsize , x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), emission_subgrid_delta (:, source_index )) proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_nc_index )) = & proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_nc_index )) + temp_emission * nh3emission_scale if ( proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_nc_index )). gt . 0. ) agriculture_emission_data_available ( i , j ) = . true . !write(*,*)i,j,proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_nc_index)),agriculture_emission_data_available(i,j)!temp_emission*nh3emission_scale/totalnh3emission endif enddo enddo endif enddo write ( unit_logfile , '(A,I)' ) ' Agriculture counts = ' , count close ( unit_in ) enddo !file loop !After populating the grid with emission data (kg/yr) then fill all the other untouched grids with EMEP emission data (mg/m&#94;2/yr) or (mg/m&#94;2/hr). !Doesn't work. Would need to have a Nederlands mask instead of checking if emissions have been written or not. !!Do not use!! if ( 1. eq . 2 ) then if (. not . save_emissions_for_EMEP ( agriculture_index )) then !First find out how many agriculture emission subgrids there are in each EMEP grid allocate ( agriculture_emission_emep_subgrid_count ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) !This loop determines if there is an emep grid associated with an emission grid which should always be true agriculture_emission_emep_subgrid_count = 0 do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) !ii=crossreference_emission_to_target_subgrid(i,j,x_dim_index,source_index) !jj=crossreference_emission_to_target_subgrid(i,j,y_dim_index,source_index) !iii=crossreference_target_to_emep_subgrid(ii,jj,x_dim_index) !jjj=crossreference_target_to_emep_subgrid(ii,jj,y_dim_index) iii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , source_index ) jjj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , source_index ) agriculture_emission_emep_subgrid_count ( iii , jjj ) = agriculture_emission_emep_subgrid_count ( iii , jjj ) + 1 enddo enddo !Note, in current reading we have average emissions from EMEP not total do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) !write(*,*) i,j,agriculture_emission_data_available(i,j) if (. not . agriculture_emission_data_available ( i , j )) then !ii=crossreference_emission_to_target_subgrid(i,j,x_dim_index,source_index) !jj=crossreference_emission_to_target_subgrid(i,j,y_dim_index,source_index) !iii=crossreference_target_to_emep_subgrid(ii,jj,x_dim_index) !jjj=crossreference_target_to_emep_subgrid(ii,jj,y_dim_index) iii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , source_index ) jjj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , source_index ) if ( agriculture_emission_emep_subgrid_count ( iii , jjj ). ne . 0 ) then !Convert mg/m2/hr to kg/emission subgrid. Need to put in time here for the hourly runs. Need to fix proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_index )) = var3d_nc ( iii , jjj , 1 , emis_nc_index , agriculture_nc_index , pollutant_loop_back_index ( nh3_nc_index )) / 1.0e6 & * emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index ) * 2 4. * 36 5. !If hourly data then convert to mean hour emission emissions !if (hourly_calculations) proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_index)) & !    =proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_index))/24./365. !write(*,*) i,j,iii,jjj !write(*,*) pollutant_loop_back_index(nh3_nc_index),proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_index)),var3d_nc(iii,jjj,1,emis_nc_index,agriculture_nc_index,pollutant_loop_back_index(nh3_nc_index)) endif endif !write(*,*) agriculture_emission_emep_subgrid_count(iii,jjj) enddo enddo endif deallocate ( agriculture_emission_data_available ) endif end subroutine uEMEP_read_agriculture_rivm_data","tags":"","loc":"proc/uemep_read_agriculture_rivm_data.html"},{"title":"uEMEP_read_emission_rivm_data – uEMEP","text":"public  subroutine uEMEP_read_emission_rivm_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_emission_rivm_data use uEMEP_definitions implicit none integer i , j character ( 256 ) temp_str integer unit_in logical :: exists integer count real ddlatitude , ddlongitude , totalemission real y_emission , x_emission integer i_emission_index , j_emission_index real emission_scale integer i_file integer source_index character ( 256 ) component_str integer i_source real height integer snap , compound_nc_index integer i_pollutant integer , allocatable :: count_subgrid (:,:,:) real :: height_mean ( n_source_index ) = 0 integer :: count_mean ( n_source_index ) = 0 integer :: io write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading emission rivm data  (uEMEP_read_emission_rivm_data)' write ( unit_logfile , '(A)' ) '================================================================' !Set the projection to the dutch one !Should already have been specified. Not generic enough !projection_type=RDM_projection_index !Set the sources to be downscaled to 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then proxy_emission_subgrid (:,:, i_source ,:) = 0. emission_properties_subgrid (:,:, emission_h_index , i_source ) = 0. endif enddo allocate ( count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) count_subgrid = 0 !Read in as g/s and convert to ug/s which is used in the model emission_scale = 1.0e6 !Set filename, only 1 file used pathfilename_emission_rivm ( 1 ) = trim ( pathname_emission_rivm ( 1 )) // trim ( filename_emission_rivm ( 1 )) !pathfilename_emission_rivm(2)=trim(pathname_emission_rivm(2))//trim(filename_emission_rivm(2)) !Test existence of the emission files. Only one file used. If does not exist then stop inquire ( file = trim ( pathfilename_emission_rivm ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: emission RIVM file does not exist: ' , trim ( pathfilename_emission_rivm ( 1 )) stop endif !inquire(file=trim(pathfilename_emission_rivm(2)),exist=exists) !if (.not.exists) then !    write(unit_logfile,'(A,A)') ' ERROR: emission RIVM file does not exist: ', trim(pathfilename_emission_rivm(2)) !    stop !endif !Open the files for reading i_file = 1 unit_in = 20 open ( unit_in , file = pathfilename_emission_rivm ( i_file ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening emmision RIVM file ' // trim ( pathfilename_emission_rivm ( i_file )) rewind ( unit_in ) !Read header x,y,emission read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) trim ( temp_str ) count = 0 do !read(unit_in,'(A)') temp_str ddlatitude = 0. ; ddlongitude = 0. ; totalemission = 0. ; height = 0 ; snap = 0 ; component_str = '' ; !read(unit_in,'(2f,e,f,i,a)') x_emission,y_emission,totalemission,height,snap,component_str read ( unit_in , * , iostat = io ) x_emission , y_emission , totalemission , height , snap , component_str if ( io /= 0 ) exit !write(*,'(2f,e,f,i,a)') x_emission,y_emission,totalemission,height,snap,trim(component_str) compound_nc_index = 0 if ( index ( component_str , 'NOx' ). ne . 0 ) compound_nc_index = nox_nc_index if ( index ( component_str , 'PM10' ). ne . 0 ) compound_nc_index = pm10_nc_index if ( index ( component_str , 'NH3' ). ne . 0 ) compound_nc_index = nh3_nc_index if ( index ( component_str , 'PM25' ). ne . 0 ) compound_nc_index = pm25_nc_index !write(*,'(i,a)') compound_nc_index,trim(component_str) !Find the source sector in SNAP source_index = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ). and . uEMEP_to_EMEP_sector ( i_source ). eq . snap ) then source_index = i_source endif enddo !write(*,*) count count = count + 1 !Convert lat lon to utm coords !call RDM2LL(y_emission,x_emission,ddlatitude,ddlongitude) !if (mod(count,100000).eq.0) write(unit_logfile,'(i,2f12.2,e12.2,f12.2,i,2a)') count,x_emission,y_emission,totalemission,height,snap,'  ',trim(component_str) !write(*,*) source_index,compound_nc_index !Assumes the projection for the subgrid and the emissions are the same if ( source_index . gt . 0. and . compound_nc_index . gt . 0 ) then !Find the subgrid index it belongs to i_emission_index = 1 + floor (( x_emission - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_emission_index = 1 + floor (( y_emission - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !write(*,*) i_emission_index,j_emission_index,emission_subgrid_min(x_dim_index,source_index),emission_subgrid_min(y_dim_index,source_index) !Check that it is valid and add it to the subgrid if ( i_emission_index . ge . 1. and . i_emission_index . le . emission_subgrid_dim ( x_dim_index , source_index ). and . j_emission_index . ge . 1. and . j_emission_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then !Add to subgrid proxy_emission_subgrid ( i_emission_index , j_emission_index , source_index , pollutant_loop_back_index ( compound_nc_index )) = & proxy_emission_subgrid ( i_emission_index , j_emission_index , source_index , pollutant_loop_back_index ( compound_nc_index )) & + totalemission * emission_scale emission_properties_subgrid ( i_emission_index , j_emission_index , emission_h_index , source_index ) = & emission_properties_subgrid ( i_emission_index , j_emission_index , emission_h_index , source_index ) + height !emission_properties_subgrid(i_emission_index,j_emission_index,emission_h_index,source_index)= height count_subgrid ( i_emission_index , j_emission_index , source_index ) = count_subgrid ( i_emission_index , j_emission_index , source_index ) + 1 !write(*,*) count_subgrid(i_emission_index,j_emission_index,source_index) endif endif enddo write ( unit_logfile , '(A,I)' ) ' Emission counts = ' , count close ( unit_in ) !enddo !file loop !Average the emission height sum and check output by looking at means do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) if ( count_subgrid ( i , j , i_source ). gt . 0 ) then emission_properties_subgrid ( i , j , emission_h_index , i_source ) = emission_properties_subgrid ( i , j , emission_h_index , i_source ) / count_subgrid ( i , j , i_source ) height_mean ( i_source ) = emission_properties_subgrid ( i , j , emission_h_index , i_source ) + height_mean ( i_source ) count_mean ( i_source ) = count_mean ( i_source ) + 1 endif enddo enddo endif enddo where ( count_mean . gt . 0 ) height_mean = height_mean / count_mean !Show results do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,A,A,ES10.2,A,f6.2)' ) 'Emission source ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), ': Total RIVM emissions (ug/s)=' , & sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , i_source ), 1 : emission_subgrid_dim ( y_dim_index , i_source ), i_source , i_pollutant )), '  Mean emission height (m)=' , height_mean ( i_source ) enddo endif enddo deallocate ( count_subgrid ) end subroutine uEMEP_read_emission_rivm_data","tags":"","loc":"proc/uemep_read_emission_rivm_data.html"},{"title":"distrl – uEMEP","text":"public  subroutine distrl(x0, y0, x1, y1, x2, y2, xm, ym, dm, wm) The subroutine calculates the minimum distance from a given receptor\npoint to a given line source. Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 Receptor point x-coordinate real, intent(in) :: y0 Receptor point y-coordinate real, intent(in) :: x1 Line source x-coordinate 1 real, intent(in) :: y1 Line source y-coordinate 1 real, intent(in) :: x2 Line source x-coordinate 2 real, intent(in) :: y2 Line source y-coordinate 2 real, intent(out) :: xm Minimum distance x-coordinate real, intent(out) :: ym Minimum distance y-coordinate real, intent(out) :: dm Minimum distance real :: wm Source Code subroutine distrl ( x0 , y0 , x1 , y1 , x2 , y2 , xm , ym , dm , wm ) !! The subroutine calculates the minimum distance from a given receptor !! point to a given line source. real , intent ( in ) :: x0 !! Receptor point x-coordinate real , intent ( in ) :: y0 !! Receptor point y-coordinate real , intent ( in ) :: x1 !! Line source x-coordinate 1 real , intent ( in ) :: y1 !! Line source y-coordinate 1 real , intent ( in ) :: x2 !! Line source x-coordinate 2 real , intent ( in ) :: y2 !! Line source y-coordinate 2 real , intent ( out ) :: xm !! Minimum distance x-coordinate real , intent ( out ) :: ym !! Minimum distance y-coordinate real , intent ( out ) :: dm !! Minimum distance ! Local variables real :: num , denum , wm if ( x1 == x2 . and . y1 == y2 ) then wm = 0.5 else num = ( x0 - x1 ) * ( x2 - x1 ) + ( y0 - y1 ) * ( y2 - y1 ) denum = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) wm = num / denum end if wm = min ( wm , 1.0 ) wm = max ( wm , 0.0 ) xm = ( 1.0 - wm ) * x1 + wm * x2 ym = ( 1.0 - wm ) * y1 + wm * y2 dm = sqrt (( x0 - xm ) * ( x0 - xm ) + ( y0 - ym ) * ( y0 - ym )) end subroutine distrl","tags":"","loc":"proc/distrl.html"},{"title":"distrl_sqr – uEMEP","text":"public  subroutine distrl_sqr(x0, y0, x1, y1, x2, y2, xm, ym, dm_sqr, wm) Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 Receptor point x-coordinate real, intent(in) :: y0 Receptor point y-coordinate real, intent(in) :: x1 Line source x-coordinate 1 real, intent(in) :: y1 Line source y-coordinate 1 real, intent(in) :: x2 Line source x-coordinate 2 real, intent(in) :: y2 Line source y-coordinate 2 real, intent(out) :: xm Minimum distance x-coordinate real, intent(out) :: ym Minimum distance y-coordinate real, intent(out) :: dm_sqr Minimum distance real :: wm Source Code subroutine distrl_sqr ( x0 , y0 , x1 , y1 , x2 , y2 , xm , ym , dm_sqr , wm ) real , intent ( in ) :: x0 !! Receptor point x-coordinate real , intent ( in ) :: y0 !! Receptor point y-coordinate real , intent ( in ) :: x1 !! Line source x-coordinate 1 real , intent ( in ) :: y1 !! Line source y-coordinate 1 real , intent ( in ) :: x2 !! Line source x-coordinate 2 real , intent ( in ) :: y2 !! Line source y-coordinate 2 real , intent ( out ) :: xm !! Minimum distance x-coordinate real , intent ( out ) :: ym !! Minimum distance y-coordinate real , intent ( out ) :: dm_sqr !! Minimum distance ! Local variables real :: num , denum , wm if ( x1 == x2 . and . y1 == y2 ) then wm = 0.5 else num = ( x0 - x1 ) * ( x2 - x1 ) + ( y0 - y1 ) * ( y2 - y1 ) denum = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) wm = num / denum end if wm = min ( wm , 1.0 ) wm = max ( wm , 0.0 ) xm = ( 1.0 - wm ) * x1 + wm * x2 ym = ( 1.0 - wm ) * y1 + wm * y2 dm_sqr = ( x0 - xm ) * ( x0 - xm ) + ( y0 - ym ) * ( y0 - ym ) end subroutine distrl_sqr","tags":"","loc":"proc/distrl_sqr.html"},{"title":"nxtdat – uEMEP","text":"public  subroutine nxtdat(un, leof) The subroutine prepares for reading the next uncommented line of data from file Arguments Type Intent Optional Attributes Name integer, intent(inout) :: un logical, intent(out) :: leof Source Code subroutine nxtdat ( un , leof ) !! The subroutine prepares for reading the next uncommented line of data from file integer , intent ( inout ) :: un logical , intent ( out ) :: leof ! Local variables character ( len = 256 ) :: txtstr integer :: io ! If file unit is non-positive then just return if ( un . le . 0 ) return leof = . false . ! Read lines from file do read ( un , \"(a)\" , iostat = io ) txtstr if ( io /= 0 ) then leof = . true . exit else if ( txtstr ( 1 : 1 ) == \"*\" . or . txtstr ( 1 : 1 ) == \"{\" . or . txtstr ( 1 : 1 ) == \"#\" ) then cycle else backspace ( un ) exit end if end if end do end subroutine nxtdat","tags":"","loc":"proc/nxtdat.html"},{"title":"ll2utm – uEMEP","text":"public  subroutine ll2utm(iutm, isone_in, lat, lon, utmn, utme) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator integer, intent(in) :: isone_in UTM zone input? real, intent(in) :: lat Latitude in decimal degrees real, intent(in) :: lon Longitude in decimal degress real, intent(out) :: utmn UTM east-coordinate (y) (meter from west border) real, intent(out) :: utme UTM north-coordinate (x) (meter from equator) Source Code subroutine ll2utm ( iutm , isone_in , lat , lon , utmn , utme ) integer , intent ( in ) :: iutm !! UTM coordinate system indicator integer , intent ( in ) :: isone_in !! UTM zone input? real , intent ( in ) :: lat !! Latitude in decimal degrees real , intent ( in ) :: lon !! Longitude in decimal degress real , intent ( out ) :: utmn !! UTM east-coordinate (y) (meter from west border) real , intent ( out ) :: utme !! UTM north-coordinate (x) (meter from equator) ! Local variables and parameters real :: isone ! UTM zone real ( dp ), parameter :: deast = 50000 0.0 ! East movement UTM real ( dp ), parameter :: scale = 0.9996 ! Scale UTM real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: latv ! Scaled latitude real ( dp ) :: lonv ! Scaled longitude real ( dp ) :: lon0 ! Central meridian of UTM zone real ( dp ) :: b , e , e2 , m , n ! Intermediate values select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! Scale coordinates isone = abs ( isone_in ) latv = lat * pi / 18 0.0 lon0 = real ( isone - 3 0.0 ) * 6.0 - 3.0 lonv = ( lon - lon0 ) * pi / 18 0.0 ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) n = a / dsqrt ( 1.0 - e2 * dsin ( latv ) * dsin ( latv )) e = dsqrt ( e2 * dcos ( latv ) * dcos ( latv ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) b = (( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * latv & - ( 3.0 * f / 4.0 - 3.0 * f * f * f / 12 8.0 ) * dsin ( 2.0 * latv ) & + ( 1 5.0 * f * f / 6 4.0 + 1 5.0 * f * f * f / 12 8.0 ) * dsin ( 4.0 * latv ) & - ( 3 5.0 * f * f * f / 38 4.0 ) * dsin ( 6.0 * latv )) * a ! Calculate UTM north coordinate utmn = ( b + lonv * lonv * n * dsin ( latv ) * dcos ( latv ) / 2.0 & + lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - dtan ( latv ) * dtan ( latv ) + 9.0 * e * e + 4.0 * e * e * e * e ) & / 2 4.0 + lonv * lonv * lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 6 1.0 - 5 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) & / 72 0.0 ) * scale if ( lat < 0.0 ) then utmn = utmn + 1000000 0.0 end if ! Calculate UTM east coordinate utme = ( lonv * n * dcos ( latv ) & + lonv * lonv * lonv * n * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 1.0 - dtan ( latv ) * dtan ( latv ) + e * e ) / 6.0 & + lonv * lonv * lonv * lonv * lonv * n & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - 1 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) / 12 0.0 ) & * scale + deast end subroutine ll2utm","tags":"","loc":"proc/ll2utm.html"},{"title":"ll2ltm – uEMEP","text":"public  subroutine ll2ltm(iutm, lon0, lat, lon, utmn, utme) Local lon version (of ll2utm) without zone, so just typical Transverse\nMecantor (Local Transverse Mecantor) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator real, intent(in) :: lon0 Central meridian of UTM zone real, intent(in) :: lat Latitude in decimal degrees real, intent(in) :: lon Longitude in decimal degrees real, intent(out) :: utmn UTM north-coordinate (x) (meter from equator) real, intent(out) :: utme UTM  east-coordinate (y) (meter from west border) Source Code subroutine ll2ltm ( iutm , lon0 , lat , lon , utmn , utme ) !! Local lon version (of ll2utm) without zone, so just typical Transverse !! Mecantor (Local Transverse Mecantor) integer , intent ( in ) :: iutm !! UTM coordinate system indicator real , intent ( in ) :: lon0 !! Central meridian of UTM zone real , intent ( in ) :: lat !! Latitude in decimal degrees real , intent ( in ) :: lon !! Longitude in decimal degrees real , intent ( out ) :: utmn !! UTM north-coordinate (x) (meter from equator) real , intent ( out ) :: utme !! UTM  east-coordinate (y) (meter from west border) ! Local variables and paramters real ( dp ), parameter :: deast = 50000 0.0 ! East movement UTM real ( dp ), parameter :: scale = 0.9996 ! Scale UTM real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: latv ! Scaled latitude real ( dp ) :: lonv ! Scaled longitude real ( dp ) :: b , e , e2 , m , n ! Intermediate values select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! Scale coordinates latv = lat * pi / 18 0.0 lonv = ( lon - lon0 ) * pi / 18 0.0 ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) n = a / dsqrt ( 1.0 - e2 * dsin ( latv ) * dsin ( latv )) e = dsqrt ( e2 * dcos ( latv ) * dcos ( latv ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) b = (( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * latv & - ( 3.0 * f / 4.0 - 3.0 * f * f * f / 12 8.0 ) * dsin ( 2.0 * latv ) & + ( 1 5.0 * f * f / 6 4.0 + 1 5.0 * f * f * f / 12 8.0 ) * dsin ( 4.0 * latv ) & - ( 3 5.0 * f * f * f / 38 4.0 ) * dsin ( 6.0 * latv )) * a ! Calculate UTM north coordinate utmn = ( b + lonv * lonv * n * dsin ( latv ) * dcos ( latv ) / 2.0 & + lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - dtan ( latv ) * dtan ( latv ) + 9.0 * e * e + 4.0 * e * e * e * e ) & / 2 4.0 + lonv * lonv * lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 6 1.0 - 5 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) & / 72 0.0 ) * scale if ( lat < 0.0 ) then utmn = utmn + 1000000 0.0 end if ! Calculate UTM east coordinate utme = ( lonv * n * dcos ( latv ) & + lonv * lonv * lonv * n * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 1.0 - dtan ( latv ) * dtan ( latv ) + e * e ) / 6.0 & + lonv * lonv * lonv * lonv * lonv * n & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - 1 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) / 12 0.0 ) & * scale + deast end subroutine ll2ltm","tags":"","loc":"proc/ll2ltm.html"},{"title":"utm2ll – uEMEP","text":"public  subroutine utm2ll(iutm, isone_in, utmn_in, utme, lat, lon) The subroutine converts UTM north- and east-coordinates to latitude\nand longitude Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator integer, intent(in) :: isone_in UTM zone real, intent(in) :: utmn_in UTM north-coordinate (X) (meter from equator) real, intent(in) :: utme UTM  east-coordinate (Y) (meter from west border) real, intent(out) :: lat Latitude in decimal degrees real, intent(out) :: lon Longitude in decimal degrees Source Code subroutine utm2ll ( iutm , isone_in , utmn_in , utme , lat , lon ) !! The subroutine converts UTM north- and east-coordinates to latitude !! and longitude integer , intent ( in ) :: iutm !! UTM coordinate system indicator integer , intent ( in ) :: isone_in !! UTM zone real , intent ( in ) :: utmn_in !! UTM north-coordinate (X) (meter from equator) real , intent ( in ) :: utme !! UTM  east-coordinate (Y) (meter from west border) real , intent ( out ) :: lat !! Latitude in decimal degrees real , intent ( out ) :: lon !! Longitude in decimal degrees ! Local variables and parameters integer :: isone real :: utmn ! UTM north-coordinate real ( dp ), parameter :: deast = 50000 0.0 real ( dp ), parameter :: scale = 0.9996 real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: la0 ! Tangeringsmeridian real ( dp ) :: x ! Scaled north-coordinate real ( dp ) :: y ! Scaled east-coordinate real ( dp ) :: bb0 , e , e2 , fi , m , n ! Intermediate value select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! Adjust for southern hemisphere, specified by negative isone_in if ( isone_in < 0 ) then utmn = utmn_in - 1000000 0.0 else utmn = utmn_in end if isone = abs ( isone_in ) ! Scale coordinates x = utmn / scale y = ( utme - deast ) / scale la0 = real ( isone - 30 ) * 6.0 - 3.0 ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) bb0 = ( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * a fi = x / bb0 & + ( 3.0 * f / 4.0 + 3.0 * f * f / 8.0 + 2 1.0 * f * f * f / 25 6.0 ) * dsin ( 2.0 * x / bb0 ) & + ( 2 1.0 * f * f / 6 4.0 + 2 1.0 * f * f * f / 6 4.0 ) * dsin ( 4.0 * x / bb0 ) & + ( 15 1.0 * f * f * f / 76 8.0 ) * dsin ( 6.0 * x / bb0 ) n = a / dsqrt ( 1.0 - e2 * dsin ( fi ) * dsin ( fi )) e = dsqrt ( e2 * dcos ( fi ) * dcos ( fi ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) ! Calculate latitude and longitude in radians lat = fi - ( y * y * dtan ( fi )) / ( 2.0 * m * n ) & + ( y * y * y * y * dtan ( fi )) / ( 2 4.0 * m * n * n * n ) & * ( 5.0 + 3.0 * dtan ( fi ) * dtan ( fi ) + e * e & - 9.0 * e * e * dtan ( fi ) * dtan ( fi ) - 4.0 * e * e * e * e ) & - ( y * y * y * y * y * y * dtan ( fi )) / ( 72 0.0 * m * n * n * n * n * n ) & * ( 6 1.0 + 9 0.0 * dtan ( fi ) * dtan ( fi ) & + 4 5.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi )) lon = y / ( n * dcos ( fi )) & - ( y * y * y * ( 1.0 + 2.0 * dtan ( fi ) * dtan ( fi ) + e * e )) & / ( 6.0 * n * n * n * dcos ( fi )) & + ( y * y * y * y * y * ( 5.0 + 2 8.0 * dtan ( fi ) * dtan ( fi ) & + 2 4.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi ))) & / ( 12 0.0 * n * n * n * n * n * dcos ( fi )) + la0 * pi / 18 0.0 ! Convert from radians to degrees lat = lat * 18 0.0 / pi lon = lon * 18 0.0 / pi end subroutine utm2ll","tags":"","loc":"proc/utm2ll.html"},{"title":"ltm2ll – uEMEP","text":"public  subroutine ltm2ll(iutm, isone_in, la0, utmn_in, utme, lat, lon) Local Transverse Mecantor version of utm2ll Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator integer, intent(in) :: isone_in UTM zone real, intent(in) :: la0 Tangeringsmeridian real, intent(in) :: utmn_in UTM north-coordinate (X) (meter from equator) real, intent(in) :: utme UTM  east-coordinate (Y) (meter from west border) real, intent(out) :: lat Latitude in decimal degrees real, intent(out) :: lon Longitude in decimal degrees Source Code subroutine ltm2ll ( iutm , isone_in , la0 , utmn_in , utme , lat , lon ) !! Local Transverse Mecantor version of utm2ll integer , intent ( in ) :: iutm !! UTM coordinate system indicator integer , intent ( in ) :: isone_in !! UTM zone real , intent ( in ) :: la0 !! Tangeringsmeridian real , intent ( in ) :: utmn_in !! UTM north-coordinate (X) (meter from equator) real , intent ( in ) :: utme !! UTM  east-coordinate (Y) (meter from west border) real , intent ( out ) :: lat !! Latitude in decimal degrees real , intent ( out ) :: lon !! Longitude in decimal degrees ! Local variables and parameters integer :: isone real :: utmn ! UTM north-coordinate real ( dp ), parameter :: deast = 50000 0.0 real ( dp ), parameter :: scale = 0.9996 real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: x ! Scaled north-coordinate real ( dp ) :: y ! Scaled east-coordinate real ( dp ) :: bb0 , e , e2 , fi , m , n ! Intermediate values select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! djust for Southern Hemisphere, specified by negative isone_in if ( isone_in < 0 ) then utmn = utmn_in - 1000000 0.0 else utmn = utmn_in end if isone = abs ( isone_in ) ! Scale coordinates x = utmn / scale y = ( utme - deast ) / scale ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) bb0 = ( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * a fi = x / bb0 & + ( 3.0 * f / 4.0 + 3.0 * f * f / 8.0 + 2 1.0 * f * f * f / 25 6.0 ) * dsin ( 2.0 * x / bb0 ) & + ( 2 1.0 * f * f / 6 4.0 + 2 1.0 * f * f * f / 6 4.0 ) * dsin ( 4.0 * x / bb0 ) & + ( 15 1.0 * f * f * f / 76 8.0 ) * dsin ( 6.0 * x / bb0 ) n = a / dsqrt ( 1.0 - e2 * dsin ( fi ) * dsin ( fi )) e = dsqrt ( e2 * dcos ( fi ) * dcos ( fi ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) ! Calculate latitude and longitude in radians lat = fi - ( y * y * dtan ( fi )) / ( 2.0 * m * n ) & + ( y * y * y * y * dtan ( fi )) / ( 2 4.0 * m * n * n * n ) & * ( 5.0 + 3.0 * dtan ( fi ) * dtan ( fi ) + e * e & - 9.0 * e * e * dtan ( fi ) * dtan ( fi ) - 4.0 * e * e * e * e ) & - ( y * y * y * y * y * y * dtan ( fi )) / ( 72 0.0 * m * n * n * n * n * n ) & * ( 6 1.0 + 9 0.0 * dtan ( fi ) * dtan ( fi ) & + 4 5.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi )) lon = y / ( n * dcos ( fi )) & - ( y * y * y * ( 1.0 + 2.0 * dtan ( fi ) * dtan ( fi ) + e * e )) & / ( 6.0 * n * n * n * dcos ( fi )) & + ( y * y * y * y * y * ( 5.0 + 2 8.0 * dtan ( fi ) * dtan ( fi ) & + 2 4.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi ))) & / ( 12 0.0 * n * n * n * n * n * dcos ( fi )) + la0 * pi / 18 0.0 ! Convert from radians to degrees lat = lat * 18 0.0 / pi lon = lon * 18 0.0 / PI end subroutine ltm2ll","tags":"","loc":"proc/ltm2ll.html"},{"title":"uEMEP_set_tile_grids – uEMEP","text":"public  subroutine uEMEP_set_tile_grids() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_tile_grids use uEMEP_definitions implicit none integer n_tiles_population_classes , n_tiles_traffic_classes , n_tiles_shipping_classes parameter ( n_tiles_population_classes = 5 , n_tiles_traffic_classes = 5 , n_tiles_shipping_classes = 1 ) real limit_val_tile_population ( n_tiles_population_classes ) ! data limit_val_tile_population /0.,100.,1000.,5000.,10000./ data limit_val_tile_population / 0. , 10 0. , 100 0. , 1000 0. , 10000 0. / integer :: num_tiles_with_population ( n_tiles_population_classes ) = 0 real limit_val_tile_traffic ( n_tiles_traffic_classes ) data limit_val_tile_traffic / 0. , 100 0. , 1000 0. , 10000 0. , 100000 0. / integer :: num_tiles_with_traffic ( n_tiles_traffic_classes ) = 0 real limit_val_tile_shipping ( n_tiles_shipping_classes ) data limit_val_tile_shipping / 0. / integer :: num_tiles_with_shipping ( n_tiles_shipping_classes ) = 0 real tile_subgrid_delta ( n_dim_index ) real tile_subgrid_min ( n_dim_index ) real tile_subgrid_max ( n_dim_index ) integer tile_subgrid_dim ( n_dim_index ) real , allocatable :: tile_subgrid (:,:,:) real , allocatable :: x_tile_subgrid (:,:) real , allocatable :: y_tile_subgrid (:,:) real , allocatable :: lon_tile_subgrid (:,:) real , allocatable :: lat_tile_subgrid (:,:) real , allocatable :: crossreference_emission_to_tile_subgrid (:,:,:,:) real , allocatable :: crossreference_population_to_tile_subgrid (:,:,:) integer , allocatable :: tile_class_subgrid (:,:) integer , allocatable :: tile_municipality_subgrid (:,:) real , allocatable :: aggregated_tile_subgrid (:,:,:) real , allocatable :: aggregated_x_tile_subgrid (:,:,:) real , allocatable :: aggregated_y_tile_subgrid (:,:,:) integer , allocatable :: aggregated_tile_class_subgrid (:,:,:) integer i , j , i_class , i_tile , j_tile , i_source , k , l integer n_tile_index integer tile_population_index !,tile_municipality_index,tile_class_index character ( 256 ) temp_name , temp_str , temp_str1 integer * 8 ssb_id integer municipality_id real x_ssb , f_easting , ssb_dx , y_ssb , ssb_dy integer num_tiles_with_municipality logical exists integer unit_in integer count , index_val integer num_tile_classes ( 10 ) real resolution_tile_classes ( 10 ) character ( 8 ) count_str integer :: unit_tile = 21 real population_tile_scale integer reduce_grid_class real aggregation_tile_scale ( 10 ) integer n_aggregated_tiles !parameter (n_aggregated_tiles=4) !40to5km !parameter (n_aggregated_tiles=5) !160to10km parameter ( n_aggregated_tiles = 1 ) !make_100km_files real aggregated_tile_subgrid_delta ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_min ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_max ( n_dim_index , n_aggregated_tiles ) integer aggregated_tile_subgrid_dim ( n_dim_index , n_aggregated_tiles ) integer count_tile_class ( 4 ) integer i_tile_class ( 4 ) integer j_tile_class ( 4 ) logical :: use_aggregated_tiling = . true . logical :: save_as_seperate_files = . true . integer sum_count , max_count integer count_class ( n_aggregated_tiles , 10 ) logical OK integer max_counter , zero_counter logical :: make_100km_files = . true . integer n_search parameter ( n_search = 5 ) character ( 16 ) search_str ( n_search ) real search_delta ( n_search ) integer temp_search integer :: io data search_str / '1000m' , '500m' , '250m' , '100m' , '50m' / data search_delta / 100 0. , 50 0. , 25 0. , 10 0. , 5 0. / write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating tile distribution and resolution (uEMEP_set_tile_grids)' write ( unit_logfile , '(A)' ) '================================================================' !Set tile index values n_tile_index = n_source_index + 1 tile_population_index = n_source_index + 1 !tile_municipality_index=n_source_index+2 !tile_class_index=n_source_index+3 !Reduce size of grids at and above this value reduce_grid_class = 6 !Set to 6 does not reduce !Specify the tiling region to cover all of Norway population_tile_scale = 1. !For 10 km !population_tile_scale=3. !For 20 km population_tile_scale = 0.625 !For 5 km, to give 250 people /km&#94;2 tile_subgrid_min ( x_dim_index ) =- 7000 0. - 40000 tile_subgrid_min ( y_dim_index ) = 644000 0. - 40000 tile_subgrid_max ( x_dim_index ) = 111000 0. + 4000 0. tile_subgrid_max ( y_dim_index ) = 795000 0. + 4000 0. if ( make_100km_files ) then tile_subgrid_min ( x_dim_index ) =- 7000 0. - 30000 tile_subgrid_max ( x_dim_index ) = 111000 0. + 15000 0. tile_subgrid_min ( y_dim_index ) = 644000 0. - 40000 tile_subgrid_max ( y_dim_index ) = 795000 0. + 5000 0. endif !40to5km tile class population_tile_scale = 0.5 !For 5 km, to give 200 people /km&#94;2 tile_subgrid_delta ( x_dim_index ) = 500 0. tile_subgrid_delta ( y_dim_index ) = 500 0. !160to10 km tile classs population_tile_scale = 1. tile_subgrid_delta ( x_dim_index ) = 1000 0. tile_subgrid_delta ( y_dim_index ) = 1000 0. if ( make_100km_files ) then tile_subgrid_delta ( x_dim_index ) = 10000 0. tile_subgrid_delta ( y_dim_index ) = 10000 0. endif limit_val_tile_population = limit_val_tile_population * population_tile_scale !Set all tile subgrids relative to the target subgrid tile_subgrid_dim ( x_dim_index ) = floor (( tile_subgrid_max ( x_dim_index ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition tile_subgrid_dim ( y_dim_index ) = floor (( tile_subgrid_max ( y_dim_index ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition tile_subgrid_dim ( t_dim_index ) = 1 !Not used !aggregation_tile_scale if ( n_aggregated_tiles . eq . 5 ) then !Not in use aggregation_tile_scale ( 1 ) = 1 6. aggregation_tile_scale ( 2 ) = 8. aggregation_tile_scale ( 3 ) = 4. aggregation_tile_scale ( 4 ) = 2. aggregation_tile_scale ( 5 ) = 1. elseif ( n_aggregated_tiles . eq . 4 ) then aggregation_tile_scale ( 1 ) = 8. aggregation_tile_scale ( 2 ) = 4. aggregation_tile_scale ( 3 ) = 2. aggregation_tile_scale ( 4 ) = 1. elseif ( n_aggregated_tiles . eq . 3 ) then aggregation_tile_scale ( 1 ) = 4. aggregation_tile_scale ( 2 ) = 2. aggregation_tile_scale ( 3 ) = 1. elseif ( n_aggregated_tiles . eq . 1 ) then aggregation_tile_scale ( 1 ) = 1. endif do k = 1 , n_aggregated_tiles aggregated_tile_subgrid_min (:, k ) = tile_subgrid_min (:) aggregated_tile_subgrid_max (:, k ) = tile_subgrid_max (:) aggregated_tile_subgrid_delta (:, k ) = tile_subgrid_delta (:) * aggregation_tile_scale ( k ) aggregated_tile_subgrid_dim ( x_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( x_dim_index , k ) - aggregated_tile_subgrid_min ( x_dim_index , k )) / aggregated_tile_subgrid_delta ( x_dim_index , k )) aggregated_tile_subgrid_dim ( y_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( y_dim_index , k ) - aggregated_tile_subgrid_min ( y_dim_index , k )) / aggregated_tile_subgrid_delta ( y_dim_index , k )) enddo !Allocate tile subgrids if (. not . allocated ( tile_subgrid )) allocate ( tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_tile_index )) if (. not . allocated ( x_tile_subgrid )) allocate ( x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_tile_subgrid )) allocate ( y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_tile_subgrid )) allocate ( lon_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_tile_subgrid )) allocate ( lat_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( crossreference_emission_to_tile_subgrid )) allocate ( crossreference_emission_to_tile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) if (. not . allocated ( crossreference_population_to_tile_subgrid )) allocate ( crossreference_population_to_tile_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ), 2 )) if (. not . allocated ( tile_class_subgrid )) allocate ( tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( tile_municipality_subgrid )) allocate ( tile_municipality_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( aggregated_tile_subgrid )) allocate ( aggregated_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_x_tile_subgrid )) allocate ( aggregated_x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_y_tile_subgrid )) allocate ( aggregated_y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_tile_class_subgrid )) allocate ( aggregated_tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) !Set to 0 all tile values tile_subgrid = 0. tile_municipality_subgrid = 0 tile_class_subgrid = 0 !Read in SSB file containing gridded municipality ids !ssb_dx=1000. !ssb_dy=1000. f_easting = 2.e6 !Search file name to define the grid size ssb_dx = 0. ssb_dy = 0. do k = 1 , n_search temp_search = index ( filename_population ( municipality_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality masking data with resolution ' // trim ( adjustl ( search_str ( k ))) endif enddo if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( municipality_index )) stop else write ( unit_logfile , '(A,2f12.2)' ) 'Setting municipality SSB grid size (x,y) = ' , ssb_dx , ssb_dy endif pathfilename_population ( municipality_index ) = trim ( pathname_population ( municipality_index )) // trim ( filename_population ( municipality_index )) !Test existence of the filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( municipality_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file with municipality IDs does not exist: ' , trim ( pathfilename_population ( municipality_index )) stop endif temp_name = pathfilename_population ( municipality_index ) !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB municipality file ' // trim ( temp_name ) rewind ( unit_in ) !Read header SSBID0250M;kommunenum read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 do ssb_id = 0 ; municipality_id = 0 !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id read ( temp_str , * ) municipality_id count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ssb_id,municipality_id !Convert id to grid centre coordinates that are already in UTM33 for SSB data x_ssb = floor ( ssb_id / 1000000 0. ) - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. !Find the tile this ssb grid is in i_tile = 1 + floor (( x_ssb - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition j_tile = 1 + floor (( y_ssb - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition !Add the municipality id to give the grid a value if ( municipality_id . gt . 0 ) then tile_municipality_subgrid ( i_tile , j_tile ) = tile_municipality_subgrid ( i_tile , j_tile ) + municipality_id endif enddo close ( unit_in ) !Determine tile subgrid do j = 1 , tile_subgrid_dim ( y_dim_index ) do i = 1 , tile_subgrid_dim ( x_dim_index ) x_tile_subgrid ( i , j ) = tile_subgrid_min ( x_dim_index ) + tile_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) !New definition y_tile_subgrid ( i , j ) = tile_subgrid_min ( y_dim_index ) + tile_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !New definition call PROJ2LL ( x_tile_subgrid ( i , j ), y_tile_subgrid ( i , j ), lon_tile_subgrid ( i , j ), lat_tile_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon !if (EMEP_projection_type.eq.LCC_projection_index) then !    call lb2lambert2_uEMEP(xproj_tile_subgrid(i,j),yproj_tile_subgrid(i,j),lon_tile_subgrid(i,j),lat_tile_subgrid(i,j),EMEP_projection_attributes) !else !    xproj_tile_subgrid(i,j)=lon_tile_subgrid(i,j) !    yproj_tile_subgrid(i,j)=lat_tile_subgrid(i,j) !endif enddo enddo !Determine the aggregated tile subgrids, in UTM only do k = 1 , n_aggregated_tiles do j = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) aggregated_x_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( x_dim_index , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) * ( i - 0.5 ) aggregated_y_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( y_dim_index , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) * ( j - 0.5 ) enddo enddo enddo !Create a cross reference grid do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo endif enddo do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_population_subgrid ( i , j ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_population_subgrid ( i , j ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo !Calculate the population within each tile do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) i_tile = crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) j_tile = crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) tile_subgrid ( i_tile , j_tile , tile_population_index ) = tile_subgrid ( i_tile , j_tile , tile_population_index ) + population_subgrid ( i , j , population_data_type ) enddo enddo !Calculate the veh.km within each tile i_source = traffic_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) tile_subgrid ( i_tile , j_tile , traffic_index ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) / 100 0. !ADT*km enddo enddo !Calculate the shipping emissions within each tile i_source = shipping_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) tile_subgrid ( i_tile , j_tile , i_source ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) !emission for the time period enddo enddo !Write summary results num_tiles_with_municipality = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) num_tiles_with_municipality = num_tiles_with_municipality + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'MUNICIPALITY TILE: ' , num_tiles_with_municipality !Write summary results num_tiles_with_population = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_population_classes - 1 if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( i_class + 1 )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo i_class = n_tiles_population_classes if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_population_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' -' , limit_val_tile_population ( i_class + 1 ), num_tiles_with_population ( i_class ) enddo i_class = n_tiles_population_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' <' , ' ' , num_tiles_with_population ( i_class ) !Write summary results num_tiles_with_traffic = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_traffic_classes - 1 if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( i_class + 1 )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo i_class = n_tiles_traffic_classes if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_traffic_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' -' , limit_val_tile_traffic ( i_class + 1 ), num_tiles_with_traffic ( i_class ) enddo i_class = n_tiles_traffic_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' <' , ' ' , num_tiles_with_traffic ( i_class ) !Write summary results num_tiles_with_shipping = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_subgrid ( i_tile , j_tile , shipping_index ). gt . limit_val_tile_shipping ( 1 )) num_tiles_with_shipping ( 1 ) = num_tiles_with_shipping ( 1 ) + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'SHIPPING TILE: ' , num_tiles_with_shipping ( 1 ) num_tile_classes = 0 !Class 1: 500 m. No emissions at all so interpolated, irrespective of population !Class 2: 250 m. Shipping emissions > 0 and Traffic < 1000 (1) or (population < 1000 and Traffic < 10000 (2)) !Class 3: 125 m. Traffic < 10000 (2) or (population > 1000 (2) population < 5000 (2) !Class 4: 50 m. Traffic > 10000 (2) and population > 5000 (3) tile_class_subgrid = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) !Only choose tiles that are part of a municipality if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) then tile_class_subgrid ( i_tile , j_tile ) = 1 if ( tile_subgrid ( i_tile , j_tile , shipping_index ). le . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 1 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 2 )) then tile_class_subgrid ( i_tile , j_tile ) = 1 !No sources and population less than 100 elseif ( tile_subgrid ( i_tile , j_tile , shipping_index ). ge . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). ge . limit_val_tile_population ( 1 )) then tile_class_subgrid ( i_tile , j_tile ) = 2 !Little traffic but any shipping and any population elseif (( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 )). or . & ( tile_subgrid ( i_tile , j_tile , traffic_index ). ge . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 ))) then tile_class_subgrid ( i_tile , j_tile ) = 3 !Population from 1000 to 5000 or road traffic elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 4 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 10000 elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 100000 endif if ( make_100km_files ) then if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) then tile_class_subgrid ( i_tile , j_tile ) = 1 endif endif num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) = num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) + 1 endif enddo enddo write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 1 (500m): ' , num_tile_classes ( 1 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 2 (250m): ' , num_tile_classes ( 2 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 3 (125m): ' , num_tile_classes ( 3 ) if ( reduce_grid_class . eq . 4 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) endif if ( reduce_grid_class . eq . 5 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) endif resolution_tile_classes ( 1 ) = 50 0. resolution_tile_classes ( 2 ) = 25 0. resolution_tile_classes ( 3 ) = 12 5. resolution_tile_classes ( 4 ) = 5 0. resolution_tile_classes ( 5 ) = 2 5. if ( make_100km_files ) then resolution_tile_classes ( 1 ) = 10 0. endif !Preallocate the smallest aggregated tiles with the calculated tile value aggregated_tile_class_subgrid = 0 aggregated_tile_class_subgrid (:,:, n_aggregated_tiles ) = tile_class_subgrid !Aggregate tiles. Using classes of 2, 3 and 4 only do k = n_aggregated_tiles - 1 , 1 , - 1 do j_tile = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i_tile = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) count = 0 do j = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k + 1 ) do i = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k + 1 ) if ( aggregated_x_tile_subgrid ( i , j , k + 1 ). ge . aggregated_x_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. & . and . aggregated_x_tile_subgrid ( i , j , k + 1 ). lt . aggregated_x_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. & . and . aggregated_y_tile_subgrid ( i , j , k + 1 ). ge . aggregated_y_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. & . and . aggregated_y_tile_subgrid ( i , j , k + 1 ). lt . aggregated_y_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. ) then !.and.aggregated_tile_class_subgrid(i,j,k+1).ne.-1) then !This k+1 aggregated tile is within the k tile. Give it a class count = count + 1 count_tile_class ( count ) = aggregated_tile_class_subgrid ( i , j , k + 1 ) i_tile_class ( count ) = i j_tile_class ( count ) = j endif enddo enddo if ( count . eq . 4 ) then !4 x k+1 tiles have been found. Check if they are the same and not equal to the last tile value sum_count = sum ( count_tile_class ( 1 : count )) max_count = maxval ( count_tile_class ( 1 : count )) !if (count_tile_class(1)*count.le.sum_count.and.count_tile_class(2)*count.le.sum_count & !    .and.count_tile_class(3)*count.le.sum_count.and.count_tile_class(4)*count.le.sum_count.and.maxval(count_tile_class).lt.4) then OK = . true . max_counter = 0 zero_counter = 0 do l = 1 , count if ( count_tile_class ( l ). eq . max_count ) max_counter = max_counter + 1 if ( count_tile_class ( l ). eq . 0 ) zero_counter = zero_counter + 1 enddo do l = 1 , count !if (((count_tile_class(l).le.max_count.and.count_tile_class(l).ge.0)).and.OK.and.max_count.lt.4 & !    .and.((max_counter+zero_counter.ge.1.and.k.eq.3).or.(max_counter+zero_counter.ge.1.and.k.eq.2).or.(max_counter+zero_counter.ge.3.and.k.eq.1)) & !    .and..not.(k.eq.1.and.max_count.eq.3)) & !This does not allow 125 m to be the largest size. Removed for 160to10km if ((( count_tile_class ( l ). le . max_count . and . count_tile_class ( l ). ge . 0 )). and . OK . and . max_count . lt . 4 & . and .(( max_counter + zero_counter . ge . 1. and . k . eq . 3 ). or .( max_counter + zero_counter . ge . 1. and . k . eq . 2 ). or .( max_counter + zero_counter . ge . 3. and . k . eq . 1 )) & ) & then OK = . true . else OK = . false . endif enddo if ( OK ) then !if (count_tile_class(1).le.max_count.and.count_tile_class(2).le.max_count & !    .and.count_tile_class(3).le.max_count.and.count_tile_class(4).le.max_count.and.max_count.lt.4) then !Allocate the class to the k tile aggregated_tile_class_subgrid ( i_tile , j_tile , k ) = max_count !sum_count/count !Remove the class from the k+1 tiles do l = 1 , count aggregated_tile_class_subgrid ( i_tile_class ( l ), j_tile_class ( l ), k + 1 ) =- 1 enddo !write(*,*)  'Count is 4 and using' else !write(*,*)  'Count is 4 and not using' aggregated_tile_class_subgrid ( i_tile , j_tile , k ) =- 1 endif else !write(*,*) 'Can not find k+1 tiles',count endif enddo enddo enddo !Save results in a single file if (. not . use_aggregated_tiling ) then temp_name = trim ( pathname_tiles ) // trim ( filename_tiles ) write ( unit_logfile , '(a,2a)' ) 'Saving to: ' , trim ( temp_name ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) count = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )). gt . 0 ) then if ( tile_class_subgrid ( i_tile , j_tile ). lt . reduce_grid_class ) then count = count + 1 !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. else !Divide into 4 lesser grids do j = 0 , 1 do i = 0 , 1 count = count + 1 !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * i write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * j write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * ( i - 1. ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * ( j - 1. ) enddo enddo endif endif enddo enddo close ( unit_tile ) !Save results in multiple files if ( save_as_seperate_files ) then count = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )). gt . 0 ) then if ( tile_class_subgrid ( i_tile , j_tile ). lt . reduce_grid_class ) then count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. close ( unit_tile ) else !Divide into 4 lesser grids do j = 0 , 1 do i = 0 , 1 count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * i write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * j write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * ( i - 1. ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * ( j - 1. ) close ( unit_tile ) enddo enddo endif endif enddo enddo endif write ( unit_logfile , '(a,i)' ) 'Tiles before aggregation: ' , count endif if ( use_aggregated_tiling ) then temp_name = trim ( pathname_tiles ) // trim ( filename_tiles ) write ( unit_logfile , '(a,2a)' ) 'Saving to: ' , trim ( temp_name ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) count = 0 do k = 1 , n_aggregated_tiles count_class ( k ,:) = 0 do j_tile = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i_tile = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) !if (num_tile_classes(tile_class_subgrid(i_tile,j_tile)).gt.0) then if ( aggregated_tile_class_subgrid ( i_tile , j_tile , k ). gt . 0 ) then count = count + 1 !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. count_class ( k , aggregated_tile_class_subgrid ( i_tile , j_tile , k )) = count_class ( k , aggregated_tile_class_subgrid ( i_tile , j_tile , k )) + 1 endif !endif enddo enddo write ( unit_logfile , '(a,i,f12.2)' ) 'TILE SIZE: ' , k , aggregated_tile_subgrid_delta ( x_dim_index , k ) / 100 0. write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 1 (500m): ' , count_class ( k , 1 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 2 (250m): ' , count_class ( k , 2 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 3 (125m): ' , count_class ( k , 3 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , count_class ( k , 4 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , count_class ( k , 5 ) enddo close ( unit_tile ) !Save results in multiple files if ( save_as_seperate_files ) then count = 0 do k = 1 , n_aggregated_tiles do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( aggregated_tile_class_subgrid ( i_tile , j_tile , k ). gt . 0 ) then count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. close ( unit_tile ) endif enddo enddo enddo endif endif write ( unit_logfile , '(a,i)' ) 'Tiles saved: ' , count write ( unit_logfile , '(a)' ) ' Stopping after calculating tiles' stop end subroutine uEMEP_set_tile_grids","tags":"","loc":"proc/uemep_set_tile_grids.html"},{"title":"uEMEP_set_region_tile_grids – uEMEP","text":"public  subroutine uEMEP_set_region_tile_grids() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_region_tile_grids !This routine creates the tile files for regions/municipalities !It is based on the variable tile make 'uEMEP_set_tile_grids' so has a lot of unused code in it !It basically reads the masking file, in SSB coordinates, and then finds the extent of this to create municipality tile limits and various resolutions use uEMEP_definitions implicit none integer n_tiles_population_classes , n_tiles_traffic_classes , n_tiles_shipping_classes parameter ( n_tiles_population_classes = 5 , n_tiles_traffic_classes = 5 , n_tiles_shipping_classes = 1 ) real limit_val_tile_population ( n_tiles_population_classes ) data limit_val_tile_population / 0. , 10 0. , 100 0. , 1000 0. , 10000 0. / integer :: num_tiles_with_population ( n_tiles_population_classes ) = 0 real limit_val_tile_traffic ( n_tiles_traffic_classes ) data limit_val_tile_traffic / 0. , 100 0. , 1000 0. , 10000 0. , 100000 0. / integer :: num_tiles_with_traffic ( n_tiles_traffic_classes ) = 0 real limit_val_tile_shipping ( n_tiles_shipping_classes ) data limit_val_tile_shipping / 0. / integer :: num_tiles_with_shipping ( n_tiles_shipping_classes ) = 0 real tile_subgrid_delta ( n_dim_index ) real tile_subgrid_min ( n_dim_index ) real tile_subgrid_max ( n_dim_index ) integer tile_subgrid_dim ( n_dim_index ) real , allocatable :: tile_subgrid (:,:,:) real , allocatable :: x_tile_subgrid (:,:) real , allocatable :: y_tile_subgrid (:,:) real , allocatable :: lon_tile_subgrid (:,:) real , allocatable :: lat_tile_subgrid (:,:) real , allocatable :: crossreference_emission_to_tile_subgrid (:,:,:,:) real , allocatable :: crossreference_population_to_tile_subgrid (:,:,:) integer , allocatable :: tile_class_subgrid (:,:) integer , allocatable :: tile_municipality_subgrid (:,:) real , allocatable :: aggregated_tile_subgrid (:,:,:) real , allocatable :: aggregated_x_tile_subgrid (:,:,:) real , allocatable :: aggregated_y_tile_subgrid (:,:,:) integer , allocatable :: aggregated_tile_class_subgrid (:,:,:) integer i , j , i_class , i_tile , j_tile , i_source , k integer n_tile_index integer tile_population_index !,tile_municipality_index,tile_class_index character ( 256 ) temp_name , temp_str , temp_str1 integer * 8 ssb_id integer municipality_id real x_ssb , f_easting , ssb_dx , y_ssb , ssb_dy integer num_tiles_with_municipality logical exists integer unit_in integer count , index_val integer num_tile_classes ( 10 ) real resolution_tile_classes ( 10 ) character ( 8 ) count_str integer :: unit_tile = 21 real population_tile_scale integer reduce_grid_class real aggregation_tile_scale ( 10 ) integer n_aggregated_tiles parameter ( n_aggregated_tiles = 4 ) !40to5km !parameter (n_aggregated_tiles=5) !160to10km integer dim_region_tiles parameter ( dim_region_tiles = 500 ) integer internal_region_index ( dim_region_tiles ), internal_region_id ( dim_region_tiles ) character ( 256 ) internal_region_name ( dim_region_tiles ) integer n_region_tiles real tile_region_min ( dim_region_tiles , n_dim_index ), tile_region_max ( dim_region_tiles , n_dim_index ) real aggregated_tile_subgrid_delta ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_min ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_max ( n_dim_index , n_aggregated_tiles ) integer aggregated_tile_subgrid_dim ( n_dim_index , n_aggregated_tiles ) logical :: save_as_seperate_files = . true . integer n_search parameter ( n_search = 5 ) character ( 16 ) search_str ( n_search ) real search_delta ( n_search ) integer temp_search integer :: io data search_str / '_1000m' , '_500m' , '_250m' , '_100m' , '_50m' / data search_delta / 100 0. , 50 0. , 25 0. , 10 0. , 5 0. / write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating regional tile distribution and resolution (uEMEP_set_region_tile_grids)' write ( unit_logfile , '(A)' ) '================================================================' !Set tile index values n_tile_index = n_source_index + 1 tile_population_index = n_source_index + 1 !tile_municipality_index=n_source_index+2 !tile_class_index=n_source_index+3 !Reduce size of grids at and above this value reduce_grid_class = 6 !Set to 6 does not reduce !Specify the tiling region to cover all of Norway population_tile_scale = 1. !For 10 km !population_tile_scale=3. !For 20 km population_tile_scale = 0.625 !For 5 km, to give 250 people /km&#94;2 tile_subgrid_min ( x_dim_index ) =- 7000 0. - 40000 tile_subgrid_min ( y_dim_index ) = 644000 0. - 40000 tile_subgrid_max ( x_dim_index ) = 111000 0. + 4000 0. tile_subgrid_max ( y_dim_index ) = 795000 0. + 4000 0. !40to5km tile class population_tile_scale = 0.5 !For 5 km, to give 200 people /km&#94;2 tile_subgrid_delta ( x_dim_index ) = 500 0. tile_subgrid_delta ( y_dim_index ) = 500 0. !Municipality tile classs population_tile_scale = 0.01 tile_subgrid_delta ( x_dim_index ) = 100 0. tile_subgrid_delta ( y_dim_index ) = 100 0. limit_val_tile_population = limit_val_tile_population * population_tile_scale !Set all tile subgrids relative to the target subgrid tile_subgrid_dim ( x_dim_index ) = floor (( tile_subgrid_max ( x_dim_index ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition tile_subgrid_dim ( y_dim_index ) = floor (( tile_subgrid_max ( y_dim_index ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition tile_subgrid_dim ( t_dim_index ) = 1 !Not used !aggregation_tile_scale if ( n_aggregated_tiles . eq . 5 ) then !Not in use aggregation_tile_scale ( 1 ) = 1 6. aggregation_tile_scale ( 2 ) = 8. aggregation_tile_scale ( 3 ) = 4. aggregation_tile_scale ( 4 ) = 2. aggregation_tile_scale ( 5 ) = 1. elseif ( n_aggregated_tiles . eq . 4 ) then aggregation_tile_scale ( 1 ) = 8. aggregation_tile_scale ( 2 ) = 4. aggregation_tile_scale ( 3 ) = 2. aggregation_tile_scale ( 4 ) = 1. elseif ( n_aggregated_tiles . eq . 3 ) then aggregation_tile_scale ( 1 ) = 4. aggregation_tile_scale ( 2 ) = 2. aggregation_tile_scale ( 3 ) = 1. endif do k = 1 , n_aggregated_tiles aggregated_tile_subgrid_min (:, k ) = tile_subgrid_min (:) aggregated_tile_subgrid_max (:, k ) = tile_subgrid_max (:) aggregated_tile_subgrid_delta (:, k ) = tile_subgrid_delta (:) * aggregation_tile_scale ( k ) aggregated_tile_subgrid_dim ( x_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( x_dim_index , k ) - aggregated_tile_subgrid_min ( x_dim_index , k )) / aggregated_tile_subgrid_delta ( x_dim_index , k )) aggregated_tile_subgrid_dim ( y_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( y_dim_index , k ) - aggregated_tile_subgrid_min ( y_dim_index , k )) / aggregated_tile_subgrid_delta ( y_dim_index , k )) enddo !Allocate tile subgrids if (. not . allocated ( tile_subgrid )) allocate ( tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_tile_index )) if (. not . allocated ( x_tile_subgrid )) allocate ( x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_tile_subgrid )) allocate ( y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_tile_subgrid )) allocate ( lon_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_tile_subgrid )) allocate ( lat_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( crossreference_emission_to_tile_subgrid )) allocate ( crossreference_emission_to_tile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) if (. not . allocated ( crossreference_population_to_tile_subgrid )) allocate ( crossreference_population_to_tile_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ), 2 )) if (. not . allocated ( tile_class_subgrid )) allocate ( tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( tile_municipality_subgrid )) allocate ( tile_municipality_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( aggregated_tile_subgrid )) allocate ( aggregated_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_x_tile_subgrid )) allocate ( aggregated_x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_y_tile_subgrid )) allocate ( aggregated_y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_tile_class_subgrid )) allocate ( aggregated_tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) !Set to 0 all tile values tile_subgrid = 0. tile_municipality_subgrid = 0 tile_class_subgrid = 0 !Read in SSB file containing gridded municipality ids !ssb_dx=1000. !ssb_dy=1000. f_easting = 2.e6 !Search file name to define the grid size ssb_dx = 0. ssb_dy = 0. do k = 1 , n_search temp_search = index ( filename_population ( municipality_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality masking data with resolution ' // trim ( adjustl ( search_str ( k ))) endif enddo if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( municipality_index )) stop else write ( unit_logfile , '(A,2f12.2)' ) 'Setting municipality SSB grid size (x,y) = ' , ssb_dx , ssb_dy endif pathfilename_population ( municipality_index ) = trim ( pathname_population ( municipality_index )) // trim ( filename_population ( municipality_index )) !Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( municipality_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file with municipality IDs does not exist: ' , trim ( pathfilename_population ( municipality_index )) stop endif temp_name = pathfilename_population ( municipality_index ) !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB municipality file ' // trim ( temp_name ) rewind ( unit_in ) !Read header SSBID0250M;kommunenum read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 do ssb_id = 0 ; municipality_id = 0 !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id read ( temp_str , * ) municipality_id count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ssb_id,municipality_id !Convert id to grid centre coordinates that are already in UTM33 for SSB data x_ssb = floor ( ssb_id / 1000000 0. ) - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. !Find the tile this ssb grid is in i_tile = 1 + floor (( x_ssb - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition j_tile = 1 + floor (( y_ssb - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition !Add the municipality id to give the grid a value if ( municipality_id . gt . 0 ) then tile_municipality_subgrid ( i_tile , j_tile ) = municipality_id endif enddo close ( unit_in ) !Read municipality ID's and names pathfilename_region_id = trim ( pathname_region_id ) // trim ( filename_region_id ) !Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_region_id ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Region file with municipality IDs does not exist: ' , trim ( pathfilename_region_id ) stop endif temp_name = pathfilename_region_id !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening municipality ID file ' // trim ( temp_name ) rewind ( unit_in ) !Read header index,ID,name read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 do count = count + 1 read ( unit_in , * , iostat = io ) internal_region_index ( count ), internal_region_id ( count ), internal_region_name ( count ) if ( io /= 0 ) exit enddo n_region_tiles = count close ( unit_in ) write ( unit_logfile , '(A,i)' ) 'Number of municipalities: ' , n_region_tiles !Determine tile subgrid do j = 1 , tile_subgrid_dim ( y_dim_index ) do i = 1 , tile_subgrid_dim ( x_dim_index ) x_tile_subgrid ( i , j ) = tile_subgrid_min ( x_dim_index ) + tile_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) !New definition y_tile_subgrid ( i , j ) = tile_subgrid_min ( y_dim_index ) + tile_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !New definition call PROJ2LL ( x_tile_subgrid ( i , j ), y_tile_subgrid ( i , j ), lon_tile_subgrid ( i , j ), lat_tile_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon !if (EMEP_projection_type.eq.LCC_projection_index) then !    call lb2lambert2_uEMEP(xproj_tile_subgrid(i,j),yproj_tile_subgrid(i,j),lon_tile_subgrid(i,j),lat_tile_subgrid(i,j),EMEP_projection_attributes) !else !    xproj_tile_subgrid(i,j)=lon_tile_subgrid(i,j) !    yproj_tile_subgrid(i,j)=lat_tile_subgrid(i,j) !endif enddo enddo !Find grid max and min for each municipality do k = 1 , n_region_tiles tile_region_min ( k , x_dim_index ) = 1e24 tile_region_max ( k , x_dim_index ) =- 1e24 tile_region_min ( k , y_dim_index ) = 1e24 tile_region_max ( k , y_dim_index ) =- 1e24 do j = 1 , tile_subgrid_dim ( y_dim_index ) do i = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i , j ). eq . internal_region_id ( k )) then if ( x_tile_subgrid ( i , j ). lt . tile_region_min ( k , x_dim_index )) tile_region_min ( k , x_dim_index ) = x_tile_subgrid ( i , j ) if ( x_tile_subgrid ( i , j ). gt . tile_region_max ( k , x_dim_index )) tile_region_max ( k , x_dim_index ) = x_tile_subgrid ( i , j ) if ( y_tile_subgrid ( i , j ). lt . tile_region_min ( k , y_dim_index )) tile_region_min ( k , y_dim_index ) = y_tile_subgrid ( i , j ) if ( y_tile_subgrid ( i , j ). gt . tile_region_max ( k , y_dim_index )) tile_region_max ( k , y_dim_index ) = y_tile_subgrid ( i , j ) endif enddo enddo !Add or subtract ssb grid size to allow for the poor resolution and make sure all of the kommune is within the tile tile_region_min ( k , x_dim_index ) = tile_region_min ( k , x_dim_index ) - ssb_dx * 1.5 tile_region_max ( k , x_dim_index ) = tile_region_max ( k , x_dim_index ) + ssb_dx * 1.5 tile_region_min ( k , y_dim_index ) = tile_region_min ( k , y_dim_index ) - ssb_dy * 1.5 tile_region_max ( k , y_dim_index ) = tile_region_max ( k , y_dim_index ) + ssb_dy * 1.5 enddo !Determine the aggregated tile subgrids, in UTM only do k = 1 , n_aggregated_tiles do j = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) aggregated_x_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( x_dim_index , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) * ( i - 0.5 ) aggregated_y_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( y_dim_index , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) * ( j - 0.5 ) enddo enddo enddo !Create a cross reference grid do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo endif enddo do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_population_subgrid ( i , j ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_population_subgrid ( i , j ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo !Calculate the population within each tile do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) i_tile = crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) j_tile = crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) if ( i_tile . gt . 0. and . j_tile . gt . 0 ) then tile_subgrid ( i_tile , j_tile , tile_population_index ) = tile_subgrid ( i_tile , j_tile , tile_population_index ) + population_subgrid ( i , j , population_data_type ) endif enddo enddo !Calculate the veh.km within each tile i_source = traffic_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) if ( i_tile . gt . 0. and . j_tile . gt . 0 ) then tile_subgrid ( i_tile , j_tile , traffic_index ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) / 100 0. !ADT*km endif enddo enddo !Calculate the shipping emissions within each tile i_source = shipping_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) if ( i_tile . gt . 0. and . j_tile . gt . 0 ) then tile_subgrid ( i_tile , j_tile , i_source ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) !emission for the time period endif enddo enddo !Write summary results num_tiles_with_municipality = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) num_tiles_with_municipality = num_tiles_with_municipality + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'MUNICIPALITY TILE: ' , num_tiles_with_municipality !Write summary results num_tiles_with_population = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_population_classes - 1 if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( i_class + 1 )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo i_class = n_tiles_population_classes if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_population_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' -' , limit_val_tile_population ( i_class + 1 ), num_tiles_with_population ( i_class ) enddo i_class = n_tiles_population_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' <' , ' ' , num_tiles_with_population ( i_class ) !Write summary results num_tiles_with_traffic = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_traffic_classes - 1 if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( i_class + 1 )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo i_class = n_tiles_traffic_classes if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_traffic_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' -' , limit_val_tile_traffic ( i_class + 1 ), num_tiles_with_traffic ( i_class ) enddo i_class = n_tiles_traffic_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' <' , ' ' , num_tiles_with_traffic ( i_class ) !Write summary results num_tiles_with_shipping = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_subgrid ( i_tile , j_tile , shipping_index ). gt . limit_val_tile_shipping ( 1 )) num_tiles_with_shipping ( 1 ) = num_tiles_with_shipping ( 1 ) + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'SHIPPING TILE: ' , num_tiles_with_shipping ( 1 ) num_tile_classes = 0 !Class 1: 500 m. No emissions at all so interpolated, irrespective of population !Class 2: 250 m. Shipping emissions > 0 and Traffic < 1000 (1) or (population < 1000 and Traffic < 10000 (2)) !Class 3: 125 m. Traffic < 10000 (2) or (population > 1000 (2) population < 5000 (2) !Class 4: 50 m. Traffic > 10000 (2) and population > 5000 (3) tile_class_subgrid = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) !Only choose tiles that are part of a municipality if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) then tile_class_subgrid ( i_tile , j_tile ) = 1 if ( tile_subgrid ( i_tile , j_tile , shipping_index ). le . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 1 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 2 )) then tile_class_subgrid ( i_tile , j_tile ) = 1 !No sources and population less than 100 elseif ( tile_subgrid ( i_tile , j_tile , shipping_index ). ge . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). ge . limit_val_tile_population ( 1 )) then tile_class_subgrid ( i_tile , j_tile ) = 2 !Little traffic but any shipping and any population elseif (( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 )). or . & ( tile_subgrid ( i_tile , j_tile , traffic_index ). ge . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 ))) then tile_class_subgrid ( i_tile , j_tile ) = 3 !Population from 1000 to 5000 or road traffic elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 4 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 10000 elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 100000 endif !if (tile_class_subgrid(i_tile,j_tile).eq.2) tile_class_subgrid(i_tile,j_tile)=3 num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) = num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) + 1 endif enddo enddo write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 1 (500m): ' , num_tile_classes ( 1 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 2 (250m): ' , num_tile_classes ( 2 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 3 (125m): ' , num_tile_classes ( 3 ) if ( reduce_grid_class . eq . 4 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) endif if ( reduce_grid_class . eq . 5 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) endif resolution_tile_classes ( 1 ) = 50 0. resolution_tile_classes ( 2 ) = 25 0. resolution_tile_classes ( 3 ) = 12 5. resolution_tile_classes ( 4 ) = 5 0. resolution_tile_classes ( 5 ) = 2 5. !Save results in a single file temp_name = trim ( pathname_tiles ) // trim ( filename_tiles ) write ( unit_logfile , '(a,2a)' ) 'Saving to: ' , trim ( temp_name ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) count = 0 do k = 1 , n_region_tiles count = count + 1 write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count !write(unit_tile,'(a,i0.5)') 'tile_tag= ',count write ( unit_tile , '(a,a)' ) 'region_name= ' , trim ( internal_region_name ( count )) write ( unit_tile , '(a,i0.5)' ) 'region_id= ' , internal_region_id ( count ) write ( unit_tile , '(a,i0.5)' ) 'region_index= ' , internal_region_index ( count ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , tile_region_min ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , tile_region_min ( k , y_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , tile_region_max ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , tile_region_max ( k , y_dim_index ) enddo close ( unit_tile ) !Save results in multiple files if ( save_as_seperate_files ) then count = 0 do k = 1 , n_region_tiles count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,a)' ) 'region_name= ' , trim ( internal_region_name ( count )) write ( unit_tile , '(a,i0.5)' ) 'region_id= ' , internal_region_id ( count ) write ( unit_tile , '(a,i0.5)' ) 'region_index= ' , internal_region_index ( count ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , tile_region_min ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , tile_region_min ( k , y_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , tile_region_max ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , tile_region_max ( k , y_dim_index ) close ( unit_tile ) enddo write ( unit_logfile , '(a,i)' ) 'Number of region tiles: ' , count endif write ( unit_logfile , '(a)' ) ' Stopping after calculating tiles' stop end subroutine uEMEP_set_region_tile_grids","tags":"","loc":"proc/uemep_set_region_tile_grids.html"},{"title":"uEMEP_subgrid_deposition – uEMEP","text":"public  subroutine uEMEP_subgrid_deposition(source_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer :: source_index Source Code subroutine uEMEP_subgrid_deposition ( source_index ) use uEMEP_definitions implicit none integer source_index integer i , j , ii , jj , tt , k integer i_pollutant !Define the target subgrid to be the same as the emission subgrid real , allocatable :: target_subgrid (:,:,:) real , allocatable :: target_deposition_subgrid (:,:,:,:) real , allocatable :: x_target_subgrid (:,:) real , allocatable :: y_target_subgrid (:,:) real , allocatable :: traveltime_target_subgrid (:,:,:,:) real :: target_subgrid_delta ( 2 ) integer target_subgrid_dim ( n_dim_index ) !define the temporary arrays for meteo real , allocatable :: temp_FF_subgrid (:,:) real , allocatable :: temp_FF_integral_subgrid (:,:) real , allocatable :: trajectory_vector (:,:) real , allocatable :: angle_diff (:,:) real temp_sum_subgrid ( n_pollutant_loop ) integer traj_max_index logical valid_traj real traj_step_size , x_loc , y_loc , FFgrid_loc , logz0_loc , u_star0_loc , FF10_loc , zc_loc , invL_loc real ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , sig_y_00_loc , sig_z_00_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc real FF_loc , FF_zc_loc , precip_loc real FF_integral_loc integer n_plume_subgrid_max parameter ( n_plume_subgrid_max = 100000 ) integer plume_crossreference ( n_plume_subgrid_max , 2 ) real plume_distance ( n_plume_subgrid_max , 2 ) real temp_plume_distance ( n_plume_subgrid_max ) integer sorted_plume_index ( n_plume_subgrid_max ) real plume_source ( n_pollutant_loop ) integer plume_count , max_plume_count real xpos_limit , ypos_limit real distance_subgrid , distance_subgrid_min , distance_emission_subgrid_min integer i_target_start , i_target_end , j_target_start , j_target_end integer t_start , t_end integer i_cross , j_cross integer i_cross_integral , j_cross_integral integer i_cross_deposition , j_cross_deposition integer i_cross_target_integral , j_cross_target_integral integer subsource_index real subgrid_internal , subgrid_internal_integral real subgrid_internal_pollutant ( n_pollutant_loop ), drydepo_internal_pollutant ( n_pollutant_loop ), wetdepo_internal_pollutant ( n_pollutant_loop ) real drydepo_internal_integral real vertical_integral_internal , wetdepo_internal , wetdepo_internal_integral real xpos_emission_subgrid , ypos_emission_subgrid real xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min real xpos_target_subgrid , ypos_target_subgrid integer target_subgrid_dim_min ( 2 ), target_subgrid_dim_max ( 2 ) real plume_vertical_integral ( n_integral_subgrid_index ) real plume_vertical_integral_pollutant ( n_integral_subgrid_index ) real , allocatable :: target_vertical_integral_subgrid (:,:,:) integer i_integral integer count !Functions !integer rargsort(n_plume_subgrid_max) write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating deposition and dispersion (uEMEP_subgrid_deposition)' write ( unit_logfile , '(A)' ) '================================================================' !Set up the target subgrid to be the same as the emission subgrid for that source. target_subgrid_dim (:) = emission_subgrid_dim (:, source_index ) target_subgrid_delta (:) = emission_subgrid_delta (:, source_index ) !Deposition and plume depletion must be calculated also in the buffer zone if ( calculate_source_depletion_flag ) then !Need to calculate on all the grids to get the depletion target_subgrid_dim_min (:) = 1 ; target_subgrid_dim_max (:) = target_subgrid_dim ( 1 : 2 ) else !Limit the target grid to slightly larger than concentration grid target_subgrid_dim_min ( x_dim_index ) =- 1 + 1 + floor (( subgrid_min ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) target_subgrid_dim_min ( y_dim_index ) =- 1 + 1 + floor (( subgrid_min ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) target_subgrid_dim_max ( x_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) target_subgrid_dim_max ( y_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) endif !Allocate the target subgrid to be the same as the emission subgrid but no time dimension if ( allocated ( target_subgrid )) deallocate ( target_subgrid ) if ( allocated ( target_deposition_subgrid )) deallocate ( target_deposition_subgrid ) if ( allocated ( x_target_subgrid )) deallocate ( x_target_subgrid ) if ( allocated ( y_target_subgrid )) deallocate ( y_target_subgrid ) if ( allocated ( traveltime_target_subgrid )) deallocate ( traveltime_target_subgrid ) if (. not . allocated ( target_subgrid )) allocate ( target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), n_pollutant_loop )) if (. not . allocated ( target_deposition_subgrid )) allocate ( target_deposition_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), n_deposition_index , n_pollutant_loop )) if (. not . allocated ( x_target_subgrid )) allocate ( x_target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_target_subgrid )) allocate ( y_target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ))) if (. not . allocated ( traveltime_target_subgrid )) allocate ( traveltime_target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), 2 , n_pollutant_loop )) if ( adjust_wetdepo_integral_to_lowest_layer_flag . or . local_subgrid_method_flag . eq . 1 ) then if ( allocated ( target_vertical_integral_subgrid )) deallocate ( target_vertical_integral_subgrid ) if (. not . allocated ( target_vertical_integral_subgrid )) allocate ( target_vertical_integral_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), 3 )) endif x_target_subgrid (:,:) = x_emission_subgrid (:,:, source_index ) y_target_subgrid (:,:) = y_emission_subgrid (:,:, source_index ) !Allocate temporary wind speed subgrid allocate ( temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( temp_FF_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) !Set the x and y position limits to coincide to half the EMEP grid (refered here as lon and lat but can be also LCC projection) times the number of grids xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Minimum distance for travel time calculation set to half of a grid diagonal weighted so the circle has the same area as the square with that diagonal distance_subgrid_min = sqrt ( subgrid_delta ( x_dim_index ) * subgrid_delta ( x_dim_index ) + subgrid_delta ( y_dim_index ) * subgrid_delta ( y_dim_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 !Minimum distance for dispersion set to  half of an emission grid diagonal weighted so the circle has the same area as the square with that diagonal distance_emission_subgrid_min = sqrt ( emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( x_dim_index , source_index ) & + emission_subgrid_delta ( y_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 !Set the subsource_index to 1 so no additional subsources in these routines subsource_index = 1 !Set local dispersion parameters to be used only in the annual calculation, overwritten in the hourly files !if (annual_calculations) then call uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) sig_y_00_loc = sig_y_00 ( source_index , subsource_index ) sig_z_00_loc = sig_z_00 ( source_index , subsource_index ) h_emis_loc = h_emis ( source_index , subsource_index ) z_rec_loc = z_rec ( source_index , subsource_index ) !endif write ( unit_logfile , '(a,i3)' ) 'Calculating deposition and dispersion data for ' // trim ( source_file_str ( source_index )) !Set the target grid loop variables j_target_start = 1 ; j_target_end = target_subgrid_dim ( y_dim_index ) i_target_start = 1 ; i_target_end = target_subgrid_dim ( x_dim_index ) j_target_start = target_subgrid_dim_min ( y_dim_index ); j_target_end = target_subgrid_dim_max ( y_dim_index ) i_target_start = target_subgrid_dim_min ( x_dim_index ); i_target_end = target_subgrid_dim_max ( x_dim_index ) !write(*,*) j_target_start,j_target_end,i_target_start,i_target_end !stop !Set the start and end times of the loop t_start = 1 ; t_end = subgrid_dim ( t_dim_index ) !Loop through the time do tt = t_start , t_end !Initialise the final grid to 0 subgrid (:,:, tt , proxy_subgrid_index , source_index ,:) = 0. subgrid (:,:, tt , drydepo_local_subgrid_index , source_index ,:) = 0. subgrid (:,:, tt , wetdepo_local_subgrid_index , source_index ,:) = 0. integral_subgrid (:,:, tt ,:, source_index ,:) = 0. !deposition_subgrid(:,:,tt,:,:)=0. !Initialise the target grid to 0 target_subgrid = 0. target_deposition_subgrid = 0. target_vertical_integral_subgrid = 0. !Set the last meteo data subgrid in the case when the internal time loop is used if (. not . use_single_time_loop_flag ) then if ( tt . gt . t_start ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt - 1 ,:) else last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt ,:) endif endif !Finds the angle difference between the current and last meteo field for dispersion and implements meandering if selected do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) if ( hourly_calculations ) then call delta_wind_direction ( i_cross , j_cross , tt , meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ), angle_diff ( i_cross , j_cross )) else angle_diff ( i_cross , j_cross ) = 0. endif enddo enddo !Create a temporary wind speed subgrid for each hour call uEMEP_create_wind_field ( temp_FF_subgrid , angle_diff , wind_level_flag , source_index , subsource_index , tt ) !Create an integral wind speed subgrid call uEMEP_create_wind_field ( temp_FF_integral_subgrid , angle_diff , wind_level_integral_flag , source_index , subsource_index , tt ) !Define the trajectory and its length !Maxium number of trajectory steps and size of steps based on the integral (meteorology) loop size if ( use_trajectory_flag ( source_index )) then traj_step_size = min ( integral_subgrid_delta ( x_dim_index ), integral_subgrid_delta ( y_dim_index )) * traj_step_scale traj_max_index = floor ( max ( integral_subgrid_loop_index ( x_dim_index ), integral_subgrid_loop_index ( y_dim_index )) / traj_step_scale ) if ( tt . eq . t_start ) write ( unit_logfile , '(a,f12.1,i)' ) 'Trajectory step (m) and dimensions: ' , traj_step_size , traj_max_index if (. not . allocated ( trajectory_vector )) allocate ( trajectory_vector ( traj_max_index , 2 )) endif max_plume_count = 0 !Set up the deposition target subgrid based on the emission subgrid. !This works when the deposition subgrid is larger than the target emission subgrid !When the deposition subgrid is smaller than the target then we need to take the average of the grids !This should be area weighted but is not if ( calculate_deposition_flag ) then if ( deposition_subgrid_delta ( x_dim_index ). lt . target_subgrid_delta ( x_dim_index )) then do jj = j_target_start , j_target_end do ii = i_target_start , i_target_end i_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , y_dim_index , source_index ) !i_loop_deposition=floor(target_subgrid_delta(x_dim_index)/deposition_subgrid_delta(x_dim_index)/2.) !target_deposition_subgrid(ii,jj,:,:)=target_deposition_subgrid(ii,jj,:,:)+deposition_subgrid(i_cross_deposition,j_cross_deposition,tt,:,:) !write(*,*) deposition_subgrid(i_cross_deposition,j_cross_deposition,tt,:,:) do i_pollutant = 1 , n_pollutant_loop target_deposition_subgrid ( ii , jj , vd_index , i_pollutant ) = target_deposition_subgrid ( ii , jj , vd_index , i_pollutant ) + & area_weighted_extended_interpolation_function ( x_deposition_subgrid , y_deposition_subgrid , deposition_subgrid (:,:, tt , vd_index , i_pollutant ) & , deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), deposition_subgrid_delta (:), x_target_subgrid ( ii , jj ), y_target_subgrid ( ii , jj ), target_subgrid_delta ) enddo enddo enddo else do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) i_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , y_dim_index , source_index ) target_deposition_subgrid ( ii , jj ,:,:) = deposition_subgrid ( i_cross_deposition , j_cross_deposition , tt ,:,:) !write(*,*) deposition_subgrid(i_cross_deposition,j_cross_deposition,tt,:,:) enddo enddo endif endif !Loop through all the emission subgrids do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) !Allocate temporary emission (plume source) for this grid and time plume_source (:) = emission_subgrid ( ii , jj , tt , source_index ,:) !Only calculate if there is an emissions if ( sum ( plume_source (:)). ne . 0 ) then !Calculate the trajectory for this emission source if ( use_trajectory_flag ( source_index )) then trajectory_vector = NODATA_value !Calculate the trajectory for this emission grid call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( ii , jj , source_index ), y_emission_subgrid ( ii , jj , source_index ), tt , & traj_max_index , traj_step_size , trajectory_vector (:, x_dim_index ), trajectory_vector (:, y_dim_index )) else !Create an artificial trajectory here for the straight line case by making the trajectory step size half the size of the integral grid !Not working!!!! traj_step_size = min ( integral_subgrid_max ( x_dim_index ) - integral_subgrid_min ( x_dim_index ), integral_subgrid_max ( y_dim_index ) - integral_subgrid_min ( y_dim_index )) / 2. call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( ii , jj , source_index ), y_emission_subgrid ( ii , jj , source_index ), tt , & traj_max_index , traj_step_size , trajectory_vector (:, x_dim_index ), trajectory_vector (:, y_dim_index )) endif !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) i_cross_integral = min ( max ( 1 , i_cross_integral ), integral_subgrid_dim ( x_dim_index )) j_cross_integral = min ( max ( 1 , j_cross_integral ), integral_subgrid_dim ( y_dim_index )) !Set the local wind speed and other parameters at emission position FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) FF_integral_loc = temp_FF_integral_subgrid ( i_cross_integral , j_cross_integral ) !L_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,invL_subgrid_index) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) u_star0_loc = max ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , ustar_subgrid_index ), ustar_min ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) !MORE COMPLICATED BECAUSE THE PLUME DEPLETION MUST ALSO BE CALCULATED OUTSIDE THE TARGET REGION!! !SO THE LOOP NEEDS TO BE THE EMISSION LOOP NOT JUST THE TARGET LOOP !Loop through the target grids and find the distance of each target grid along the plume centre line if ( calculate_deposition_flag . and . calculate_source_depletion_flag ) then !Set the size of the loop region around the emission cell to be up to emission_subgrid_loop_index i_target_start = max ( 1 , ii - emission_subgrid_loop_index ( x_dim_index , source_index )) i_target_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), ii + emission_subgrid_loop_index ( x_dim_index , source_index )) j_target_start = max ( 1 , jj - emission_subgrid_loop_index ( y_dim_index , source_index )) j_target_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), jj + emission_subgrid_loop_index ( y_dim_index , source_index )) else !Usea smaller area i_target_start = max ( 1 , ii - emission_subgrid_loop_index ( x_dim_index , source_index )) i_target_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), ii + emission_subgrid_loop_index ( x_dim_index , source_index )) j_target_start = max ( 1 , jj - emission_subgrid_loop_index ( y_dim_index , source_index )) j_target_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), jj + emission_subgrid_loop_index ( y_dim_index , source_index )) endif !Set the emission limits (EMEP projection ) surrounding the target grid xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , source_index ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , source_index ) xpos_area_max = xpos_emission_subgrid + xpos_limit xpos_area_min = xpos_emission_subgrid - xpos_limit ypos_area_max = ypos_emission_subgrid + ypos_limit ypos_area_min = ypos_emission_subgrid - ypos_limit plume_count = 0 plume_crossreference = 0 plume_distance = 0 !write(*,*) i_target_end-i_target_start,j_target_end-j_target_start do j = j_target_start , j_target_end do i = i_target_start , i_target_end !Only calculate if it is within the local region distance !Set the EMEP projection position of the emission grid. This guarantees that it extentds to the right distance xpos_target_subgrid = xproj_emission_subgrid ( i , j , source_index ) ypos_target_subgrid = yproj_emission_subgrid ( i , j , source_index ) !Select only target grids within the predefined region if ( xpos_target_subgrid . ge . xpos_area_min . and . xpos_target_subgrid . le . xpos_area_max & . and . ypos_target_subgrid . ge . ypos_area_min . and . ypos_target_subgrid . le . ypos_area_max ) then !Find the integral index for the target grid i_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , source_index ) j_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , source_index ) i_cross_target_integral = min ( max ( 1 , i_cross_target_integral ), integral_subgrid_dim ( x_dim_index )) j_cross_target_integral = min ( max ( 1 , j_cross_target_integral ), integral_subgrid_dim ( y_dim_index )) !Set the mixing height at the average of the emission and target position h_mix_loc = ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) + meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , hmix_subgrid_index )) / 2. !Set the precipitation at the receptor grid precip_loc = meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , precip_subgrid_index ) !Find the minimum distance to the trajectory and check it is valid (downwind) call uEMEP_minimum_distance_trajectory_fast ( x_target_subgrid ( i , j ), y_target_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_vector (:, x_dim_index ), trajectory_vector (:, y_dim_index ), x_loc , y_loc , valid_traj ) !valid_traj=.false. if ( valid_traj ) then !Check if y_loc is within 4*sigma region based on the PG stability functions at emission position call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Put the plume in the plume vector for later use if ( abs ( y_loc ). lt . 3. * sig_y_loc ) then plume_count = plume_count + 1 !Check number of subgrids in plume does not exceed allowable if ( plume_count . gt . n_plume_subgrid_max ) then write ( unit_logfile , '(a,i)' ) 'WARNING: Number of subgrids for a plume exceeds the maximum value of: ' , n_plume_subgrid_max write ( unit_logfile , '(a)' ) '         Exiting the plume but will continue calculating' goto 10 else plume_crossreference ( plume_count , x_dim_index ) = i plume_crossreference ( plume_count , y_dim_index ) = j plume_distance ( plume_count , x_dim_index ) = x_loc plume_distance ( plume_count , y_dim_index ) = y_loc endif endif endif endif enddo enddo max_plume_count = max ( max_plume_count , plume_count ) !Sort the target grids from closest to furthest creating a crossreference index !write(*,*) 'IN: ',plume_distance(1:plume_count,x_dim_index) 10 temp_plume_distance ( 1 : plume_count ) = plume_distance ( 1 : plume_count , x_dim_index ) call rargsort ( temp_plume_distance ( 1 : plume_count ), sorted_plume_index ( 1 : plume_count ), plume_count ) !write(*,*) 'OUT:',sorted_plume_index(1:plume_count) !Set the plume source that will be depleted with deposition plume_source = emission_subgrid ( ii , jj , tt , source_index ,:) !Loop through the sorted array starting at the closest (which should always be the emission grid) !write(*,*) ii,jj,plume_count do k = 1 , plume_count x_loc = plume_distance ( sorted_plume_index ( k ), x_dim_index ) y_loc = plume_distance ( sorted_plume_index ( k ), y_dim_index ) i = plume_crossreference ( sorted_plume_index ( k ), x_dim_index ) j = plume_crossreference ( sorted_plume_index ( k ), y_dim_index ) !write(*,*) x_loc,y_loc !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 3 ) then !Set initial values for sigma. Initial sig_y is set here as well but is overridden by Kz dispersion call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !Add the meandering and change in wind angle to the plume since not included in Kz calculation sig_y_loc = sig_y_loc + x_loc * angle_diff ( i_cross_integral , j_cross_integral ) !Use the average of the emision height and zc to determine wind speed. Is set to true if wind_level_flag=6 !CHECK THIS if ( wind_level_flag . eq . 6. or . wind_level_zc_flag ) then !Set the minimum wind speed FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif if ( wind_level_integral_flag . eq . 6 ) then !Set the minimum wind speed FF_integral_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif if ( stability_scheme_flag . eq . 4 ) then write ( unit_logfile , '(a,i)' ) 'Stability_scheme_flag=4 (Kz emulator) no longer an option. Stopping' stop !call uEMEP_set_dispersion_sigma_Kz_emulator(h_emis_loc,invL_loc,logz0_loc,h_mix_loc,sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) endif !Adjust the height of the wind to the average of the emission and plume centre of mass height. !This is already the case in the Kz calculation so not repeated here. if ( wind_level_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then !if (wind_level_flag.eq.6) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif if ( wind_level_integral_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then !if (wind_level_flag.eq.6) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_integral_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !Calculate the dispersion based on the derived sigmas subgrid_internal = gauss_plume_cartesian_sigma_func ( x_loc , y_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc ) !write(*,'(9es12.2)') x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,subgrid_internal !Only use half of the source grid for deposition and depletion if ( k . gt . 1 ) then !s/m3 *m2=s/m subgrid_internal_integral = ( subgrid_internal ) * target_subgrid_delta ( x_dim_index ) * target_subgrid_delta ( y_dim_index ) else subgrid_internal_integral = ( subgrid_internal ) * target_subgrid_delta ( x_dim_index ) * 0.5 * target_subgrid_delta ( y_dim_index ) !Half the grid endif !Calculate the vertically integrated mass of the plume (s/m2) up to the lowest level and up to the mixing height if ( adjust_wetdepo_integral_to_lowest_layer_flag . and . calculate_deposition_flag ) then plume_vertical_integral ( hsurf_integral_subgrid_index ) = gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc , 0. , H_emep ) * H_emep plume_vertical_integral ( hmix_integral_subgrid_index ) = gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc , 0. , h_mix_loc ) * h_mix_loc !write(*,*) h_mix_loc,x_loc,sig_z_loc,vertical_integral_internal/(sig_z_loc*sqrt(2.*3.14159)/(2.*3.14159*sig_y_loc*sig_z_loc)*exp(-0.5*(y_loc*y_loc)/(sig_y_loc*sig_y_loc))/FF_loc*plume_source(i_pollutant) ) !write(*,*) plume_vertical_integral(1)/plume_vertical_integral(2),H_emep/h_mix_loc,H_emep/h_mix_loc/(plume_vertical_integral(1)/plume_vertical_integral(2)) !Calculate the average concentration in the lowest layer !These two give the same results but the second is quicker. Can put it in a seperate subroutine !vertical_integral_internal=gauss_plume_cartesian_sigma_integral_func(x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,0.,h_mix_loc)*h_mix_loc*plume_source(i_pollutant) vertical_integral_internal = exp ( - 0.5 * ( y_loc * y_loc ) / ( sig_y_loc * sig_y_loc )) / FF_loc / ( sqrt ( 2. * 3.14159 ) * sig_y_loc ) !write(*,*) h_mix_loc,x_loc,sig_z_loc,vertical_integral_internal/(exp(-0.5*(y_loc*y_loc)/(sig_y_loc*sig_y_loc))/FF_loc/(sqrt(2.*3.14159)*sig_y_loc)*plume_source(i_pollutant)) endif if ( local_subgrid_method_flag . eq . 1 ) then plume_vertical_integral ( hsurf_average_subgrid_index ) = gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_integral_loc , 0. , H_emep ) endif if ( subgrid_internal_integral . gt . 0 ) then if ( calculate_deposition_flag ) then do i_pollutant = 1 , n_pollutant_loop !Multiply by the emissions to get the concentration prior to depletion (ug/m3) subgrid_internal_pollutant ( i_pollutant ) = subgrid_internal * plume_source ( i_pollutant ) !Calculate the dry deposition flux (ug/m3 *m/s=ug/s/m2) drydepo_internal_pollutant ( i_pollutant ) = subgrid_internal_pollutant ( i_pollutant ) * target_deposition_subgrid ( i , j , vd_index , i_pollutant ) !Calculate the dimensionless integral for plume depletion (s/m *m/s=1) drydepo_internal_integral = subgrid_internal_integral * target_deposition_subgrid ( i , j , vd_index , i_pollutant ) !Set the scavenging (s/m2 /m *m/s = /m2). 1e-3/3600 converts mm/hr to m/s wetdepo_internal = vertical_integral_internal * wetdepo_scavanging_rate ( pollutant_loop_index ( i_pollutant )) * ( precip_loc / 100 0. / 360 0. ) !Calculate the wet deposition flux ( /m2 ug/s = ug/m2/s) wetdepo_internal_pollutant ( i_pollutant ) = wetdepo_internal * plume_source ( i_pollutant ) !Calculate the dimensionless integral for plume depletion (/m2 * m2 = 1) wetdepo_internal_integral = wetdepo_internal * target_subgrid_delta ( x_dim_index ) * target_subgrid_delta ( y_dim_index ) !Make integrated concentration values plume_vertical_integral_pollutant (:) = plume_vertical_integral (:) * plume_source ( i_pollutant ) !Calculate the plume depletion by dry and wet deposition (ug/s) if ( calculate_source_depletion_flag ) then plume_source ( i_pollutant ) = plume_source ( i_pollutant ) * exp ( - drydepo_internal_integral - wetdepo_internal_integral ) endif !write(*,'(f12.2,4es12.2,f12.3)') x_loc,subgrid_internal_pollutant(i_pollutant),subgrid_internal,plume_source(i_pollutant),drydepo_internal_pollutant(i_pollutant)*target_subgrid_delta(x_dim_index)*target_subgrid_delta(y_dim_index),plume_source(i_pollutant)/emission_subgrid(ii,jj,tt,source_index,i_pollutant) !Add to the dry deposition target grid target_deposition_subgrid ( i , j , drydepo_index , i_pollutant ) = target_deposition_subgrid ( i , j , drydepo_index , i_pollutant ) + drydepo_internal_pollutant ( i_pollutant ) !Add to the wet deposition target grid target_deposition_subgrid ( i , j , wetdepo_index , i_pollutant ) = target_deposition_subgrid ( i , j , wetdepo_index , i_pollutant ) + wetdepo_internal_pollutant ( i_pollutant ) !Add to the target concentration subgrid position target_subgrid ( i , j , i_pollutant ) = target_subgrid ( i , j , i_pollutant ) + subgrid_internal_pollutant ( i_pollutant ) enddo else !No deposition do i_pollutant = 1 , n_pollutant_loop !Multiply by the emissions to get the concentration prior to depletion (ug/m3) subgrid_internal_pollutant ( i_pollutant ) = subgrid_internal * plume_source ( i_pollutant ) !Add to the target concentration subgrid position target_subgrid ( i , j , i_pollutant ) = target_subgrid ( i , j , i_pollutant ) + subgrid_internal_pollutant ( i_pollutant ) !Make integrated concentration values plume_vertical_integral_pollutant (:) = plume_vertical_integral (:) * plume_source ( i_pollutant ) enddo endif !Determine the distance for the travel time calculation distance_subgrid = sqrt ( x_loc * x_loc + y_loc * y_loc ) distance_subgrid = max ( distance_subgrid , distance_subgrid_min ) !Add to the travel time array traveltime_target_subgrid ( i , j , 1 ,:) = traveltime_target_subgrid ( i , j , 1 ,:) + distance_subgrid / FF_loc * subgrid_internal_pollutant traveltime_target_subgrid ( i , j , 2 ,:) = traveltime_target_subgrid ( i , j , 2 ,:) + subgrid_internal_pollutant !Calculate the vertically integrated mass of the plume (s/m2) up to the lowest level and up to the mixing height if (( calculate_deposition_flag . and . adjust_wetdepo_integral_to_lowest_layer_flag ). or . local_subgrid_method_flag . eq . 1 ) then target_vertical_integral_subgrid ( i , j ,:) = target_vertical_integral_subgrid ( i , j ,:) + plume_vertical_integral_pollutant (:) !write(*,'(2i,4es12.2)') i,j,plume_vertical_integral(1),target_vertical_integral_subgrid(i,j,1),plume_vertical_integral(2),target_vertical_integral_subgrid(i,j,2) endif endif enddo !plume loop endif !end if emission not 0 enddo !End of emission loop enddo write ( unit_logfile , '(a,i)' ) 'Maximum number of subgrids per plume in this period and region = ' , max_plume_count !This ratio should be 1 in a well mixed layer. It can be used to estimate the average column concentration based on the surface layer concentration !target_vertical_integral_subgrid(:,:,4)=target_vertical_integral_subgrid(:,:,1)/target_vertical_integral_subgrid(:,:,2) !Interpolate target grid to the concentration subgrid do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( calculate_deposition_flag ) then subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_deposition_subgrid (:,:, drydepo_index , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_deposition_subgrid (:,:, wetdepo_index , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) endif subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_subgrid (:,:, i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_target_subgrid (:,:, 1 , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_target_subgrid (:,:, 2 , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) enddo else subgrid ( i , j , tt , proxy_subgrid_index , source_index ,:) = NODATA_value traveltime_subgrid ( i , j , tt ,:,:) = NODATA_value endif enddo enddo !Determine the final travel time traveltime_subgrid (:,:, tt , 3 ,:) = traveltime_subgrid (:,:, tt , 1 ,:) / traveltime_subgrid (:,:, tt , 2 ,:) where ( traveltime_subgrid (:,:, tt , 2 ,:). eq . 0 ) traveltime_subgrid (:,:, tt , 3 ,:) = 360 0. * 1 2. !Place the vertically integrated values in the integral subgrid from the target grid, that is the same as the emission grid !write(*,*) 'Interpolating vertically integrated values to the integral grid' if (( calculate_deposition_flag . and . adjust_wetdepo_integral_to_lowest_layer_flag ). or . local_subgrid_method_flag . eq . 1 ) then do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) !i_cross_integral=crossreference_integral_to_emission_subgrid(i,j,x_dim_index,source_index) !j_cross_integral=crossreference_integral_to_emission_subgrid(i,j,y_dim_index,source_index) !i_cross_integral=max(1,i_cross_integral);i_cross_integral=min(integral_subgrid_dim(x_dim_index),i_cross_integral) !j_cross_integral=max(1,j_cross_integral);j_cross_integral=min(integral_subgrid_dim(y_dim_index),j_cross_integral) do i_integral = 1 , n_integral_subgrid_index do i_pollutant = 1 , n_pollutant_loop integral_subgrid ( i , j , tt , i_integral , source_index , i_pollutant ) = integral_subgrid ( i , j , tt , i_integral , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_vertical_integral_subgrid (:,:, i_integral ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_integral_subgrid ( i , j ), y_integral_subgrid ( i , j )) !write(*,*) i,j,i_integral,integral_subgrid(i,j,tt,i_integral,source_index,i_pollutant) enddo enddo enddo enddo !Add to allsource do i_integral = 1 , n_integral_subgrid_index integral_subgrid (:,:, tt , i_integral , allsource_index ,:) = integral_subgrid (:,:, tt , i_integral , allsource_index ,:) + integral_subgrid (:,:, tt , i_integral , source_index ,:) enddo endif !Show mean outputs for checking do i_pollutant = 1 , n_pollutant_loop temp_sum_subgrid ( i_pollutant ) = 0. count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) + subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) count = count + 1 endif enddo enddo if ( count . gt . 0 ) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) / count else temp_sum_subgrid ( i_pollutant ) = 0 endif write ( unit_logfile , '(a,3f12.3)' ) 'Mean concentration ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , temp_sum_subgrid ( i_pollutant ) enddo enddo !End time loop if ( allocated ( trajectory_vector )) deallocate ( trajectory_vector ) if ( allocated ( target_subgrid )) deallocate ( target_subgrid ) if ( allocated ( target_deposition_subgrid )) deallocate ( target_deposition_subgrid ) if ( allocated ( temp_FF_subgrid )) deallocate ( temp_FF_subgrid ) if ( allocated ( temp_FF_integral_subgrid )) deallocate ( temp_FF_integral_subgrid ) if ( allocated ( traveltime_target_subgrid )) deallocate ( traveltime_target_subgrid ) if ( allocated ( target_vertical_integral_subgrid )) deallocate ( target_vertical_integral_subgrid ) end subroutine uEMEP_subgrid_deposition","tags":"","loc":"proc/uemep_subgrid_deposition.html"},{"title":"uEMEP_create_wind_field – uEMEP","text":"private  subroutine uEMEP_create_wind_field(temp_FF_subgrid, angle_diff, wind_level_flag_in, source_index_in, subsource_index_in, tt_in) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name real, intent(out) :: temp_FF_subgrid (integral_subgrid_dim(x_dim_index),integral_subgrid_dim(y_dim_index)) real, intent(in) :: angle_diff (integral_subgrid_dim(x_dim_index),integral_subgrid_dim(y_dim_index)) integer, intent(in) :: wind_level_flag_in integer, intent(in) :: source_index_in integer, intent(in) :: subsource_index_in integer, intent(in) :: tt_in Source Code subroutine uEMEP_create_wind_field ( temp_FF_subgrid , angle_diff , wind_level_flag_in , source_index_in , subsource_index_in , tt_in ) use uEMEP_definitions implicit none integer , intent ( in ) :: wind_level_flag_in , tt_in , source_index_in , subsource_index_in integer j_cross , i_cross integer i_cross_integral , j_cross_integral integer ii , jj real z0_temp , h_temp real sig_y_00_loc , h_emis_loc , h_mix_loc , FF10_loc , x_loc , sig_z_loc , sig_y_loc , ff_loc , logz0_loc real sig_z_00_loc , sig_y_0_loc , sig_z_0_loc , zc_loc , u_star0_loc !define the temporary arrays for meteo real , intent ( out ) :: temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index )) real , intent ( in ) :: angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index )) temp_FF_subgrid = 0. if ( wind_level_flag_in . ne . 5 ) then do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) z0_temp = exp ( meteo_subgrid ( i_cross , j_cross , tt_in , logz0_subgrid_index )) h_temp = h_emis ( source_index_in , subsource_index_in ) if ( annual_calculations . and . wind_level_flag_in . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FFgrid_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag_in . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( annual_calculations . and . wind_level_flag_in . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FF10_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag_in . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FFgrid_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FF10_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( wind_level_flag_in . eq . 0 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag_in . eq . 5 ) then !Will set based on sigma z centre of mass temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag_in . eq . 6 ) then !Will set based on sigma z centre of mass and emission height temp_FF_subgrid ( i_cross , j_cross ) = 1. else write ( unit_logfile , '(a)' ) 'No valid wind_level_flag_in selected. Stopping (uEMEP_subgrid_dispersion)' stop endif !Setting a minimum value for wind for dispersion purposes (cannot be zero) temp_FF_subgrid ( i_cross , j_cross ) = sqrt ( temp_FF_subgrid ( i_cross , j_cross ) * temp_FF_subgrid ( i_cross , j_cross ) + FF_min_dispersion * FF_min_dispersion ) if ( temp_FF_subgrid ( i_cross , j_cross ). eq . 0 ) then write ( unit_logfile , '(a,2i)' ) 'Zero wind speed at integral grid (stopping): ' , i_cross , j_cross stop endif enddo enddo endif !If wind level flag is set to 5, use of initial plume centre of mass, then set wind speed for each non-zero emission grid if ( wind_level_flag_in . eq . 5 ) then temp_FF_subgrid = 0. do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index_in ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index_in ) if ( sum ( emission_subgrid ( ii , jj , tt_in , source_index_in ,:)). ne . 0 ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index_in ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index_in ) !Set the local variables logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , logz0_subgrid_index ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index_in ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index_in ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index_in ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , hmix_subgrid_index ) if ( annual_calculations ) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , inv_FF10_subgrid_index ) endif !Set sig_0's at the emission position x_loc = 0. call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index_in ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Use the initial plume centre of mass to determine wind advection height call z_centremass_gauss_func ( sig_z_0_loc , h_emis_loc , h_mix_loc , zc_loc ) call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) !Set the minimum wind speed FF_loc = sqrt ( FF_loc * FF_loc + FF_min_dispersion * FF_min_dispersion ) temp_FF_subgrid ( ii , jj ) = FF_loc !write(*,*) FF10_loc,FF_loc,zc_loc,sig_z_0_loc endif enddo enddo endif end subroutine uEMEP_create_wind_field","tags":"","loc":"proc/uemep_create_wind_field.html"},{"title":"uEMEP_set_dispersion_sigma_Kz – uEMEP","text":"public  subroutine uEMEP_set_dispersion_sigma_Kz(Kz_scheme_in, x_in, sig_z00, sig_y00, sigy_0_subgid_width_scale, sig_z_in, z_emis_loc, h_mix_loc, invL, u_val, z_val, logz0, subgrid_delta, u_star0_in, average_zc_h_in_Kz_flag, n_kz_iterations, sig_y_scaling_factor, sig_z, sig_y, u_zc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Kz_scheme_in real, intent(in) :: x_in real, intent(in) :: sig_z00 real, intent(in) :: sig_y00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: sig_z_in real, intent(in) :: z_emis_loc real, intent(in) :: h_mix_loc real, intent(in) :: invL real, intent(in) :: u_val real, intent(in) :: z_val real, intent(in) :: logz0 real, intent(in) :: subgrid_delta (2) real, intent(in) :: u_star0_in logical, intent(in) :: average_zc_h_in_Kz_flag integer, intent(in) :: n_kz_iterations real, intent(in) :: sig_y_scaling_factor real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: u_zc Source Code subroutine uEMEP_set_dispersion_sigma_Kz ( Kz_scheme_in , x_in , sig_z00 , sig_y00 , sigy_0_subgid_width_scale , sig_z_in , z_emis_loc , h_mix_loc , invL , u_val , z_val , logz0 , subgrid_delta , u_star0_in , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z , sig_y , u_zc ) implicit none real , intent ( in ) :: x_in , sig_z00 , sig_y00 , sigy_0_subgid_width_scale , sig_z_in , z_emis_loc , h_mix_loc , invL , u_val , z_val , logz0 , subgrid_delta ( 2 ), u_star0_in , sig_y_scaling_factor integer , intent ( in ) :: Kz_scheme_in , n_kz_iterations logical , intent ( in ) :: average_zc_h_in_Kz_flag real , intent ( out ) :: sig_z , sig_y , u_zc integer n_loop , j real K_z , L real :: z_tau_min = 2. , z_tau_max = 10 0. real z0 , zc real :: K_min = 0.001 real l_t , f_t real u_star0 , u_star0_val , tau real min_xy , x real phih_temp n_loop = n_kz_iterations !Limit stable L to this positive L value !L=1.e6 !L=lowest_stable_L !if (abs(invL).gt.1./L) L=1./invL L = 1. / invL !Why does it not explode? when invL=0? if ( abs ( invL ) < epsilon0 ) L = 1.0e6 z0 = exp ( logz0 ) min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. !min_x=1. !x=max(x_in,min_xy) !Set x to this value because it simulates that it has already travelled half a grid to get this sig_z0 !Which is why sg_z is added only to sig_z00 x = x_in + min_xy !Initialise sig_z sig_z = sig_z_in !If the emission is above the boundary layer height then set the initial plume guess to its low turbulence form !Same values used in the emulator (1/1000 slender plume) if ( z_emis_loc / h_mix_loc . ge . 1.0 ) sig_z = sig_z00 + 0.001 * exp ( 1.0 * log ( x )) !Set ustar0 for K_z to the value from EMEP u_star0 = u_star0_in zc = z_emis_loc !Set zc and K_z at start of plume based on sig_z0 !call z_centremass_gauss_func(sig_z0,z_emis_loc,h_mix_loc,zc_start) !call Kz_func(h_mix_loc,L,u_star0,zc_start,K_min,K_z_start) !call u_profile_val_func(zc_start,L,u_val,z_val,h_mix_loc,z0,u_zc_start,u_star0,u_hmix) !Put bug back in u_zc = u_val !Calculate the Lagrangian time scale before the iteration loop using a minimum distance for this to make it non zero on the grid !l_t=max(x,min_xy)/u_zc tau = 0.6 * max ( min ( z_tau_max , z_emis_loc ), z_tau_min ) / u_star0 !f_t=1.+tau/l_t*(exp(-l_t/tau)-1.) !if (x.lt.200) then !write(*,'(a,i,5f)') 'S: ',j,tau,l_t,f_t,u_zc,sig_z !write(*,'(a,5f)') 'S: ',tau,u_star0,z_tau_max,z_emis_loc,z_tau_min !endif !All functions commented out 4 secs !All functions included 15 secs !Without u_profile 11 secs !Commenting out all functions below gives 7 secs do j = 1 , n_loop !Calculate centre of mass for the emission height. call z_centremass_gauss_func ( sig_z , z_emis_loc , h_mix_loc , zc ) !4.5 sec if ( average_zc_h_in_Kz_flag ) zc = ( z_emis_loc + zc ) / 2. !write(*,'(i,4f)') j,sig_z,z_emis_loc,h_mix_loc,zc !Calculate the wind profile !call u_profile_val_func(zc,L,u_val,z_val,h_mix_loc,z0,u_zc,u_star0_val,u_hmix) !7secs. Without phim_func calls 5 secs call u_profile_neutral_val_func ( zc , u_val , z_val , h_mix_loc , z0 , u_zc , u_star0_val ) !write(*,'(i,9f)') j,zc,L,u_val,z_val,h_mix_loc,z0,u_zc,u_star0,u_hmix !u_zc=(u_zc+u_zc_start)/2. !write(*,'(i,8f)') j,x,u_star0_in,u_star0,zc,z_val,u_zc,u_zc_start,u_val !Use the calculated u_star for the dispersion, not the EMEP input !u_star0=u_star0_val !Calculate K_z at the centre of mass if ( Kz_scheme_in . eq . 2 ) then call TROENKz ( zc , h_mix_loc , u_star0 , invL , K_min , K_z , phih_temp ) else call Kz_func ( h_mix_loc , L , u_star0 , zc , K_min , K_z ) !5.5 secs endIf !write(*,'(i,1f)') j,K_z !Take average of K_z_start(x=0) and K_z(x) !K_z=(K_z+K_z_start)/2. !calculate l_t based on the centre of mass wind speed l_t = max ( x , min_xy ) / u_zc f_t = 1. + tau / l_t * ( exp ( - l_t / tau ) - 1. ) !Calculate sig_z for the next iteration, using the sig_z0 from the neutral plume approximation sig_z = sig_z00 + sqrt ( 2. * K_z * l_t * f_t ) !write(*,'(i,1f)') j,sig_z !write(*,*) K_z,l_t,f_t,sig_z,u_zc !write(*,*) j,z_emis_loc,zc,h_mix_loc*0.25,sig_z !if (x.lt.200) then !write(*,'(a,i,5f)') 'S: ',j,tau,l_t,f_t,u_zc,sig_z !endif enddo !Calculate sigma_y at the maximum K, around the average of the emission height and 0.25 of the boundary layer height !THis is new 27.10.2018 and not tested. It will reduce sig_y which is OK !h_y=(h_mix_loc*0.25+z_emis_loc)/2. !call Kz_func(h_mix_loc,L,u_star0,h_y,K_min,K_y) !sig_y=sig_y00+min_xy*sigy_0_subgid_width_scale+sqrt(2.*K_y*l_t*f_t) !Should change this to what is documented, i.e. 2*sig_z. Need to test sig_y = sig_y00 + min_xy * sigy_0_subgid_width_scale + ( sig_z - sig_z00 ) * sig_y_scaling_factor end subroutine uEMEP_set_dispersion_sigma_Kz","tags":"","loc":"proc/uemep_set_dispersion_sigma_kz.html"},{"title":"Kz_func – uEMEP","text":"private  subroutine Kz_func(z_pbl, L, u_star0_in, z, K_min, K_z) Arguments Type Intent Optional Attributes Name real, intent(in) :: z_pbl real, intent(in) :: L real, intent(in) :: u_star0_in real, intent(in) :: z real, intent(in) :: K_min real, intent(out) :: K_z Source Code subroutine Kz_func ( z_pbl , L , u_star0_in , z , K_min , K_z ) implicit none real , intent ( in ) :: z_pbl , L , u_star0_in , z , K_min real , intent ( out ) :: K_z real kappa parameter ( kappa = 0.4 ) real phih , phih_i real phih_hs , phih_i_hs real phih_hs_p1 , phih_i_hs_p1 real K_zpbl , K_zhs , h_s , delta_K_zhs , u_star0 h_s = 0.04 * z_pbl !ustar0 cannot be 0. Set to a low value !u_star0=max(u_star0_in,0.01) u_star0 = u_star0_in call phih_func ( z , L , phih , phih_i ) K_zpbl = K_min K_z = K_min if ( L . ge . 0 ) then !K_z=0.39*u_star0*z*exp(-0.5*(z/0.21/z_pbl)*(z/0.21/z_pbl))  !As in EMEP !K_z=0.39*u_star0*z*exp(-0.5*(z/0.32/z_pbl)*(z/0.32/z_pbl)) !Adjusted to match under neutral conditions K_z = 0.39 * u_star0 * z / phih * exp ( - 0.5 * ( z / 0.32 / z_pbl ) * ( z / 0.32 / z_pbl )) !Adjusted but with stability added else call phih_func ( h_s , L , phih_hs , phih_i_hs ) call phih_func ( h_s + 1. , L , phih_hs_p1 , phih_i_hs_p1 ) K_zhs = u_star0 * kappa * h_s / phih_hs delta_K_zhs = u_star0 * kappa * (( h_s + 1. ) / phih_hs_p1 - ( h_s ) / phih_hs ) if ( z . le . h_s ) K_z = u_star0 * kappa * z / phih if ( z . gt . h_s . and . z . le . z_pbl ) K_z = K_zpbl + (( z_pbl - z ) / ( z_pbl - h_s )) * (( z_pbl - z ) / ( z_pbl - h_s )) * ( K_zhs - K_zpbl + ( z - h_s ) * ( delta_K_zhs + 2. * ( K_zhs - K_zpbl ) / ( z_pbl - h_s ))) endif K_z = max ( K_z , K_min ) end subroutine Kz_func","tags":"","loc":"proc/kz_func.html"},{"title":"TROENKz – uEMEP","text":"private  subroutine TROENKz(z, h, ustar, invL, Kdef, Kz, phih) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: h real, intent(in) :: ustar real, intent(in) :: invL real, intent(in) :: Kdef real, intent(out) :: Kz real, intent(out) :: phih Source Code subroutine TROENKz ( z , h , ustar , invL , Kdef , Kz , phih ) !Vertical dispersion routine as described in: !Troen, I., & Mahrt, L. (1986). A Simple Model of the Atmospheric Boundary !Layer: !Sensitivity to Surface Evaporation. Boundary-Layer Meteorology, 37, 129-148. !https://doi.org/10.1007/BF00122760 implicit none real , intent ( in ) :: z ! height real , intent ( in ) :: h ! Boundary layer depth real , intent ( in ) :: ustar , invL , Kdef !  u*, 1/L, default Kz real , intent ( out ) :: Kz , phih real :: ws real :: kappa = 0.4 real :: zsurf !Height of the surface layer. Stability function for unstable calculated !here for z>zsurf zsurf = 0.1 * h if ( z < h ) then if ( invL < 0 ) then !phih=(1-7.*min(z,zsurf)*invL)**(-1./3.) !Original in !Troen and Mahrt for phim, so no Prandtl number !phih=(1-16.*min(z,zsurf)*invL)**(-1./2.) !As in Garratt and Obrien for phih, so with Prandtl number phih = ( 1 - 1 6. * z * invL ) ** ( - 1. / 2. ) !As in Garratt and Obrien for phih, so with Prandtl number else phih = 1 + 5. * z * invL !As in Garratt, Prandtl number is 1 in stable boundary layer endif ws = ustar / phih Kz = kappa * ws * z * ( 1. - z / h ) ** 2 else Kz = Kdef endif end subroutine TROENKz","tags":"","loc":"proc/troenkz.html"},{"title":"TROENKz_invL_from_phi – uEMEP","text":"public  subroutine TROENKz_invL_from_phi(z, phih, invL) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: phih real, intent(out) :: invL Source Code subroutine TROENKz_invL_from_phi ( z , phih , invL ) implicit none real , intent ( in ) :: z ! height real , intent ( in ) :: phih real , intent ( out ) :: invL !1/L if ( phih < 1 ) then !phih=(1-16.*min(z,zsurf)*invL)**(-1./2.) !As in Garratt and Obrien for phih, so with Prandtl number invL = ( phih **- 2. - 1 ) / ( - 1 6. * z ) else !phih=1+5.*z*invL !As in Garratt, Prandtl number is 1 in stable boundary layer invL = ( phih - 1 ) / 5. / z endif end subroutine TROENKz_invL_from_phi","tags":"","loc":"proc/troenkz_invl_from_phi.html"},{"title":"z_centremass_gauss_func – uEMEP","text":"public  subroutine z_centremass_gauss_func(sigma, h, z_pbl, z_c) Arguments Type Intent Optional Attributes Name real, intent(in) :: sigma real, intent(in) :: h real, intent(in) :: z_pbl real, intent(out) :: z_c Source Code subroutine z_centremass_gauss_func ( sigma , h , z_pbl , z_c ) implicit none real , intent ( in ) :: sigma , h , z_pbl real , intent ( out ) :: z_c real z_loop ( 5 ) real H_c integer i_loop , i real sqrt_2pi , sqrt_2 real pi parameter ( pi = 3.141592653589793 ) sqrt_2pi = sqrt ( 2. * pi ) sqrt_2 = sqrt ( 2. ) i_loop = 5 z_loop ( 1 ) = h ; z_loop ( 2 ) =- h ; z_loop ( 3 ) = 2. * z_pbl - h ; z_loop ( 4 ) = 2. * z_pbl + h ; z_loop ( 5 ) =- 2. * z_pbl + h z_c = 0. !c_z=0.;c_av=0. H_c = z_pbl !If the emission height h is greater than the boundary layer height then only allow reflection from the surface !and set the top of the integration H_c to infinity if ( h . gt . z_pbl ) then H_c = 1.e16 i_loop = 2 endif !Reduce the loop size when the reflection from the boundary layer is not important if ( sigma + h . lt . z_pbl / 3. ) then i_loop = 2 endif !Remove this after finished testing !i_loop=5 do i = 1 , i_loop z_c = z_c + sigma / sqrt_2pi * ( exp ( - 0.5 * ( z_loop ( i ) / sigma ) * ( z_loop ( i ) / sigma )) - exp ( - 0.5 * (( H_c - z_loop ( i )) / sigma ) * (( H_c - z_loop ( i )) / sigma ))) & + z_loop ( i ) / 2 * ( erf (( H_c - z_loop ( i )) / sqrt_2 / sigma ) + erf (( z_loop ( i )) / sqrt_2 / sigma )) !c_av=c_av+0.5*(erf((z_pbl-z_loop(i))/sqrt_2/sigma)+erf((z_loop(i))/sqrt_2/sigma))/z_pbl !c_z=c_z+1./sigma/sqrt_2pi*exp(-0.5*((z-z_loop(i))/sigma)*((z-z_loop(i))/sigma)) enddo !if (sigma.gt.0.9*z_pbl) then !c_z=1./z_pbl !c_av=1./z_pbl !endif end subroutine z_centremass_gauss_func","tags":"","loc":"proc/z_centremass_gauss_func.html"},{"title":"u_profile_val_func – uEMEP","text":"private  subroutine u_profile_val_func(z, L, u_val, z_val_in, z_pbl, z0, u, u_star0, u_pbl) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(in) :: u_val real, intent(in) :: z_val_in real, intent(in) :: z_pbl real, intent(in) :: z0 real, intent(out) :: u real, intent(out) :: u_star0 real, intent(out) :: u_pbl Source Code subroutine u_profile_val_func ( z , L , u_val , z_val_in , z_pbl , z0 , u , u_star0 , u_pbl ) implicit none real , intent ( in ) :: z , L , u_val , z_val_in , z_pbl , z0 real , intent ( out ) :: u , u_star0 , u_pbl real a , b , p , kappa parameter ( a = 1 6. , b = 5. , p =- 0.25 , kappa = 0.4 ) real z_l , z_val real phim , phim_i real phim_val , phim_i_val !real phim_pbl,phih_pbl,phim_i_pbl,phih_i_pbl !If the input height is above the boundary layer then set the height to pbl height and calculate z_val = z_val_in if ( z_val . ge . z_pbl ) z_val = z_pbl z_l = 0.4 * z_pbl call phim_func ( z , L , phim , phim_i ) call phim_func ( z_val , L , phim_val , phim_i_val ) !call phi_func(z_pbl,L,phim_pbl,phih_pbl,phim_i_pbl,phih_i_pbl) if ( L . ge . 0. ) then u_star0 = u_val * kappa / ( log ( z_val / z0 ) - phim_i_val + kappa * z_val / z_l * ( 1 - z_val / 2. / z_pbl ) - z_val / z_pbl * ( 1 + b * z_val / 2. / L )) !u_pbl=u_star0/kappa*(log(z_pbl/z0)-phim_i_pbl+kappa*z_pbl/z_l*(1-z_pbl/2./z_pbl)-z_pbl/z_pbl*(1+b*z_pbl/2./L)) u = u_star0 / kappa * ( log ( z / z0 ) - phim_i + kappa * z / z_l * ( 1 - z / 2. / z_pbl ) - z / z_pbl * ( 1 + b * z / 2. / L )) else u_star0 = u_val * kappa / ( log ( z_val / z0 ) - phim_i_val + kappa * z_val / z_l * ( 1 - z_val / 2. / z_pbl ) - 1. / z_pbl * (( a * z_val - L ) * phim_val + L ) / a / ( p + 1 )) !u_pbl=u_star0/kappa*(log(z_pbl/z0)-phim_i_pbl+kappa*z_pbl/z_l*(1-z_pbl/2./z_pbl)-1./z_pbl*((a*z_pbl-L)*phim_pbl+L)/a/(p+1)) u = u_star0 / kappa * ( log ( z / z0 ) - phim_i + kappa * z / z_l * ( 1 - z / 2. / z_pbl ) - 1. / z_pbl * (( a * z - L ) * phim + L ) / a / ( p + 1 )) endif !u_pbl not used and so not calculated here u_pbl = u if ( z . ge . z_pbl ) then u = u_pbl endif end subroutine u_profile_val_func","tags":"","loc":"proc/u_profile_val_func.html"},{"title":"u_profile_neutral_val_func – uEMEP","text":"public  subroutine u_profile_neutral_val_func(z, u_val, z_val_in, z_pbl, z0, u, u_star0) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: u_val real, intent(in) :: z_val_in real, intent(in) :: z_pbl real, intent(in) :: z0 real, intent(out) :: u real, intent(out) :: u_star0 Source Code subroutine u_profile_neutral_val_func ( z , u_val , z_val_in , z_pbl , z0 , u , u_star0 ) implicit none real , intent ( in ) :: z , u_val , z_val_in , z_pbl , z0 real , intent ( out ) :: u , u_star0 real kappa parameter ( kappa = 0.4 ) real z_l , z_val !If the input height is above the boundary layer then set the height to pbl height and calculate z_val = min ( z_val_in , z_pbl ) z_l = 0.4 * z_pbl u_star0 = u_val * kappa / ( log ( z_val / z0 ) + kappa * z_val / z_l * ( 1 - z_val / 2. / z_pbl ) - z_val / z_pbl ) u = u_star0 / kappa * ( log ( z / z0 ) + kappa * z / z_l * ( 1 - z / 2. / z_pbl ) - z / z_pbl ) end subroutine u_profile_neutral_val_func","tags":"","loc":"proc/u_profile_neutral_val_func.html"},{"title":"phi_func – uEMEP","text":"private  subroutine phi_func(z, L, phim, phih, phim_i, phih_i) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(out) :: phim real, intent(out) :: phih real, intent(out) :: phim_i real, intent(out) :: phih_i Source Code subroutine phi_func ( z , L , phim , phih , phim_i , phih_i ) implicit none real , intent ( in ) :: z , L real , intent ( out ) :: phim , phih , phim_i , phih_i real a , b , p , q , pi parameter ( a = 1 6. , b = 5. , p =- 0.25 , q =- 0.5 , pi = 3.141592653589793 ) real eps eps = z / L if ( eps . ge . 0 ) then phim = 1. + b * eps phim_i =- b * eps phih = phim phih_i = phim_i else phim = exp ( p * log (( 1. - a * eps ))) phih = exp ( q * log (( 1. - a * eps ))) phim_i = 2. * log (( 1. + 1. / phim ) / 2. ) + log (( 1. + 1. / ( phim * phim )) / 2. ) - 2. * atan ( 1. / phim ) + pi / 2. phih_i = 2. * log (( 1. + 1. / phih ) / 2. ) endif end subroutine phi_func","tags":"","loc":"proc/phi_func.html"},{"title":"phim_func – uEMEP","text":"private  subroutine phim_func(z, L, phim, phim_i) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(out) :: phim real, intent(out) :: phim_i Source Code subroutine phim_func ( z , L , phim , phim_i ) implicit none real , intent ( in ) :: z , L real , intent ( out ) :: phim , phim_i real a , b , p , pi parameter ( a = 1 6. , b = 5. , p =- 0.25 , pi = 3.141592653589793 ) real eps eps = z / L if ( eps . ge . 0 ) then phim = 1. + b * eps phim_i =- b * eps else phim = exp ( p * log (( 1. - a * eps ))) phim_i = 2. * log (( 1. + 1. / phim ) / 2. ) + log (( 1. + 1. / ( phim * phim )) / 2. ) - 2. * atan ( 1. / phim ) + pi / 2. endif end subroutine phim_func","tags":"","loc":"proc/phim_func.html"},{"title":"phih_func – uEMEP","text":"private  subroutine phih_func(z, L, phih, phih_i) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(out) :: phih real, intent(out) :: phih_i Source Code subroutine phih_func ( z , L , phih , phih_i ) implicit none real , intent ( in ) :: z , L real , intent ( out ) :: phih , phih_i real a , b , q parameter ( a = 1 6. , b = 5. , q =- 0.5 ) real eps eps = z / L if ( eps . ge . 0 ) then phih = 1. + b * eps phih_i =- b * eps else phih = exp ( q * log (( 1. - a * eps ))) phih_i = 2. * log (( 1. + 1. / phih ) / 2. ) endif end subroutine phih_func","tags":"","loc":"proc/phih_func.html"},{"title":"z_centremass_gauss_array_func – uEMEP","text":"private  subroutine z_centremass_gauss_array_func(sig_norm, h_norm, n_array, zc_array) Arguments Type Intent Optional Attributes Name real, intent(in) :: sig_norm real, intent(in) :: h_norm real, intent(in) :: n_array real, intent(out) :: zc_array (int(n_array)) Source Code subroutine z_centremass_gauss_array_func ( sig_norm , h_norm , n_array , zc_array ) implicit none real , intent ( in ) :: sig_norm , h_norm , n_array real , intent ( out ) :: zc_array ( int ( n_array )) real z_loop ( 5 ) real H_c real z_c integer i_loop , i , k real sqrt_2pi , sqrt_2 real pi parameter ( pi = 3.141592653589793 ) sqrt_2pi = sqrt ( 2. * pi ) sqrt_2 = sqrt ( 2. ) i_loop = 5 z_loop ( 1 ) = h_norm ; z_loop ( 2 ) =- h_norm ; z_loop ( 3 ) = 2. - h_norm ; z_loop ( 4 ) = 2. + h_norm ; z_loop ( 5 ) =- 2. + h_norm H_c = 1. !If the emission height h is greater than the boundary layer height then only allow reflection from the surface !and set the top of the integration H_c to infinity if ( h_norm . gt . 1. ) then H_c = 1.e4 i_loop = 2 endif !Reduce the loop size when the reflection from the boundary layer is not important !if (sig_norm+h_norm.lt.1./3.) then !    i_loop=2 !endif !Remove this after finished testing i_loop = 5 do k = 1 , int ( n_array ) z_c = 0. do i = 1 , i_loop z_c = z_c + sig_norm / sqrt_2pi * ( exp ( - 0.5 * ( z_loop ( i ) / sig_norm ) * ( z_loop ( i ) / sig_norm )) - exp ( - 0.5 * (( H_c - z_loop ( i )) / sig_norm ) * (( H_c - z_loop ( i )) / sig_norm ))) & + z_loop ( i ) / 2. * ( erf (( H_c - z_loop ( i )) / sqrt_2 / sig_norm ) + erf (( z_loop ( i )) / sqrt_2 / sig_norm )) enddo zc_array ( k ) = z_c enddo end subroutine z_centremass_gauss_array_func","tags":"","loc":"proc/z_centremass_gauss_array_func.html"},{"title":"gauss_plume_second_order_rotated_reflected_func – uEMEP","text":"public  function gauss_plume_second_order_rotated_reflected_func(r, z, ay, by, az, bz, sig_y_0, sig_z_0, z_s, z_pbl) Arguments Type Intent Optional Attributes Name real :: r real :: z real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: z_s real :: z_pbl Return Value real Source Code function gauss_plume_second_order_rotated_reflected_func ( r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl ) implicit none real r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl real gauss_plume_second_order_rotated_reflected_func real sig_th , sig_z , B , c real order_1 , order_2 real z_loop ( 6 ) integer n_loop , k real :: correction = 2. real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 r = max ( 1. , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) !write(*,*) sig_z,sig_th*r,sig_z_0,sig_y_0 B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) !write(*,*) B if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif if ( sig_z . gt . 0.9 * z_pbl ) then if ( B . gt . - 1. ) then !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) c = 1. / ( z_pbl * 2. * pi * r * sqrt ( 1. + B )) * erf ( correction * pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B )) else c = correction / ( 2. * sqrt ( 2 * pi ) * sig_th * r ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) endif else c = 0. do k = 1 , n_loop if ( B . gt . - 1. ) then !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) c = c + 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( correction * pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B )) * ( exp (( - ( z - z_loop ( k )) ** 2 ) / 2. / sig_z ** 2 )) else c = c + correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) * ( exp (( - ( z - z_loop ( k )) ** 2 ) / 2. / sig_z ** 2 )) !Perhaps also a correction in the higher orders but must calculate that again endif !if (r.eq.1.) write(*,*) k,r,c,1./(4.*pi*sig_y_0*sig_z_0) enddo endif !write(*,*) c,z_pbl !Original ! if (B.gt.-1.) then !    !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) !    c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*erf(pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) !else !    c=1./(4.*pi*sig_th*r*sig_z)*(1-order_1*pi**2*(1.+B)/(24*sig_th**2)+order_2*pi**4*((1.+B**2)/(640.*sig_th**4)))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) !endif gauss_plume_second_order_rotated_reflected_func = c end function gauss_plume_second_order_rotated_reflected_func","tags":"","loc":"proc/gauss_plume_second_order_rotated_reflected_func.html"},{"title":"gauss_plume_second_order_rotated_func – uEMEP","text":"private  function gauss_plume_second_order_rotated_func(r, z, ay, by, az, bz, sig_y_0, sig_z_0, h) Arguments Type Intent Optional Attributes Name real :: r real :: z real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: h Return Value real Source Code function gauss_plume_second_order_rotated_func ( r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , h ) implicit none real r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , h real gauss_plume_second_order_rotated_func real sig_th , sig_z , B , c real order_1 , order_2 real :: correction = 2. real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 r = max ( 0.001 , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) !write(*,*) sig_z,sig_th*r,sig_z_0,sig_y_0 B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) !write(*,*) B if ( B . gt . - 1. ) then !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) c = 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B ) * correction ) * ( exp (( - ( z - h ) ** 2 ) / 2. / sig_z ** 2 ) + exp (( - ( z + h ) ** 2 ) / 2. / sig_z ** 2 )) else c = correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) * ( exp (( - ( z - h ) ** 2 ) / 2. / sig_z ** 2 ) + exp (( - ( z + h ) ** 2 ) / 2. / sig_z ** 2 )) endif gauss_plume_second_order_rotated_func = c end function gauss_plume_second_order_rotated_func","tags":"","loc":"proc/gauss_plume_second_order_rotated_func.html"},{"title":"gauss_plume_second_order_rotated_integral_func – uEMEP","text":"public  function gauss_plume_second_order_rotated_integral_func(r, ay, by, az, bz, sig_y_0, sig_z_0, h, H1, H2) Arguments Type Intent Optional Attributes Name real :: r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: h real :: H1 real :: H2 Return Value real Source Code function gauss_plume_second_order_rotated_integral_func ( r , ay , by , az , bz , sig_y_0 , sig_z_0 , h , H1 , H2 ) implicit none real r , ay , by , az , bz , sig_y_0 , sig_z_0 , h , H1 , H2 real gauss_plume_second_order_rotated_integral_func real sig_th , sig_z , B , c_y_int , c_z_int real order_1 , order_2 real :: correction = 2. real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 !Still need to implement reflections r = max ( 0.001 , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) c_z_int = sqrt ( pi / 2. ) * sig_z * ( erf (( H2 - h ) / sqrt ( 2. ) / sig_z ) - erf (( H1 - h ) / sqrt ( 2. ) / sig_z ) + erf (( H2 + h ) / sqrt ( 2. ) / sig_z ) - erf (( H1 + h ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) if ( B . gt . - 1. ) then !c_int=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B)) c_y_int = 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B ) * correction ) else c_y_int = correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) endif gauss_plume_second_order_rotated_integral_func = c_y_int * c_z_int end function gauss_plume_second_order_rotated_integral_func","tags":"","loc":"proc/gauss_plume_second_order_rotated_integral_func.html"},{"title":"gauss_plume_second_order_rotated_reflected_integral_func – uEMEP","text":"public  function gauss_plume_second_order_rotated_reflected_integral_func(r, ay, by, az, bz, sig_y_0, sig_z_0, z_s, z_pbl, H1, H2) Arguments Type Intent Optional Attributes Name real :: r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: z_s real :: z_pbl real :: H1 real :: H2 Return Value real Source Code function gauss_plume_second_order_rotated_reflected_integral_func ( r , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl , H1 , H2 ) implicit none real r , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl , H1 , H2 real gauss_plume_second_order_rotated_reflected_integral_func real sig_th , sig_z , B , c_y_int , c_z_int real order_1 , order_2 real :: correction = 2. integer k , n_loop real z_loop ( 6 ) real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 !Still need to implement reflections r = max ( 0.001 , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif if ( sig_z . gt . 0.9 * z_pbl ) then c_z_int = 1. / z_pbl else c_z_int = 0. do k = 1 , n_loop c_z_int = c_z_int + sqrt ( pi / 2. ) * sig_z * ( erf (( H2 - z_loop ( k )) / sqrt ( 2. ) / sig_z ) - erf (( H1 - z_loop ( k )) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) enddo endif if ( B . gt . - 1. ) then c_y_int = 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B ) * correction ) else c_y_int = correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) endif !write(*,*) c_y_int,c_z_int gauss_plume_second_order_rotated_reflected_integral_func = c_y_int * c_z_int end function gauss_plume_second_order_rotated_reflected_integral_func","tags":"","loc":"proc/gauss_plume_second_order_rotated_reflected_integral_func.html"},{"title":"gauss_plume_cartesian_func – uEMEP","text":"private  function gauss_plume_cartesian_func(x_s, y_s, z_s, cos_val, sin_val, x_r, y_r, z_r, ay, by, az, bz, sig_y_0, sig_z_0, delta) Arguments Type Intent Optional Attributes Name real :: x_s real :: y_s real :: z_s real :: cos_val real :: sin_val real :: x_r real :: y_r real :: z_r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: delta Return Value real Source Code function gauss_plume_cartesian_func ( x_s , y_s , z_s , cos_val , sin_val , x_r , y_r , z_r , ay , by , az , bz , sig_y_0 , sig_z_0 , delta ) implicit none real x_s , y_s , z_s , x_r , y_r , z_r real ay , by , az , bz , sig_y_0 , sig_z_0 , delta real gauss_plume_cartesian_func real sig_y , sig_z , x , y real cos_val , sin_val real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) x = ( x_r - x_s ) * cos_val + ( y_r - y_s ) * sin_val y =- ( x_r - x_s ) * sin_val + ( y_r - y_s ) * cos_val gauss_plume_cartesian_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) !write(*,*)sig_y_0,sig_y,sig_z_0,sig_z !gauss_plume_cartesian_func=1./(2.*pi*sig_y*sig_z)*exp((-y**2)/2./sig_y**2) & !    *(exp((-(z_r-z_s)**2)/2./sig_z**2)+exp((-(z_r+z_s)**2)/2./sig_z**2)) gauss_plume_cartesian_func = 1. / ( 2. * pi * sig_y * sig_z ) * exp ( - y * y / 2. / sig_y / sig_y ) & * ( exp ( - ( z_r - z_s ) * ( z_r - z_s ) / 2. / sig_z / sig_z ) + exp ( - ( z_r + z_s ) * ( z_r + z_s ) / 2. / sig_z / sig_z )) endif end function gauss_plume_cartesian_func","tags":"","loc":"proc/gauss_plume_cartesian_func.html"},{"title":"gauss_plume_cartesian_integral_func – uEMEP","text":"private  function gauss_plume_cartesian_integral_func(x_s, y_s, z_s, cos_val, sin_val, x_r, y_r, ay, by, az, bz, sig_y_0, sig_z_0, H1, H2, delta) Arguments Type Intent Optional Attributes Name real :: x_s real :: y_s real :: z_s real :: cos_val real :: sin_val real :: x_r real :: y_r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: H1 real :: H2 real :: delta Return Value real Source Code function gauss_plume_cartesian_integral_func ( x_s , y_s , z_s , cos_val , sin_val , x_r , y_r , ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta ) implicit none real x_s , y_s , z_s , x_r , y_r real ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta real gauss_plume_cartesian_integral_func real sig_y , sig_z , x , y real cos_val , sin_val real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) x = ( x_r - x_s ) * cos_val + ( y_r - y_s ) * sin_val y =- ( x_r - x_s ) * sin_val + ( y_r - y_s ) * cos_val gauss_plume_cartesian_integral_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) !gauss_plume_cartesian_integral_func=1./(2.*pi*sig_y)*exp((-y**2)/2./sig_y**2) & !    *sqrt(pi/2.)*(erf((z_s-H1)/sqrt(2.)/sig_z)-erf((z_s-H2)/sqrt(2.)/sig_z)+erf((z_s+H2)/sqrt(2.)/sig_z)-erf((z_s+H1)/sqrt(2.)/sig_z))/(H2-H1) gauss_plume_cartesian_integral_func = 1. / ( 2. * pi * sig_y ) * exp (( - y * y ) / 2. / ( sig_y * sig_y )) & * sqrt ( pi / 2. ) * ( erf (( z_s - H1 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s - H2 ) / sqrt ( 2. ) / sig_z ) + erf (( z_s + H2 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s + H1 ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) endif end function gauss_plume_cartesian_integral_func","tags":"","loc":"proc/gauss_plume_cartesian_integral_func.html"},{"title":"gauss_plume_cartesian_trajectory_func – uEMEP","text":"private  function gauss_plume_cartesian_trajectory_func(x, y, z_s, z_r, ay, by, az, bz, sig_y_0, sig_z_0, delta) Arguments Type Intent Optional Attributes Name real :: x real :: y real :: z_s real :: z_r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: delta Return Value real Source Code function gauss_plume_cartesian_trajectory_func ( x , y , z_s , z_r , ay , by , az , bz , sig_y_0 , sig_z_0 , delta ) implicit none real x , y , z_s , z_r real ay , by , az , bz , sig_y_0 , sig_z_0 , delta real gauss_plume_cartesian_trajectory_func real sig_y , sig_z real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) !x=(x_r-x_s)*cos_val+(y_r-y_s)*sin_val !y=-(x_r-x_s)*sin_val+(y_r-y_s)*cos_val gauss_plume_cartesian_trajectory_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) gauss_plume_cartesian_trajectory_func = 1. / ( 2. * pi * sig_y * sig_z ) * exp (( - y * y ) / 2. / ( sig_y * sig_y )) & * ( exp (( - ( z_r - z_s ) * ( z_r - z_s )) / 2. / ( sig_z * sig_z )) + exp (( - ( z_r + z_s ) * ( z_r + z_s )) / 2. / ( sig_z * sig_z ))) endif end function gauss_plume_cartesian_trajectory_func","tags":"","loc":"proc/gauss_plume_cartesian_trajectory_func.html"},{"title":"gauss_plume_cartesian_trajectory_integral_func – uEMEP","text":"private  function gauss_plume_cartesian_trajectory_integral_func(x, y, z_s, ay, by, az, bz, sig_y_0, sig_z_0, H1, H2, delta) Arguments Type Intent Optional Attributes Name real :: x real :: y real :: z_s real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: H1 real :: H2 real :: delta Return Value real Source Code function gauss_plume_cartesian_trajectory_integral_func ( x , y , z_s , ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta ) implicit none real x , y , z_s real ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta real gauss_plume_cartesian_trajectory_integral_func real sig_y , sig_z real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) !x=(x_r-x_s)*cos_val+(y_r-y_s)*sin_val !y=-(x_r-x_s)*sin_val+(y_r-y_s)*cos_val gauss_plume_cartesian_trajectory_integral_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) !gauss_plume_cartesian_integral_func=1./(2.*pi*sig_y)*exp((-y**2)/2./sig_y**2) & !    *sqrt(pi/2.)*(erf((z_s-H1)/sqrt(2.)/sig_z)-erf((z_s-H2)/sqrt(2.)/sig_z)+erf((z_s+H2)/sqrt(2.)/sig_z)-erf((z_s+H1)/sqrt(2.)/sig_z))/(H2-H1) gauss_plume_cartesian_trajectory_integral_func = 1. / ( 2. * pi * sig_y ) * exp (( - y * y ) / 2. / ( sig_y * sig_y )) & * sqrt ( pi / 2. ) * ( erf (( z_s - H1 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s - H2 ) / sqrt ( 2. ) / sig_z ) + erf (( z_s + H2 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s + H1 ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) endif end function gauss_plume_cartesian_trajectory_integral_func","tags":"","loc":"proc/gauss_plume_cartesian_trajectory_integral_func.html"},{"title":"gauss_plume_cartesian_sigma_func – uEMEP","text":"public  function gauss_plume_cartesian_sigma_func(x, y, z_s, z_r, sig_z, sig_y, z_pbl, FF) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z_s real, intent(in) :: z_r real, intent(in) :: sig_z real, intent(in) :: sig_y real, intent(in) :: z_pbl real, intent(in) :: FF Return Value real Source Code function gauss_plume_cartesian_sigma_func ( x , y , z_s , z_r , sig_z , sig_y , z_pbl , FF ) implicit none real , intent ( in ) :: x , y , z_s , z_r , sig_y , sig_z , z_pbl , FF real gauss_plume_cartesian_sigma_func real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) real z_loop ( 5 ) real c_z integer k , n_loop gauss_plume_cartesian_sigma_func = 0. if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then !write(*,*) 'here' !If the emission height z_s is greater than the boundary layer height z_pbl then only allow reflection from the surface !Also if z_r+z_s<z_pbl/3 then only use surface reflections since the pbl reflection counts for so little !Otherwise allow reflection from surface and boundary layer if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif !For large sigmaz set the plume to be evenly distributed in the boundary layer !A value of 0.9 is used as this is the correct value for surface level releases and within 2% for high level releases !Should not be used for above boundary layer releases but is not accounted for if ( sig_z . gt . 0.9 * z_pbl ) then c_z = 1. / z_pbl gauss_plume_cartesian_sigma_func = c_z / ( sqrt ( 2. * pi ) * sig_y ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF else c_z = 0. do k = 1 , n_loop c_z = c_z + exp ( - 0.5 * (( z_r - z_loop ( k )) / sig_z ) * (( z_r - z_loop ( k )) / sig_z )) enddo gauss_plume_cartesian_sigma_func = c_z / ( 2. * pi * sig_y * sig_z ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF endif !if (x.eq.0) then !    write(*,*) gauss_plume_cartesian_sigma_func*FF,1./(2.*pi*sig_y*sig_z) !endif endif end function gauss_plume_cartesian_sigma_func","tags":"","loc":"proc/gauss_plume_cartesian_sigma_func.html"},{"title":"gauss_plume_cartesian_sigma_integral_func – uEMEP","text":"public  function gauss_plume_cartesian_sigma_integral_func(x, y, z_s, sig_z, sig_y, z_pbl, FF, H1, H2) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z_s real, intent(in) :: sig_z real, intent(in) :: sig_y real, intent(in) :: z_pbl real, intent(in) :: FF real, intent(in) :: H1 real, intent(in) :: H2 Return Value real Source Code function gauss_plume_cartesian_sigma_integral_func ( x , y , z_s , sig_z , sig_y , z_pbl , FF , H1 , H2 ) implicit none real , intent ( in ) :: x , y , z_s , sig_y , sig_z , z_pbl , FF , H1 , H2 real gauss_plume_cartesian_sigma_integral_func real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) real z_loop ( 5 ) real c_z integer k , n_loop gauss_plume_cartesian_sigma_integral_func = 0. if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then !If the emission height z_s is greater than the boundary layer height z_pbl then only allow reflection from the surface !Also if z_r+z_s<z_pbl/3 then only use surface reflections since the pbl reflection counts for so little !Otherwise allow reflection from surface and boundary layer if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif !For large sigmaz set the plume to be evenly distributed in the boundary layer !A value of 0.9 is used as this is the correct value for surface level releases and within 2% for high level releases !Should not be used for above boundary layer releases but is not accounted for if ( sig_z . gt . 0.9 * z_pbl ) then c_z = 1. / z_pbl gauss_plume_cartesian_sigma_integral_func = c_z / ( sqrt ( 2. * pi ) * sig_y ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF else c_z = 0. do k = 1 , n_loop !c_z=c_z+exp(-0.5*((z_r-z_loop(k))/sig_z)*((z_r-z_loop(k))/sig_z)) c_z = c_z + sqrt ( pi / 2. ) * sig_z * ( erf (( z_loop ( k ) - H1 ) / sqrt ( 2. ) / sig_z ) - erf (( z_loop ( k ) - H2 ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) enddo gauss_plume_cartesian_sigma_integral_func = c_z / ( 2. * pi * sig_y * sig_z ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF endif !gauss_plume_cartesian_integral_func=1./(2.*pi*sig_y)*exp((-y*y)/2./(sig_y*sig_y)) & !    *sqrt(pi/2.)*(erf((z_s-H1)/sqrt(2.)/sig_z)-erf((z_s-H2)/sqrt(2.)/sig_z)+erf((z_s+H2)/sqrt(2.)/sig_z)-erf((z_s+H1)/sqrt(2.)/sig_z))/(H2-H1) endif end function gauss_plume_cartesian_sigma_integral_func","tags":"","loc":"proc/gauss_plume_cartesian_sigma_integral_func.html"},{"title":"uEMEP_read_SSB_data – uEMEP","text":"public  subroutine uEMEP_read_SSB_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_SSB_data use uEMEP_definitions implicit none integer i , j , k character ( 256 ) temp_name character ( 256 ) temp_str , temp_str1 , temp_str2 integer unit_in logical :: exists integer count , index_val integer temp_int integer * 8 ssb_id real dwe_todw , dwe_mult real pop_tot , emp_tot integer i_ssb_index , j_ssb_index integer source_index , subsource_index integer t integer , allocatable :: count_subgrid (:,:) real , allocatable :: temp1_subgrid (:,:), temp2_subgrid (:,:), temp3_subgrid (:,:) real x_ssb , y_ssb real :: f_easting = 2.e6 integer SSB_file_index real :: ssb_dx = 25 0. , ssb_dy = 25 0. real heating_proxy integer :: use_region = 0 character ( 256 ) region_number_str integer n_search parameter ( n_search = 5 ) character ( 16 ) search_str ( n_search ) real search_delta ( n_search ) integer temp_search integer :: io data search_str / '1000m' , '500m' , '250m' , '100m' , '50m' / data search_delta / 100 0. , 50 0. , 25 0. , 10 0. , 5 0. / write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading SSB data  (uEMEP_read_SSB_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = heating_index n_subsource ( source_index ) = 1 t = 1 !Initialise the use_grid array to false if population is to be used for the auto subgridding if ( use_population_positions_for_auto_subgrid_flag ) then use_subgrid = . false . endif !If dwellings are read then allocate the emission heating arrays. Otherwise allocate the population arrays if ( SSB_data_type . eq . dwelling_index ) then proxy_emission_subgrid (:,:, source_index ,:) = 0. allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp1_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp2_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp3_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) else allocate ( count_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) allocate ( temp1_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) allocate ( temp2_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) allocate ( temp3_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) endif count_subgrid = 0 SSB_file_index = SSB_data_type if ( SSB_data_type . eq . dwelling_index ) then pathfilename_heating ( SSB_file_index ) = trim ( pathname_heating ( SSB_file_index )) // trim ( filename_heating ( SSB_file_index )) !Test existence of the heating filename. If does not exist then stop inquire ( file = trim ( pathfilename_heating ( SSB_file_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file does not exist: ' , trim ( pathfilename_heating ( SSB_file_index )) stop endif temp_name = pathfilename_heating ( SSB_file_index ) elseif (. not . use_region_select_and_mask_flag ) then pathfilename_population ( SSB_file_index ) = trim ( pathname_population ( SSB_file_index )) // trim ( filename_population ( SSB_file_index )) !Test existence of the heating filename. If does not exist then stop inquire ( file = trim ( pathfilename_population ( SSB_file_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file does not exist: ' , trim ( pathfilename_population ( SSB_file_index )) stop endif temp_name = pathfilename_population ( SSB_file_index ) elseif ( use_region_select_and_mask_flag . and . SSB_data_type . eq . population_index ) then region_number_str = '' write ( region_number_str , * ) region_index region_number_str = trim ( region_number_str ) // '_' pathfilename_population ( SSB_file_index ) = trim ( pathname_population ( SSB_file_index )) // trim ( adjustl ( region_number_str )) // trim ( filename_population ( SSB_file_index )) !Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( SSB_file_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file does not exist: ' , trim ( pathfilename_population ( SSB_file_index )) stop endif temp_name = pathfilename_population ( SSB_file_index ) end if ! Determine grid resolution of population file ! NB: should this also be done for dwelling_index and establishement_index? if ( SSB_data_type . eq . population_index ) then !Search file name to define the grid size ssb_dx = 0. ; ssb_dy = 0. do k = 1 , n_search temp_search = index ( filename_population ( SSB_file_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality population data with resolution ' // trim ( adjustl ( search_str ( k ))) ! No point changing 'limit_population_delta' here, since it has already been used (uEMEP_set_subgrids) !limit_population_delta=search_delta(k) endif enddo if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( SSB_file_index )) stop endif endif !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB file ' // trim ( temp_name ) rewind ( unit_in ) subsource_index = 1 !Read header SSBID0250M;dwe_todw;dwe_det;dwe_2dw;dwe_row;dwe_mult;dwe_com;dwe_oth;dwe_area read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) !read(unit_in,'(A)') temp_str !write(*,*) trim(temp_str) count = 0 do ssb_id = 0 ; dwe_todw = 0 ; dwe_mult = 0 ; pop_tot = 0 ; emp_tot = 0 if ( SSB_data_type . eq . dwelling_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !Extract the ssb id for the coordinates index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id !Extract the total number of dwellings index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) dwe_todw !Skip over some values not to be used index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int !Extract the multiple dwellings number index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) dwe_mult endif if ( SSB_data_type . eq . population_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,*) trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id !write(*,*) trim(temp_str) !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:);if (index_val.gt.1) read(temp_str1,*) pop_tot read ( temp_str , * ) pop_tot !write (*,*) ssb_id,pop_tot,index_val endif if ( SSB_data_type . eq . establishment_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,*) trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id !write(*,*) trim(temp_str) index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int read ( temp_str , * ) pop_tot !write (*,*) ssb_id,pop_tot,index_val endif if ( SSB_data_type . eq . kindergaten_index . or . SSB_data_type . eq . school_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,'(a)') trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) x_ssb index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) y_ssb index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_str2 index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int !write(*,'(a)') trim(temp_str) index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) pop_tot !read(temp_str,*) pop_tot !write (*,*) x_ssb,y_ssb,pop_tot endif if ( SSB_data_type . eq . home_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,'(a)') trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_str2 index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) y_ssb index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) x_ssb !index_val=index(temp_str,',',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:);if (index_val.gt.1) read(temp_str1,*) pop_tot read ( temp_str , * ) pop_tot !write (*,*) trim(temp_str2),y_32,x_32,pop_tot !Convert from UTM32 to 33 !call UTM2LL(utm_zone-1,y_32,x_32,lat_32,lon_32) !write(*,*) lat_32,lon_32 !call ll2utm_modern(1,utm_zone,lat_32,lon_32,y_ssb,x_ssb) !write(*,*) y_ssb,x_ssb endif count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ssb_id,dwe_todw,dwe_mult,pop_tot if ( dwe_todw . gt . 0. or . pop_tot . gt . 0 ) then !Convert id to grid centre coordinates that are already in UTM33 for SSB data if ( SSB_data_type . eq . dwelling_index . or . SSB_data_type . eq . establishment_index . or . SSB_data_type . eq . population_index ) then x_ssb = ssb_id / 10000000 - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. endif !Convert lat lon to utm coords !call ll2utm_modern(1,utm_zone,ddlatitude,ddlongitude,y_ship,x_ship) !Add to heating emission proxy subgrid if ( SSB_data_type . eq . dwelling_index ) then !Find the grid index it belongs to i_ssb_index = 1 + floor (( x_ssb - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ssb_index = 1 + floor (( y_ssb - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then !write(*,*) x_ssb,y_ssb,emission_subgrid_delta(x_dim_index,source_index),i_ssb_index,j_ssb_index !Reduce the number of dwellings when they are in a multiple dwelling by factor of 5. i.e. the proxy is reduced in blocks with the assumption that only 1 in 5 use their wood heater heating_proxy = dwe_todw heating_proxy = max ( 0. , dwe_todw - dwe_mult ) + dwe_mult / 5. proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) + heating_proxy count_subgrid ( i_ssb_index , j_ssb_index ) = count_subgrid ( i_ssb_index , j_ssb_index ) + 1 !write(*,*) count,proxy_emission_subgrid(i_ssb_index,j_ssb_index,source_index,subsource_index) endif else !Find the grid index it belongs to in the population grid i_ssb_index = 1 + floor (( x_ssb - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) j_ssb_index = 1 + floor (( y_ssb - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . population_subgrid_dim ( x_dim_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . population_subgrid_dim ( y_dim_index ). and . pop_tot . gt . 0 ) then population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) = population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) + pop_tot count_subgrid ( i_ssb_index , j_ssb_index ) = count_subgrid ( i_ssb_index , j_ssb_index ) + 1 !write(*,*) count,proxy_emission_subgrid(i_ssb_index,j_ssb_index,source_index,subsource_index) endif if ( use_population_positions_for_auto_subgrid_flag ) then !Cover the grids when target grids are smaller than population grids if ( SSB_data_type . eq . population_index ) then use_region = floor ( population_subgrid_delta ( x_dim_index ) / subgrid_delta ( x_dim_index ) / 2. ) endif !Find the grid index it belongs to in the target grid i_ssb_index = 1 + floor (( x_ssb - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) j_ssb_index = 1 + floor (( y_ssb - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) if ( i_ssb_index - use_region . ge . 1. and . i_ssb_index + use_region . le . subgrid_dim ( x_dim_index ) & . and . j_ssb_index - use_region . ge . 1. and . j_ssb_index + use_region . le . subgrid_dim ( y_dim_index ). and . pop_tot . gt . 0 ) then use_subgrid ( i_ssb_index - use_region : i_ssb_index + use_region , j_ssb_index - use_region : j_ssb_index + use_region ,:) = . true . endif endif endif endif enddo if ( SSB_data_type . eq . dwelling_index ) then write ( unit_logfile , '(A,I)' ) 'Dwelling counts = ' , count write ( unit_logfile , '(A,es12.3)' ) 'Total dwellings = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , 1 )) write ( unit_logfile , '(A,I,a,i,a)' ) 'Number of grid placements = ' , sum ( count_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ))), ' of ' , emission_subgrid_dim ( x_dim_index , source_index ) * emission_subgrid_dim ( y_dim_index , source_index ), ' grids' else write ( unit_logfile , '(A,I)' ) 'Population type index = ' , SSB_data_type write ( unit_logfile , '(A,I)' ) 'Population counts = ' , count write ( unit_logfile , '(A,es12.3)' ) 'Total population = ' , sum ( population_subgrid (:,:, SSB_data_type )) write ( unit_logfile , '(A,I,a,i,a)' ) 'Number of grid placements = ' , sum ( count_subgrid ), ' of ' , subgrid_dim ( x_dim_index ) * subgrid_dim ( y_dim_index ), ' grids' endif close ( unit_in ) deallocate ( count_subgrid ) !Find the number of subgrids to be used if ( use_population_positions_for_auto_subgrid_flag . and . SSB_data_type . ne . dwelling_index ) then count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) count = count + 1 enddo enddo write ( unit_logfile , '(a,i,a,i)' ) ' Using population for subgrids. Number of subgrids to be calculated based on population = ' , count , ' of ' , subgrid_dim ( y_dim_index ) * subgrid_dim ( x_dim_index ) endif deallocate ( temp1_subgrid , temp2_subgrid , temp3_subgrid ) end subroutine uEMEP_read_SSB_data","tags":"","loc":"proc/uemep_read_ssb_data.html"},{"title":"uEMEP_read_netcdf_population – uEMEP","text":"public  subroutine uEMEP_read_netcdf_population() Uses uEMEP_definitions netcdf Arguments None Source Code subroutine uEMEP_read_netcdf_population use uEMEP_definitions use netcdf implicit none integer status_nc integer i_split , j_split , n_delta_split integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc , var_id_nc_temp real x_ssb , y_ssb integer i_ssb_index , j_ssb_index real delta_pop_nc ( num_dims_population_nc ) integer dim_id_nc ( num_dims_population_nc ) integer dim_length_population_nc ( num_dims_population_nc ) real y_pop , x_pop integer source_index logical :: exists !Temporary reading rvariables real , allocatable :: population_nc_dp (:,:,:) double precision , allocatable :: var2d_nc_dp (:,:) !If the data type is dwelling then this means it is for heating if ( SSB_data_type . eq . dwelling_index ) source_index = heating_index !Set the filename pathfilename_population ( SSB_data_type ) = trim ( pathname_population ( SSB_data_type )) // trim ( filename_population ( SSB_data_type )) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_population ( SSB_data_type )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_population ( SSB_data_type )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_population ( SSB_data_type )) status_nc = NF90_OPEN ( pathfilename_population ( SSB_data_type ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the projection. If no projection then in lat lon coordinates !status_nc = NF90_INQ_VARID (id_nc,'projection_lambert',var_id_nc) !status_nc = NF90_INQ_VARID (id_nc,'mollweide',var_id_nc_temp) !if (status_nc.eq.NF90_NOERR) then !    population_nc_projection_type=mollweide_projection_index !    var_id_nc=var_id_nc_temp !endif status_nc = NF90_INQ_VARID ( id_nc , 'transverse_mercator' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = UTM_projection_index var_id_nc = var_id_nc_temp endif status_nc = NF90_INQ_VARID ( id_nc , 'projection_utm' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = UTM_projection_index var_id_nc = var_id_nc_temp endif status_nc = NF90_INQ_VARID ( id_nc , 'projection_lambert' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = LCC_projection_index var_id_nc = var_id_nc_temp endif status_nc = NF90_INQ_VARID ( id_nc , 'projection_ETRS89_LAEA' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = LAEA_projection_index var_id_nc = var_id_nc_temp endif if ( population_nc_projection_type . ne . LL_projection_index ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) status_nc = nf90_get_att ( id_nc , var_id_nc , 'Central_Meridian' , population_nc_projection_attributes ( 1 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'False_Easting' , population_nc_projection_attributes ( 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'False_Northing' , population_nc_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_prime_meridian' , population_nc_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'semi_major_axis' , population_nc_projection_attributes ( 5 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'inverse_flattening' , population_nc_projection_attributes ( 6 )) write ( unit_logfile , '(A,4i,6f12.2)' ) 'Reading projection (index, params) ' , population_nc_projection_type , population_nc_projection_attributes ( 1 : 6 ) endif !Even if projection is Mollweide still use the lat lon positions !population_nc_projection_type=LL_projection_index !Find the (x,y) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_population_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_population_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_population_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_population_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_population_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of population dimensions (x,y): ' , dim_length_population_nc !Allocate the temporary arrays for lat,lon and population if (. not . allocated ( population_nc_dp )) allocate ( population_nc_dp ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ), num_var_population_nc )) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index )), num_dims_population_nc )) !x and y !Read the x and y values to get the delta do i = 1 , num_dims_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_population_nc ( i ), i ), start = ( / 1 / ), count = ( / dim_length_population_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_pop_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.2)' ) 'Population grid delta (m): ' , delta_pop_nc do i = 1 , num_var_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , population_nc_dp (:,:, i ), start = ( / 1 , 1 / ), count = ( / dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Population variable min and max: ' , trim ( var_name_nc_temp ), minval ( population_nc_dp (:,:, i )), maxval ( population_nc_dp (:,:, i )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo !Loop through the population data and put it in the population grid !Converting from lat lon to the subgrid coordinates and then finding the nearest neighbour !If population_subgrid_delta<delta_pop_nc then split the input grid into subgrids that are smaller than subgrid !Split any way into four even if they are the same grids for better interpolation n_delta_split = floor ( sqrt ( delta_pop_nc ( x_dim_nc_index ) ** 2 + delta_pop_nc ( y_dim_nc_index ) ** 2 ) / sqrt ( population_subgrid_delta ( x_dim_index ) ** 2 + population_subgrid_delta ( y_dim_index ) ** 2 ) + . 001 ) n_delta_split = 10 * max ( n_delta_split , 1 ) write ( unit_logfile , '(A,i)' ) 'Population grids split into this many segments for numerical nearest neighbour interpolation: ' , n_delta_split !Already defined as 0. Do it again population_subgrid (:,:, SSB_data_type ) = 0 do j = 1 , dim_length_population_nc ( y_dim_nc_index ) do i = 1 , dim_length_population_nc ( x_dim_nc_index ) if ( population_nc_dp ( i , j , population_nc_index ). gt . 0 ) then if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , population_nc_dp ( i , j , lat_nc_index ), population_nc_dp ( i , j , lon_nc_index ), y_pop , x_pop ) !write(*,*) population_nc_dp(i,j,lat_nc_index),population_nc_dp(i,j,lon_nc_index),y_pop,x_pop elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , population_nc_dp ( i , j , lat_nc_index ), population_nc_dp ( i , j , lon_nc_index ), y_pop , x_pop ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_pop , y_pop , population_nc_dp ( i , j , lon_nc_index ), population_nc_dp ( i , j , lat_nc_index ), projection_attributes ) !call LAEA2LL(x_pop,y_pop,x_ssb,y_ssb,projection_attributes) !write(*,*) population_nc_dp(i,j,lon_nc_index)-x_ssb,population_nc_dp(i,j,lat_nc_index)-y_ssb else write ( unit_logfile , '(A)' ) 'No supported projection available for population. Stopping ' stop endif !Loop through the n_delta_split do i_split = 1 , n_delta_split do j_split = 1 , n_delta_split x_ssb = x_pop - delta_pop_nc ( x_dim_nc_index ) * 0.5 + ( i_split - 0.5 ) * delta_pop_nc ( x_dim_nc_index ) / n_delta_split y_ssb = y_pop - delta_pop_nc ( y_dim_nc_index ) * 0.5 + ( j_split - 0.5 ) * delta_pop_nc ( y_dim_nc_index ) / n_delta_split if ( SSB_data_type . eq . population_index ) then i_ssb_index = 1 + floor (( x_ssb - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) j_ssb_index = 1 + floor (( y_ssb - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . population_subgrid_dim ( x_dim_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . population_subgrid_dim ( y_dim_index )) then population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) = population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) & + population_nc_dp ( i , j , population_nc_index ) / ( n_delta_split ** 2 ) !write(*,'(2i,6f12.1)') i_split,j_split,x_pop,y_pop,x_ssb,y_ssb,(i_split-0.5)*delta_pop_nc(x_dim_nc_index)/n_delta_split,(j_split-0.5)*delta_pop_nc(y_dim_nc_index)/n_delta_split !write(*,*) i_split,j_split,i_ssb_index,j_ssb_index !write(*,*) i_ssb_index,j_ssb_index,SSB_data_type,population_subgrid(i_ssb_index,j_ssb_index,SSB_data_type) endif endif if ( SSB_data_type . eq . dwelling_index ) then i_ssb_index = 1 + floor (( x_ssb - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ssb_index = 1 + floor (( y_ssb - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) & + population_nc_dp ( i , j , population_nc_index ) / ( n_delta_split ** 2 ) endif endif enddo enddo endif enddo enddo if ( allocated ( population_nc_dp )) deallocate ( population_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) end subroutine uEMEP_read_netcdf_population","tags":"","loc":"proc/uemep_read_netcdf_population.html"},{"title":"uEMEP_read_netcdf_population_latlon – uEMEP","text":"public  subroutine uEMEP_read_netcdf_population_latlon() Uses uEMEP_definitions netcdf Arguments None Source Code subroutine uEMEP_read_netcdf_population_latlon use uEMEP_definitions use netcdf implicit none integer status_nc integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc real delta_pop_nc ( num_dims_population_nc ) integer dim_id_nc ( num_dims_population_nc ) integer dim_length_population_nc ( num_dims_population_nc ) integer dim_start_population_nc ( num_dims_population_nc ) integer source_index logical reduce_population_region_flag real temp_lon ( 4 ), temp_lat ( 4 ), temp_x ( 4 ), temp_y ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max real temp_delta ( num_dims_population_nc ) real correct_lon ( 2 ) real temp_scale integer :: name_index = 0 logical :: exists !Temporary reading rvariables real , allocatable :: population_nc_dp (:,:,:) !double precision, allocatable :: population_nc_dp(:,:,:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: temp_var2d_nc_dp (:,:) !If the data type is dwelling then this means it is for heating !Always set to this since emissions will be the largest domain, when reducing the reading domain !source_index=heating_index if ( SSB_data_type . eq . dwelling_index ) source_index = heating_index if ( SSB_data_type . eq . dwelling_index ) name_index = dwelling_nc_index if ( SSB_data_type . eq . population_index ) name_index = population_nc_index !Set the filename pathfilename_population ( SSB_data_type ) = trim ( pathname_population ( SSB_data_type )) // trim ( filename_population ( SSB_data_type )) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_population ( SSB_data_type )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_population ( SSB_data_type )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_population ( SSB_data_type )) status_nc = NF90_OPEN ( pathfilename_population ( SSB_data_type ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the (lon,lat) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_population_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_population_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_population_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_population_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_population_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of population dimensions (lon,lat): ' , dim_length_population_nc !Reduce the size of the grid to the heating emission grid size reduce_population_region_flag = . true . if ( reduce_population_region_flag ) then write ( unit_logfile , '(A)' ) 'Reducing population domain for reading' !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon if ( SSB_data_type . eq . dwelling_index ) then call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) endif if ( SSB_data_type . eq . population_index ) then call PROJ2LL ( population_subgrid_min ( x_dim_index ), population_subgrid_min ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( population_subgrid_max ( x_dim_index ), population_subgrid_max ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( population_subgrid_min ( x_dim_index ), population_subgrid_max ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( population_subgrid_max ( x_dim_index ), population_subgrid_min ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) endif temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 temp_x = temp_lon ; temp_y = temp_lat do i = 1 , 4 !write(*,*) i,temp_x(i),temp_y(i) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo write ( unit_logfile , '(A,2f12.2)' ) 'Min: ' , temp_x_min , temp_y_min write ( unit_logfile , '(A,2f12.2)' ) 'Max: ' , temp_x_max , temp_y_max !Read the lon and lat values to get the delta and size. Put in temporary array !Allocate the temporary arrays for lat,lon and population if (. not . allocated ( temp_var2d_nc_dp )) allocate ( temp_var2d_nc_dp ( max ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index )), num_dims_population_nc )) !x and y dim_start_population_nc = 1 do i = 1 , num_dims_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var2d_nc_dp ( 1 : dim_length_population_nc ( i ), i ), start = ( / dim_start_population_nc ( i ) / ), count = ( / dim_length_population_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_pop_nc = temp_var2d_nc_dp ( 2 ,:) - temp_var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Population grid delta (degrees): ' , delta_pop_nc !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = delta_pop_nc ( 1 ) temp_delta ( 2 ) = delta_pop_nc ( 2 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max !Increase the region by 5 grids to be certain i_temp_min = max ( 1 , i_temp_min - 5 ) i_temp_max = min ( dim_length_population_nc ( x_dim_nc_index ), i_temp_max + 5 ) j_temp_min = max ( 1 , j_temp_min - 5 ) j_temp_max = min ( dim_length_population_nc ( y_dim_nc_index ), j_temp_max + 5 ) dim_length_population_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_population_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_population_nc ( x_dim_nc_index ) = i_temp_min dim_start_population_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading population i grids: ' , i_temp_min , i_temp_max , dim_length_population_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading population j grids: ' , j_temp_min , j_temp_max , dim_length_population_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading population lon grids (min,max): ' , temp_var2d_nc_dp ( i_temp_min , x_dim_nc_index ), temp_var2d_nc_dp ( i_temp_max , x_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading population lat grids (min,max): ' , temp_var2d_nc_dp ( j_temp_min , y_dim_nc_index ), temp_var2d_nc_dp ( j_temp_max , y_dim_nc_index ) !endif endif if ( i_temp_min . ge . i_temp_max . or . j_temp_min . ge . j_temp_max ) then !No population data available write ( unit_logfile , '(A)' ) ' WARNING: No population data available in this region. Setting to 0' proxy_emission_subgrid (:,:, source_index ,:) = 0. population_subgrid (:,:, SSB_data_type ) = 0 else if (. not . allocated ( population_nc_dp )) allocate ( population_nc_dp ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ), num_var_population_nc )) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index )), num_dims_population_nc )) !x and y !Read the lon and lat values to get the delta do i = 1 , num_dims_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_population_nc ( i ), i ), start = ( / dim_start_population_nc ( i ) / ), count = ( / dim_length_population_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_pop_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Population grid delta (degrees): ' , delta_pop_nc !write(*,*) var2d_nc_dp(1,1),var2d_nc_dp(dim_length_population_nc(x_dim_nc_index),1) !write(*,*) var2d_nc_dp(1,2),var2d_nc_dp(dim_length_population_nc(y_dim_nc_index),2) !Read the population data !write(*,*) 'Reading population data' !do i=1,num_var_population_nc i = name_index !Uses the population_nc_index as index, =1, but not logical !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , population_nc_dp (:,:, population_nc_index ), start = ( / dim_start_population_nc ( x_dim_nc_index ), dim_start_population_nc ( y_dim_nc_index ) / ), count = ( / dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Population variable min and max: ' , trim ( var_name_nc_temp ), minval ( population_nc_dp (:,:, population_nc_index )), maxval ( population_nc_dp (:,:, population_nc_index )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif !enddo !write(*,*) 'Finished reading population data' !Loop through the population data and put it in the population grid !Converting from lat lon to the subgrid coordinates and then finding the nearest neighbour !Interpolate to the population grid in lat lon coordinates population_subgrid (:,:, SSB_data_type ) = 0. !where (population_nc_dp.lt.0.0D00) population_nc_dp=0.0D00 where ( population_nc_dp . lt . 0.0 ) population_nc_dp = 0.0 write ( unit_logfile , '(2a,2f12.2)' ) 'Population min and max: ' , trim ( var_name_nc_temp ), minval ( population_nc_dp (:,:, population_nc_index )), maxval ( population_nc_dp (:,:, population_nc_index )) !stop if ( SSB_data_type . eq . population_index ) then do j = 1 , population_subgrid_dim ( y_dim_nc_index ) do i = 1 , population_subgrid_dim ( x_dim_nc_index ) !Project the centre position to lat lon call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_population_subgrid ( i , j ) - population_subgrid_delta ( x_dim_index ) / 2. , y_population_subgrid ( i , j ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_population_subgrid ( i , j ) + population_subgrid_delta ( x_dim_index ) / 2. , y_population_subgrid ( i , j ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ) - population_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ) + population_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !write(*,*) correct_lon ! population_subgrid(i,j,SSB_data_type)=area_weighted_extended_vectorgrid_interpolation_function( & !     real(var2d_nc_dp(1:dim_length_population_nc(x_dim_nc_index),x_dim_nc_index))*correct_lon(1),real(var2d_nc_dp(1:dim_length_population_nc(y_dim_nc_index),y_dim_nc_index)) & !     ,population_nc_dp(:,:,population_nc_index),dim_length_population_nc(x_dim_nc_index),dim_length_population_nc(y_dim_nc_index) & !     ,delta_pop_nc*correct_lon,temp_lon(1)*correct_lon(1),temp_lat(1),temp_delta*correct_lon) ! write(*,*) temp_lon(1),temp_lat(1),var2d_nc_dp(int(dim_length_population_nc(x_dim_nc_index)/2),x_dim_nc_index),var2d_nc_dp(int(dim_length_population_nc(y_dim_nc_index)/2),y_dim_nc_index),population_subgrid(i,j,SSB_data_type) !Take the nearest instead for a check !i_ssb_index=1+floor((temp_lon(1)-var2d_nc_dp(1,x_dim_nc_index))/delta_pop_nc(1)+0.5) !j_ssb_index=1+floor((temp_lat(1)-var2d_nc_dp(1,y_dim_nc_index))/delta_pop_nc(2)+0.5) !population_subgrid(i,j,SSB_data_type)=population_nc_dp(i_ssb_index,j_ssb_index,population_nc_index) !Do the interpolation on the same grid then scale afterwards. Equivalent to interpolating density then rescaling with grid size population_subgrid ( i , j , SSB_data_type ) = area_weighted_extended_vectorgrid_interpolation_function ( & real ( var2d_nc_dp ( 1 : dim_length_population_nc ( x_dim_nc_index ), x_dim_nc_index )) * correct_lon ( 1 ), real ( var2d_nc_dp ( 1 : dim_length_population_nc ( y_dim_nc_index ), y_dim_nc_index )) & , population_nc_dp (:,:, population_nc_index ), dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) & , delta_pop_nc * correct_lon , temp_lon ( 1 ) * correct_lon ( 1 ), temp_lat ( 1 ), delta_pop_nc * correct_lon ) temp_scale = ( temp_delta ( 1 ) * correct_lon ( 1 ) * temp_delta ( 2 ) * correct_lon ( 2 )) / ( delta_pop_nc ( 1 ) * correct_lon ( 1 ) * delta_pop_nc ( 2 ) * correct_lon ( 2 )) !write(*,*) temp_scale population_subgrid ( i , j , SSB_data_type ) = population_subgrid ( i , j , SSB_data_type ) * temp_scale if ( isnan ( population_subgrid ( i , j , SSB_data_type ))) then write ( * , * ) 'Stopping, nan in population_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif if ( population_subgrid ( i , j , SSB_data_type ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in population_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif enddo enddo write ( unit_logfile , '(A,f12.2)' ) 'Total population in read domain: ' , sum ( population_nc_dp (:,:, population_nc_index )) write ( unit_logfile , '(A,f12.2)' ) 'Total population in subgrid domain: ' , sum ( population_subgrid (:,:, SSB_data_type )) endif if ( SSB_data_type . eq . dwelling_index ) then proxy_emission_subgrid (:,:, source_index ,:) = 0. do j = 1 , emission_subgrid_dim ( y_dim_nc_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_nc_index , source_index ) !Project the centre position to lat lon call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !Interpolate on same grid then scale, equivalent to interpolating density and then recalculating proxy_emission_subgrid ( i , j , source_index ,:) = area_weighted_extended_vectorgrid_interpolation_function ( & real ( var2d_nc_dp ( 1 : dim_length_population_nc ( x_dim_nc_index ), x_dim_nc_index )) * correct_lon ( 1 ), real ( var2d_nc_dp ( 1 : dim_length_population_nc ( y_dim_nc_index ), y_dim_nc_index )) & , population_nc_dp (:,:, population_nc_index ), dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) & , delta_pop_nc * correct_lon , temp_lon ( 1 ) * correct_lon ( 1 ), temp_lat ( 1 ), delta_pop_nc * correct_lon ) temp_scale = ( temp_delta ( 1 ) * correct_lon ( 1 ) * temp_delta ( 2 ) * correct_lon ( 2 )) / ( delta_pop_nc ( 1 ) * correct_lon ( 1 ) * delta_pop_nc ( 2 ) * correct_lon ( 2 )) proxy_emission_subgrid ( i , j , source_index ,:) = proxy_emission_subgrid ( i , j , source_index ,:) * temp_scale if ( isnan ( proxy_emission_subgrid ( i , j , source_index , 1 ))) then write ( * , * ) 'Stopping, nan in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif if ( proxy_emission_subgrid ( i , j , source_index , 1 ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif enddo enddo !Apply the power law scaling for population to reduce the distribution in higher population areas write ( unit_logfile , '(A,f12.2)' ) 'Power scaling of population using: ' , population_power_scale proxy_emission_subgrid (:,:, source_index ,:) = proxy_emission_subgrid (:,:, source_index ,:) ** population_power_scale endif endif !No population available if ( allocated ( population_nc_dp )) deallocate ( population_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_var2d_nc_dp )) deallocate ( temp_var2d_nc_dp ) end subroutine uEMEP_read_netcdf_population_latlon","tags":"","loc":"proc/uemep_read_netcdf_population_latlon.html"},{"title":"uEMEP_define_subgrid_extent – uEMEP","text":"public  subroutine uEMEP_define_subgrid_extent() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_define_subgrid_extent use uEMEP_definitions implicit none integer i_source !integer ii,jj real dx_temp , dy_temp real lon_temp , lat_temp write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Define subgrid extent and buffer zones (uEMEP_define_subgrid_extent)' write ( unit_logfile , '(A)' ) '================================================================' !If annual calculations then always set time start and stop to 1 if ( annual_calculations ) then start_time_nc_index = 1 end_time_nc_index = 1 start_time_meteo_nc_index = 1 end_time_meteo_nc_index = 1 endif !Set the time index to be the same as the EMEP time dimensions emission_subgrid_dim ( t_dim_index ,:) = subgrid_dim ( t_dim_index ) init_emission_subgrid_dim ( t_dim_index ,:) = subgrid_dim ( t_dim_index ) integral_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,I6)' ) 'Number of external time steps:' , end_time_loop_index - start_time_loop_index + 1 write ( unit_logfile , '(A,I6)' ) 'Number of internal time steps:' , subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,2I6)' ) 'Number of target grids:' , subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Number of integral grids:' , integral_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Max number of emission grids:' , emission_max_subgrid_dim ( 1 : 2 ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I6)' ) 'Number of emission grids: ' , trim ( source_file_str ( i_source )), emission_subgrid_dim ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2I8)' ) 'Number of initial emission grids: ' , trim ( source_file_str ( i_source )), init_emission_subgrid_dim ( 1 : 2 , i_source ) endif enddo !Allocate buffers and adjust the dimensions appropriately !Calculate the max loop size to cover the nearest EMEP grids. This avoids looping through all the grids !loop_index_scale=1.2*EMEP_grid_interpolation_size/2.*local_fraction_grid_size_scaling !Was 1.5 loop_index_scale = 1.2 * EMEP_grid_interpolation_size / 2. * local_fraction_grid_size_scaling !Was 1.5 !Define the centre of the subgrid !ii=int(subgrid_dim(x_dim_index)/2) !jj=int(subgrid_dim(y_dim_index)/2) call PROJ2LL (( subgrid_min ( x_dim_index ) + subgrid_max ( x_dim_index )) / 2. ,( subgrid_min ( y_dim_index ) + subgrid_max ( y_dim_index )) / 2. , lon_temp , lat_temp , projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL((subgrid_min(y_dim_index)+subgrid_max(y_dim_index))/2.,(subgrid_min(x_dim_index)+subgrid_max(x_dim_index))/2.,lat_temp,lon_temp) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,(subgrid_min(y_dim_index)+subgrid_max(y_dim_index))/2.,(subgrid_min(x_dim_index)+subgrid_max(x_dim_index))/2.,lat_temp,lon_temp) !endif if ( EMEP_projection_type . eq . LL_projection_index ) then dx_temp = 11100 0. * dgrid_nc ( lon_nc_index ) * cos ( lat_temp * pi / 18 0. ) dy_temp = 11100 0. * dgrid_nc ( lat_nc_index ) else !Assumed LCC or PS dx_temp = dgrid_nc ( lon_nc_index ) dy_temp = dgrid_nc ( lat_nc_index ) endif subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / subgrid_delta ( x_dim_index ) * loop_index_scale ) subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / subgrid_delta ( y_dim_index ) * loop_index_scale ) integral_subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / integral_subgrid_delta ( x_dim_index ) * loop_index_scale ) integral_subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / integral_subgrid_delta ( y_dim_index ) * loop_index_scale ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid_loop_index ( x_dim_index , i_source ) = floor ( dx_temp / emission_subgrid_delta ( x_dim_index , i_source ) * loop_index_scale ) emission_subgrid_loop_index ( y_dim_index , i_source ) = floor ( dy_temp / emission_subgrid_delta ( y_dim_index , i_source ) * loop_index_scale ) endif enddo do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then init_emission_subgrid_loop_index ( x_dim_index , i_source ) = floor ( dx_temp / init_emission_subgrid_delta ( x_dim_index , i_source ) * loop_index_scale ) init_emission_subgrid_loop_index ( y_dim_index , i_source ) = floor ( dy_temp / init_emission_subgrid_delta ( y_dim_index , i_source ) * loop_index_scale ) endif enddo if ( calculate_deposition_flag ) then deposition_subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / deposition_subgrid_delta ( x_dim_index ) * loop_index_scale ) deposition_subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / deposition_subgrid_delta ( y_dim_index ) * loop_index_scale ) endif if ( read_landuse_flag ) then landuse_subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / landuse_subgrid_delta ( x_dim_index ) * loop_index_scale ) landuse_subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / landuse_subgrid_delta ( y_dim_index ) * loop_index_scale ) endif !Set the buffer sizes according to these loops for emissions only !This will remove edge effects for dispersion but will only remove edge effects for moving window only when emissions are used for redistribution buffer_index_scale = loop_index_scale !if (use_downwind_position_flag) buffer_index_scale=buffer_index_scale*2. if ( use_buffer_zone ) then buffer_index ( x_dim_index ) = floor ( dx_temp / subgrid_delta ( x_dim_index ) * buffer_index_scale ) buffer_index ( y_dim_index ) = floor ( dy_temp / subgrid_delta ( y_dim_index ) * buffer_index_scale ) integral_buffer_index ( x_dim_index ) = floor ( dx_temp / integral_subgrid_delta ( x_dim_index ) * buffer_index_scale ) integral_buffer_index ( y_dim_index ) = floor ( dy_temp / integral_subgrid_delta ( y_dim_index ) * buffer_index_scale ) !Buffer index for emissions a half grid larger because of the possible use of the integral do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) if ( local_subgrid_method_flag . eq . 3 ) then !Extend the emission buffer zone 0.5 EMEP grids when redistributing emissions to gurantee all emissions are accounted for emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) endif endif enddo do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then init_emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / init_emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) init_emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / init_emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) if ( local_subgrid_method_flag . eq . 3 ) then !Extend the emission buffer zone 0.5 EMEP grids when redistributing emissions to gurantee all emissions are accounted for init_emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / init_emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) init_emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / init_emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) endif endif enddo if ( calculate_deposition_flag ) then deposition_buffer_index ( x_dim_index ) = floor ( dx_temp / deposition_subgrid_delta ( x_dim_index ) * buffer_index_scale ) deposition_buffer_index ( y_dim_index ) = floor ( dy_temp / deposition_subgrid_delta ( y_dim_index ) * buffer_index_scale ) endif !Make sure the landuse bufferzone is the same as the emissions in case it is used as a proxy if ( read_landuse_flag ) then landuse_buffer_index ( x_dim_index ) = floor ( dx_temp / landuse_subgrid_delta ( x_dim_index ) * ( buffer_index_scale + 0.5 )) landuse_buffer_index ( y_dim_index ) = floor ( dy_temp / landuse_subgrid_delta ( y_dim_index ) * ( buffer_index_scale + 0.5 )) if ( local_subgrid_method_flag . eq . 3 ) then landuse_buffer_index ( x_dim_index ) = floor ( dx_temp / landuse_subgrid_delta ( x_dim_index ) * ( buffer_index_scale + 1.0 )) landuse_buffer_index ( y_dim_index ) = floor ( dy_temp / landuse_subgrid_delta ( y_dim_index ) * ( buffer_index_scale + 1.0 )) endif endif else buffer_index = 0 emission_buffer_index = 0 init_emission_buffer_index = 0 integral_buffer_index = 0 deposition_buffer_index = 0 landuse_buffer_index = 0 endif buffer_size = buffer_index * subgrid_delta emission_buffer_size = emission_buffer_index * emission_subgrid_delta init_emission_buffer_size = emission_buffer_index * init_emission_subgrid_delta integral_buffer_size = integral_buffer_index * integral_subgrid_delta if ( calculate_deposition_flag ) then deposition_buffer_size = deposition_buffer_index * deposition_subgrid_delta endif if ( read_landuse_flag ) then landuse_buffer_size = landuse_buffer_index * landuse_subgrid_delta endif do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid_dim ( 1 : 2 , i_source ) = emission_subgrid_dim ( 1 : 2 , i_source ) + emission_buffer_index ( 1 : 2 , i_source ) * 2 emission_subgrid_min ( 1 : 2 , i_source ) = emission_subgrid_min ( 1 : 2 , i_source ) - emission_buffer_size ( 1 : 2 , i_source ) emission_subgrid_max ( 1 : 2 , i_source ) = emission_subgrid_max ( 1 : 2 , i_source ) + emission_buffer_size ( 1 : 2 , i_source ) endif enddo !emission_max_subgrid_dim(1:2)=emission_max_subgrid_dim(1:2)+buffer_index(1:2)*2 emission_max_subgrid_dim ( 1 : 2 ) = maxval ( emission_subgrid_dim ( 1 : 2 ,:), 2 ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then init_emission_subgrid_dim ( 1 : 2 , i_source ) = init_emission_subgrid_dim ( 1 : 2 , i_source ) + init_emission_buffer_index ( 1 : 2 , i_source ) * 2 init_emission_subgrid_min ( 1 : 2 , i_source ) = init_emission_subgrid_min ( 1 : 2 , i_source ) - init_emission_buffer_size ( 1 : 2 , i_source ) init_emission_subgrid_max ( 1 : 2 , i_source ) = init_emission_subgrid_max ( 1 : 2 , i_source ) + init_emission_buffer_size ( 1 : 2 , i_source ) endif enddo integral_subgrid_dim ( 1 : 2 ) = integral_subgrid_dim ( 1 : 2 ) + integral_buffer_index ( 1 : 2 ) * 2 integral_subgrid_min ( 1 : 2 ) = integral_subgrid_min ( 1 : 2 ) - integral_buffer_size ( 1 : 2 ) integral_subgrid_max ( 1 : 2 ) = integral_subgrid_max ( 1 : 2 ) + integral_buffer_size ( 1 : 2 ) if ( calculate_deposition_flag ) then deposition_subgrid_dim ( 1 : 2 ) = deposition_subgrid_dim ( 1 : 2 ) + deposition_buffer_index ( 1 : 2 ) * 2 deposition_subgrid_min ( 1 : 2 ) = deposition_subgrid_min ( 1 : 2 ) - deposition_buffer_size ( 1 : 2 ) deposition_subgrid_max ( 1 : 2 ) = deposition_subgrid_max ( 1 : 2 ) + deposition_buffer_size ( 1 : 2 ) endif if ( read_landuse_flag ) then landuse_subgrid_dim ( 1 : 2 ) = landuse_subgrid_dim ( 1 : 2 ) + landuse_buffer_index ( 1 : 2 ) * 2 landuse_subgrid_min ( 1 : 2 ) = landuse_subgrid_min ( 1 : 2 ) - landuse_buffer_size ( 1 : 2 ) landuse_subgrid_max ( 1 : 2 ) = landuse_subgrid_max ( 1 : 2 ) + landuse_buffer_size ( 1 : 2 ) endif write ( unit_logfile , '(A,2I5)' ) 'Number of target grids to be looped for each EMEP grid:' , subgrid_loop_index ( 1 : 2 ) write ( unit_logfile , '(A,2I5)' ) 'Number of integral grids to be looped for each EMEP grid:' , integral_subgrid_loop_index ( 1 : 2 ) write ( unit_logfile , '(A,2I5)' ) 'Size of integral grid buffer zone:' , integral_buffer_index ( 1 : 2 ) if ( calculate_deposition_flag ) then write ( unit_logfile , '(A,2I5)' ) 'Size of deposition grid buffer zone:' , deposition_buffer_index ( 1 : 2 ) endif if ( read_landuse_flag ) then write ( unit_logfile , '(A,2I5)' ) 'Size of landuse grid buffer zone:' , landuse_buffer_index ( 1 : 2 ) endif do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I5)' ) 'Size of emission grid buffer zone: ' , trim ( source_file_str ( i_source )), emission_buffer_index ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2I5)' ) 'Size of initial emission grid buffer zone: ' , trim ( source_file_str ( i_source )), emission_buffer_index ( 1 : 2 , i_source ) endif enddo write ( unit_logfile , '(A,2I6)' ) 'Number of target grids:' , subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Number of integral grids:' , integral_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Number of integral grids:' , integral_subgrid_dim ( 1 : 2 ) if ( calculate_deposition_flag ) then write ( unit_logfile , '(A,2I6)' ) 'Number of deposition grids:' , deposition_subgrid_dim ( 1 : 2 ) endif write ( unit_logfile , '(A,2I6)' ) 'Max number of emission grids:' , emission_max_subgrid_dim ( 1 : 2 ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I6)' ) 'Number of emission grids:' , trim ( source_file_str ( i_source )), emission_subgrid_dim ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Min of emission grids:   ' , trim ( source_file_str ( i_source )), emission_subgrid_min ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Max of emission grids:   ' , trim ( source_file_str ( i_source )), emission_subgrid_max ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Delta of emission grids: ' , trim ( source_file_str ( i_source )), emission_subgrid_delta ( 1 : 2 , i_source ) endif if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I8)' ) 'Number of initial emission grids:' , trim ( source_file_str ( i_source )), init_emission_subgrid_dim ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Min of initial emission grids:   ' , trim ( source_file_str ( i_source )), init_emission_subgrid_min ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Max of initial emission grids:   ' , trim ( source_file_str ( i_source )), init_emission_subgrid_max ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Delta of initial emission grids: ' , trim ( source_file_str ( i_source )), init_emission_subgrid_delta ( 1 : 2 , i_source ) endif enddo end subroutine uEMEP_define_subgrid_extent","tags":"","loc":"proc/uemep_define_subgrid_extent.html"},{"title":"uEMEP_define_subgrid – uEMEP","text":"public  subroutine uEMEP_define_subgrid() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_define_subgrid use uEMEP_definitions implicit none integer i , j integer i_source !integer ii,jj integer :: subsource_index = 1 write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Define subgrid arrays (uEMEP_define_subgrid)' write ( unit_logfile , '(A)' ) '================================================================' !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( subgrid )) deallocate ( subgrid ) if ( allocated ( x_subgrid )) deallocate ( x_subgrid ) if ( allocated ( y_subgrid )) deallocate ( y_subgrid ) if ( allocated ( lon_subgrid )) deallocate ( lon_subgrid ) if ( allocated ( lat_subgrid )) deallocate ( lat_subgrid ) if ( allocated ( xproj_subgrid )) deallocate ( xproj_subgrid ) if ( allocated ( yproj_subgrid )) deallocate ( yproj_subgrid ) if ( allocated ( traveltime_subgrid )) deallocate ( traveltime_subgrid ) !Define target grid if (. not . allocated ( subgrid )) allocate ( subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_subgrid_index , n_source_index , n_pollutant_loop )) if (. not . allocated ( x_subgrid )) allocate ( x_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_subgrid )) allocate ( y_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_subgrid )) allocate ( lon_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_subgrid )) allocate ( lat_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_subgrid )) allocate ( xproj_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_subgrid )) allocate ( yproj_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( traveltime_subgrid )) allocate ( traveltime_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), 3 , n_pollutant_loop )) !Last index 1 for weighted time, 2 for sum of weights, 3 for final time traveltime_subgrid = 0. ! Allocate in-region arrays for downscaled in-region contributions if ( trace_emissions_from_in_region ) then if ( allocated ( subgrid_proxy_from_in_region )) deallocate ( subgrid_proxy_from_in_region ) if ( allocated ( subgrid_local_from_in_region )) deallocate ( subgrid_local_from_in_region ) allocate ( subgrid_proxy_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( subgrid_local_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) subgrid_proxy_from_in_region = 0.0 subgrid_local_from_in_region = 0.0 end if !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( comp_subgrid )) deallocate ( comp_subgrid ) if ( allocated ( comp_EMEP_subgrid )) deallocate ( comp_EMEP_subgrid ) if ( allocated ( orig_EMEP_subgrid )) deallocate ( orig_EMEP_subgrid ) if ( allocated ( species_EMEP_subgrid )) deallocate ( species_EMEP_subgrid ) !Define compound subgrid. Same as target in dimensions if (. not . allocated ( comp_subgrid )) then allocate ( comp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) comp_subgrid = 0. endif if (. not . allocated ( comp_EMEP_subgrid )) then allocate ( comp_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) comp_EMEP_subgrid = 0. endif if (. not . allocated ( orig_EMEP_subgrid )) then allocate ( orig_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) orig_EMEP_subgrid = 0. endif if (. not . allocated ( species_EMEP_subgrid ). and .( save_emep_species . or . save_seasalt )) then allocate ( species_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_pmxx_sp_index , n_species_loop_index )) species_EMEP_subgrid = 0. endif do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) x_subgrid ( i , j ) = subgrid_min ( x_dim_index ) + subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_subgrid ( i , j ) = subgrid_min ( y_dim_index ) + subgrid_delta ( y_dim_index ) * ( j - 0.5 ) call PROJ2LL ( x_subgrid ( i , j ), y_subgrid ( i , j ), lon_subgrid ( i , j ), lat_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_subgrid(i,j),x_subgrid(i,j),lat_subgrid(i,j),lon_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_subgrid(i,j),x_subgrid(i,j),lat_subgrid(i,j),lon_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_subgrid ( i , j ), yproj_subgrid ( i , j ), lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_subgrid ( i , j ), yproj_subgrid ( i , j ), lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_subgrid ( i , j ) = lon_subgrid ( i , j ) yproj_subgrid ( i , j ) = lat_subgrid ( i , j ) endif enddo enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( integral_subgrid )) deallocate ( integral_subgrid ) if ( allocated ( x_integral_subgrid )) deallocate ( x_integral_subgrid ) if ( allocated ( y_integral_subgrid )) deallocate ( y_integral_subgrid ) if ( allocated ( lon_integral_subgrid )) deallocate ( lon_integral_subgrid ) if ( allocated ( lat_integral_subgrid )) deallocate ( lat_integral_subgrid ) if ( allocated ( xproj_integral_subgrid )) deallocate ( xproj_integral_subgrid ) if ( allocated ( yproj_integral_subgrid )) deallocate ( yproj_integral_subgrid ) if ( allocated ( meteo_nc_xproj_integral_subgrid )) deallocate ( meteo_nc_xproj_integral_subgrid ) if ( allocated ( meteo_nc_yproj_integral_subgrid )) deallocate ( meteo_nc_yproj_integral_subgrid ) !Define integral grid if (. not . allocated ( integral_subgrid )) allocate ( integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_dim ( t_dim_index ), n_integral_subgrid_index , n_source_index , n_pollutant_loop )) if (. not . allocated ( x_integral_subgrid )) allocate ( x_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_integral_subgrid )) allocate ( y_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_integral_subgrid )) allocate ( lon_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_integral_subgrid )) allocate ( lat_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_integral_subgrid )) allocate ( xproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_integral_subgrid )) allocate ( yproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if ( use_alternative_meteorology_flag ) then if (. not . allocated ( meteo_nc_xproj_integral_subgrid )) allocate ( meteo_nc_xproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( meteo_nc_yproj_integral_subgrid )) allocate ( meteo_nc_yproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) endif integral_subgrid = 0. do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) x_integral_subgrid ( i , j ) = integral_subgrid_min ( x_dim_index ) + integral_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_integral_subgrid ( i , j ) = integral_subgrid_min ( y_dim_index ) + integral_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) call PROJ2LL ( x_integral_subgrid ( i , j ), y_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_integral_subgrid(i,j),x_integral_subgrid(i,j),lat_integral_subgrid(i,j),lon_integral_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_integral_subgrid(i,j),x_integral_subgrid(i,j),lat_integral_subgrid(i,j),lon_integral_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_integral_subgrid ( i , j ), yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_integral_subgrid ( i , j ), yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_integral_subgrid ( i , j ) = lon_integral_subgrid ( i , j ) yproj_integral_subgrid ( i , j ) = lat_integral_subgrid ( i , j ) endif if ( use_alternative_meteorology_flag ) then if ( meteo_nc_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( meteo_nc_xproj_integral_subgrid ( i , j ), meteo_nc_yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) elseif ( meteo_nc_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( meteo_nc_xproj_integral_subgrid ( i , j ), meteo_nc_yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) else meteo_nc_xproj_integral_subgrid ( i , j ) = lon_integral_subgrid ( i , j ) meteo_nc_yproj_integral_subgrid ( i , j ) = lat_integral_subgrid ( i , j ) endif endif enddo enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( meteo_subgrid )) deallocate ( meteo_subgrid ) if ( allocated ( last_meteo_subgrid )) deallocate ( last_meteo_subgrid ) !Define meteo grid, same positional coordinates as the integral grid (lower resolution) if (. not . allocated ( meteo_subgrid )) allocate ( meteo_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_dim ( t_dim_index ), n_meteo_subgrid_index )) if (. not . allocated ( last_meteo_subgrid )) allocate ( last_meteo_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), n_meteo_subgrid_index )) !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( use_subgrid )) deallocate ( use_subgrid ) !if (allocated(use_subgrid_val)) deallocate (use_subgrid_val) if ( allocated ( use_subgrid_interpolation_index )) deallocate ( use_subgrid_interpolation_index ) !Allocate the use_subgrid array and set to true for all subgrids if (. not . allocated ( use_subgrid )) allocate ( use_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_source_index )) !if (.not.allocated(use_subgrid_val)) allocate (use_subgrid_val(subgrid_dim(x_dim_index),subgrid_dim(y_dim_index),n_source_index)) if (. not . allocated ( use_subgrid_interpolation_index )) allocate ( use_subgrid_interpolation_index ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_source_index )) use_subgrid = . true . !use_subgrid_val=1 !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( proxy_emission_subgrid )) deallocate ( proxy_emission_subgrid ) if ( allocated ( emission_subgrid )) deallocate ( emission_subgrid ) if ( allocated ( x_emission_subgrid )) deallocate ( x_emission_subgrid ) if ( allocated ( y_emission_subgrid )) deallocate ( y_emission_subgrid ) if ( allocated ( lon_emission_subgrid )) deallocate ( lon_emission_subgrid ) if ( allocated ( lat_emission_subgrid )) deallocate ( lat_emission_subgrid ) if ( allocated ( xproj_emission_subgrid )) deallocate ( xproj_emission_subgrid ) if ( allocated ( yproj_emission_subgrid )) deallocate ( yproj_emission_subgrid ) if ( allocated ( emission_time_profile_subgrid )) deallocate ( emission_time_profile_subgrid ) if ( allocated ( emission_properties_subgrid )) deallocate ( emission_properties_subgrid ) !Allocate emission grids with same dimensions as the maximum emission subgrid if (. not . allocated ( proxy_emission_subgrid )) allocate ( proxy_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( emission_subgrid )) allocate ( emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( x_emission_subgrid )) allocate ( x_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( y_emission_subgrid )) allocate ( y_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lon_emission_subgrid )) allocate ( lon_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lat_emission_subgrid )) allocate ( lat_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( emission_time_profile_subgrid )) allocate ( emission_time_profile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( xproj_emission_subgrid )) allocate ( xproj_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( yproj_emission_subgrid )) allocate ( yproj_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( emission_properties_subgrid )) allocate ( emission_properties_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_emission_index , n_source_index )) emission_time_profile_subgrid = 1. proxy_emission_subgrid = 0. emission_subgrid = 0. emission_properties_subgrid = 0. !Define emission grids do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) x_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( x_dim_index , i_source ) + emission_subgrid_delta ( x_dim_index , i_source ) * ( i - 0.5 ) y_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( y_dim_index , i_source ) + emission_subgrid_delta ( y_dim_index , i_source ) * ( j - 0.5 ) call PROJ2LL ( x_emission_subgrid ( i , j , i_source ), y_emission_subgrid ( i , j , i_source ), lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), projection_attributes , projection_type ) !if (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_emission_subgrid(i,j,i_source),x_emission_subgrid(i,j,i_source), & !    lat_emission_subgrid(i,j,i_source),lon_emission_subgrid(i,j,i_source)) !elseif (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_emission_subgrid(i,j,i_source),x_emission_subgrid(i,j,i_source), & !    lat_emission_subgrid(i,j,i_source),lon_emission_subgrid(i,j,i_source)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_emission_subgrid ( i , j , i_source ), yproj_emission_subgrid ( i , j , i_source ), lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_emission_subgrid ( i , j , i_source ), yproj_emission_subgrid ( i , j , i_source ), lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) else xproj_emission_subgrid ( i , j , i_source ) = lon_emission_subgrid ( i , j , i_source ) yproj_emission_subgrid ( i , j , i_source ) = lat_emission_subgrid ( i , j , i_source ) endif enddo enddo endif enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( population_subgrid )) deallocate ( population_subgrid ) if ( allocated ( x_population_subgrid )) deallocate ( x_population_subgrid ) if ( allocated ( y_population_subgrid )) deallocate ( y_population_subgrid ) if ( allocated ( lon_population_subgrid )) deallocate ( lon_population_subgrid ) if ( allocated ( lat_population_subgrid )) deallocate ( lat_population_subgrid ) if ( allocated ( xproj_population_subgrid )) deallocate ( xproj_population_subgrid ) if ( allocated ( yproj_population_subgrid )) deallocate ( yproj_population_subgrid ) !Define population grid if (. not . allocated ( population_subgrid )) allocate ( population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ), n_population_index )) if (. not . allocated ( x_population_subgrid )) allocate ( x_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_population_subgrid )) allocate ( y_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_population_subgrid )) allocate ( lon_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_population_subgrid )) allocate ( lat_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_population_subgrid )) allocate ( xproj_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_population_subgrid )) allocate ( yproj_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) population_subgrid = 0 do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) x_population_subgrid ( i , j ) = population_subgrid_min ( x_dim_index ) + population_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_population_subgrid ( i , j ) = population_subgrid_min ( y_dim_index ) + population_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the population call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ), lon_population_subgrid ( i , j ), lat_population_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_population_subgrid(i,j),x_population_subgrid(i,j),lat_population_subgrid(i,j),lon_population_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_population_subgrid(i,j),x_population_subgrid(i,j),lat_population_subgrid(i,j),lon_population_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_population_subgrid ( i , j ), yproj_population_subgrid ( i , j ), lon_population_subgrid ( i , j ), lat_population_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_population_subgrid ( i , j ), yproj_population_subgrid ( i , j ), lon_population_subgrid ( i , j ), lat_population_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_population_subgrid ( i , j ) = lon_population_subgrid ( i , j ) yproj_population_subgrid ( i , j ) = lat_population_subgrid ( i , j ) endif enddo enddo !Place some properties in the emission properties subgrid do j = 1 , emission_max_subgrid_dim ( y_dim_index ) do i = 1 , emission_max_subgrid_dim ( x_dim_index ) emission_properties_subgrid ( i , j , emission_h_index ,:) = h_emis (:, subsource_index ) emission_properties_subgrid ( i , j , emission_sigz00_index ,:) = sig_z_00 (:, subsource_index ) emission_properties_subgrid ( i , j , emission_sigy00_index ,:) = sig_y_00 (:, subsource_index ) enddo enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( calculate_deposition_flag ) then if ( allocated ( orig_EMEP_deposition_subgrid )) deallocate ( orig_EMEP_deposition_subgrid ) if ( allocated ( deposition_subgrid )) deallocate ( deposition_subgrid ) if ( allocated ( x_deposition_subgrid )) deallocate ( x_deposition_subgrid ) if ( allocated ( y_deposition_subgrid )) deallocate ( y_deposition_subgrid ) if ( allocated ( lon_deposition_subgrid )) deallocate ( lon_deposition_subgrid ) if ( allocated ( lat_deposition_subgrid )) deallocate ( lat_deposition_subgrid ) if ( allocated ( xproj_deposition_subgrid )) deallocate ( xproj_deposition_subgrid ) if ( allocated ( yproj_deposition_subgrid )) deallocate ( yproj_deposition_subgrid ) !Define deposition grid if (. not . allocated ( orig_EMEP_deposition_subgrid )) allocate ( orig_EMEP_deposition_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_deposition_index , n_compound_index )) if (. not . allocated ( deposition_subgrid )) allocate ( deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), deposition_subgrid_dim ( t_dim_index ), n_deposition_index , n_pollutant_loop )) if (. not . allocated ( x_deposition_subgrid )) allocate ( x_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_deposition_subgrid )) allocate ( y_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_deposition_subgrid )) allocate ( lon_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_deposition_subgrid )) allocate ( lat_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_deposition_subgrid )) allocate ( xproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_deposition_subgrid )) allocate ( yproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) orig_EMEP_deposition_subgrid = 0 deposition_subgrid = 0 do j = 1 , deposition_subgrid_dim ( y_dim_index ) do i = 1 , deposition_subgrid_dim ( x_dim_index ) x_deposition_subgrid ( i , j ) = deposition_subgrid_min ( x_dim_index ) + deposition_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_deposition_subgrid ( i , j ) = deposition_subgrid_min ( y_dim_index ) + deposition_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the deposition call PROJ2LL ( x_deposition_subgrid ( i , j ), y_deposition_subgrid ( i , j ), lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_deposition_subgrid(i,j),x_deposition_subgrid(i,j),lat_deposition_subgrid(i,j),lon_deposition_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_deposition_subgrid(i,j),x_deposition_subgrid(i,j),lat_deposition_subgrid(i,j),lon_deposition_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_deposition_subgrid ( i , j ), yproj_deposition_subgrid ( i , j ), lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_deposition_subgrid ( i , j ), yproj_deposition_subgrid ( i , j ), lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_deposition_subgrid ( i , j ) = lon_deposition_subgrid ( i , j ) yproj_deposition_subgrid ( i , j ) = lat_deposition_subgrid ( i , j ) endif enddo enddo endif if ( read_landuse_flag ) then !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( landuse_subgrid )) deallocate ( landuse_subgrid ) if ( allocated ( x_landuse_subgrid )) deallocate ( x_landuse_subgrid ) if ( allocated ( y_landuse_subgrid )) deallocate ( y_landuse_subgrid ) if ( allocated ( lon_landuse_subgrid )) deallocate ( lon_landuse_subgrid ) if ( allocated ( lat_landuse_subgrid )) deallocate ( lat_landuse_subgrid ) if ( allocated ( xproj_landuse_subgrid )) deallocate ( xproj_landuse_subgrid ) if ( allocated ( yproj_landuse_subgrid )) deallocate ( yproj_landuse_subgrid ) !Define landuse grid if (. not . allocated ( landuse_subgrid )) allocate ( landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ), n_landuse_index )) if (. not . allocated ( x_landuse_subgrid )) allocate ( x_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_landuse_subgrid )) allocate ( y_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_landuse_subgrid )) allocate ( lon_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_landuse_subgrid )) allocate ( lat_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_landuse_subgrid )) allocate ( xproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_landuse_subgrid )) allocate ( yproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) landuse_subgrid = 0 do j = 1 , landuse_subgrid_dim ( y_dim_index ) do i = 1 , landuse_subgrid_dim ( x_dim_index ) x_landuse_subgrid ( i , j ) = landuse_subgrid_min ( x_dim_index ) + landuse_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_landuse_subgrid ( i , j ) = landuse_subgrid_min ( y_dim_index ) + landuse_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the landuse call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_landuse_subgrid ( i , j ) = lon_landuse_subgrid ( i , j ) yproj_landuse_subgrid ( i , j ) = lat_landuse_subgrid ( i , j ) endif enddo enddo endif !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( exposure_subgrid )) deallocate ( exposure_subgrid ) !Define exposure subgrid if (. not . allocated ( exposure_subgrid )) allocate ( exposure_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) end subroutine uEMEP_define_subgrid","tags":"","loc":"proc/uemep_define_subgrid.html"},{"title":"uEMEP_calculate_exposure – uEMEP","text":"public  subroutine uEMEP_calculate_exposure() Arguments None Source Code subroutine uEMEP_calculate_exposure () integer :: i , j integer :: i_source integer :: i_cross , j_cross real :: weighted_concentration ( n_source_index , n_pollutant_loop ) real :: subgrid_area_scaling real :: population_total ( n_pollutant_loop ) real :: max_val ( n_pollutant_loop ) integer :: i_max ( n_pollutant_loop ), j_max ( n_pollutant_loop ), i_cross_max ( n_pollutant_loop ), j_cross_max ( n_pollutant_loop ) real :: val_limit ( n_compound_nc_index ) real :: pop_over_limit ( subgrid_dim ( t_dim_index ), n_pollutant_loop ) real :: grids_over_limit ( subgrid_dim ( t_dim_index ), n_pollutant_loop ) integer :: t integer :: i_pollutant write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating exposure (uEMEP_calculate_exposure)' write ( unit_logfile , '(A)' ) '================================================================' ! Loop through target grid and find the population exposure_subgrid = 0.0 subgrid_area_scaling = 1.0 ! Scale population due to difference in grid size sizes only when population grid is used ! Only works when the target subgrid is smaller than the population subgrid if ( population_index . eq . 2 ) then ! This does not work when target grid is larger than the population grid subgrid_area_scaling = ( subgrid_delta ( x_dim_index ) * subgrid_delta ( y_dim_index )) / ( population_subgrid_delta ( x_dim_index ) * population_subgrid_delta ( y_dim_index )) end if population_total = 0 max_val = - 1.0 pop_over_limit = 0.0 grids_over_limit = 0.0 val_limit ( no2_index ) = 10 0.0 ! TODO: Need to fix this later val_limit ( pm10_index ) = 5 0.0 ! TODO: Need to fix this later val_limit ( pm25_index ) = 3 0.0 ! TODO: Need to fix this later i_max = 0 ; j_max = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) i_cross = crossreference_target_to_population_subgrid ( i , j , x_dim_index ) j_cross = crossreference_target_to_population_subgrid ( i , j , y_dim_index ) do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . use_subgrid ( i , j , i_source )) then exposure_subgrid ( i , j ,:, i_source ,:) = subgrid ( i , j ,:, local_subgrid_index , i_source ,:) * population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling end if end do ! Calculate number over limit. Does not work for hourly data properly yet i_source = allsource_index do i_pollutant = 1 , n_pollutant_loop do t = 1 , subgrid_dim ( t_dim_index ) if ( use_subgrid ( i , j , i_source )) then if ( pollutant_loop_index ( i_pollutant ) . eq . no2_nc_index ) then if ( comp_subgrid ( i , j , t , pollutant_loop_index ( i_pollutant )) . gt . val_limit ( pollutant_loop_index ( i_pollutant ))) then pop_over_limit ( t , i_pollutant ) = pop_over_limit ( t , i_pollutant ) + population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling grids_over_limit ( t , i_pollutant ) = grids_over_limit ( t , i_pollutant ) + 1 end if end if end if end do if ( use_subgrid ( i , j , allsource_index )) then exposure_subgrid ( i , j ,:, allsource_index , i_pollutant ) = subgrid ( i , j ,:, total_subgrid_index , allsource_index , i_pollutant ) * population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling population_total ( i_pollutant ) = population_total ( i_pollutant ) + population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling if ( sum ( subgrid ( i , j ,:, total_subgrid_index , allsource_index , i_pollutant )) / subgrid_dim ( t_dim_index ) . gt . max_val ( i_pollutant )) then max_val ( i_pollutant ) = sum ( subgrid ( i , j ,:, total_subgrid_index , allsource_index , i_pollutant )) / subgrid_dim ( t_dim_index ) i_max ( i_pollutant ) = i j_max ( i_pollutant ) = j end if i_cross_max ( i_pollutant ) = crossreference_target_to_population_subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ), x_dim_index ) j_cross_max ( i_pollutant ) = crossreference_target_to_population_subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ), y_dim_index ) end if end do end do end do do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A)' ) 'Population weighted concentration and max time average concentration (with population) by source per period for ' // trim ( input_comp_name ) weighted_concentration ( allsource_index , i_pollutant ) = sum ( exposure_subgrid (:,:,:, allsource_index , i_pollutant )) / population_total ( i_pollutant ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,2f12.2,2f12.0)' ) 'Total ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , weighted_concentration ( allsource_index , i_pollutant ), max_val ( i_pollutant ), population_total ( i_pollutant ), population_subgrid ( i_cross_max ( i_pollutant ), j_cross_max ( i_pollutant ), population_data_type ) ! Calculate population weighted values for each source do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then weighted_concentration ( i_source , i_pollutant ) = sum ( exposure_subgrid (:,:,:, i_source , i_pollutant )) / population_total ( i_pollutant ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,2f12.2)' ) trim ( source_file_str ( i_source )) // ': ' , weighted_concentration ( i_source , i_pollutant ), sum ( subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, local_subgrid_index , i_source , i_pollutant )) / subgrid_dim ( t_dim_index ) end if end do write ( unit_logfile , '(A24,2f12.2)' ) 'nonlocal: ' , weighted_concentration ( allsource_index , i_pollutant ) - sum ( weighted_concentration (:, i_pollutant )) + weighted_concentration ( allsource_index , i_pollutant ), & 2 * sum ( subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, total_subgrid_index , allsource_index , i_pollutant )) / subgrid_dim ( t_dim_index ) - sum ( subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, local_subgrid_index ,:, i_pollutant )) / subgrid_dim ( t_dim_index ) ! In case of no2 recalculate the total and present it again as no2 and not nox if ( pollutant_loop_index ( i_pollutant ) . eq . nox_nc_index ) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) i_cross = crossreference_target_to_population_subgrid ( i , j , x_dim_index ) j_cross = crossreference_target_to_population_subgrid ( i , j , y_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then exposure_subgrid ( i , j ,:, allsource_index , i_pollutant ) = comp_subgrid ( i , j ,:, no2_nc_index ) * population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling end if end do end do weighted_concentration ( allsource_index , i_pollutant ) = sum ( exposure_subgrid (:,:,:, allsource_index , i_pollutant )) / population_total ( i_pollutant ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,2f12.2)' ) 'Total no2: ' , weighted_concentration ( allsource_index , i_pollutant ), sum ( comp_subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, no2_nc_index )) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,f12.2)' ) 'Population over limit: ' , maxval ( pop_over_limit ) write ( unit_logfile , '(A24,f12.2)' ) 'Grids over limit: ' , maxval ( grids_over_limit ) end if end do !pollutant loop end subroutine uEMEP_calculate_exposure","tags":"","loc":"proc/uemep_calculate_exposure.html"},{"title":"area_weighted_interpolation_function – uEMEP","text":"public  function area_weighted_interpolation_function(xgrid, ygrid, zgrid, xdim, ydim, delta, xval, yval) result(res) Returns the area weight value for a a point at position xval, yval from the grid values xgrid,ygrid,zgrid Arguments Type Intent Optional Attributes Name real, intent(in) :: xgrid (xdim,ydim) real, intent(in) :: ygrid (xdim,ydim) real, intent(in) :: zgrid (xdim,ydim) integer, intent(in) :: xdim integer, intent(in) :: ydim real, intent(in) :: delta (2) real, intent(in) :: xval real, intent(in) :: yval Return Value real Source Code function area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) result ( res ) !! Returns the area weight value for a a point at position xval, yval from the grid values xgrid,ygrid,zgrid integer , intent ( in ) :: xdim , ydim real , intent ( in ) :: delta ( 2 ) real , intent ( in ) :: xgrid ( xdim , ydim ), ygrid ( xdim , ydim ), zgrid ( xdim , ydim ) real , intent ( in ) :: xval , yval real :: res ! Local variables real :: zval real :: sum_weight real :: weighting integer :: i , j , ii , jj real :: xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min real :: xpos_max , xpos_min , ypos_max , ypos_min ! If only on grid available then return the value of that grid if ( xdim . eq . 1 . and . ydim . eq . 1 ) then res = zgrid ( xdim , ydim ) return endif ! Find grid index for position val i = 1 + floor (( xval - xgrid ( 1 , 1 )) / delta ( 1 ) + 0.5 ) j = 1 + floor (( yval - ygrid ( 1 , 1 )) / delta ( 2 ) + 0.5 ) i = max ( 1 , i ); i = min ( xdim , i ) j = max ( 1 , j ); j = min ( ydim , j ) if ( i . lt . 1 . or . j . lt . 1 . or . i . gt . xdim . or . j . gt . ydim ) then write ( * , '(A,4i6)' ) 'Interpolation out of range in area_weighted_interpolation_function. Stopping. (i,j,xdim,ydim)' , i , j , xdim , ydim write ( * , '(4f12.2)' ) xval , yval , xgrid ( 1 , 1 ), ygrid ( 1 , 1 ) stop 1 else xpos_area_max = xval + delta ( 1 ) / 2.0 xpos_area_min = xval - delta ( 1 ) / 2.0 ypos_area_max = yval + delta ( 2 ) / 2.0 ypos_area_min = yval - delta ( 2 ) / 2.0 zval = 0.0 sum_weight = 0.0 do jj = j - 1 , j + 1 do ii = i - 1 , i + 1 xpos_min = max ( xpos_area_min , xgrid ( ii , jj ) - delta ( 1 ) / 2.0 ) xpos_max = min ( xpos_area_max , xgrid ( ii , jj ) + delta ( 1 ) / 2.0 ) ypos_min = max ( ypos_area_min , ygrid ( ii , jj ) - delta ( 2 ) / 2.0 ) ypos_max = min ( ypos_area_max , ygrid ( ii , jj ) + delta ( 2 ) / 2.0 ) if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / delta ( 1 ) / delta ( 2 ) else weighting = 0.0 endif zval = zval + zgrid ( ii , jj ) * weighting sum_weight = sum_weight + weighting enddo enddo endif res = zval end function area_weighted_interpolation_function","tags":"","loc":"proc/area_weighted_interpolation_function.html"},{"title":"area_weighted_extended_interpolation_function – uEMEP","text":"public  function area_weighted_extended_interpolation_function(xgrid, ygrid, zgrid, xdim, ydim, delta, xval, yval, delta_val) result(res) Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid\nDelta_val can be any size Arguments Type Intent Optional Attributes Name real, intent(in) :: xgrid (xdim,ydim) real, intent(in) :: ygrid (xdim,ydim) real, intent(in) :: zgrid (xdim,ydim) integer, intent(in) :: xdim integer, intent(in) :: ydim real, intent(in) :: delta (2) real, intent(in) :: xval real, intent(in) :: yval real, intent(in) :: delta_val (2) Return Value real Source Code function area_weighted_extended_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval , delta_val ) result ( res ) !! Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid !! Delta_val can be any size integer , intent ( in ) :: xdim , ydim real , intent ( in ) :: delta ( 2 ) real , intent ( in ) :: delta_val ( 2 ) real , intent ( in ) :: xgrid ( xdim , ydim ), ygrid ( xdim , ydim ), zgrid ( xdim , ydim ) real , intent ( in ) :: xval , yval real :: res ! Local variables real :: zval , sum_weight , weighting real :: xpos_max , xpos_min , ypos_max , ypos_min real :: xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min integer :: i , j , ii , jj , iii , jjj integer :: ii_delta , jj_delta ! If only on grid available then return the value of that grid if ( xdim . eq . 1 . and . ydim . eq . 1 ) then res = zgrid ( xdim , ydim ) return endif ! Find grid index for position val i = 1 + floor (( xval - xgrid ( 1 , 1 )) / delta ( 1 ) + 0.5 ) j = 1 + floor (( yval - ygrid ( 1 , 1 )) / delta ( 2 ) + 0.5 ) i = max ( 1 , i ); i = min ( xdim , i ) j = max ( 1 , j ); j = min ( ydim , j ) if ( i . lt . 1 . or . j . lt . 1 . or . i . gt . xdim . or . j . gt . ydim ) then write ( * , '(A,4i6)' ) 'Interpolation out of range in area_weighted_extended_interpolation_function. Stopping. (i,j,xdim,ydim)' , i , j , xdim , ydim write ( * , '(4f12.2)' ) xval , yval , xgrid ( 1 , 1 ), ygrid ( 1 , 1 ) stop else xpos_area_max = xval + delta_val ( 1 ) / 2.0 xpos_area_min = xval - delta_val ( 1 ) / 2.0 ypos_area_max = yval + delta_val ( 2 ) / 2.0 ypos_area_min = yval - delta_val ( 2 ) / 2.0 jj_delta = 1 + floor ( 0.5 * ( delta_val ( 2 ) / delta ( 2 ) - 1.0 )) ii_delta = 1 + floor ( 0.5 * ( delta_val ( 1 ) / delta ( 1 ) - 1.0 )) zval = 0.0 sum_weight = 0.0 do jjj = j - jj_delta , j + jj_delta do iii = i - ii_delta , i + ii_delta jj = max ( jjj , 1 ); jj = min ( jj , ydim ) ii = max ( iii , 1 ); ii = min ( ii , xdim ) xpos_min = max ( xpos_area_min , xgrid ( ii , jj ) - delta ( 1 ) / 2.0 ) xpos_max = min ( xpos_area_max , xgrid ( ii , jj ) + delta ( 1 ) / 2.0 ) ypos_min = max ( ypos_area_min , ygrid ( ii , jj ) - delta ( 2 ) / 2.0 ) ypos_max = min ( ypos_area_max , ygrid ( ii , jj ) + delta ( 2 ) / 2.0 ) if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / delta_val ( 1 ) / delta_val ( 2 ) else weighting = 0.0 endif zval = zval + zgrid ( ii , jj ) * weighting sum_weight = sum_weight + weighting enddo enddo endif res = zval end function area_weighted_extended_interpolation_function","tags":"","loc":"proc/area_weighted_extended_interpolation_function.html"},{"title":"area_weighted_extended_vectorgrid_interpolation_function – uEMEP","text":"public  function area_weighted_extended_vectorgrid_interpolation_function(xgrid, ygrid, zgrid, xdim, ydim, delta, xval, yval, delta_val) result(res) Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid\nDelta_val can be any size\nvectorgrid means the grid positions only have one dimension Arguments Type Intent Optional Attributes Name real, intent(in) :: xgrid (xdim) real, intent(in) :: ygrid (ydim) real, intent(in) :: zgrid (xdim,ydim) integer, intent(in) :: xdim integer, intent(in) :: ydim real, intent(in) :: delta (2) real, intent(in) :: xval real, intent(in) :: yval real, intent(in) :: delta_val (2) Return Value real Source Code function area_weighted_extended_vectorgrid_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval , delta_val ) result ( res ) !! Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid !! Delta_val can be any size !! vectorgrid means the grid positions only have one dimension integer , intent ( in ) :: xdim , ydim real , intent ( in ) :: delta ( 2 ) real , intent ( in ) :: delta_val ( 2 ) real , intent ( in ) :: xgrid ( xdim ), ygrid ( ydim ), zgrid ( xdim , ydim ) real , intent ( in ) :: xval , yval real :: res ! Local variables real :: zval , sum_weight , weighting real :: xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min real :: xpos_max , xpos_min , ypos_max , ypos_min integer :: i , j , ii , jj , iii , jjj integer :: ii_delta , jj_delta ! If only on grid available then return the value of that grid if ( xdim . eq . 1 . and . ydim . eq . 1 ) then res = zgrid ( xdim , ydim ) return endif ! Find grid index for position val i = 1 + floor (( xval - xgrid ( 1 )) / delta ( 1 ) + 0.5 ) j = 1 + floor (( yval - ygrid ( 1 )) / delta ( 2 ) + 0.5 ) i = max ( 1 , i ); i = min ( xdim , i ) j = max ( 1 , j ); j = min ( ydim , j ) if ( i . lt . 1 . or . j . lt . 1 . or . i . gt . xdim . or . j . gt . ydim ) then write ( * , '(A,4i6)' ) 'Interpolation out of range in area_weighted_extended_interpolation_function. Stopping. (i,j,xdim,ydim)' , i , j , xdim , ydim write ( * , '(4f12.2)' ) xval , yval , xgrid ( 1 ), ygrid ( 1 ) stop else xpos_area_max = xval + delta_val ( 1 ) / 2.0 xpos_area_min = xval - delta_val ( 1 ) / 2.0 ypos_area_max = yval + delta_val ( 2 ) / 2.0 ypos_area_min = yval - delta_val ( 2 ) / 2.0 jj_delta = 1 + floor ( 0.5 * ( delta_val ( 2 ) / delta ( 2 ) - 1.0 )) ii_delta = 1 + floor ( 0.5 * ( delta_val ( 1 ) / delta ( 1 ) - 1.0 )) zval = 0.0 sum_weight = 0.0 do jjj = j - jj_delta , j + jj_delta do iii = i - ii_delta , i + ii_delta jj = max ( jjj , 1 ); jj = min ( jj , ydim ) ii = max ( iii , 1 ); ii = min ( ii , xdim ) xpos_min = max ( xpos_area_min , xgrid ( ii ) - delta ( 1 ) / 2.0 ) xpos_max = min ( xpos_area_max , xgrid ( ii ) + delta ( 1 ) / 2.0 ) ypos_min = max ( ypos_area_min , ygrid ( jj ) - delta ( 2 ) / 2.0 ) ypos_max = min ( ypos_area_max , ygrid ( jj ) + delta ( 2 ) / 2.0 ) if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / delta_val ( 1 ) / delta_val ( 2 ) else weighting = 0.0 endif zval = zval + zgrid ( ii , jj ) * weighting sum_weight = sum_weight + weighting enddo enddo endif res = zval end function area_weighted_extended_vectorgrid_interpolation_function","tags":"","loc":"proc/area_weighted_extended_vectorgrid_interpolation_function.html"},{"title":"uEMEP_set_constants – uEMEP","text":"public  subroutine uEMEP_set_constants() Uses uEMEP_definitions Doesn't exist but name is used\nDoesn't exist but name is used\nDoesn't exist but name is used. Will be calculated Arguments None Source Code subroutine uEMEP_set_constants use uEMEP_definitions implicit none integer i , j integer count character ( 256 ) deposition_str !Initialise some array flags replace_EMEP_local_with_subgrid_local = . false . calculate_source = . false . calculate_EMEP_source = . false . !Initialise the number of variables read in EMEP num_lc_var_nc = num_lc_var_nc_start frac_nc_index = num_var_nc_start + 1 local_nc_index = num_var_nc_start + 2 num_var_nc = num_var_nc_start + 2 frac_nc_loop_index = frac_nc_index local_nc_loop_index = local_nc_index lc_frac_nc_loop_index = lc_frac_nc_index lc_local_nc_loop_index = lc_local_nc_index min_frac_nc_loop_index = minval ( frac_nc_loop_index ) max_frac_nc_loop_index = maxval ( frac_nc_loop_index ) min_lc_frac_nc_loop_index = minval ( lc_frac_nc_loop_index ) max_lc_frac_nc_loop_index = maxval ( lc_frac_nc_loop_index ) !convert_local_to_fraction_loop_index(lc_local_nc_loop_index)=lc_frac_nc_loop_index dim_name_nc ( x_dim_nc_index ) = 'lon' dim_name_nc ( y_dim_nc_index ) = 'lat' dim_name_nc ( z_dim_nc_index ) = 'lev' dim_name_nc ( time_dim_nc_index ) = 'time' dim_name_nc ( xdist_dim_nc_index ) = 'x_dist' dim_name_nc ( ydist_dim_nc_index ) = 'y_dist' !Sectors. Default are SNAP sectors before reading config files uEMEP_to_EMEP_sector = 0 uEMEP_to_EMEP_sector ( traffic_index ) = 7 uEMEP_to_EMEP_sector ( shipping_index ) = 8 uEMEP_to_EMEP_sector ( agriculture_index ) = 10 uEMEP_to_EMEP_sector ( heating_index ) = 2 uEMEP_to_EMEP_sector ( industry_index ) = 3 !Used to be 4??? Changed when including the rest !Set replace value to -1 as flag uEMEP_to_EMEP_replace_sector =- 1 uEMEP_to_EMEP_sector ( publicpower_index ) = 1 uEMEP_to_EMEP_sector ( fugitive_index ) = 4 uEMEP_to_EMEP_sector ( solvents_index ) = 6 uEMEP_to_EMEP_sector ( aviation_index ) = 8 uEMEP_to_EMEP_sector ( offroad_index ) = 8 uEMEP_to_EMEP_sector ( waste_index ) = 9 uEMEP_to_EMEP_sector ( livestock_index ) = 10 uEMEP_to_EMEP_sector ( other_index ) = 5 uEMEP_to_EMEP_sector_str ( traffic_index ) = '07' uEMEP_to_EMEP_sector_str ( shipping_index ) = '08' uEMEP_to_EMEP_sector_str ( agriculture_index ) = '10' uEMEP_to_EMEP_sector_str ( heating_index ) = '02' uEMEP_to_EMEP_sector_str ( industry_index ) = '03' uEMEP_to_EMEP_sector_str ( publicpower_nc_index ) = '01' uEMEP_to_EMEP_sector_str ( fugitive_nc_index ) = '04' uEMEP_to_EMEP_sector_str ( solvents_nc_index ) = '06' uEMEP_to_EMEP_sector_str ( aviation_nc_index ) = '08' uEMEP_to_EMEP_sector_str ( offroad_nc_index ) = '08' uEMEP_to_EMEP_sector_str ( waste_nc_index ) = '09' uEMEP_to_EMEP_sector_str ( livestock_nc_index ) = '10' uEMEP_to_EMEP_sector_str ( other_nc_index ) = '05' !Concentrations var_name_nc = '' var_name_nc ( conc_nc_index , o3_nc_index , allsource_nc_index ) = 'o3' var_name_nc ( conc_nc_index , no2_nc_index , allsource_nc_index ) = 'no2' var_name_nc ( conc_nc_index , nox_nc_index , allsource_nc_index ) = 'nox' var_name_nc ( conc_nc_index , nh3_nc_index , allsource_nc_index ) = 'nh3' var_name_nc ( conc_nc_index , nh4_nc_index , allsource_nc_index ) = 'nh4' var_name_nc ( conc_nc_index , pm25_nc_index , allsource_nc_index ) = 'pm25' var_name_nc ( conc_nc_index , pm10_nc_index , allsource_nc_index ) = 'pm10' var_name_nc ( conc_nc_index , pmco_nc_index , allsource_nc_index ) = 'pmco' var_name_nc ( conc_nc_index , pmex_nc_index , allsource_nc_index ) = 'pmex' var_name_nc ( conc_nc_index , so2_nc_index , allsource_nc_index ) = 'so2' var_name_nc ( conc_nc_index , pm_nc_index , allsource_nc_index ) = 'pm' var_name_nc ( conc_nc_index , all_nc_index , allsource_nc_index ) = 'all' var_name_nc ( conc_nc_index , all_sand_nc_index , allsource_nc_index ) = 'all_sand' var_name_nc ( conc_nc_index , all_sand_salt_nc_index , allsource_nc_index ) = 'all_sand_salt' var_name_nc ( conc_nc_index , all_salt_nc_index , allsource_nc_index ) = 'all_salt' var_name_nc ( conc_nc_index , all_totals_nc_index , allsource_nc_index ) = 'all_totals' var_name_nc ( conc_nc_index , aaqd_totals_nc_index , allsource_nc_index ) = 'aaqd_totals' var_name_nc ( conc_nc_index , gp_totals_nc_index , allsource_nc_index ) = 'gp_totals' var_name_nc ( conc_nc_index , op_totals_nc_index , allsource_nc_index ) = 'op_totals' var_name_nc ( conc_nc_index , pm25_sand_nc_index , allsource_nc_index ) = 'pm25_sand' var_name_nc ( conc_nc_index , pm10_sand_nc_index , allsource_nc_index ) = 'pm10_sand' var_name_nc ( conc_nc_index , pm25_salt_nc_index , allsource_nc_index ) = 'pm25_salt' var_name_nc ( conc_nc_index , pm10_salt_nc_index , allsource_nc_index ) = 'pm10_salt' var_name_nc ( conc_nc_index , bap_nc_index , allsource_nc_index ) = 'bap' var_name_nc ( conc_nc_index , co_nc_index , allsource_nc_index ) = 'co' var_name_nc ( conc_nc_index , c6h6_nc_index , allsource_nc_index ) = 'benzene' var_name_nc ( conc_nc_index , somo35_nc_index , allsource_nc_index ) = 'somo35' var_name_nc ( conc_nc_index , comax_nc_index , allsource_nc_index ) = 'maxco' var_name_nc ( conc_nc_index , o3max_nc_index , allsource_nc_index ) = 'maxo3' var_name_nc ( conc_nc_index , o3_26th_nc_index , allsource_nc_index ) = '26th_o3' !Special extrasource file. Will be used if called with. use_alternative_ppm_variable_for_lf var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index ) = 'D3_ug_PPM25' var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index ) = 'D3_ug_PPM_C' !Local fractions var_name_nc ( frac_nc_index , nox_nc_index , traffic_nc_index ) = 'nox_sec07_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , traffic_nc_index ) = 'pmco_sec07_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , traffic_nc_index ) = 'pm25_sec07_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , shipping_nc_index ) = 'nox_sec08_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , shipping_nc_index ) = 'pm25_sec08_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , shipping_nc_index ) = 'pmco_sec08_local_fraction' var_name_nc ( frac_nc_index , nh3_nc_index , agriculture_nc_index ) = 'nh3_sec10_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , heating_nc_index ) = 'nox_sec02_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , heating_nc_index ) = 'pm25_sec02_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , heating_nc_index ) = 'pmco_sec02_local_fraction' !SNAP 1 is energy, SNAP 3 is combustion in manufacturing and SNAP 4 is process, all should be used but in Norway it is mostly process??? var_name_nc ( frac_nc_index , nox_nc_index , industry_nc_index ) = 'nox_sec04_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , industry_nc_index ) = 'pm25_sec04_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , industry_nc_index ) = 'pmco_sec04_local_fraction' !Total emissions. These arer reset later var_name_nc ( emis_nc_index , nh3_nc_index , allsource_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , allsource_nc_index ) = 'Emis_mgm2_nox' var_name_nc ( emis_nc_index , pmco_nc_index , allsource_nc_index ) = 'Emis_mgm2_pmco' var_name_nc ( emis_nc_index , pm25_nc_index , allsource_nc_index ) = 'Emis_mgm2_pm25' !Sector emissions var_name_nc ( emis_nc_index , nh3_nc_index , agriculture_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec7nox' var_name_nc ( emis_nc_index , pm25_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec7pm25' var_name_nc ( emis_nc_index , pmco_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec7pmco' var_name_nc ( emis_nc_index , nox_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec8nox' var_name_nc ( emis_nc_index , pm25_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec8pm25' var_name_nc ( emis_nc_index , pmco_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec8pmco' var_name_nc ( emis_nc_index , nox_nc_index , heating_nc_index ) = 'Emis_mgm2_sec2nox' var_name_nc ( emis_nc_index , pm25_nc_index , heating_nc_index ) = 'Emis_mgm2_sec2pm25' var_name_nc ( emis_nc_index , pmco_nc_index , heating_nc_index ) = 'Emis_mgm2_sec2pmco' var_name_nc ( emis_nc_index , nox_nc_index , industry_nc_index ) = 'Emis_mgm2_sec4nox' var_name_nc ( emis_nc_index , pm25_nc_index , industry_nc_index ) = 'Emis_mgm2_sec4pm25' var_name_nc ( emis_nc_index , pmco_nc_index , industry_nc_index ) = 'Emis_mgm2_sec4pmco' !Meteorology var_name_nc ( ugrid_nc_index , all_nc_index , allsource_nc_index ) = 'u_wind' var_name_nc ( vgrid_nc_index , all_nc_index , allsource_nc_index ) = 'v_wind' var_name_nc ( u10_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_u10' var_name_nc ( v10_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_v10' var_name_nc ( FFgrid_nc_index , all_nc_index , allsource_nc_index ) = 'wind_speed' var_name_nc ( FF10_nc_index , all_nc_index , allsource_nc_index ) = 'ws10m' var_name_nc ( inv_FFgrid_nc_index , all_nc_index , allsource_nc_index ) = 'inv_wind_speed' var_name_nc ( inv_FF10_nc_index , all_nc_index , allsource_nc_index ) = 'inv_ws10m' var_name_nc ( hmix_nc_index , all_nc_index , allsource_nc_index ) = 'HMIX' var_name_nc ( kz_nc_index , all_nc_index , allsource_nc_index ) = 'Kz' var_name_nc ( ustar_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_ustar_nwp' var_name_nc ( logz0_nc_index , all_nc_index , allsource_nc_index ) = 'av_logz0' var_name_nc ( invL_nc_index , all_nc_index , allsource_nc_index ) = 'inv_L' var_name_nc ( J_nc_index , all_nc_index , allsource_nc_index ) = 'J(NO2)' var_name_nc ( ZTOP_nc_index , all_nc_index , allsource_nc_index ) = 'Z_TOP' var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_t2m' var_name_nc ( precip_nc_index , all_nc_index , allsource_nc_index ) = 'WDEP_PREC' !'precipitations' var_name_nc ( phi_nc_index , all_nc_index , allsource_nc_index ) = 'phi_nwp' surface_level_nc = 7 !Will be reset as length of 'lev' dimension !Alternative meteorology. dim_name_meteo_nc ( x_dim_nc_index ) = 'x' dim_name_meteo_nc ( y_dim_nc_index ) = 'y' dim_name_meteo_nc ( z_dim_nc_index ) = 'height3' dim_name_meteo_nc ( time_dim_nc_index ) = 'time' !Landuse dim_name_landuse_nc ( x_dim_nc_index ) = 'lon' dim_name_landuse_nc ( y_dim_nc_index ) = 'lat' var_name_landuse_nc = 'Band1' var_name_meteo_nc = '' !Depends which file you read unfortunately. My files lat, MEPS latitude WHY? !Put these in the config file !var_name_meteo_nc(lon_nc_index)='lon' !var_name_meteo_nc(lat_nc_index)='lat' var_name_meteo_nc ( lon_nc_index ) = 'longitude' var_name_meteo_nc ( lat_nc_index ) = 'latitude' var_name_meteo_nc ( ugrid_nc_index ) = 'u_wind' !!Doesn't exist but name is used var_name_meteo_nc ( vgrid_nc_index ) = 'v_wind' !!Doesn't exist but name is used var_name_meteo_nc ( FFgrid_nc_index ) = 'FF_wind' !Doesn't exist but name is used var_name_meteo_nc ( FF10_nc_index ) = 'wind_speed' var_name_meteo_nc ( inv_FFgrid_nc_index ) = '' var_name_meteo_nc ( inv_FF10_nc_index ) = '' var_name_meteo_nc ( hmix_nc_index ) = 'atmosphere_boundary_layer_thickness' var_name_meteo_nc ( kz_nc_index ) = '' var_name_meteo_nc ( ustar_nc_index ) = 'ustar' !Doesn't exist but name is used var_name_meteo_nc ( logz0_nc_index ) = 'Z0' !Needs to be converted to log(Z0) var_name_meteo_nc ( invL_nc_index ) = 'invL' !!Doesn't exist but name is used. Will be calculated var_name_meteo_nc ( J_nc_index ) = '' var_name_meteo_nc ( ZTOP_nc_index ) = '' var_name_meteo_nc ( t2m_nc_index ) = 'air_temperature_2m' var_name_meteo_nc ( precip_nc_index ) = 'precipitation_amount_acc' var_name_meteo_nc ( phi_nc_index ) = 'phi_nwp' !Additional     parameter (u10_nc_subgrid_index=22,v10_nc_subgrid_index=23,uw_nc_subgrid_index=24,vw_nc_subgrid_index=25,Hflux_nc_subgrid_index=26) var_name_meteo_nc ( u10_nc_index ) = 'x_wind_10m' !10 m wind not grid. Replaces ugrid. Used for direction var_name_meteo_nc ( v10_nc_index ) = 'y_wind_10m' !10 m wind not grid. Replaces vgrid. Used for direction var_name_meteo_nc ( uw_nc_index ) = 'downward_eastward_momentum_flux_in_air' !Will be used to determine ustar var_name_meteo_nc ( vw_nc_index ) = 'downward_northward_momentum_flux_in_air' !Will be used to determine ustar var_name_meteo_nc ( Hflux_nc_index ) = 'integral_of_surface_downward_sensible_heat_flux_wrt_time' !var_name_meteo_nc(rh2m_nc_index)='relative_humidity_2m' !var_name_meteo_nc(t0m_nc_index)='air_temperature_0m' !var_name_meteo_nc(t12m_nc_index)='air_temperature_ml' !This is at level 0 !var_name_meteo_nc(t100m_nc_index)='air_temperature_ml' !This is at model level 4 (0-4) !var_name_meteo_nc(SWflux_nc_index)='integral_of_surface_downwelling_shortwave_flux_in_air_wrt_time' !var_name_meteo_nc(LWflux_nc_index)='integral_of_surface_downwelling_longwave_flux_in_air_wrt_time' !var_name_meteo_nc(cloudcover_nc_index)='cloud_area_fraction' !var_name_meteo_nc(rain_nc_index)='precipitation_amount_acc' !var_name_meteo_nc(snow_nc_index)='snowfall_amount_acc' !var_name_meteo_nc(pressure_nc_index)='surface_air_pressure' !dim_name_population_nc(x_dim_nc_index)='x' !dim_name_population_nc(y_dim_nc_index)='y' dim_name_population_nc ( x_dim_nc_index ) = 'lon' dim_name_population_nc ( y_dim_nc_index ) = 'lat' !var_name_population_nc(lon_nc_index)='lon' !var_name_population_nc(lat_nc_index)='lat' var_name_population_nc ( population_nc_index ) = 'Band1' var_name_population_nc ( dwelling_nc_index ) = 'Band1' dim_name_shipping_nc ( x_dim_nc_index ) = 'lon' dim_name_shipping_nc ( y_dim_nc_index ) = 'lat' var_name_shipping_nc ( population_nc_index ) = 'nox' !Additional compounds for chemistry and totals comp_name_nc = '' comp_name_nc ( o3_nc_index ) = 'D3_ug_O3' comp_name_nc ( no2_nc_index ) = 'D3_ug_NO2' comp_name_nc ( nox_nc_index ) = 'D3_ugN_NOX' comp_name_nc ( nh3_nc_index ) = 'D3_ug_NH3' !comp_name_nc(nh3_nc_index)='nh3' comp_name_nc ( nh4_nc_index ) = 'D3_ug_NH4_F' !comp_name_nc(pm25_nc_index)='pm25' !comp_name_nc(pmco_nc_index)='D3_ug_PMCO' comp_name_nc ( pm10_nc_index ) = 'D3_ug_PM10' comp_name_nc ( pm25_nc_index ) = 'D3_ug_PM25' comp_name_nc ( pmex_nc_index ) = 'Exhaust' !comp_name_nc(pm25_nc_index)='SURF_ug_PM25_rh50' comp_name_nc ( co_nc_index ) = 'D3_ug_CO' comp_name_nc ( bap_nc_index ) = 'D3_ug_BAP' comp_name_nc ( c6h6_nc_index ) = 'D3_ug_BENZENE' comp_name_nc ( somo35_nc_index ) = 'SOMO35' comp_name_nc ( comax_nc_index ) = 'MaxD8M_CO' comp_name_nc ( o3max_nc_index ) = 'MaxD8M_O3' comp_name_nc ( o3_26th_nc_index ) = 'MaxD8M_O3_26th' comp_name_nc ( so2_nc_index ) = 'D3_ug_SO2' comp_name_nc ( pm25_sand_nc_index ) = 'PM25_sand' comp_name_nc ( pm10_sand_nc_index ) = 'PM10_sand' comp_name_nc ( pm25_salt_nc_index ) = 'PM25_salt' comp_name_nc ( pm10_salt_nc_index ) = 'PM10_salt' !Additional speciation of PM from EMEP species_name_nc = '' species_name_nc ( pm10_sp_index , sp_soa_index ) = 'pm10_EMEP_soa' species_name_nc ( pm25_sp_index , sp_soa_index ) = 'pm25_EMEP_soa' species_name_nc ( pm10_sp_index , sp_asoa_index ) = 'pm10_EMEP_asoa' species_name_nc ( pm25_sp_index , sp_asoa_index ) = 'pm25_EMEP_asoa' species_name_nc ( pm10_sp_index , sp_bsoa_index ) = 'pm10_EMEP_bsoa' species_name_nc ( pm25_sp_index , sp_bsoa_index ) = 'pm25_EMEP_bsoa' !species_name_nc(pm25_sp_index,sp_asoa_in_index)='SURF_ug_ASOA' !species_name_nc(pm25_sp_index,sp_bsoa_in_index)='SURF_ug_BSOA' species_name_nc ( pm25_sp_index , sp_asoa_in_index ) = 'SURF_ug_PM_ASOA' species_name_nc ( pm25_sp_index , sp_bsoa_in_index ) = 'SURF_ug_PM_BSOA' species_name_nc ( pm10_sp_index , sp_sia_index ) = 'pm10_EMEP_sia' species_name_nc ( pm25_sp_index , sp_sia_index ) = 'pm25_EMEP_sia' species_name_nc ( pm10_sp_index , sp_sia_in_index ) = 'SURF_ug_SIA' species_name_nc ( pm25_sp_index , sp_no3_index ) = 'SURF_ug_NO3_F' species_name_nc ( pm25_sp_index , sp_so4_index ) = 'SURF_ug_SO4' species_name_nc ( pm25_sp_index , sp_nh4_index ) = 'SURF_ug_NH4_F' species_name_nc ( pmco_sp_index , sp_no3_index ) = 'SURF_ug_NO3_C' species_name_nc ( pm10_sp_index , sp_dust_index ) = 'pm10_EMEP_dust' species_name_nc ( pm25_sp_index , sp_dust_index ) = 'pm25_EMEP_dust' species_name_nc ( pmco_sp_index , sp_dust_index ) = 'pmco_EMEP_dust' species_name_nc ( pmco_sp_index , sp_dust_sah_index ) = 'SURF_ug_DUST_SAH_C' species_name_nc ( pm25_sp_index , sp_dust_sah_index ) = 'SURF_ug_DUST_SAH_F' species_name_nc ( pmco_sp_index , sp_dust_wb_index ) = 'SURF_ug_DUST_WB_C' species_name_nc ( pm25_sp_index , sp_dust_wb_index ) = 'SURF_ug_DUST_WB_F' species_name_nc ( pm25_sp_index , sp_seasalt_index ) = 'pm25_EMEP_seasalt' species_name_nc ( pm10_sp_index , sp_seasalt_index ) = 'pm10_EMEP_seasalt' species_name_nc ( pm25_sp_index , sp_seasalt_in_index ) = 'SURF_ug_SEASALT_F' species_name_nc ( pmco_sp_index , sp_seasalt_in_index ) = 'SURF_ug_SEASALT_C' species_name_nc ( pm10_sp_index , sp_ffire_index ) = 'pm10_EMEP_fire' species_name_nc ( pm25_sp_index , sp_ffire_index ) = 'pm25_EMEP_fire' species_name_nc ( pm25_sp_index , sp_ffire_bc_index ) = 'SURF_ug_FFIRE_BC' species_name_nc ( pm25_sp_index , sp_ffire_rem_index ) = 'SURF_ug_FFIRE_REMPPM25' species_name_nc ( pm10_sp_index , sp_ppm_index ) = 'pm10_EMEP_ppm' species_name_nc ( pm25_sp_index , sp_ppm_index ) = 'pm25_EMEP_ppm' species_name_nc ( pm10_sp_index , sp_ppm_in_index ) = 'SURF_ug_PPM10' species_name_nc ( pm25_sp_index , sp_ppm_in_index ) = 'SURF_ug_PPM25' species_name_nc ( pmco_sp_index , sp_ppm_in_index ) = 'SURF_ug_PPM_C' species_name_nc ( pm10_sp_index , sp_pm_index ) = 'pm10_EMEP_total' species_name_nc ( pm25_sp_index , sp_pm_index ) = 'pm25_EMEP_total' species_name_nc ( pm10_sp_index , sp_pm_in_index ) = 'SURF_ug_PM10' species_name_nc ( pm25_sp_index , sp_pm_in_index ) = 'SURF_ug_PMFINE' !This must be set to FINE if SOA is to be derived by subtracting the other species !species_name_nc(pm25_sp_index,sp_pm_in_index)='SURF_ug_PM25' species_name_nc ( pmco_sp_index , sp_pm_in_index ) = 'SURF_ug_PMCO' species_name_nc ( pm10_sp_index , sp_water_index ) = 'pm10_EMEP_water' species_name_nc ( pm25_sp_index , sp_water_index ) = 'pm25_EMEP_water' species_name_nc ( pm10_sp_index , sp_water_in_index ) = '' !species_name_nc(pm25_sp_index,sp_pm_in_index)='SURF_ug_PMFINE' species_name_nc ( pm25_sp_index , sp_water_in_index ) = 'SURF_PM25water' !Additional compounds for OP calculations. From Willem !aSOA = ['SURF_ug_PM_ASOA'] !bSOA = ['SURF_ug_PM_BSOA'] !# BBOA: the POA from biomass burning (and other residential heating sources such as coal) !BBOA_f = ['SURF_ug_POM_F_RES', !                  'SURF_ug_EC_F_RES_NEW', !                  'SURF_ug_EC_F_RES_AGE', !                  'SURF_ug_REMPPM25_RES', !                  'SURF_ug_FFIRE_OM', !                  'SURF_ug_FFIRE_BC', !                  'SURF_ug_FFIRE_REMPPM25'] species_name_nc ( pm10_sp_index , sp_BBOA_index ) = 'pm10_EMEP_BBOA' species_name_nc ( pm25_sp_index , sp_BBOA_index ) = 'pm25_EMEP_BBOA' species_name_nc ( pmco_sp_index , sp_BBOA_index ) = 'pmco_EMEP_BBOA' species_name_nc ( pm10_sp_index , sp_BBOA_RES_index ) = 'pm10_EMEP_BBOA_RES' species_name_nc ( pm25_sp_index , sp_BBOA_RES_index ) = 'pm25_EMEP_BBOA_RES' species_name_nc ( pmco_sp_index , sp_BBOA_RES_index ) = 'pmco_EMEP_BBOA_RES' species_name_nc ( pm25_sp_index , sp_POM_RES_in_index ) = 'SURF_ug_POM_F_RES' species_name_nc ( pm25_sp_index , sp_EC_RES_NEW_in_index ) = 'SURF_ug_EC_F_RES_NEW' species_name_nc ( pm25_sp_index , sp_EC_RES_AGE_in_index ) = 'SURF_ug_EC_F_RES_AGE' species_name_nc ( pm25_sp_index , sp_REM_RES_in_index ) = 'SURF_ug_REMPPM25_RES' species_name_nc ( pm25_sp_index , sp_FFIRE_OM_in_index ) = 'SURF_ug_FFIRE_OM' species_name_nc ( pm25_sp_index , sp_FFIRE_BC_in_index ) = 'SURF_ug_FFIRE_BC' species_name_nc ( pm25_sp_index , sp_FFIRE_REM_in_index ) = 'SURF_ug_FFIRE_REMPPM25' !BBOA_c = ['SURF_ug_EC_C_RES', !                  'SURF_ug_POM_C_RES', !                   'SURF_ug_REMPPM_C_RES', !                   'SURF_ug_FFIRE_C'] species_name_nc ( pmco_sp_index , sp_EC_RES_in_index ) = 'SURF_ug_EC_C_RES' species_name_nc ( pmco_sp_index , sp_POM_RES_in_index ) = 'SURF_ug_POM_C_RES' species_name_nc ( pmco_sp_index , sp_REM_RES_in_index ) = 'SURF_ug_REMPPM_C_RES' species_name_nc ( pmco_sp_index , sp_FFIRE_in_index ) = 'SURF_ug_FFIRE_C' !OP_aSOA = 0.44 # nmol min-1 ug-1; multiply with the ug/m3 concs to get OP !OP_bSOA = 0.15 !OP_BBOA = 0.08 !----------------------------------------------------------- !And then for the non-exhaust and exhaust (HOA) contributions I combine the LFs with the LF pm25 and pmco fields, and multiply by: !OP_HOA = 0.94 # nmol min-1 ug-1 !OP_nonexh = 3.51 !Deposition names deposition_name_nc = '' i = nh3_nc_index if ( i . eq . nh3_nc_index ) deposition_str = 'NH3' deposition_name_nc ( temp_conif_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_CF' deposition_name_nc ( temp_decid_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_DF' deposition_name_nc ( med_needle_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_NF' deposition_name_nc ( med_broadleaf_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_BF' deposition_name_nc ( temp_crop_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_TC' deposition_name_nc ( med_crop_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_MC' deposition_name_nc ( root_crop_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_RC' deposition_name_nc ( moorland_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_SNL' deposition_name_nc ( grass_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_GR' deposition_name_nc ( medscrub_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_MS' deposition_name_nc ( wetlands_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_WE' deposition_name_nc ( tundra_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_TU' deposition_name_nc ( desert_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_DE' deposition_name_nc ( water_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_W' deposition_name_nc ( ice_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_ICE' deposition_name_nc ( urban_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_U' deposition_name_nc ( grid_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_Grid' var_name_nc ( wetdepo_nc_index , i , allsource_nc_index ) = 'WDEP_' // trim ( deposition_str ) var_name_nc ( drydepo_nc_index , i , allsource_nc_index ) = 'DDEP_' // trim ( deposition_str ) // '_m2Grid' comp_scale_nc (:) = 1. comp_scale_nc ( nox_nc_index ) = ( 1 4. + 2. * 1 6. ) / 1 4. !Value read in is in ugN converted to nh3 depo_scale_nc (:) = 1. depo_scale_nc ( nh3_nc_index ) = ( 1 4. + 3. * 1. ) / 1 4. !Value read in is in ugN converted to nh3 !Names for the OP calculations !Allocate the indexes for specifying compound and sources together. Never used and not correct either!!! count = 0 do i = 1 , size ( compound_source_index , 1 ) do j = 1 , size ( compound_source_index , 2 ) count = count + 1 compound_source_index ( i , j ) = count enddo enddo !Allocate source strings for writing to files source_file_str ( allsource_index ) = 'allsources' source_file_str ( traffic_index ) = 'traffic' source_file_str ( shipping_index ) = 'shipping' source_file_str ( agriculture_index ) = 'agriculture' source_file_str ( heating_index ) = 'heating' source_file_str ( industry_index ) = 'industry' source_file_str ( publicpower_index ) = 'publicpower' source_file_str ( fugitive_index ) = 'fugitive' source_file_str ( solvents_index ) = 'solvents' source_file_str ( aviation_index ) = 'aviation' source_file_str ( offroad_index ) = 'offroad' source_file_str ( waste_index ) = 'waste' source_file_str ( livestock_index ) = 'livestock' source_file_str ( other_index ) = 'other' source_file_str ( traffic_exhaust_index ) = 'traffic_exhaust' source_file_str ( traffic_nonexhaust_index ) = 'traffic_nonexhaust' do i = 1 , n_pollutant_nc_index pollutant_file_str ( i ) = var_name_nc ( conc_nc_index , i , allsource_nc_index ) enddo !do i=1,n_possible_subsource !    write(str_temp,'(i1)') i !    subsource_str(i)='_'//trim(str_temp) !enddo !Set filename indexes for grids generated by uEMEP j = 0 do i = 1 , n_source_index j = j + 1 ; proxy_emission_file_index ( i ) = j j = j + 1 ; emission_file_index ( i ) = j j = j + 1 ; proxy_file_index ( i ) = j j = j + 1 ; proxy_integral_file_index ( i ) = j j = j + 1 ; emep_subgrid_file_index ( i ) = j j = j + 1 ; emep_subgrid_nonlocal_file_index ( i ) = j j = j + 1 ; emep_subgrid_local_file_index ( i ) = j j = j + 1 ; emep_additional_subgrid_nonlocal_file_index ( i ) = j j = j + 1 ; emep_additional_subgrid_local_file_index ( i ) = j j = j + 1 ; emep_subgrid_semilocal_file_index ( i ) = j j = j + 1 ; subgrid_sourcetotal_inregion_file_index ( i ) = j j = j + 1 ; subgrid_sourcetotal_file_index ( i ) = j j = j + 1 ; emep_subgrid_frac_file_index ( i ) = j j = j + 1 ; subgrid_local_file_index ( i ) = j j = j + 1 ; subgrid_total_file_index ( i ) = j j = j + 1 ; use_subgrid_file_index ( i ) = j j = j + 1 ; emep_emission_subgrid_file_index ( i ) = j enddo do i = 1 , n_population_index j = j + 1 ; population_file_index ( i ) = j enddo j = j + 1 ; subgrid_ugrid_file_index = j j = j + 1 ; subgrid_vgrid_file_index = j j = j + 1 ; subgrid_u10_file_index = j j = j + 1 ; subgrid_v10_file_index = j j = j + 1 ; subgrid_hmix_file_index = j j = j + 1 ; subgrid_kz_file_index = j j = j + 1 ; subgrid_logz0_file_index = j j = j + 1 ; subgrid_invL_file_index = j j = j + 1 ; subgrid_FFgrid_file_index = j j = j + 1 ; subgrid_FF10_file_index = j j = j + 1 ; subgrid_DDgrid_file_index = j j = j + 1 ; subgrid_DD10_file_index = j j = j + 1 ; subgrid_invFFgrid_file_index = j j = j + 1 ; subgrid_invFF10_file_index = j j = j + 1 ; subgrid_ustar_file_index = j j = j + 1 ; subgrid_t2m_file_index = j j = j + 1 ; subgrid_J_file_index = j j = j + 1 ; subgrid_meteo_file_index = j !Set initial values  for the dispersion parameters sig_y_00 = 1 0. sig_z_00 = 1 0. h_emis = 1 5. z_rec = 2. h_emis ( traffic_index ,:) = 2. h_emis ( shipping_index ,:) = 7 0. h_emis ( heating_index ,:) = 1 5. h_emis ( agriculture_index ,:) = 1. h_emis ( industry_index ,:) = 10 0. h_emis ( aviation_index ,:) = 1 0. h_emis ( fugitive_index ,:) = 5. h_emis ( livestock_index ,:) = 5. h_emis ( solvents_index ,:) = 1 5. h_emis ( offroad_index ,:) = 5. h_emis ( waste_index ,:) = 1 5. sig_y_00 ( shipping_index ,:) = 5. sig_y_00 ( traffic_index ,:) = 1. sig_y_00 ( heating_index ,:) = 5. sig_y_00 ( agriculture_index ,:) = 5. sig_y_00 ( industry_index ,:) = 5. sig_y_00 ( aviation_index ,:) = 2 5. sig_z_00 ( shipping_index ,:) = 5. sig_z_00 ( traffic_index ,:) = 1. sig_z_00 ( heating_index ,:) = 1 0. sig_z_00 ( agriculture_index ,:) = 1 0. sig_z_00 ( industry_index ,:) = 1 0. sig_z_00 ( aviation_index ,:) = 1 0. !Set all emission factors to unity emission_factor = 1. !Set all no2, relative to nox, to 0.1. emission_factor ( no2_index ,:,:) = 0.1 !Preset all initial emission factors emission_factor ( nox_index , traffic_index ,:) = 0.4 !(g/km/veh) emission_factor ( nox_index , shipping_index ,:) = 1. !Shipping data is in emissions [tonne/month] emission_factor ( nox_index , heating_index ,:) = 3. / 1 5. !(kg/dwelling/year) Estimate only emission_factor ( nox_index , industry_index ,:) = 1. !Industry data is in emissions [tonne/year] emission_factor ( no2_index , traffic_index ,:) = 0.15 * emission_factor ( nox_index , traffic_index ,:) emission_factor ( no2_index , shipping_index ,:) = 0.10 * emission_factor ( nox_index , shipping_index ,:) emission_factor ( no2_index , heating_index ,:) = 0.1 * emission_factor ( nox_index , heating_index ,:) !(kg/dwelling/year) Estimate only emission_factor ( no2_index , industry_index ,:) = 0.10 * emission_factor ( nox_index , shipping_index ,:) emission_factor ( pm25_index , traffic_index ,:) = 0.01 !(g/km/veh) emission_factor ( pm25_index , shipping_index ,:) = 1. !Shipping data is in emissions [tonne/month] emission_factor ( pm25_index , heating_index ,:) = 3. !(kg/dwelling/year) SSB number is 6 emission_factor ( pm25_index , industry_index ,:) = 1. emission_factor ( pm10_index , traffic_index ,:) = 0.01 !(g/km/veh) emission_factor ( pm10_index , shipping_index ,:) = 1. !Shipping data is in emissions [tonne/month] emission_factor ( pm10_index , heating_index ,:) = 3. !(kg/dwelling/year) SSB number is 6 emission_factor ( pm10_index , industry_index ,:) = 1. emission_factor ( pmex_index , traffic_index ,:) = 0.01 !(g/km/veh) emission_factor ( nh3_index , agriculture_index ,:) = 1. !Agriculture data is in emissions [kg/yr] emission_factor ( nh4_index , agriculture_index ,:) = 1. !Agriculture data is in emissions [kg/yr] ratio_truck_car_emission ( nox_index ) = 1 2.5 !4.86/.318 !From excel sheet for NOx. 12.5 matches the values used in NORTRIP ratio_truck_car_emission ( no2_index ) = 1 2.5 !4.86/.318 !Should perhaps be different but ratio_truck_car_emission ( pm25_index ) = 1 0. ratio_truck_car_emission ( pm10_index ) = 1 0. ratio_truck_car_emission ( pmex_index ) = 1 0. !Set AQI thresholds aqi_hourly_limits ( no2_index , 1 ) = 10 0. ; aqi_hourly_limits ( no2_index , 2 ) = 20 0. ; aqi_hourly_limits ( no2_index , 3 ) = 40 0. ; !aqi_hourly_limits(pm10_index,1)=50.;aqi_hourly_limits(pm10_index,2)=80.;aqi_hourly_limits(pm10_index,3)=400.; !aqi_hourly_limits(pm25_index,1)=25.;aqi_hourly_limits(pm25_index,2)=40.;aqi_hourly_limits(pm25_index,3)=150.; aqi_hourly_limits ( pm10_index , 1 ) = 6 0. ; aqi_hourly_limits ( pm10_index , 2 ) = 12 0. ; aqi_hourly_limits ( pm10_index , 3 ) = 40 0. ; aqi_hourly_limits ( pm25_index , 1 ) = 3 0. ; aqi_hourly_limits ( pm25_index , 2 ) = 5 0. ; aqi_hourly_limits ( pm25_index , 3 ) = 15 0. ; aqi_hourly_limits ( o3_index , 1 ) = 10 0. ; aqi_hourly_limits ( o3_index , 2 ) = 18 0. ; aqi_hourly_limits ( o3_index , 3 ) = 24 0. ; aqi_daily_limits ( pm10_index , 1 ) = 3 0. ; aqi_daily_limits ( pm10_index , 2 ) = 5 0. ; aqi_daily_limits ( pm10_index , 3 ) = 15 0. ; aqi_daily_limits ( pm25_index , 1 ) = 1 5. ; aqi_daily_limits ( pm25_index , 2 ) = 2 5. ; aqi_daily_limits ( pm25_index , 3 ) = 7 5. ; !Not properly defined aqi_annual_limits ( no2_index , 1 ) = 0. ; aqi_annual_limits ( no2_index , 2 ) = 4 0. ; aqi_annual_limits ( no2_index , 3 ) = 4 0. ; aqi_annual_limits ( pm10_index , 1 ) = 0. ; aqi_annual_limits ( pm10_index , 2 ) = 2 5. ; aqi_annual_limits ( pm10_index , 3 ) = 3 5. ; aqi_annual_limits ( pm25_index , 1 ) = 0. ; aqi_annual_limits ( pm25_index , 2 ) = 1 5. ; aqi_annual_limits ( pm25_index , 3 ) = 2 5. ; !For temperature scaling traffic_nox_emission_temperature_ref_temperature ( 1 ) =- 1 5. traffic_nox_emission_temperature_ref_temperature ( 2 ) = 5. traffic_nox_emission_temperature_ref_scaling ( 1 ) = 3. traffic_nox_emission_temperature_ref_scaling ( 2 ) = 1. !EMEP projection default (LCC) !Pre feb 2020 values EMEP_projection_type = LCC_projection_index EMEP_projection_attributes ( 1 ) = 6 3.0 !Standard parallel 1 EMEP_projection_attributes ( 2 ) = 6 3.0 !Standard parallel 2 EMEP_projection_attributes ( 3 ) = 1 5.0 !lon0 EMEP_projection_attributes ( 4 ) = 6 3.0 !lat0 EMEP_projection_attributes ( 5 ) = 637100 0.0 !earth_radius EMEP_projection_attributes ( 6 ) = 1.e12 !flattening spherical earth. Never used? !uEMEP projection default (UTM) projection_type = UTM_projection_index projection_attributes ( 1 ) = utm_zone projection_attributes ( 2 ) = utm_lon0 !uEMEP projection alternative (LAEA) for European modelling. Can copy to config file if it is to be used !projection_type=LAEA_projection_index !projection_attributes(1) = 10.  !lon0 !projection_attributes(2) = 52.  !lat0 !projection_attributes(3) = 4321000.  !false_easting !projection_attributes(4) = 3210000.  !false_northing !projection_attributes(5) = 6370000.0  !earth_radius !These are used for landuse sector conversion only. They are already specified in uEMEP_to_EMEP_sector convert_GNFR_to_uEMEP_sector_index ( 1 ) = publicpower_nc_index convert_GNFR_to_uEMEP_sector_index ( 2 ) = industry_nc_index convert_GNFR_to_uEMEP_sector_index ( 3 ) = heating_nc_index convert_GNFR_to_uEMEP_sector_index ( 4 ) = fugitive_nc_index convert_GNFR_to_uEMEP_sector_index ( 5 ) = solvents_nc_index convert_GNFR_to_uEMEP_sector_index ( 6 ) = traffic_nc_index convert_GNFR_to_uEMEP_sector_index ( 7 ) = shipping_nc_index convert_GNFR_to_uEMEP_sector_index ( 8 ) = aviation_nc_index convert_GNFR_to_uEMEP_sector_index ( 9 ) = offroad_nc_index convert_GNFR_to_uEMEP_sector_index ( 10 ) = waste_nc_index convert_GNFR_to_uEMEP_sector_index ( 11 ) = livestock_nc_index convert_GNFR_to_uEMEP_sector_index ( 12 ) = agriculture_nc_index convert_GNFR_to_uEMEP_sector_index ( 13 ) = other_nc_index convert_uEMEP_to_GNFR_sector_index ( publicpower_nc_index ) = 1 convert_uEMEP_to_GNFR_sector_index ( industry_nc_index ) = 2 convert_uEMEP_to_GNFR_sector_index ( heating_nc_index ) = 3 convert_uEMEP_to_GNFR_sector_index ( fugitive_nc_index ) = 4 convert_uEMEP_to_GNFR_sector_index ( solvents_nc_index ) = 5 convert_uEMEP_to_GNFR_sector_index ( traffic_nc_index ) = 6 convert_uEMEP_to_GNFR_sector_index ( shipping_nc_index ) = 7 convert_uEMEP_to_GNFR_sector_index ( aviation_nc_index ) = 8 convert_uEMEP_to_GNFR_sector_index ( offroad_nc_index ) = 9 convert_uEMEP_to_GNFR_sector_index ( waste_nc_index ) = 10 convert_uEMEP_to_GNFR_sector_index ( livestock_nc_index ) = 11 convert_uEMEP_to_GNFR_sector_index ( agriculture_nc_index ) = 12 convert_uEMEP_to_GNFR_sector_index ( other_nc_index ) = 13 end subroutine uEMEP_set_constants","tags":"","loc":"proc/uemep_set_constants.html"},{"title":"uEMEP_set_pollutant_loop – uEMEP","text":"public  subroutine uEMEP_set_pollutant_loop() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_pollutant_loop use uEMEP_definitions implicit none integer p_loop !Set the pollutant index loops after reading in pollutant_index !Remove the sand and salt PM2.5, not necessary. Fixed ratio if needed n_pollutant_loop=6 if ( pollutant_index . eq . all_sand_salt_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 6 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_index ( 5 ) = pm10_sand_nc_index pollutant_loop_index ( 6 ) = pm10_salt_nc_index pollutant_loop_index ( 7 ) = pm25_sand_nc_index pollutant_loop_index ( 8 ) = pm25_salt_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 pollutant_loop_back_index ( pm10_sand_nc_index ) = 5 pollutant_loop_back_index ( pm10_salt_nc_index ) = 6 pollutant_loop_back_index ( pm25_sand_nc_index ) = 7 pollutant_loop_back_index ( pm25_salt_nc_index ) = 8 elseif ( pollutant_index . eq . all_salt_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 5 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_index ( 5 ) = pm10_salt_nc_index pollutant_loop_index ( 6 ) = pm25_salt_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 pollutant_loop_back_index ( pm10_salt_nc_index ) = 5 pollutant_loop_back_index ( pm25_salt_nc_index ) = 6 elseif ( pollutant_index . eq . all_sand_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 5 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_index ( 5 ) = pm10_sand_nc_index pollutant_loop_index ( 6 ) = pm25_sand_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 pollutant_loop_back_index ( pm10_sand_nc_index ) = 5 pollutant_loop_back_index ( pm25_sand_nc_index ) = 6 elseif ( pollutant_index . eq . all_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 4 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 elseif ( pollutant_index . eq . all_totals_nc_index ) then n_emep_pollutant_loop = 3 n_pollutant_loop = 3 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 elseif ( pollutant_index . eq . aaqd_totals_nc_index ) then n_emep_pollutant_loop = 6 n_pollutant_loop = 6 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = co_nc_index pollutant_loop_index ( 5 ) = bap_nc_index pollutant_loop_index ( 6 ) = c6h6_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( co_nc_index ) = 4 pollutant_loop_back_index ( bap_nc_index ) = 5 pollutant_loop_back_index ( c6h6_nc_index ) = 6 extract_benzene_from_voc_emissions = . true . elseif ( pollutant_index . eq . gp_totals_nc_index ) then n_emep_pollutant_loop = 4 n_pollutant_loop = 4 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = co_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( co_nc_index ) = 4 elseif ( pollutant_index . eq . op_totals_nc_index ) then n_emep_pollutant_loop = 3 n_pollutant_loop = 3 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 elseif ( pollutant_index . eq . pm_nc_index ) then n_emep_pollutant_loop = 2 n_pollutant_loop = 3 pollutant_loop_index ( 1 ) = pm25_nc_index pollutant_loop_index ( 2 ) = pm10_nc_index pollutant_loop_index ( 3 ) = pmex_nc_index pollutant_loop_back_index ( pm25_nc_index ) = 1 pollutant_loop_back_index ( pm10_nc_index ) = 2 pollutant_loop_back_index ( pmex_nc_index ) = 3 elseif ( pollutant_index . eq . nh3_nc_index ) then n_emep_pollutant_loop = 1 n_pollutant_loop = 1 pollutant_loop_index ( 1 ) = nh3_nc_index pollutant_loop_index ( 2 ) = nh4_nc_index pollutant_loop_back_index ( nh3_nc_index ) = 1 pollutant_loop_back_index ( nh4_nc_index ) = 2 else n_emep_pollutant_loop = 1 n_pollutant_loop = 1 pollutant_loop_index ( 1 ) = pollutant_index pollutant_loop_back_index ( pollutant_index ) = 1 !write(*,*) pollutant_loop_index(1),pollutant_index endif !Set indexing for additional compounds. Only used when reading in EMEP data do p_loop = 1 , n_pollutant_loop if ( pollutant_loop_index ( p_loop ). eq . nox_nc_index ) then n_pollutant_compound_loop ( p_loop ) = 3 pollutant_compound_loop_index ( p_loop , 1 ) = nox_nc_index pollutant_compound_loop_index ( p_loop , 2 ) = no2_nc_index pollutant_compound_loop_index ( p_loop , 3 ) = o3_nc_index !Add addition values to be read and saved if ( save_EMEP_somo35 ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = somo35_nc_index endif if ( save_EMEP_o3max ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = o3max_nc_index endif if ( save_EMEP_o3_26th ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = o3_26th_nc_index endif if ( save_EMEP_so2 ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = so2_nc_index endif elseif ( pollutant_loop_index ( p_loop ). eq . nh3_nc_index ) then n_pollutant_compound_loop ( p_loop ) = 2 pollutant_compound_loop_index ( p_loop , 1 ) = nh3_nc_index pollutant_compound_loop_index ( p_loop , 2 ) = nh4_nc_index elseif ( pollutant_loop_index ( p_loop ). eq . co_nc_index ) then n_pollutant_compound_loop ( p_loop ) = 1 pollutant_compound_loop_index ( p_loop , 1 ) = co_nc_index if ( save_EMEP_comax ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = comax_nc_index endif else n_pollutant_compound_loop ( p_loop ) = 1 pollutant_compound_loop_index ( p_loop , 1 ) = pollutant_loop_index ( p_loop ) endif enddo write ( unit_logfile , '(a,i)' ) 'Number of pollutants=' , n_pollutant_loop write ( unit_logfile , '(a,i)' ) 'Number of EMEP pollutants=' , n_emep_pollutant_loop end subroutine uEMEP_set_pollutant_loop","tags":"","loc":"proc/uemep_set_pollutant_loop.html"},{"title":"uEMEP_set_species_loop – uEMEP","text":"public  subroutine uEMEP_set_species_loop() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_species_loop use uEMEP_definitions implicit none integer s_loop !Set the pollutant index loops after reading in pollutant_index !Remove the sand and salt PM2.5, not necessary. Fixed ratio if needed n_pollutant_loop=6 if ( save_emep_species ) then n_species_loop_index = n_sp_index do s_loop = 1 , n_species_loop_index species_loop_index ( s_loop ) = s_loop enddo elseif ( save_seasalt ) then n_species_loop_index = 1 species_loop_index ( 1 ) = sp_seasalt_index else !No species will be read or chosen. Set to 0 to make sure it fails if they are n_species_loop_index = 1 species_loop_index ( 1 ) = 0 endif !Override the save_emep_species to include the OP species if ( save_emep_OP_species ) then n_species_loop_index = n_sp_OP_index do s_loop = 1 , n_species_loop_index species_loop_index ( s_loop ) = s_loop enddo endif write ( unit_logfile , '(a,i)' ) 'Number of species=' , n_species_loop_index !write(*,*) '####0: ',n_species_loop_index end subroutine uEMEP_set_species_loop","tags":"","loc":"proc/uemep_set_species_loop.html"},{"title":"uEMEP_reset_constants – uEMEP","text":"public  subroutine uEMEP_reset_constants() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_reset_constants !Reset some constants based on the configuration file input use uEMEP_definitions implicit none integer index_start character ( 256 ) prefix_str , postfix_str integer i , j character ( 8 ) sector_str_lf , sector_str_emis integer sector_index character ( 256 ) temp_str integer i_comp , i_source , p_loop character ( 256 ) local_fraction_naming_template_str_temp , local_fraction_grid_size_str if ( index ( alternative_meteorology_type , 'nortrip' ). gt . 0 ) then var_name_meteo_nc ( lon_nc_index ) = 'lon' var_name_meteo_nc ( lat_nc_index ) = 'lat' endif !Reset meteorological names if ( index ( alternative_meteorology_type , 'nbv' ). gt . 0 ) then dim_name_meteo_nc ( z_dim_nc_index ) = 'height4' var_name_meteo_nc ( lon_nc_index ) = 'lon' var_name_meteo_nc ( lat_nc_index ) = 'lat' var_name_meteo_nc ( hmix_nc_index ) = 'boundary_layer_height' var_name_meteo_nc ( logz0_nc_index ) = 'surface_roughness_momentum' !Needs to be converted to log(Z0) var_name_meteo_nc ( Hflux_nc_index ) = 'surface_upward_sensible_heat_flux' !Note this is upward not downward so must have a negative when read var_name_meteo_nc ( precip_nc_index ) = 'precipitation_amount' endif if ( use_EMEP_surface_ozone_flag ) then comp_name_nc ( o3_nc_index ) = 'SURF_ug_O3' endif !If GNFR19 emissions are true then so are the GNFR13 emissions if ( use_GNFR19_emissions_from_EMEP_flag ) use_GNFR_emissions_from_EMEP_flag = . true . !Set the emission sector index to be read to standard GNFR. !Not actually used now but could be used in the loop below if ( use_GNFR_emissions_from_EMEP_flag ) then uEMEP_to_EMEP_sector ( allsource_index ) = 0 uEMEP_to_EMEP_sector ( traffic_index ) = 6 uEMEP_to_EMEP_sector ( shipping_index ) = 7 uEMEP_to_EMEP_sector ( agriculture_index ) = 12 uEMEP_to_EMEP_sector ( heating_index ) = 3 uEMEP_to_EMEP_sector ( industry_index ) = 2 uEMEP_to_EMEP_sector ( publicpower_nc_index ) = 1 uEMEP_to_EMEP_sector ( fugitive_nc_index ) = 4 uEMEP_to_EMEP_sector ( solvents_nc_index ) = 5 uEMEP_to_EMEP_sector ( aviation_nc_index ) = 8 uEMEP_to_EMEP_sector ( offroad_nc_index ) = 9 uEMEP_to_EMEP_sector ( waste_nc_index ) = 10 uEMEP_to_EMEP_sector ( livestock_nc_index ) = 11 uEMEP_to_EMEP_sector ( other_nc_index ) = 13 uEMEP_to_EMEP_sector ( publicpower_point_nc_index ) = 14 uEMEP_to_EMEP_sector ( publicpower_area_nc_index ) = 15 uEMEP_to_EMEP_sector ( traffic_gasoline_nc_index ) = 16 uEMEP_to_EMEP_sector ( traffic_diesel_nc_index ) = 17 uEMEP_to_EMEP_sector ( traffic_gas_nc_index ) = 18 uEMEP_to_EMEP_sector ( traffic_nonexhaust_nc_index ) = 19 endif !Create the sector strings, different for emissions to the local fraction strings, no leading 0's do i_source = 1 , n_source_nc_index write ( temp_str , '(i2)' ) uEMEP_to_EMEP_sector ( i_source ) if ( uEMEP_to_EMEP_sector ( i_source ). lt . 10 ) then uEMEP_to_EMEP_sector_str ( i_source ) = '0' // trim ( adjustl ( temp_str )) else uEMEP_to_EMEP_sector_str ( i_source ) = trim ( temp_str ) endif write ( uEMEP_to_EMEP_emis_sector_str ( i_source ), '(i2)' ) uEMEP_to_EMEP_sector ( i_source ) uEMEP_to_EMEP_emis_sector_str ( i_source ) = adjustl ( uEMEP_to_EMEP_emis_sector_str ( i_source )) if ( i_source . eq . allsource_nc_index ) then uEMEP_to_EMEP_emis_sector_str ( i_source ) = '' uEMEP_to_EMEP_sector_str ( i_source ) = '' endif !write(*,*) i_source,uEMEP_to_EMEP_sector_str(i_source),' ',uEMEP_to_EMEP_emis_sector_str(i_source) enddo if ( use_alphabetic_GNFR_emissions_from_EMEP_flag ) then uEMEP_to_EMEP_emis_sector_str ( allsource_index ) = '' uEMEP_to_EMEP_emis_sector_str ( traffic_index ) = 'F' uEMEP_to_EMEP_emis_sector_str ( shipping_index ) = 'G' uEMEP_to_EMEP_emis_sector_str ( agriculture_index ) = 'L' uEMEP_to_EMEP_emis_sector_str ( heating_index ) = 'C' uEMEP_to_EMEP_emis_sector_str ( industry_index ) = 'B' uEMEP_to_EMEP_emis_sector_str ( publicpower_nc_index ) = 'A' uEMEP_to_EMEP_emis_sector_str ( fugitive_nc_index ) = 'D' uEMEP_to_EMEP_emis_sector_str ( solvents_nc_index ) = 'E' uEMEP_to_EMEP_emis_sector_str ( aviation_nc_index ) = 'H' uEMEP_to_EMEP_emis_sector_str ( offroad_nc_index ) = 'I' uEMEP_to_EMEP_emis_sector_str ( waste_nc_index ) = 'J' uEMEP_to_EMEP_emis_sector_str ( livestock_nc_index ) = 'K' uEMEP_to_EMEP_emis_sector_str ( other_nc_index ) = 'M' uEMEP_to_EMEP_emis_sector_str ( traffic_gasoline_nc_index ) = 'F1' uEMEP_to_EMEP_emis_sector_str ( traffic_diesel_nc_index ) = 'F2' uEMEP_to_EMEP_emis_sector_str ( traffic_gas_nc_index ) = 'F3' uEMEP_to_EMEP_emis_sector_str ( traffic_nonexhaust_nc_index ) = 'F4' uEMEP_to_EMEP_emis_sector_str ( publicpower_point_nc_index ) = 'A1' uEMEP_to_EMEP_emis_sector_str ( publicpower_area_nc_index ) = 'A2' uEMEP_to_EMEP_emis_sector_str ( traffic_exhaust_nc_index ) = 'F1-3' !Not read endif save_EMEP_source = calculate_EMEP_source !Automatically set these extra files to be read !Of these only the traffic exhaust and nonexhaust will be saved if ( use_GNFR19_emissions_from_EMEP_flag ) then calculate_EMEP_source ( traffic_gasoline_nc_index ) = . true . calculate_EMEP_source ( traffic_diesel_nc_index ) = . true . calculate_EMEP_source ( traffic_gas_nc_index ) = . true . calculate_EMEP_source ( publicpower_point_nc_index ) = . true . calculate_EMEP_source ( publicpower_area_nc_index ) = . true . calculate_EMEP_source ( traffic_exhaust_nc_index ) = . true . calculate_EMEP_source ( traffic_nonexhaust_nc_index ) = . true . !We do not want to add these since they are already in traffic but we do want to save them calculate_EMEP_source ( traffic_exhaust_nc_index ) = . false . calculate_EMEP_source ( traffic_nonexhaust_nc_index ) = . false . save_EMEP_source ( traffic_exhaust_nc_index ) = . true . save_EMEP_source ( traffic_nonexhaust_nc_index ) = . true . endif !integer GNFR_index(n_source_nc_index) !A 1 �PublicPower� (1) !B 2 �Industry� (3) !C 3 �OtherStationaryComb� (2) !D 4 �Fugitive� (4) !E 5 �Solvents� (6) !F 6 �RoadTransport� (7) !G 7 �Shipping� (8) !H 8 �Aviation� (8) !I 9 �Offroad� (8) !J 10 �Waste� (9) !K 11 �AgriLivestock� (10) !L 12 �AgriOther� (10) !M 13 �Other� (5) !These are for the previous EMEP version before 4.3.3 if ( use_GNFR_emissions_from_EMEP_flag ) then !Local fractions var_name_nc ( frac_nc_index , nox_nc_index , traffic_nc_index ) = 'nox_sec06_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , traffic_nc_index ) = 'pmco_sec06_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , traffic_nc_index ) = 'pm25_sec06_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , shipping_nc_index ) = 'nox_sec07_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , shipping_nc_index ) = 'pm25_sec07_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , shipping_nc_index ) = 'pmco_sec07_local_fraction' !var_name_nc(frac_nc_index,nh3_nc_index,agriculture_nc_index)='nh3_sec11_local_fraction' !var_name_nc(frac_nc_index,nh3_nc_index,agriculture_nc_index)='nh3_sec12_local_fraction' !Read as total for the time being as these have become two sectors now var_name_nc ( frac_nc_index , nh3_nc_index , agriculture_nc_index ) = 'nh3_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , heating_nc_index ) = 'nox_sec03_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , heating_nc_index ) = 'pm25_sec03_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , heating_nc_index ) = 'pmco_sec03_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , industry_nc_index ) = 'nox_sec02_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , industry_nc_index ) = 'pm25_sec02_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , industry_nc_index ) = 'pmco_sec02_local_fraction' !Total emissions remain the same var_name_nc ( emis_nc_index , nh3_nc_index , allsource_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , allsource_nc_index ) = 'Emis_mgm2_nox' var_name_nc ( emis_nc_index , pmco_nc_index , allsource_nc_index ) = 'Emis_mgm2_pmco' var_name_nc ( emis_nc_index , pm25_nc_index , allsource_nc_index ) = 'Emis_mgm2_pm25' !Sector emissions read as total var_name_nc ( emis_nc_index , nh3_nc_index , agriculture_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec6nox' var_name_nc ( emis_nc_index , pm25_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec6pm25' var_name_nc ( emis_nc_index , pmco_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec6pmco' var_name_nc ( emis_nc_index , nox_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec7nox' var_name_nc ( emis_nc_index , pm25_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec7pm25' var_name_nc ( emis_nc_index , pmco_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec7pmco' var_name_nc ( emis_nc_index , nox_nc_index , heating_nc_index ) = 'Emis_mgm2_sec3nox' var_name_nc ( emis_nc_index , pm25_nc_index , heating_nc_index ) = 'Emis_mgm2_sec3pm25' var_name_nc ( emis_nc_index , pmco_nc_index , heating_nc_index ) = 'Emis_mgm2_sec3pmco' var_name_nc ( emis_nc_index , nox_nc_index , industry_nc_index ) = 'Emis_mgm2_sec2nox' var_name_nc ( emis_nc_index , pm25_nc_index , industry_nc_index ) = 'Emis_mgm2_sec2pm25' var_name_nc ( emis_nc_index , pmco_nc_index , industry_nc_index ) = 'Emis_mgm2_sec2pmco' endif !General setting of names. Overrides all other presets do i_comp = 1 , n_pollutant_nc_index do i_source = 1 , n_source_nc_index var_name_nc ( frac_nc_index , i_comp , i_source ) = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_nc_index )) // '_sec' // trim ( uEMEP_to_EMEP_sector_str ( i_source )) // '_local_fraction' var_name_nc ( emis_nc_index , i_comp , i_source ) = 'Emis_mgm2_sec' // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // var_name_nc ( conc_nc_index , i_comp , allsource_nc_index ) if ( i_source . eq . allsource_nc_index ) then var_name_nc ( frac_nc_index , i_comp , i_source ) = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_nc_index )) // '_local_fraction' var_name_nc ( emis_nc_index , i_comp , i_source ) = 'Emis_mgm2_' // var_name_nc ( conc_nc_index , i_comp , allsource_nc_index ) endif if ( extract_benzene_from_voc_emissions . and . i_comp . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i_comp , i_source ) = 'Emis_mgm2_sec' // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // 'voc' endif !write(*,*) i_comp,i_source,trim(var_name_nc(frac_nc_index,i_comp,i_source)),trim(var_name_nc(emis_nc_index,i_comp,i_source)) enddo enddo if ( use_emission_naming_template_flag ) then !Set the prefix and postfix part of the emission name string based on the template !Assumes compound is added at the end index_start = INDEX ( emission_naming_template_str , '<n>' ) if ( index_start . eq . 0 ) then prefix_str = '' else prefix_str = emission_naming_template_str ( 1 : index_start - 1 ) endif if ( index_start + 3. gt . len_trim ( emission_naming_template_str )) then postfix_str = '' else postfix_str = emission_naming_template_str ( index_start + 3 :) endif !write(*,*) index_start,index_start+3,len_trim(emission_naming_template_str) if ( use_GNFR_emissions_from_EMEP_flag . or . use_alphabetic_GNFR_emissions_from_EMEP_flag ) then write ( unit_logfile , '(a)' ) 'Using emission name template for GNFR sectors: ' // trim ( emission_naming_template_str ) do i = 1 , n_pollutant_nc_index do i_source = 1 , n_source_nc_index var_name_nc ( emis_nc_index , i , i_source ) = trim ( prefix_str ) // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , i_source ) = trim ( prefix_str ) // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // trim ( postfix_str ) // 'voc' endif if ( i_source . eq . allsource_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // 'voc' endif if ( use_alphabetic_GNFR_emissions_from_EMEP_flag ) then !Remove any leading '_' in the postfix_str index_start = INDEX ( postfix_str , '_' ) if ( index_start . eq . 1 ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ( 2 :)) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ( 2 :)) // 'voc' endif else var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ) // 'voc' endif endif endif endif !write(*,*) i,i_source,trim(var_name_nc(emis_nc_index,i,i_source)) enddo enddo else write ( unit_logfile , '(a)' ) 'Using emission name template for SNAP sectors: ' // trim ( emission_naming_template_str ) do i = 1 , n_pollutant_nc_index do i_source = 1 , n_source_nc_index var_name_nc ( emis_nc_index , i , i_source ) = trim ( prefix_str ) // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( i_source . eq . allsource_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // 'voc' endif endif enddo enddo endif endif !Set the indexes for the local fraction data and increase the number of variables appropriately !Include a conversion array between the local and fraction arrays if ( use_local_fraction_naming_template_flag ) then i = 0 do j = 1 , n_local_fraction_grids i = i + 1 ; lc_frac_nc_loop_index ( j ) = i enddo do j = 1 , n_local_fraction_grids i = i + 1 ; lc_local_nc_loop_index ( j ) = i !convert_local_to_fraction_loop_index(lc_local_nc_loop_index(j))=lc_frac_nc_loop_index(j) enddo !do j=1,n_local_fraction_grids !    convert_fraction_to_local_loop_index(lc_fraction_nc_loop_index(j))=lc_local_nc_loop_index(j) !enddo num_lc_var_nc = i write ( unit_logfile , '(a,i)' ) 'New number of num_lc_var_nc variables with additional LF EMEP: ' , num_lc_var_nc min_lc_frac_nc_loop_index = minval ( lc_frac_nc_loop_index ) max_lc_frac_nc_loop_index = maxval ( lc_frac_nc_loop_index ) i = num_var_nc_start do j = 1 , n_local_fraction_grids i = i + 1 ; frac_nc_loop_index ( j ) = i convert_frac_to_lc_frac_loop_index ( frac_nc_loop_index ( j )) = lc_frac_nc_loop_index ( j ) !write(*,*) i,j,frac_nc_loop_index(j),convert_frac_to_lc_frac_loop_index(frac_nc_loop_index(j)) enddo do j = 1 , n_local_fraction_grids i = i + 1 ; local_nc_loop_index ( j ) = i enddo num_var_nc = i write ( unit_logfile , '(a,i)' ) 'New number of num_var_nc variables with additional LF EMEP: ' , num_var_nc min_frac_nc_loop_index = minval ( frac_nc_loop_index ) max_frac_nc_loop_index = maxval ( frac_nc_loop_index ) endif if ( use_local_fraction_naming_template_flag ) then !Set the prefix and postfix part of the emission name string based on the template !Assumes compound is added at the end do j = 1 , n_local_fraction_grids local_fraction_naming_template_str_temp = local_fraction_naming_template_str index_start = INDEX ( local_fraction_naming_template_str_temp , '<n>' ) if ( index_start . eq . 0 ) then prefix_str = '' else prefix_str = local_fraction_naming_template_str_temp ( 1 : index_start - 1 ) endif if ( index_start + 3. gt . len_trim ( local_fraction_naming_template_str_temp )) then postfix_str = '' else postfix_str = local_fraction_naming_template_str_temp ( index_start + 3 :) endif !Create the local fraction grid size for appending to the variable name write ( temp_str , '(i2)' ) local_fraction_grid_size ( j ) local_fraction_grid_size_str = '_' // trim ( adjustl ( temp_str )) // 'x' // trim ( adjustl ( temp_str )) if (. not . use_local_fraction_grid_size_in_template_flag ) then local_fraction_grid_size_str = '' endif !write(*,*) index_start,index_start+3,len_trim(emission_naming_template_str) write ( unit_logfile , '(a,i)' ) 'Using local fraction name template: ' // trim ( local_fraction_naming_template_str_temp ) // ' for lf grid = ' , j !do i=1,n_pollutant_nc_index do p_loop = 1 , n_emep_pollutant_loop + 1 if ( p_loop . le . n_emep_pollutant_loop ) then i = pollutant_loop_index ( p_loop ) else i = pmco_nc_index !Necessary to include this endif do i_source = 1 , n_source_nc_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . save_EMEP_source ( i_source ). or . i_source . eq . allsource_nc_index ) then var_name_nc ( frac_nc_loop_index ( j ), i , i_source ) = trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) // '_' // trim ( prefix_str ) // trim ( uEMEP_to_EMEP_sector_str ( i_source )) // trim ( postfix_str ) // trim ( local_fraction_grid_size_str ) if ( i_source . eq . allsource_nc_index ) then var_name_nc ( frac_nc_loop_index ( j ), i , allsource_nc_index ) = trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) // trim ( postfix_str ) // trim ( local_fraction_grid_size_str ) endif write ( unit_logfile , '(2i6,2a)' ) i , i_source , '  ' , trim ( var_name_nc ( frac_nc_loop_index ( j ), i , i_source )) endif enddo enddo enddo endif !Only works on the old sectors and lf names if ( use_user_specified_sectors_flag ) then write ( unit_logfile , '(a)' ) 'Replacing sector index in EMEP (sector,pollutant,lf_name,emis_name)' do sector_index = 0 , n_source_nc_index if ( calculate_source ( sector_index ). and . uEMEP_to_EMEP_replace_sector ( sector_index ). ge . 0 ) then !sector_index=traffic_nc_index write ( sector_str_lf , '(i0.2)' ) uEMEP_to_EMEP_replace_sector ( sector_index ) write ( sector_str_emis , '(i0.1)' ) uEMEP_to_EMEP_replace_sector ( sector_index ) if ( uEMEP_to_EMEP_replace_sector ( sector_index ). ne . 0 ) then sector_str_lf = '_sec' // trim ( sector_str_lf ) sector_str_emis = trim ( sector_str_emis ) else sector_str_lf = '' sector_str_emis = '' endif do i = 1 , n_pollutant_nc_index !Can fix the above problem here if ( use_local_fraction_naming_template_flag ) then var_name_nc ( frac_nc_index , i , sector_index ) = trim ( prefix_str ) // trim ( sector_str_lf ) // trim ( postfix_str ) else var_name_nc ( frac_nc_index , i , sector_index ) = trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) // trim ( sector_str_lf ) // '_local_fraction' endif !var_name_nc(frac_nc_index,pmco_nc_index,sector_index)='pmco'//trim(sector_str)//'_local_fraction' !var_name_nc(frac_nc_index,pm25_nc_index,sector_index)='pm25'//trim(sector_str)//'_local_fraction' if ( use_emission_naming_template_flag ) then var_name_nc ( emis_nc_index , i , sector_index ) = trim ( prefix_str ) // trim ( sector_str_emis ) // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) else var_name_nc ( emis_nc_index , i , sector_index ) = 'Emis_mgm2_sec' // trim ( sector_str_emis ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) endif write ( unit_logfile , '(2i8,a6,i2,a4,i2,a3,2a48)' ) sector_index , i , ' from ' , uEMEP_to_EMEP_sector ( sector_index ), ' to ' , uEMEP_to_EMEP_replace_sector ( sector_index ), ' : ' , trim ( var_name_nc ( frac_nc_index , i , sector_index )), trim ( var_name_nc ( emis_nc_index , i , sector_index )) enddo endif enddo endif !stop !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count if ( use_EMEP_surface_compounds_flag ) then write ( unit_logfile , '(a)' ) 'Using EMEP surface compounds instead of gridded' comp_name_nc ( o3_nc_index ) = 'SURF_ug_O3' comp_name_nc ( no2_nc_index ) = 'SURF_ug_NO2' comp_name_nc ( nox_nc_index ) = 'SURF_ugN_NOX' !Not used comp_name_nc ( nh3_nc_index ) = 'SURF_ug_NH3' !comp_name_nc(nh3_nc_index)='nh3' comp_name_nc ( nh4_nc_index ) = 'SURF_ug_NH4_F' !comp_name_nc(pm25_nc_index)='pm25' !comp_name_nc(pmco_nc_index)='SURF_ug_PMCO' comp_name_nc ( pm10_nc_index ) = 'SURF_ug_PM10' comp_name_nc ( pm25_nc_index ) = 'SURF_ug_PM25' comp_name_nc ( co_nc_index ) = 'SURF_ug_CO' comp_name_nc ( bap_nc_index ) = 'SURF_ug_BAP' comp_name_nc ( c6h6_nc_index ) = 'SURF_ug_BENZENE' comp_name_nc ( so2_nc_index ) = 'SURF_ug_SO2' endif if ( use_water_in_EMEP_surface_pm_flag ) then write ( unit_logfile , '(a)' ) 'Using EMEP surface PM including water (RH50)' comp_name_nc ( pm10_nc_index ) = 'SURF_ug_PM10_rh50' comp_name_nc ( pm25_nc_index ) = 'SURF_ug_PM25_rh50' endif !Reset emission names so they will not be read if they are not used if ( make_EMEP_grid_emission_data ( allsource_index ). or . local_subgrid_method_flag . ne . 2. or . save_emissions_for_EMEP ( allsource_index ). or . save_emissions ) then else var_name_nc ( emis_nc_index ,:,:) = '' write ( unit_logfile , '(a,i)' ) 'Will not read or write any EMEP emission data' endif !If utm zones set the projection parameters to these values if ( projection_type . eq . UTM_projection_index ) then projection_attributes ( 1 ) = utm_zone projection_attributes ( 2 ) = utm_lon0 endif if ( projection_type . eq . LTM_projection_index ) then projection_attributes ( 1 ) = utm_zone projection_attributes ( 2 ) = ltm_lon0 endif !Reset the EMEP grid region based on the size of the selected local fraction local_fraction_grid_size_scaling = real ( local_fraction_grid_size ( local_fraction_grid_for_EMEP_grid_interpolation )) EMEP_grid_interpolation_size_original = EMEP_grid_interpolation_size !EMEP_grid_interpolation_size=EMEP_grid_interpolation_size_original*local_fraction_grid_size_scaling local_fraction_additional_grid_size_scaling = real ( local_fraction_grid_size ( local_fraction_grid_for_EMEP_additional_grid_interpolation )) EMEP_additional_grid_interpolation_size_original = EMEP_additional_grid_interpolation_size !EMEP_additional_grid_interpolation_size=EMEP_additional_grid_interpolation_size_original*local_fraction_additional_grid_size_scaling !Definitions of the emission saving grid. These are the pre February 2020 values !save_emission_subgrid_min(x_dim_index)=-6.498834E+05 !save_emission_subgrid_delta(x_dim_index)=2500. !save_emission_subgrid_dim(x_dim_index)=531 !save_emission_subgrid_min(y_dim_index)=-6.567275E+05 !save_emission_subgrid_delta(y_dim_index)=2500. !save_emission_subgrid_dim(y_dim_index)=671 end subroutine uEMEP_reset_constants","tags":"","loc":"proc/uemep_reset_constants.html"},{"title":"read_name_real – uEMEP","text":"public  function read_name_real(name_str, default_val, unit_in, unit_out) result(res) Reads single precision value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real Value found in name file (or default value) Source Code function read_name_real ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads single precision value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file real , intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit real :: res !! Value found in name file (or default value) ! Local variables integer :: i , index_val , io character ( len = 256 ) :: temp_str , temp_str1 , temp_str2 ! Initially, set to default value res = default_val rewind ( unit_in ) do read ( unit_in , \"(a)\" , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' ! If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,es12.4)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_real","tags":"","loc":"proc/read_name_real.html"},{"title":"read_name_double – uEMEP","text":"public  function read_name_double(name_str, default_val, unit_in, unit_out) result(res) Reads double precision value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real(kind=dp), intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real(kind=dp) Value found in name file (or default value) Source Code function read_name_double ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads double precision value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file real ( dp ), intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit real ( dp ) :: res !! Value found in name file (or default value) ! Local variables integer :: i , index_val , io character ( len = 256 ) :: temp_str , temp_str1 , temp_str2 ! Initiallly set to default value res = default_val rewind ( unit_in ) !do while (.not.eof(unit_in)) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' ! If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,es12.4)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_double","tags":"","loc":"proc/read_name_double.html"},{"title":"read_name_integer – uEMEP","text":"public  function read_name_integer(name_str, default_val, unit_in, unit_out) result(res) Reads integer value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file integer, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value integer Value found in name file (or default value) Source Code function read_name_integer ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads integer value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file integer , intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit integer :: res !! Value found in name file (or default value) ! Local variables integer :: i , index_val , io character ( 256 ) temp_str , temp_str1 , temp_str2 ! Initially set return value to default value res = default_val rewind ( unit_in ) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' !If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,i12)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_integer","tags":"","loc":"proc/read_name_integer.html"},{"title":"read_name_char – uEMEP","text":"public  function read_name_char(name_str, default_val, unit_in, unit_out) result(res) Reads string from name file Skips comments (!) and returns default string if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of string in name file character(len=*), intent(in) :: default_val Default string integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value character(len=:), allocatable String found in name file (or default string) Source Code function read_name_char ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads string from name file !! !! Skips comments (!) and returns default string if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of string in name file character ( len =* ), intent ( in ) :: default_val !! Default string integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit character ( len = :), allocatable :: res !! String found in name file (or default string) ! Local variables integer :: i , index_val , io character ( 256 ) :: temp_str , temp_str1 , temp_str2 character ( 256 ) :: call_str = 'read_name_char' ! Initially set default string as return string res = default_val rewind ( unit_in ) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' !If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then !Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then !Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then ! Special for characters so it doesn't read it's own call if ( trim ( temp_str2 ( 1 : min ( len ( trim ( temp_str2 )), len ( trim ( call_str ))))) . ne . trim ( call_str )) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if res = adjustl ( res ) write ( unit_out , '(A,A)' ) 'Setting: ' // trim ( name_str ) // ' = ' , trim ( res ) end if end if end if end if end if end do end function read_name_char","tags":"","loc":"proc/read_name_char.html"},{"title":"read_name_logical – uEMEP","text":"public  function read_name_logical(name_str, default_val, unit_in, unit_out) result(res) Reads boolean value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file logical, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value logical Source Code function read_name_logical ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads boolean value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file logical , intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit logical :: res ! Local variables integer :: i , index_val , io character ( len = 256 ) :: temp_str , temp_str1 , temp_str2 ! Initially set return value as default res = default_val rewind ( unit_in ) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' ! If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,L)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_logical","tags":"","loc":"proc/read_name_logical.html"},{"title":"read_name – uEMEP","text":"private interface read_name Module Procedures public  function read_name_real (name_str, default_val, unit_in, unit_out) result(res) Reads single precision value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real Value found in name file (or default value) public  function read_name_double (name_str, default_val, unit_in, unit_out) result(res) Reads double precision value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real(kind=dp), intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real(kind=dp) Value found in name file (or default value) public  function read_name_integer (name_str, default_val, unit_in, unit_out) result(res) Reads integer value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file integer, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value integer Value found in name file (or default value) public  function read_name_char (name_str, default_val, unit_in, unit_out) result(res) Reads string from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of string in name file character(len=*), intent(in) :: default_val Default string integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value character(len=:), allocatable String found in name file (or default string) public  function read_name_logical (name_str, default_val, unit_in, unit_out) result(res) Reads boolean value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file logical, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value logical","tags":"","loc":"interface/read_name.html"},{"title":"uEMEP_subgrid_deposition_EMEP – uEMEP","text":"public  subroutine uEMEP_subgrid_deposition_EMEP() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_subgrid_deposition_EMEP use uEMEP_definitions implicit none integer i_source , i_pollutant integer i , j real xpos_min , xpos_max , ypos_min , ypos_max real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_limit , ypos_limit integer i_nc , j_nc integer ii , jj real weighting_nc ( - 1 : 1 , - 1 : 1 ) integer i_meteo , j_meteo real h_mix_loc ( subgrid_dim ( t_dim_index )) real ratio ( subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop ) real delta_area ( 2 ) real temp ( subgrid_dim ( t_dim_index ), 2 ) integer tt real ratio_interp ( subgrid_dim ( t_dim_index ), 2 ) write ( unit_logfile , '(A)' ) 'Distributing deposition to the subgrid' !Place the EMEP deposition velocities in the deposition subgrid, no interpolation. Now done using area interpolation do i_pollutant = 1 , n_emep_pollutant_loop !do j=1,deposition_subgrid_dim(y_dim_index) !do i=1,deposition_subgrid_dim(x_dim_index) !i_cross_emep=crossreference_deposition_to_emep_subgrid(i,j,x_dim_index) !j_cross_emep=crossreference_deposition_to_emep_subgrid(i,j,y_dim_index) !deposition_subgrid(i,j,:,vd_index,i_pollutant)=depo_var3d_nc(i_cross_emep,j_cross_emep,:,grid_index,i_pollutant) !write(*,*) i,j,deposition_subgrid(i,j,:,vd_index,i_pollutant) !enddo !enddo !Place the EMEP depositions in the concentration subgrid, no interpolation do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !Nearest neighbour interpolate the EMEP compounds to subgrid !do i_loop=1,n_pollutant_compound_loop(i_pollutant) !do i_depo=1,n_deposition_index !orig_EMEP_deposition_subgrid(i,j,:,i_depo,i_pollutant)=depo_var3d_nc(ii,jj,:,i_depo,pollutant_compound_loop_index(i_pollutant,i_loop)) orig_EMEP_deposition_subgrid ( i , j ,:, drydepo_index , i_pollutant ) = var3d_nc ( ii , jj ,:, drydepo_nc_index , allsource_index , i_pollutant ) orig_EMEP_deposition_subgrid ( i , j ,:, wetdepo_index , i_pollutant ) = var3d_nc ( ii , jj ,:, wetdepo_nc_index , allsource_index , i_pollutant ) !enddo !enddo !This is overwritten in the weighted interpolation !write(*,*)sum(subgrid(i,j,:,emep_nonlocal_subgrid_index,:,:)),sum(subgrid(i,j,:,emep_subgrid_index,:,:)) subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) = var3d_nc ( ii , jj ,:, drydepo_nc_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) = var3d_nc ( ii , jj ,:, wetdepo_nc_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) enddo enddo enddo !Place the EMEP nonlocal deposition velocities in the subgrid, area weighted interpolation subgrid (:,:,:, drydepo_nonlocal_subgrid_index ,:,:) = 0. subgrid (:,:,:, wetdepo_nonlocal_subgrid_index ,:,:) = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. ypos_limit = dgrid_nc ( lat_nc_index ) / 2. ! write(*,*) integral_subgrid(:,:,1,hmix_integral_subgrid_index,allsource_index,i_pollutant) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then delta_area ( 1 ) = xpos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling * 11057 0. * cos ( 3.14159 / 18 0. * var1d_nc ( j_nc , lat_nc_index )) delta_area ( 2 ) = ypos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling * 11057 0. elseif ( EMEP_projection_type . eq . LCC_projection_index . or . EMEP_projection_type . eq . PS_projection_index ) then delta_area ( 1 ) = xpos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling delta_area ( 2 ) = ypos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling endif !write(*,*) delta_area !The adjustment for the vertical profile is done here for wet deposition !The integral subgrid values are placed onto the target subgrid using the area weighted average over the lcoal region (xpos_limit*EMEP_grid_interpolation_size) if ( adjust_wetdepo_integral_to_lowest_layer_flag ) then i_meteo = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_meteo = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) h_mix_loc (:) = meteo_subgrid ( i_meteo , j_meteo ,:, hmix_subgrid_index ) i_source = allsource_index do i_pollutant = 1 , n_pollutant_loop do tt = 1 , subgrid_dim ( t_dim_index ) temp ( tt , 2 ) = area_weighted_extended_interpolation_function ( x_integral_subgrid , y_integral_subgrid , integral_subgrid (:,:, tt , hmix_integral_subgrid_index , i_source , i_pollutant ) & , integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_delta ( x_dim_index ), x_subgrid ( i , j ), y_subgrid ( i , j ), delta_area ) temp ( tt , 1 ) = area_weighted_extended_interpolation_function ( x_integral_subgrid , y_integral_subgrid , integral_subgrid (:,:, tt , hsurf_integral_subgrid_index , i_source , i_pollutant ) & , integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_delta ( x_dim_index ), x_subgrid ( i , j ), y_subgrid ( i , j ), delta_area ) !ratio(tt,i_source,i_pollutant)=temp(tt,2)/temp(tt,1)*H_emep/h_mix_loc(tt) ratio ( tt , i_source , i_pollutant ) = temp ( tt , 2 ) / temp ( tt , 1 ) * H_emep / h_mix_loc ( tt ) !write(*,*) h_mix_loc(tt)/H_emep,temp(tt,2),temp(tt,1),ratio(tt,i_source,i_pollutant) !Division by 0 traps if ( temp ( tt , 1 ). eq . 0 ) ratio ( tt , i_source , i_pollutant ) = 0. if ( h_mix_loc ( tt ). eq . 0 ) ratio ( tt , i_source , i_pollutant ) = 0. ratio ( tt , i_source , i_pollutant ) = max ( 0. , ratio ( tt , i_source , i_pollutant )) ratio ( tt , i_source , i_pollutant ) = min ( 1. , ratio ( tt , i_source , i_pollutant )) !write(*,'(2i,3es12.2)') i,j,temp(tt,1),temp(tt,2),ratio(tt,i_source,i_pollutant) enddo enddo else ratio = 1. endif xpos_area_max = xproj_subgrid ( i , j ) + xpos_limit xpos_area_min = xproj_subgrid ( i , j ) - xpos_limit ypos_area_max = yproj_subgrid ( i , j ) + ypos_limit ypos_area_min = yproj_subgrid ( i , j ) - ypos_limit do jj = j_nc - 1 , j_nc + 1 do ii = i_nc - 1 , i_nc + 1 xpos_min = max ( xpos_area_min , var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max = min ( xpos_area_max , var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min = max ( ypos_area_min , var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max = min ( ypos_area_max , var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Determine the area intersection of the EMEP grid and an EMEP grid size centred on the integral subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii - i_nc , jj - j_nc ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii - i_nc , jj - j_nc ) = 0. endif i_source = allsource_index do i_pollutant = 1 , n_emep_pollutant_loop !Division by 0 traps ratio_interp (:, 1 ) = subgrid ( i , j ,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) / subgrid ( i , j ,:, emep_subgrid_index , allsource_index , i_pollutant ) where ( ratio_interp (:, 1 ). gt . 1. ) ratio_interp (:, 1 ) = 1. where ( ratio_interp (:, 1 ). lt . 0. ) ratio_interp (:, 1 ) = 0. where ( subgrid ( i , j ,:, emep_subgrid_index , allsource_index , i_pollutant ). eq . 0. ) ratio_interp (:, 1 ) = 0. ratio_interp (:, 2 ) = subgrid ( i , j ,:, emep_local_subgrid_index , allsource_index , i_pollutant ) / subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source , i_pollutant ) * ratio (:, i_source , i_pollutant ) !where (ratio_interp(:,2).gt.1.) ratio_interp(:,2)=1. where ( ratio_interp (:, 2 ). lt . 0. ) ratio_interp (:, 2 ) = 0. where ( subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source , i_pollutant ). eq . 0. ) ratio_interp (:, 2 ) = 0. subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + var3d_nc ( ii , jj ,:, drydepo_nc_index , i_source , i_pollutant ) & * ratio_interp (:, 1 ) & * weighting_nc ( ii - i_nc , jj - j_nc ) !subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,i_pollutant)=subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,i_pollutant) & !        +var3d_nc(ii,jj,:,wetdepo_nc_index,i_source,i_pollutant) & !        *(1.-subgrid(i,j,:,emep_local_subgrid_index,allsource_index,i_pollutant)/subgrid(i,j,:,emep_subgrid_index,i_source,i_pollutant)*ratio(:,i_source,i_pollutant)) & !        *weighting_nc(ii-i_nc,jj-j_nc) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + var3d_nc ( ii , jj ,:, wetdepo_nc_index , i_source , i_pollutant ) & / ( 1. + ratio_interp (:, 2 )) & * weighting_nc ( ii - i_nc , jj - j_nc ) !write(*,*) ratio(:,i_source,i_pollutant),subgrid(i,j,:,emep_local_subgrid_index,allsource_index,i_pollutant)/subgrid(i,j,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant) enddo enddo enddo !write(*,*) i,j,ratio,subgrid(i,j,:,emep_local_subgrid_index,i_source,:)/subgrid(i,j,:,emep_subgrid_index,i_source,:) !write(*,*) i,j,deposition_subgrid(i,j,:,vd_index,:),depo_var3d_nc(i_nc,j_nc,:,grid_index,:) enddo enddo end subroutine uEMEP_subgrid_deposition_EMEP","tags":"","loc":"proc/uemep_subgrid_deposition_emep.html"},{"title":"uEMEP_calculate_deposition – uEMEP","text":"public  subroutine uEMEP_calculate_deposition() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_calculate_deposition use uEMEP_definitions implicit none integer source_index integer i , j !real sum_temp(subgrid_dim(x_dim_index),subgrid_dim(y_dim_index),subgrid_dim(t_dim_index)) write ( unit_logfile , '(A)' ) 'Combining local deposition sources' !Calculate redistributed subgrid allsource deposition ! subgrid (:,:,:, drydepo_local_subgrid_index , allsource_index ,:) = 0. !subgrid(:,:,:,drydepo_nonlocal_subgrid_index,allsource_index,:)=0. subgrid (:,:,:, wetdepo_local_subgrid_index , allsource_index ,:) = 0. !subgrid(:,:,:,wetdepo_nonlocal_subgrid_index,allsource_index,:)=0. do source_index = 1 , n_source_index if ( calculate_source ( source_index )) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !i_cross_deposition=crossreference_target_to_deposition_subgrid(i,j,x_dim_index) !j_cross_deposition=crossreference_target_to_deposition_subgrid(i,j,y_dim_index) !subgrid(i,j,:,drydepo_nonlocal_subgrid_index,source_index,:)=subgrid(i,j,:,emep_nonlocal_subgrid_index,source_index,:) & !     *deposition_subgrid(i_cross_deposition,j_cross_deposition,:,vd_index,:) !subgrid(i,j,:,drydepo_nonlocal_subgrid_index,allsource_index,:)=subgrid(i,j,:,drydepo_nonlocal_subgrid_index,allsource_index,:)+subgrid(i,j,:,drydepo_nonlocal_subgrid_index,source_index,:) subgrid ( i , j ,:, drydepo_local_subgrid_index , allsource_index ,:) = subgrid ( i , j ,:, drydepo_local_subgrid_index , allsource_index ,:) + subgrid ( i , j ,:, drydepo_local_subgrid_index , source_index ,:) !write(*,*) subgrid(i,j,:,emep_nonlocal_subgrid_index,source_index,1),deposition_subgrid(i_cross_deposition,j_cross_deposition,:,vd_index,1) !subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,:)=subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,:)+subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,source_index,:) subgrid ( i , j ,:, wetdepo_local_subgrid_index , allsource_index ,:) = subgrid ( i , j ,:, wetdepo_local_subgrid_index , allsource_index ,:) + subgrid ( i , j ,:, wetdepo_local_subgrid_index , source_index ,:) enddo enddo endif enddo !Convert the nonlocal depositions from mg/m2/hr to ug/m2/sec for compatability with local calculations subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index ,:) = subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index ,:) * 100 0. / 360 0. subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index ,:) = subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index ,:) * 100 0. / 360 0. end subroutine uEMEP_calculate_deposition","tags":"","loc":"proc/uemep_calculate_deposition.html"},{"title":"uEMEP_set_deposition_velocities – uEMEP","text":"public  subroutine uEMEP_set_deposition_velocities() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_deposition_velocities use uEMEP_definitions implicit none integer i_pollutant integer i , j real xpos_min , xpos_max , ypos_min , ypos_max real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_limit , ypos_limit integer i_nc , j_nc integer ii , jj real weighting_nc ( - 1 : 1 , - 1 : 1 ) integer i_landuse write ( unit_logfile , '(A)' ) 'Placing EMEP deposition velocities on the deposition subgrid' !Fill in with a default value deposition_subgrid (:,:,:,:, 1 : n_pollutant_loop ) = 0. !write(*,*) size(deposition_subgrid) drydepo_vd_default ( 1 : n_compound_index ) = 0.0 !Positive value in m/s drydepo_vd_default ( nh3_index ) = 0.03 !Positive value in m/s wetdepo_scavanging_rate ( 1 : n_compound_index ) = 0.0 !Positive value in m/s wetdepo_scavanging_rate ( nh3_index ) = 0.5 * 1.e6 / 100 0. !Dimensions of m-1 W/h do i_pollutant = 1 , n_pollutant_loop deposition_subgrid (:,:,:, vd_index , i_pollutant ) = drydepo_vd_default ( pollutant_loop_index ( i_pollutant )) !write(*,*) i_source,i_pollutant,sum(deposition_subgrid(:,:,:,vd_index,i_pollutant)),drydepo_vd_default(i_pollutant) enddo !stop !Place the EMEP deposition velocities in the deposition subgrid, area weighted interpolation deposition_subgrid (:,:,:, vd_index ,:) = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. ypos_limit = dgrid_nc ( lat_nc_index ) / 2. do j = 1 , deposition_subgrid_dim ( y_dim_index ) do i = 1 , deposition_subgrid_dim ( x_dim_index ) !Cross reference EMEP grid with limits i_nc = crossreference_deposition_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_deposition_to_emep_subgrid ( i , j , y_dim_index ) i_nc = min ( max ( 2 , i_nc ), dim_length_nc ( x_dim_nc_index ) - 1 ) j_nc = min ( max ( 2 , j_nc ), dim_length_nc ( y_dim_nc_index ) - 1 ) !write(*,*) i,j,i_nc,j_nc xpos_area_max = xproj_deposition_subgrid ( i , j ) + xpos_limit xpos_area_min = xproj_deposition_subgrid ( i , j ) - xpos_limit ypos_area_max = yproj_deposition_subgrid ( i , j ) + ypos_limit ypos_area_min = yproj_deposition_subgrid ( i , j ) - ypos_limit do jj = j_nc - 1 , j_nc + 1 do ii = i_nc - 1 , i_nc + 1 xpos_min = max ( xpos_area_min , var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max = min ( xpos_area_max , var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min = max ( ypos_area_min , var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max = min ( ypos_area_max , var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Determine the area intersection of the EMEP grid and an EMEP grid size centred on the deposition subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii - i_nc , jj - j_nc ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii - i_nc , jj - j_nc ) = 0. endif if ( read_landuse_flag ) then do i_landuse = 1 , n_landuse_index - 1 deposition_subgrid ( i , j ,:, vd_index ,:) = deposition_subgrid ( i , j ,:, vd_index ,:) + depo_var3d_nc ( ii , jj ,:, i_landuse ,:) * landuse_subgrid ( i , j , i_landuse ) * weighting_nc ( ii - i_nc , jj - j_nc ) enddo else deposition_subgrid ( i , j ,:, vd_index ,:) = deposition_subgrid ( i , j ,:, vd_index ,:) + depo_var3d_nc ( ii , jj ,:, grid_index ,:) * weighting_nc ( ii - i_nc , jj - j_nc ) endif enddo enddo !Fill in zeros with the nearest EMEP value. 0 can appear because of non overlapping EMEP and landuse grids, I think where ( deposition_subgrid ( i , j ,:, vd_index ,:). eq . 0 ) deposition_subgrid ( i , j ,:, vd_index ,:) = depo_var3d_nc ( i_nc , j_nc ,:, grid_index ,:) !write(*,'(2i,23es12.2,f)') i,j,deposition_subgrid(i,j,:,vd_index,:),depo_var3d_nc(i_nc,j_nc,:,grid_index,:),sum(depo_var3d_nc(ii,jj,:,1:n_landuse_index-1,:)),sum(landuse_subgrid(i,j,1:n_landuse_index-1)) enddo enddo end subroutine uEMEP_set_deposition_velocities","tags":"","loc":"proc/uemep_set_deposition_velocities.html"},{"title":"uEMEP_subgrid_emission_EMEP – uEMEP","text":"public  subroutine uEMEP_subgrid_emission_EMEP() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_subgrid_emission_EMEP use uEMEP_definitions implicit none integer i , j integer ii , jj , tt , t real , allocatable :: weighting_nc (:,:), weighting_subgrid (:,:,:) real , allocatable :: total_weighting_nc (:,:,:), proxy_weighting_nc (:,:,:) real , allocatable :: total_proxy_emission_subgrid (:,:,:,:) real , allocatable :: total_proxy_subgrid_emission_in_EMEP_grid (:,:,:,:) integer , allocatable :: subgrid_count_nc (:,:) integer , allocatable :: subgrid_count_subgrid (:,:,:) integer i_nc_start , i_nc_end , j_nc_start , j_nc_end integer i_start , i_end , j_start , j_end , t_start , t_end real lon_min , lon_max , lat_min , lat_max integer i_nc , j_nc integer i_source integer ii_nc , jj_nc , ii_w , jj_w integer :: n_weight = 3 integer weighting_subgrid_dim ( 2 , n_source_index ) integer i_cross , j_cross !integer, allocatable :: crossreference_weighting_to_emep_subgrid(:,:,:,:) integer i_w_c , j_w_c integer i_nc_c , j_nc_c real sum_temp ( n_pollutant_loop ) real xpos_subgrid , ypos_subgrid real xpos_subgrid2 , ypos_subgrid2 integer i_pollutant !functions !Set the scaling factor for EMEP emissions depending on whether they are total emissions or average emissions !EMEP_emission_aggregation_period=365.*24.   !For aggregation over a year !EMEP_emission_aggregation_period=1.         !For hourly average if ( local_subgrid_method_flag . ne . 3. and . local_subgrid_method_flag . ne . 4 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Distributing EMEP emission to subgrids (uEMEP_subgrid_emission_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !Allocate and save the existing emission subgrid data allocate ( total_proxy_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index , n_pollutant_loop )) !There are no subsources in EMEP so this index is set to 1 and the subsource emissions are transferred to the proxy emission subgrid !subsource_index=1 !do i_source=1,n_source_index !if (calculate_source(i_source)) then !    temp_proxy_emission_subgrid(:,:,i_source,:)=sum(proxy_emission_subgrid(:,:,i_source,:),3) !endif !enddo !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) tt = 1 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_pollutant = 1 , n_pollutant_loop !write(*,*) trim(source_file_str(i_source)) !write(*,*) trim(var_name_nc(conc_nc_index,pollutant_loop_index(i_pollutant),allsource_nc_index)) !trim(pollutant_file_str(pollutant_loop_index(i_pollutant))) !write(*,*) sum(emission_subgrid(1:emission_subgrid_dim(x_dim_index,i_source),1:emission_subgrid_dim(y_dim_index,i_source),:,i_source,i_pollutant)) !write(*,*) (t_end-t_start+1) !write(unit_logfile,'(A,A,A,A,ES10.2)') 'Emission source ',trim(source_file_str(i_source))//' ',trim(var_name_nc(conc_nc_index,pollutant_loop_index(i_pollutant),allsource_nc_index)),': Total hourly average emissions before use of EMEP (ug/s)=', & !    sum(emission_subgrid(1:emission_subgrid_dim(x_dim_index,i_source),1:emission_subgrid_dim(y_dim_index,i_source),:,i_source,i_pollutant))/(t_end-t_start+1) enddo endif enddo !Distribute the EMEP emissions evenly over the subgrids within an EMEP grid if ( EMEP_emission_grid_interpolation_flag . eq . 0. or . local_subgrid_method_flag . eq . 4 ) then !if (EMEP_emission_grid_interpolation_flag.eq.0) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to all subgrids within an EMEP grid' tt = 1 allocate ( total_proxy_subgrid_emission_in_EMEP_grid ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_source_index , n_pollutant_loop )) allocate ( subgrid_count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) allocate ( subgrid_count_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) !emission_subgrid=0. total_proxy_subgrid_emission_in_EMEP_grid = 0. total_proxy_emission_subgrid = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid (:,:,:, i_source ,:) = 0. subgrid_count_subgrid = 0 subgrid_count_nc = 0 !Calculate total subgrid emissions and number of subgrids in each EMEP grid do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) ii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) jj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) ii = max ( min ( ii , dim_length_nc ( x_dim_nc_index )), 1 ) jj = max ( min ( jj , dim_length_nc ( y_dim_nc_index )), 1 ) subgrid_count_nc ( ii , jj ) = subgrid_count_nc ( ii , jj ) + 1 total_proxy_subgrid_emission_in_EMEP_grid ( ii , jj , i_source ,:) = total_proxy_subgrid_emission_in_EMEP_grid ( ii , jj , i_source ,:) + proxy_emission_subgrid ( i , j , i_source ,:) emission_subgrid ( i , j ,:, i_source ,:) = var3d_nc ( ii , jj ,:, emis_nc_index , i_source ,:) enddo enddo !Transfer the total emissions in the EMEP grid to each subgrid within that grid !if (subgrid_emission_distribution_flag) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) ii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) jj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) ii = max ( min ( ii , dim_length_nc ( x_dim_nc_index )), 1 ) jj = max ( min ( jj , dim_length_nc ( y_dim_nc_index )), 1 ) total_proxy_emission_subgrid ( i , j , i_source ,:) = total_proxy_subgrid_emission_in_EMEP_grid ( ii , jj , i_source ,:) subgrid_count_subgrid ( i , j ,:) = subgrid_count_nc ( ii , jj ) !write(*,*) subgrid_count_nc(ii,jj) !Converts from mg/m2/hour(year) to ug/s/subgrid assuming the original EMEP emissions are in mg/m2/hour(year) if ( hourly_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) & * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. if ( annual_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) & * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. / EMEP_emission_aggregation_period !write(*,*) emission_subgrid(i,j,1,i_source,subsource_index),var3d_nc(ii,jj,1,emis_nc_index,i_source)*emission_subgrid_delta(x_dim_index,i_source)*emission_subgrid_delta(y_dim_index,i_source)*1000./3600. enddo enddo !endif !Determine subgrid normalised time profile per hour from EMEP grid emissions (average hourly emission conversion) !This is not quite right because the entire emission time profile is not available in a short period !Minimum of a day is needed, with the assumption that all days are the same if ( local_subgrid_method_flag . eq . 4 ) then write ( unit_logfile , '(A)' ) 'Calculating EMEP emission time profile' do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) if ( hourly_calculations ) then sum_temp (:) = sum ( emission_subgrid ( i , j ,:, i_source ,:), 1 ) do i_pollutant = 1 , n_pollutant_loop emission_time_profile_subgrid ( i , j ,:, i_source , i_pollutant ) = emission_subgrid ( i , j ,:, i_source , i_pollutant ) / sum_temp ( i_pollutant ) * emission_subgrid_dim ( t_dim_index , i_source ) if ( sum_temp ( i_pollutant ). eq . 0. ) emission_time_profile_subgrid ( i , j ,:, i_source , i_pollutant ) = 0. enddo else emission_time_profile_subgrid ( i , j ,:, i_source ,:) = 1. endif !write(*,'(<emission_subgrid_dim(t_dim_index,i_source)>f6.2)') emission_time_profile_subgrid(i,j,:,i_source,subsource_index) !write(*,*) i,j,subgrid_count_subgrid(i,j,1,i_source),total_proxy_emission_subgrid(i,j,1,i_source,subsource_index),emission_subgrid(i,j,1,i_source,subsource_index) !Set emissions to 0 in the case when local_subgrid_method_flag.eq.4 since these are set later !This way of doing things is not logical as it fills the grid unnecessarilly. Should be fixed and made logical emission_subgrid ( i , j ,:, i_source ,:) = 0. enddo enddo endif !Distribute EMEP emissions to existing proxy subgrid emissions if ( subgrid_emission_distribution_flag . and . local_subgrid_method_flag . ne . 4 ) then if ( local_subgrid_method_flag . eq . 2 ) write ( unit_logfile , '(2A)' ) 'Distributing local emission data to subgrid emissions for: ' , trim ( source_file_str ( i_source )) if ( local_subgrid_method_flag . eq . 3 ) write ( unit_logfile , '(2A)' ) 'Distributing EMEP emissions to proxy subgrid emissions, no weighting used, for: ' , trim ( source_file_str ( i_source )) do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * subgrid_count_subgrid (:,:,:) * proxy_emission_subgrid (:,:, i_source ,:) / total_proxy_emission_subgrid (:,:, i_source ,:) where ( total_proxy_emission_subgrid (:,:, i_source ,:). eq . 0. ) emission_subgrid (:,:, t , i_source ,:) = 0. enddo !Fix round off negatives where ( emission_subgrid (:,:,:, i_source ,:). lt . 0 ) emission_subgrid (:,:,:, i_source ,:) = 0. !write(*,*) sum(emission_subgrid(:,:,:,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(emission_subgrid(:,:,:,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !write(*,*) sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !write(*,*) pmex_index,pmex_nc_index !stop endif endif enddo endif !Quick calculation of area weighting, no edge effects. Does not need to change with time !This is done also if there is moving window weighting later as it is used for the nonlocal contribution if ( EMEP_emission_grid_interpolation_flag . eq . 1. and . local_subgrid_method_flag . ne . 4 ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to proxy emission subgrids using area weighting of the EMEP grid' tt = 1 !tt=dim_length_nc(time_dim_nc_index) allocate ( weighting_nc ( n_weight , n_weight )) !EMEP grid weighting for interpolation. Does not need a source index for area weighting !allocate (subgrid_count_nc(dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),tt,n_source_index)) allocate ( subgrid_count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) !allocate (emission_subgrid(emission_max_subgrid_dim(x_dim_index),emission_max_subgrid_dim(y_dim_index),subgrid_dim(t_dim_index),n_source_index,n_pollutant_loop)) total_proxy_emission_subgrid = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid (:,:,:, i_source ,:) = 0. subgrid_count_subgrid = 0 do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) !Only calculate for valid emission subgrids when using the proxy emissions for distribution if (. not . subgrid_emission_distribution_flag . or . sum ( proxy_emission_subgrid ( i , j , i_source ,:)). ne . 0 ) then !Assumes it is never on the edge of the EMEP grid i_nc = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) weighting_nc = 0. if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid = lon_emission_subgrid ( i , j , i_source ) ypos_subgrid = lat_emission_subgrid ( i , j , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid,ypos_subgrid,lon_emission_subgrid(i,j,i_source),lat_emission_subgrid(i,j,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) endif !Calculate the area weighted EMEP grid emissions at each subgrid do jj =- 1 , + 1 do ii =- 1 , + 1 ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + 2 jj_w = jj + 2 lon_min = max ( xpos_subgrid - dgrid_nc ( lon_nc_index ) / 2. , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) lon_max = min ( xpos_subgrid + dgrid_nc ( lon_nc_index ) / 2. , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) lat_min = max ( ypos_subgrid - dgrid_nc ( lat_nc_index ) / 2. , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) lat_max = min ( ypos_subgrid + dgrid_nc ( lat_nc_index ) / 2. , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) if ( lon_max . gt . lon_min . and . lat_max . gt . lat_min ) then weighting_nc ( ii_w , jj_w ) = ( lat_max - lat_min ) * ( lon_max - lon_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii_w , jj_w ) = 0. endif emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) + var3d_nc ( ii_nc , jj_nc ,:, emis_nc_index , i_source ,:) * weighting_nc ( ii_w , jj_w ) enddo enddo !write(*,*) sum(weighting_nc) !This is OK !Calculate the total subgrid emissions in the EMEP grid region surrounding the subgrid i_start = max ( 1 , i - emission_subgrid_loop_index ( x_dim_index , i_source )) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i + emission_subgrid_loop_index ( x_dim_index , i_source )) j_start = max ( 1 , j - emission_subgrid_loop_index ( y_dim_index , i_source )) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j + emission_subgrid_loop_index ( y_dim_index , i_source )) do jj = j_start , j_end do ii = i_start , i_end if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid2 = lon_emission_subgrid ( ii , jj , i_source ) ypos_subgrid2 = lat_emission_subgrid ( ii , jj , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid2,ypos_subgrid2,lon_emission_subgrid(ii,jj,i_source),lat_emission_subgrid(ii,jj,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) endif if ( abs ( xpos_subgrid - xpos_subgrid2 ). le . dgrid_nc ( lon_nc_index ) / 2. & . and . abs ( ypos_subgrid - ypos_subgrid2 ). le . dgrid_nc ( lat_nc_index ) / 2. ) then total_proxy_emission_subgrid ( i , j , i_source ,:) = total_proxy_emission_subgrid ( i , j , i_source ,:) + proxy_emission_subgrid ( ii , jj , i_source ,:) subgrid_count_subgrid ( i , j ,:) = subgrid_count_subgrid ( i , j ,:) + 1 endif enddo enddo !Converts from mg/subgrid to ug/s/subgrid assuming the original EMEP emissions are in mg/m2/hour if ( hourly_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. if ( annual_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. / EMEP_emission_aggregation_period endif !If valid emission point enddo if ( mod ( j , 100 ). eq . 0 ) write ( * , '(A,A,A,i4,A,i4)' ) 'Subgrid emission EMEP interpolation for ' , trim ( source_file_str ( i_source )), ': ' , j , ' of ' , emission_subgrid_dim ( 2 , i_source ) enddo !Distribute EMEP emissions to subgrid emissions if ( subgrid_emission_distribution_flag ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to subgrid emissions within an area weighted EMEP grid' do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * subgrid_count_subgrid (:,:,:) * proxy_emission_subgrid (:,:, i_source ,:) / total_proxy_emission_subgrid (:,:, i_source ,:) where ( total_proxy_emission_subgrid (:,:, i_source ,:). eq . 0. ) emission_subgrid (:,:, t , i_source ,:) = 0. enddo endif endif enddo !source loop endif !Loop through subgrid and carry out a subgrid weighted moving window interpolation if ( EMEP_emission_grid_interpolation_flag . eq . 2. and . local_subgrid_method_flag . ne . 4 ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to proxy subgrids using emission weighting of the EMEP grid' !NOTE: currently does the inteprolation for all time steps which is not ncessary. Only needs to do it for 1. Same with the area interpolation. !Only use time tt for weighting distribution to increase speed. It is possible this can change with time. Replace 'tt' with ':' tt = 1 !tt=dim_length_nc(time_dim_nc_index) allocate ( total_weighting_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_pollutant_loop )) !EMEP grid weighting for interpolation allocate ( proxy_weighting_nc ( 5 , 5 , n_pollutant_loop )) !EMEP grid weighting for interpolation !allocate (subgrid_count_nc(dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),tt,n_source_index)) allocate ( subgrid_count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) i_w_c = 3 j_w_c = 3 total_proxy_emission_subgrid = 0. !emission_subgrid=0. !Set the start and end times of the loop !t_start=1 !t_end=subgrid_dim(t_dim_index) allocate ( weighting_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) weighting_subgrid_dim (:,:) = emission_subgrid_dim ( 1 : 2 ,:) !Calculate weighting sum for each EMEP grid. total_weighting_nc = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid (:,:,:, i_source ,:) = 0. subgrid_count_subgrid = 0 weighting_subgrid (:,:,:) = proxy_emission_subgrid (:,:, i_source ,:) !Calculate the total weighting (emission) in each emep grid do j = 1 , weighting_subgrid_dim ( y_dim_index , i_source ) do i = 1 , weighting_subgrid_dim ( x_dim_index , i_source ) i_nc = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) total_weighting_nc ( i_nc , j_nc ,:) = total_weighting_nc ( i_nc , j_nc ,:) + weighting_subgrid ( i , j ,:) !write(*,*) i_source,i,j,i_nc,j_nc,weighting_subgrid(i,j,:,i_source) !write(*,*) i,j,i_nc,j_nc,i_nc-crossreference_weighting_to_emep_subgrid(i,j,x_dim_index,i_source),j_nc-crossreference_weighting_to_emep_subgrid(i,j,y_dim_index,i_source) enddo enddo !Calculate the proxy weighting in the nearest emep grids for each subgrid do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) !Only calculate for valid emission subgrids when using the proxy for distribution if (. not . subgrid_emission_distribution_flag . or . sum ( proxy_emission_subgrid ( i , j , i_source ,:)). ne . 0 ) then proxy_weighting_nc = 0. i_cross = i !crossreference_target_to_emission_subgrid(i,j,x_dim_index,i_source) j_cross = j !crossreference_target_to_emission_subgrid(i,j,y_dim_index,i_source) i_nc_c = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , x_dim_index , i_source ) j_nc_c = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , y_dim_index , i_source ) !Limit the loop so that it doesn't go over more than necessary subgrids and does not go outside the domain i_start = max ( 1 , i - emission_subgrid_loop_index ( x_dim_index , i_source )) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i + emission_subgrid_loop_index ( x_dim_index , i_source )) j_start = max ( 1 , j - emission_subgrid_loop_index ( y_dim_index , i_source )) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j + emission_subgrid_loop_index ( y_dim_index , i_source )) !write(*,*) i,j,i_end-i_start,j_end-j_start if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid = lon_emission_subgrid ( i , j , i_source ) ypos_subgrid = lat_emission_subgrid ( i , j , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid,ypos_subgrid,lon_emission_subgrid(i,j,i_source),lat_emission_subgrid(i,j,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) endif do jj = j_start , j_end do ii = i_start , i_end if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid2 = lon_emission_subgrid ( ii , jj , i_source ) ypos_subgrid2 = lat_emission_subgrid ( ii , jj , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid2,ypos_subgrid2,lon_emission_subgrid(ii,jj,i_source),lat_emission_subgrid(ii,jj,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) endif if ( abs ( xpos_subgrid - xpos_subgrid2 ). le . dgrid_nc ( lon_nc_index ) / 2. & . and . abs ( ypos_subgrid - ypos_subgrid2 ). le . dgrid_nc ( lat_nc_index ) / 2. ) then i_nc = crossreference_emission_to_emep_subgrid ( ii , jj , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( ii , jj , y_dim_index , i_source ) !proxy_weighting_nc(i_nc,j_nc,:,i_source)=proxy_weighting_nc(i_nc,j_nc,:,i_source)+weighting_subgrid(ii,jj,:,i_source) proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c ,:) = proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c ,:) + weighting_subgrid ( ii , jj ,:) total_proxy_emission_subgrid ( i , j , i_source ,:) = total_proxy_emission_subgrid ( i , j , i_source ,:) + weighting_subgrid ( ii , jj ,:) !Weighting subgrid is the same as the existing proxy subgrid but without the subsource subgrid_count_subgrid ( i , j ,:) = subgrid_count_subgrid ( i , j ,:) + 1 endif enddo enddo i_cross = i !crossreference_target_to_emission_subgrid(i,j,x_dim_index,i_source) j_cross = j !crossreference_target_to_emission_subgrid(i,j,y_dim_index,i_source) i_nc = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , y_dim_index , i_source ) i_nc_start = max ( 1 , i_nc - 1 ) i_nc_end = min ( dim_length_nc ( x_dim_nc_index ), i_nc + 1 ) j_nc_start = max ( 1 , j_nc - 1 ) j_nc_end = min ( dim_length_nc ( y_dim_nc_index ), j_nc + 1 ) !write(*,*) i,j,i_nc,j_nc,i_nc_end-i_nc_start,j_nc_end-j_nc_start do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c ,:) = proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c ,:) / total_weighting_nc ( ii , jj ,:) !where (total_weighting_nc(ii,jj,tt,i_source).eq.0) proxy_weighting_nc(ii-i_nc+i_w_c,jj-j_nc+j_w_c,:,i_source)=0. where ( total_weighting_nc ( ii , jj ,:). eq . 0 ) proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c ,:) = 0. enddo enddo !Add up the contributing weights !Note that only the subsource_index=1 can be determined since EMEP has no subsources !if (hourly_calculations) then !do i_subsource=1,n_subsource_index(i_source) do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end do i_pollutant = 1 , n_pollutant_loop emission_subgrid ( i , j ,:, i_source , i_pollutant ) = emission_subgrid ( i , j ,:, i_source , i_pollutant ) & + var3d_nc ( ii , jj ,:, emis_nc_index , i_source , i_pollutant ) * proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , i_pollutant ) enddo !if (weighting_nc(ii,jj,traffic_index).ne.0) then !    write(*,*) i,j,ii,jj,weighting_nc(ii,jj,traffic_index),subgrid(i,j,traffic_index,emep_local_subgrid_index) !endif enddo enddo !write(*,*) i,j,proxy_weighting_nc(2,:,1,i_source) !write(*,*) i,j,proxy_weighting_nc(2,2,1,i_source),emission_subgrid(i,j,1,i_source,subsource_index) !write(*,*) sum(proxy_weighting_nc) !Converts from mg/subgrid to ug/s/subgrid assuming the original EMEP emissions are in mg/m2/hour if ( hourly_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. if ( annual_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. / EMEP_emission_aggregation_period endif !If valid emission subgrid enddo if ( mod ( j , 100 ). eq . 0 ) write ( * , '(A,A,A,i4,A,i4)' ) 'Subgrid emission EMEP interpolation for ' , trim ( source_file_str ( i_source )), ': ' , j , ' of ' , emission_subgrid_dim ( 2 , i_source ) enddo !Puts counts into the time array. If emission distributions change in time this needs to be replaced !do t=1,size(subgrid_count_subgrid,3) !    subgrid_count_subgrid(:,:,t,i_source)=subgrid_count_subgrid(:,:,tt,i_source) !enddo !Distribute EMEP emissions to existing subgrid emissions if ( subgrid_emission_distribution_flag ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to subgrid emissions within an emission weighted EMEP grid' do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * subgrid_count_subgrid (:,:,:) * proxy_emission_subgrid (:,:, i_source ,:) / total_proxy_emission_subgrid (:,:, i_source ,:) where ( total_proxy_emission_subgrid (:,:, i_source ,:). eq . 0. ) emission_subgrid (:,:, t , i_source ,:) = 0. enddo endif endif !End if calculate_source enddo !End source loop endif !Scale the subgrid emissions if GNFR is used do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then if ( scale_GNFR_emission_source ( i_source ). ne . 1. ) then write ( unit_logfile , '(2A,f12.2)' ) 'Scaling EMEP emissions for uEMEP source: ' , trim ( source_file_str ( i_source )), scale_GNFR_emission_source ( i_source ) do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * scale_GNFR_emission_source ( i_source ) enddo endif endif enddo !if (subgrid_emission_distribution_flag) then do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,A,A,ES10.2)' ) 'Emission source ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), ': Total hourly average emissions after use of EMEP (ug/s)=' , & sum ( emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , i_source ), 1 : emission_subgrid_dim ( y_dim_index , i_source ),:, i_source , i_pollutant )) / ( t_end - t_start + 1 ) enddo endif enddo !endif if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) if ( allocated ( total_weighting_nc )) deallocate ( total_weighting_nc ) if ( allocated ( proxy_weighting_nc )) deallocate ( proxy_weighting_nc ) if ( allocated ( weighting_subgrid )) deallocate ( weighting_subgrid ) if ( allocated ( total_proxy_emission_subgrid )) deallocate ( total_proxy_emission_subgrid ) if ( allocated ( total_proxy_subgrid_emission_in_EMEP_grid )) deallocate ( total_proxy_subgrid_emission_in_EMEP_grid ) if ( allocated ( subgrid_count_nc )) deallocate ( subgrid_count_nc ) if ( allocated ( subgrid_count_subgrid )) deallocate ( subgrid_count_subgrid ) end subroutine uEMEP_subgrid_emission_EMEP","tags":"","loc":"proc/uemep_subgrid_emission_emep.html"},{"title":"read_esri_ascii_header – uEMEP","text":"public  subroutine read_esri_ascii_header(filename_ascii_sub, ncols_sub, nrows_sub, cellsize_sub, xllcorner, yllcorner, read_nodata_flag) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub real :: cellsize_sub real :: xllcorner real :: yllcorner logical :: read_nodata_flag Source Code subroutine read_esri_ascii_header ( filename_ascii_sub , ncols_sub , nrows_sub , cellsize_sub , xllcorner , yllcorner , read_nodata_flag ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub real :: cellsize_sub real :: xllcorner real :: yllcorner logical :: read_nodata_flag ! Local variables real :: NODATA_value = - 99 9.0 integer :: unit_in = 20 character ( 256 ) :: temp_str open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'old' , readonly ) rewind ( unit_in ) read ( unit_in , * ) temp_str , ncols_sub read ( unit_in , * ) temp_str , nrows_sub read ( unit_in , * ) temp_str , xllcorner read ( unit_in , * ) temp_str , yllcorner read ( unit_in , * ) temp_str , cellsize_sub if ( read_nodata_flag ) read ( unit_in , * ) temp_str , NODATA_value write ( unit_logfile , '(2a10,4a12)' ) 'ncols' , 'nrows' , 'xllcorner' , 'yllcorner' , 'cellsize' , 'NODATA_val' write ( unit_logfile , '(2i10,4f12.1)' ) ncols_sub , nrows_sub , xllcorner , yllcorner , cellsize_sub , NODATA_value close ( unit_in ) end subroutine read_esri_ascii_header","tags":"","loc":"proc/read_esri_ascii_header.html"},{"title":"read_esri_ascii_file – uEMEP","text":"public  subroutine read_esri_ascii_file(filename_ascii_sub, ncols_sub, nrows_sub, cellsize_sub, val_array, x_array, y_array, read_nodata_flag) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) logical :: read_nodata_flag Source Code subroutine read_esri_ascii_file ( filename_ascii_sub , ncols_sub , nrows_sub , cellsize_sub , val_array , x_array , y_array , read_nodata_flag ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) logical :: read_nodata_flag ! Local variables character ( 256 ) :: temp_str integer :: i , j , ii , jj integer :: ncols_sub_temp , nrows_sub_temp real :: xllcorner real :: yllcorner real :: NODATA_value integer :: unit_in = 20 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'old' , readonly ) rewind ( unit_in ) read ( unit_in , * ) temp_str , ncols_sub_temp read ( unit_in , * ) temp_str , nrows_sub_temp read ( unit_in , * ) temp_str , xllcorner read ( unit_in , * ) temp_str , yllcorner read ( unit_in , * ) temp_str , cellsize_sub if ( read_nodata_flag ) read ( unit_in , * ) temp_str , NODATA_value if ( ncols_sub . ne . ncols_sub_temp . or . nrows_sub . ne . nrows_sub_temp ) then write ( unit_logfile , * ) 'ERROR: Subgrid columns or rows do not match. Columns: ' , ncols_sub , ncols_sub_temp , 'Rows: ' , nrows_sub , nrows_sub_temp stop 1 end if read ( unit_in , * ) (( val_array ( ii , jj ), ii = 1 , ncols_sub ), jj = nrows_sub , 1 , - 1 ) close ( unit_in ) ! Set position arrays do i = 1 , ncols_sub do j = 1 , nrows_sub x_array ( i , j ) = xllcorner + cellsize_sub / 2.0 + ( i - 1 ) * cellsize_sub y_array ( i , j ) = yllcorner + cellsize_sub / 2.0 + ( j - 1 ) * cellsize_sub end do end do end subroutine read_esri_ascii_file","tags":"","loc":"proc/read_esri_ascii_file.html"},{"title":"write_esri_ascii_file – uEMEP","text":"public  subroutine write_esri_ascii_file(filename_ascii_sub, ncols_sub, nrows_sub, cellsize_sub, val_array, x_array, y_array) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) Source Code subroutine write_esri_ascii_file ( filename_ascii_sub , ncols_sub , nrows_sub , cellsize_sub , val_array , x_array , y_array ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) ! Local variables integer :: ii , jj real :: xllcorner real :: yllcorner real :: NODATA_value = - 99 9.0 integer :: unit_in = 20 character ( len = :), allocatable :: fmt xllcorner = x_array ( 1 , 1 ) - cellsize_sub / 2.0 yllcorner = y_array ( 1 , 1 ) - cellsize_sub / 2.0 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'unknown' ) write ( unit_in , * ) 'ncols' , ncols_sub write ( unit_in , * ) 'nrows' , nrows_sub write ( unit_in , * ) 'xllcorner' , xllcorner write ( unit_in , * ) 'yllcorner' , yllcorner write ( unit_in , * ) 'cellsize' , cellsize_sub write ( unit_in , * ) 'NODATA_value' , NODATA_value do jj = nrows_sub , 1 , - 1 write ( fmt , '(A,I0,A)' ) '(' , ncols_sub , 'es12.3)' write ( unit_in , fmt ) ( val_array ( ii , jj ), ii = 1 , ncols_sub ) end do close ( unit_in ) end subroutine write_esri_ascii_file","tags":"","loc":"proc/write_esri_ascii_file.html"},{"title":"read_esri_ascii_3d_file – uEMEP","text":"private  subroutine read_esri_ascii_3d_file(filename_ascii_sub, ncols_sub, nrows_sub, nblocks_sub, cellsize_sub, val_array, x_array, y_array) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub integer :: nblocks_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub,nblocks_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) Source Code subroutine read_esri_ascii_3d_file ( filename_ascii_sub , ncols_sub , nrows_sub , nblocks_sub , cellsize_sub , val_array , x_array , y_array ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub , nblocks_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub , nblocks_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) ! Local variables character ( 256 ) :: temp_str integer :: i , j , ii , jj , tt integer :: ncols_sub_temp , nrows_sub_temp , nblocks_sub_temp real :: nrows_sub_temp_real real :: xllcorner real :: yllcorner real :: NODATA_value integer :: unit_in = 20 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'old' , readonly ) rewind ( unit_in ) read ( unit_in , * ) temp_str , ncols_sub_temp read ( unit_in , * ) temp_str , nrows_sub_temp read ( unit_in , * ) temp_str , nrows_sub_temp_real if ( temp_str . eq . 'xllcorner' ) then nblocks_sub_temp = 1 xllcorner = nrows_sub_temp_real else nrows_sub_temp = int ( nrows_sub_temp_real ) read ( unit_in , * ) temp_str , xllcorner end if read ( unit_in , * ) temp_str , yllcorner read ( unit_in , * ) temp_str , cellsize_sub read ( unit_in , * ) temp_str , NODATA_value if ( ncols_sub . ne . ncols_sub_temp . or . nrows_sub . ne . nrows_sub_temp . or . nblocks_sub . ne . nblocks_sub_temp ) then write ( unit_logfile , '(A,2I,A,2I,A,2I)' ) 'ERROR: Subgrid columns or rows do not match. Columns: ' , ncols_sub , ncols_sub_temp , '  Rows: ' , nrows_sub , nrows_sub_temp , '  Blocks: ' , nblocks_sub , nblocks_sub_temp stop 1 end if read ( unit_in , * ) ((( val_array ( ii , jj , tt ), ii = 1 , ncols_sub ), jj = nrows_sub , 1 , - 1 ), tt = 1 , nblocks_sub ) close ( unit_in ) ! Set position arrays do i = 1 , ncols_sub do j = 1 , nrows_sub x_array ( i , j ) = xllcorner + cellsize_sub / 2.0 + ( i - 1 ) * cellsize_sub y_array ( i , j ) = yllcorner + cellsize_sub / 2.0 + ( j - 1 ) * cellsize_sub end do end do end subroutine read_esri_ascii_3d_file","tags":"","loc":"proc/read_esri_ascii_3d_file.html"},{"title":"write_esri_ascii_3d_file – uEMEP","text":"private  subroutine write_esri_ascii_3d_file(filename_ascii_sub, ncols_sub, nrows_sub, nblocks_sub, cellsize_sub, val_array, x_array, y_array) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub integer :: nblocks_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub,nblocks_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) Source Code subroutine write_esri_ascii_3d_file ( filename_ascii_sub , ncols_sub , nrows_sub , nblocks_sub , cellsize_sub , val_array , x_array , y_array ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub , nblocks_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub , nblocks_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) ! Local variables integer :: ii , jj , tt real :: xllcorner real :: yllcorner real :: NODATA_value = - 99 9.0 integer :: unit_in = 20 character ( len = :), allocatable :: fmt xllcorner = x_array ( 1 , 1 ) - cellsize_sub / 2.0 yllcorner = y_array ( 1 , 1 ) - cellsize_sub / 2.0 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'unknown' ) write ( unit_in , * ) 'ncols' , ncols_sub write ( unit_in , * ) 'nrows' , nrows_sub if ( nblocks_sub . gt . 1 ) write ( unit_in , * ) 'nblocks' , nblocks_sub write ( unit_in , * ) 'xllcorner' , xllcorner write ( unit_in , * ) 'yllcorner' , yllcorner write ( unit_in , * ) 'cellsize' , cellsize_sub write ( unit_in , * ) 'NODATA_val' , NODATA_value do tt = 1 , nblocks_sub do jj = nrows_sub , 1 , - 1 write ( fmt , '(A,I0,A)' ) '(' , ncols_sub , 'es12.3)' write ( unit_in , fmt ) ( val_array ( ii , jj , tt ), ii = 1 , ncols_sub ) end do end do close ( unit_in ) end subroutine write_esri_ascii_3d_file","tags":"","loc":"proc/write_esri_ascii_3d_file.html"},{"title":"sigma0_traffic_func – uEMEP","text":"private  function sigma0_traffic_func(speed) Arguments Type Intent Optional Attributes Name real :: speed Return Value real Source Code function sigma0_traffic_func ( speed ) implicit none real :: speed real :: sigma0_traffic_func real :: min_sigma = 0.5 real :: max_sigma = 3. real :: min_speed = 4 0. real :: max_speed = 10 0. real :: gradient gradient = ( max_sigma - min_sigma ) / ( max_speed - min_speed ) sigma0_traffic_func = min ( max ( min_sigma + ( speed - min_speed ) * gradient , min_sigma ), max_sigma ) end function sigma0_traffic_func","tags":"","loc":"proc/sigma0_traffic_func.html"},{"title":"minFF_traffic_func – uEMEP","text":"private  function minFF_traffic_func(speed) Arguments Type Intent Optional Attributes Name real :: speed Return Value real Source Code function minFF_traffic_func ( speed ) implicit none real :: speed real :: minFF_traffic_func real :: min_FF = 0.0 real :: max_FF = 2. real :: min_speed = 4 0. real :: max_speed = 10 0. real :: gradient ! gradient=(max_FF-min_FF)/((max_speed-min_speed)*100000./25.) ! minFF_traffic_func=min(max(speed*adt/width*gradient,min_FF),max_FF) gradient = ( max_FF - min_FF ) / (( max_speed - min_speed )) minFF_traffic_func = min ( max ( speed * gradient , min_FF ), max_FF ) end function minFF_traffic_func","tags":"","loc":"proc/minff_traffic_func.html"},{"title":"line_fraction_in_grid_func – uEMEP","text":"private  function line_fraction_in_grid_func(x_grid, y_grid, x_line, y_line) Arguments Type Intent Optional Attributes Name real :: x_grid (2) real :: y_grid (2) real :: x_line (2) real :: y_line (2) Return Value real Source Code function line_fraction_in_grid_func ( x_grid , y_grid , x_line , y_line ) implicit none !real, intent(in) :: x_grid_in(2),y_grid_in(2),x_line_in(2),y_line_in(2) real :: line_fraction_in_grid_func real :: x_grid ( 2 ), y_grid ( 2 ), x_line ( 2 ), y_line ( 2 ) real :: x_int ( 2 ), y_int ( 2 ) real :: length_line , length_int real :: dx , dy real :: x_temp , y_temp integer node , anti_node integer node_x_grid , node_y_grid integer :: n_intersection !Set to local variables !x_grid=x_grid_in !y_grid=y_grid_in !x_line=x_line_in !y_line=y_line_in !Set the initial fraction line_fraction_in_grid_func = 0. !return !Check first for lines that cannot have an intersection. Will return 0 if ( x_line ( 1 ). lt . x_grid ( 1 ). and . x_line ( 2 ). lt . x_grid ( 1 )) return if ( x_line ( 1 ). ge . x_grid ( 2 ). and . x_line ( 2 ). ge . x_grid ( 2 )) return if ( y_line ( 1 ). lt . y_grid ( 1 ). and . y_line ( 2 ). lt . y_grid ( 1 )) return if ( y_line ( 1 ). ge . y_grid ( 2 ). and . y_line ( 2 ). ge . y_grid ( 2 )) return !if ((x_line(1).lt.x_grid(1).and.x_line(2).lt.x_grid(1)).or.(x_line(1).ge.x_grid(2).and.x_line(2).ge.x_grid(2)).or.(y_line(1).lt.y_grid(1).and.y_line(2).lt.y_grid(1)).or.(y_line(1).ge.y_grid(2).and.y_line(2).ge.y_grid(2))) return !Set length of road link length_line = sqrt (( x_line ( 1 ) - x_line ( 2 )) ** 2 + ( y_line ( 1 ) - y_line ( 2 )) ** 2 ) !Set the initial intercepts x_int ( 1 : 2 ) = x_line y_int ( 1 : 2 ) = y_line !write(*,*) x_grid(:),y_grid(:),x_line(:),y_line(:),length_line if ( length_line . eq . 0 ) return dx = MAXVAL ( x_grid ) - MINVAL ( x_grid ) dy = MAXVAL ( y_grid ) - MINVAL ( y_grid ) !Check for lines that are completely inside the grid if ( x_line ( 1 ). ge . x_grid ( 1 ). and . x_line ( 2 ). ge . x_grid ( 1 ) & . and . x_line ( 1 ). lt . x_grid ( 2 ). and . x_line ( 2 ). lt . x_grid ( 2 ) & . and . y_line ( 1 ). ge . y_grid ( 1 ). and . y_line ( 2 ). ge . y_grid ( 1 ) & . and . y_line ( 1 ). lt . y_grid ( 2 ). and . y_line ( 2 ). lt . y_grid ( 2 )) then line_fraction_in_grid_func = 1. x_int = x_line y_int = y_line return endif !Check for lines with the one of the nodes within do node = 1 , 2 if ( node . eq . 1 ) anti_node = 2 if ( node . eq . 2 ) anti_node = 1 if ( x_line ( node ). ge . x_grid ( 1 ). and . x_line ( node ). lt . x_grid ( 2 ) & . and . y_line ( node ). ge . y_grid ( 1 ). and . y_line ( node ). lt . y_grid ( 2 )) then !This node is in the grid !write(*,*) 'One node in grid' !Shift parallel and equal lines when they are on the grid edge if ( x_line ( node ). eq . x_line ( anti_node ). and . x_line ( node ). eq . x_grid ( 1 )) then x_line = x_line + dx * 1e-6 endif if ( y_line ( node ). eq . y_line ( anti_node ). and . y_line ( node ). eq . y_grid ( 1 )) then y_line = y_line + dy * 1e-6 endif !Can't intersect since it is parallel to the horizontal grid lines if ( y_line ( node ). ne . y_line ( anti_node )) then !Check intersection with the horizontal grid faces do node_y_grid = 1 , 2 x_temp = x_line ( node ) + ( y_grid ( node_y_grid ) - y_line ( node )) * ( x_line ( anti_node ) - x_line ( node )) / ( y_line ( anti_node ) - y_line ( node )) y_temp = y_grid ( node_y_grid ) !write(*,*) node,x_line(node),y_line(node),x_temp,y_temp,MINVAL(y_line),MAXVAL(y_line) if ( y_temp . ge . MINVAL ( y_line ). and . y_temp . le . MAXVAL ( y_line ). and . y_temp . ne . y_line ( node ). and . x_temp . ge . MINVAL ( x_grid ). and . x_temp . le . MAXVAL ( x_grid )) then y_int ( anti_node ) = y_grid ( node_y_grid ) x_int ( anti_node ) = x_temp x_int ( node ) = x_line ( node ) y_int ( node ) = y_line ( node ) length_int = sqrt (( x_int ( node ) - x_int ( anti_node )) ** 2 + ( y_int ( node ) - y_int ( anti_node )) ** 2 ) line_fraction_in_grid_func = length_int / length_line return endif enddo endif !Can't intersect since it is parallel with the vertical grid lines if ( x_line ( node ). ne . x_line ( anti_node )) then !Check intersection with the vertical grid faces do node_x_grid = 1 , 2 y_temp = y_line ( node ) + ( x_grid ( node_x_grid ) - x_line ( node )) * ( y_line ( anti_node ) - y_line ( node )) / ( x_line ( anti_node ) - x_line ( node )) x_temp = x_grid ( node_x_grid ) !write(*,*) node,x_line(node),y_line(node),x_temp,y_temp,MINVAL(x_line),MAXVAL(x_line) if ( x_temp . ge . MINVAL ( x_line ). and . x_temp . le . MAXVAL ( x_line ). and . x_temp . ne . x_line ( node ). and . y_temp . ge . MINVAL ( y_grid ). and . y_temp . le . MAXVAL ( y_grid )) then x_int ( anti_node ) = x_grid ( node_x_grid ) y_int ( anti_node ) = y_temp y_int ( node ) = y_line ( node ) x_int ( node ) = x_line ( node ) length_int = sqrt (( x_int ( node ) - x_int ( anti_node )) ** 2 + ( y_int ( node ) - y_int ( anti_node )) ** 2 ) line_fraction_in_grid_func = length_int / length_line return endif enddo endif endif enddo !node !Only posibility left is that both nodes are outside the grid !Find 2 intersections then n_intersection = 0 node = 1 anti_node = 2 if ( y_line ( node ). ne . y_line ( anti_node )) then !Can't intersect since it is parallel do node_y_grid = 1 , 2 !Check intersection with the horizontal grid faces x_temp = x_line ( node ) + ( y_grid ( node_y_grid ) - y_line ( node )) * ( x_line ( anti_node ) - x_line ( node )) / ( y_line ( anti_node ) - y_line ( node )) y_temp = y_grid ( node_y_grid ) if ( y_temp . ge . MINVAL ( y_line ). and . y_temp . le . MAXVAL ( y_line ). and . x_temp . ge . MINVAL ( x_grid ). and . x_temp . le . MAXVAL ( x_grid ). and . n_intersection . lt . 2 ) then n_intersection = n_intersection + 1 y_int ( n_intersection ) = y_temp x_int ( n_intersection ) = x_temp endif enddo endif if ( x_line ( node ). ne . x_line ( anti_node )) then !Can't intersect since it is parallel do node_x_grid = 1 , 2 y_temp = y_line ( node ) + ( x_grid ( node_x_grid ) - x_line ( node )) * ( y_line ( anti_node ) - y_line ( node )) / ( x_line ( anti_node ) - x_line ( node )) x_temp = x_grid ( node_x_grid ) !Use y_temp.lt.MAXVAL(y_grid) incase it is in one of the corners if ( x_temp . ge . MINVAL ( x_line ). and . x_temp . le . MAXVAL ( x_line ). and . y_temp . ge . MINVAL ( y_grid ). and . y_temp . lt . MAXVAL ( y_grid ). and . n_intersection . lt . 2 ) then n_intersection = n_intersection + 1 x_int ( n_intersection ) = x_temp y_int ( n_intersection ) = y_temp endif enddo endif if ( n_intersection . eq . 2 ) then length_int = sqrt (( x_int ( node ) - x_int ( anti_node )) ** 2 + ( y_int ( node ) - y_int ( anti_node )) ** 2 ) line_fraction_in_grid_func = length_int / length_line endif end function line_fraction_in_grid_func","tags":"","loc":"proc/line_fraction_in_grid_func.html"},{"title":"uEMEP_grid_roads – uEMEP","text":"public  subroutine uEMEP_grid_roads() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_grid_roads use uEMEP_definitions implicit none integer i , j integer ro real , allocatable :: f_subgrid (:) real , allocatable :: adt_temp (:,:) real , allocatable :: adt_car_temp (:) real , allocatable :: adt_truck_temp (:) real x_subgrid_in ( 2 ), y_subgrid_in ( 2 ) real x_line_in ( 2 ), y_line_in ( 2 ), lat_line_in ( 2 ), lon_line_in ( 2 ) integer i_traffic_index ( 2 ), j_traffic_index ( 2 ) integer i_start , i_end , j_start , j_end integer source_index , t integer i_roadlink_emission_compound ( n_pollutant_loop ) integer tt , ttt integer major_ro integer t_start_temp , t_end_temp real tunnel_ratio real sigma0_temp integer i_pollutant write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Gridding road link proxy data (uEMEP_grid_roads)' write ( unit_logfile , '(A)' ) '================================================================' allocate ( f_subgrid ( n_roadlinks )) allocate ( adt_temp ( n_roadlinks , n_pollutant_loop )) allocate ( adt_car_temp ( n_roadlinks )) allocate ( adt_truck_temp ( n_roadlinks )) !allocate (traffic_emission_subgrid(subgrid_dim(1),subgrid_dim(2)),n_emission_subgrid_index) source_index = traffic_index t = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. if ( use_traffic_for_sigma0_flag ) then emission_properties_subgrid (:,:, emission_sigy00_index , source_index ) = 0. emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) = 0. endif !Possible to split the traffic source into different subsources at this point if necessary, e.g. light and heavy traffic !Here we weight the adt by the emission ratio and give an emission factor valid for cars adt_car_temp = inputdata_rl ( 1 : n_roadlinks , adt_rl_index ) * ( 1. - inputdata_rl ( 1 : n_roadlinks , hdv_rl_index ) / 10 0. ) adt_truck_temp = inputdata_rl ( 1 : n_roadlinks , adt_rl_index ) * inputdata_rl ( 1 : n_roadlinks , hdv_rl_index ) / 10 0. do i_pollutant = 1 , n_pollutant_loop adt_temp (:, i_pollutant ) = adt_car_temp + adt_truck_temp * ratio_truck_car_emission ( pollutant_loop_index ( i_pollutant )) enddo !Calculate the pseudo traffic emissions in each grid write ( unit_logfile , * ) 'Gridding traffic emission proxy data' !Convert from uEMEP to NORTRIP if ( use_NORTRIP_emission_data ) then !This links the order of the NORTRIP output to the pollutants !Order is: pm10,pm2.5,pmex,nox,pm10_sand/salt,pm2.5_sand/salt,pm10_salt,pm2.5_salt do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 1 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 2 elseif ( pollutant_loop_index ( i_pollutant ). eq . pmex_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 3 elseif ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 4 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm10_sand_nc_index . and .( pollutant_index . eq . all_sand_nc_index . or . pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 5 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm10_salt_nc_index . and .( pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm10_salt_nc_index . and .( pollutant_index . eq . all_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 5 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_nc_index . and .( pollutant_index . eq . all_sand_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_nc_index . and .( pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 7 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_salt_nc_index . and .( pollutant_index . eq . all_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_salt_nc_index . and .( pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 8 else write ( unit_logfile , '(a,2i)' ) 'STOPPING: No valid compound chosen for NORTRIP. Stopping uEMEP_grid_roads. Pollutant index=' , pollutant_index , pollutant_loop_index ( i_pollutant ) !write(*,*) n_pollutant_loop !write(*,*) pollutant_loop_index(1:n_pollutant_loop) stop endif enddo emission_subgrid (:,:,:, traffic_index ,:) = 0. !Set the time to be used based on the time loop flag if ( use_single_time_loop_flag ) then t_start_temp = t_loop t_end_temp = t_loop else t_start_temp = 1 t_end_temp = subgrid_dim ( t_dim_index ) endif endif do ro = 1 , n_roadlinks x_line_in = inputdata_rl ( ro , x1_rl_index : x2_rl_index ) y_line_in = inputdata_rl ( ro , y1_rl_index : y2_rl_index ) !Convert to EMEP coordinates from specified projection type to lambertCC or latlon. Not certain if the fraction is correctly calculated in lat lon coordinates but otherwise very complicated if ( save_emissions_for_EMEP ( traffic_index )) then do i = 1 , 2 call PROJ2LL ( x_line_in ( i ), y_line_in ( i ), lon_line_in ( i ), lat_line_in ( i ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,y_line_in(i),x_line_in(i),lat_line_in(i),lon_line_in(i)) if ( EMEP_projection_type . eq . LL_projection_index ) then x_line_in ( i ) = lon_line_in ( i ) y_line_in ( i ) = lat_line_in ( i ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_line_in ( i ), y_line_in ( i ), lon_line_in ( i ), lat_line_in ( i ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_line_in ( i ), y_line_in ( i ), lon_line_in ( i ), lat_line_in ( i ), EMEP_projection_attributes ) endif enddo !write(*,*) x_line_in(1),y_line_in(1),lon_line_in(1),lat_line_in(1) endif i_traffic_index = 1 + floor (( x_line_in - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_traffic_index = 1 + floor (( y_line_in - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if (( i_traffic_index ( 1 ). ge . 1. or . i_traffic_index ( 2 ). ge . 1 ). and .( j_traffic_index ( 1 ). ge . 1. or . j_traffic_index ( 2 ). ge . 1 ). and . & ( i_traffic_index ( 1 ). le . emission_subgrid_dim ( x_dim_index , source_index ). or . i_traffic_index ( 2 ). le . emission_subgrid_dim ( x_dim_index , source_index )). and . & ( j_traffic_index ( 1 ). le . emission_subgrid_dim ( y_dim_index , source_index ). or . j_traffic_index ( 2 ). le . emission_subgrid_dim ( y_dim_index , source_index ))) then !write(*,*) ro,i_traffic_index,j_traffic_index !Limit the loop if it is near the edge i_start = max ( 1 , minval ( i_traffic_index )) i_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), maxval ( i_traffic_index )) j_start = max ( 1 , minval ( j_traffic_index )) j_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), maxval ( j_traffic_index )) !if (i_end-i_start.gt.2.or.j_end-j_start.gt.2) write(*,*) ro,i_start,i_end,j_start,j_end do j = j_start , j_end do i = i_start , i_end x_subgrid_in ( 1 ) = x_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( x_dim_index , source_index ) / 2. x_subgrid_in ( 2 ) = x_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( x_dim_index , source_index ) / 2. y_subgrid_in ( 1 ) = y_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( y_dim_index , source_index ) / 2. y_subgrid_in ( 2 ) = y_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( y_dim_index , source_index ) / 2. f_subgrid ( ro ) = line_fraction_in_grid_func ( x_subgrid_in , y_subgrid_in , x_line_in , y_line_in ) !do subsource_index=1,n_subsource(source_index) proxy_emission_subgrid ( i , j , source_index ,:) = proxy_emission_subgrid ( i , j , source_index ,:) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * adt_temp ( ro ,:) !Put the temporally changing emissions straight into the emission subgrid !Will not be overwritten in uEMEP_convert_proxy_to_emissions if use_NORTRIP_emission_data=true if ( use_NORTRIP_emission_data ) then major_ro = inputdata_int_rl ( ro , major_index_rl_index ) do tt = t_start_temp , t_end_temp !Convert from g/km/hour to ug/s/subgrid if ( use_single_time_loop_flag ) then ttt = t_loop t = 1 else t = tt ttt = tt endif !write(*,*) 'ro,major_ro,tt,t,ttt',ro,major_ro,tt,t,ttt !write(*,*) 'emission_grid',shape(emission_subgrid) !write(*,*) 'inputdata_rl_emissions',shape(inputdata_rl_emissions) !if (t_loop.eq.2) stop do i_pollutant = 1 , n_pollutant_loop !write(*,*) i_pollutant,major_ro,inputdata_rl(major_ro,tunnel_length_rl_index) if ( use_tunnel_deposition_flag . and . inputdata_rl ( ro , tunnel_length_rl_index ). gt . 0 ) then call tunnel_deposition_factor ( pollutant_loop_index ( i_pollutant ), inputdata_rl ( ro , tunnel_length_rl_index ) & , inputdata_rl ( ro , ADT_rl_index ) * inputdata_rl ( ro , length_rl_index ) / inputdata_rl ( ro , tunnel_length_rl_index ) & , ventilation_factor , min_ADT_ventilation_factor , min_length_ventilation_factor , windspeed_tunnel , tunnel_ratio ) else tunnel_ratio = 1. endif !Turn off tunnel emissions if required if (. not . use_tunnel_emissions_flag . and . inputdata_rl ( ro , tunnel_length_rl_index ). gt . 0 ) then tunnel_ratio = 0 endif !Converts from g/km/hr (NORTRIP) to ug/sec (uEMEP) emission_subgrid ( i , j , t , source_index , i_pollutant ) = emission_subgrid ( i , j , t , source_index , i_pollutant ) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * inputdata_rl_emissions ( major_ro , ttt , i_roadlink_emission_compound ( i_pollutant )) & * 1.e6 / 1.e3 / 360 0. * tunnel_ratio enddo !write(*,*) i,j, emission_subgrid(i,j,t,source_index,pollutant_loop_back_index(pm10_nc_index)),emission_subgrid(i,j,t,source_index,pollutant_loop_back_index(pm25_nc_index)) enddo endif !Set the sigma values according to traffic speed and road width using proxy weighting if ( use_traffic_for_sigma0_flag . and .. not . save_emissions_for_EMEP ( traffic_index )) then sigma0_temp = sigma0_traffic_func ( inputdata_rl ( ro , speed_rl_index )) if ( inputdata_rl ( ro , tunnel_length_rl_index ). gt . 5 0. ) sigma0_temp = tunnel_sig_z_00 emission_properties_subgrid ( i , j , emission_sigy00_index , source_index ) = emission_properties_subgrid ( i , j , emission_sigy00_index , source_index ) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * adt_temp ( ro , 1 ) * sqrt (( inputdata_rl ( ro , width_rl_index ) / 2. ) ** 2 + sigma0_temp ** 2 ) emission_properties_subgrid ( i , j , emission_sigz00_index , source_index ) = emission_properties_subgrid ( i , j , emission_sigz00_index , source_index ) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * adt_temp ( ro , 1 ) * sigma0_temp endif !enddo !write(*,*) ro,i,j,f_subgrid(ro) !write(*,*) ro,f_subgrid(ro),traffic_emission_subgrid(i,j,x_emission_subgrid_index),traffic_emission_subgrid(i,j,y_emission_subgrid_index),x_line_in,y_line_in enddo enddo !write(*,*) 'Gridding traffic emission',ro,' of ',n_roadlinks endif !if (mod(ro,10000).eq.0) write(*,*) 'Gridding traffic emission',ro,' of ',n_roadlinks enddo !Set the road properties based on ADT weighting if ( use_traffic_for_sigma0_flag ) then emission_properties_subgrid (:,:, emission_sigy00_index , source_index ) = emission_properties_subgrid (:,:, emission_sigy00_index , source_index ) / proxy_emission_subgrid (:,:, source_index , 1 ) emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) = emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) / proxy_emission_subgrid (:,:, source_index , 1 ) endif deallocate ( f_subgrid ) deallocate ( adt_temp ) deallocate ( adt_car_temp ) deallocate ( adt_truck_temp ) !Deallocate road link arrays after gridding but not when the external time step is used !and not when the multiple receptor grids are used !and not when the auto subgridding is used !because gridding roads is called again if ( use_single_time_loop_flag . or . use_multiple_receptor_grids_flag . or . use_emission_positions_for_auto_subgrid_flag ( allsource_index )) then !Do not deallocate because they will be used again else if ( allocated ( inputdata_rl )) deallocate ( inputdata_rl ) if ( allocated ( inputdata_int_rl )) deallocate ( inputdata_int_rl ) if ( allocated ( inputdata_rl_emissions )) deallocate ( inputdata_rl_emissions ) endif end subroutine uEMEP_grid_roads","tags":"","loc":"proc/uemep_grid_roads.html"},{"title":"tunnel_deposition_factor – uEMEP","text":"private  subroutine tunnel_deposition_factor(tunnel_pollutant_index, tunnel_length, tunnel_ADT, ventilation_fac, min_ADT_ventilation_fac, min_length_ventilation_fac, windspeed_tunnel_in, ratio) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer, intent(in) :: tunnel_pollutant_index real, intent(in) :: tunnel_length real, intent(in) :: tunnel_ADT real, intent(in) :: ventilation_fac real, intent(in) :: min_ADT_ventilation_fac real, intent(in) :: min_length_ventilation_fac real, intent(in) :: windspeed_tunnel_in real, intent(out) :: ratio Source Code subroutine tunnel_deposition_factor ( tunnel_pollutant_index , tunnel_length , tunnel_ADT , ventilation_fac , min_ADT_ventilation_fac , min_length_ventilation_fac , windspeed_tunnel_in , ratio ) use uEMEP_definitions implicit none integer , intent ( in ) :: tunnel_pollutant_index real , intent ( in ) :: tunnel_length , tunnel_ADT real , intent ( in ) :: ventilation_fac , min_ADT_ventilation_fac , min_length_ventilation_fac real , intent ( in ) :: windspeed_tunnel_in !(m/s) real :: dep_velocity !(cm/s) real :: radius_tunnel = 5. !Radius of the tunnel opening. Fixed real :: B real , intent ( out ) :: ratio dep_velocity = 0. if ( tunnel_pollutant_index . eq . pm10_index ) dep_velocity = 0.1 if ( tunnel_pollutant_index . eq . pm25_index ) dep_velocity = 0.05 if ( tunnel_pollutant_index . eq . pmex_index ) dep_velocity = 0.05 if ( tunnel_pollutant_index . eq . nox_index ) dep_velocity = 0.02 B = 2. / radius_tunnel * dep_velocity / 10 0. / max ( windspeed_tunnel_in , 0.1 ) ratio = 1. if ( B * tunnel_length . lt . 1e-5 ) then ratio = 1 - B * tunnel_length / 2. else ratio = 1 / B * ( 1 - exp ( - B * tunnel_length )) / tunnel_length endif !Adjust for ventilation if ( tunnel_ADT . gt . min_ADT_ventilation_fac . and . tunnel_length . gt . min_length_ventilation_fac ) then !write(*,*) min_ADT_ventilation_fac,min_length_ventilation_fac,ratio,B ratio = ratio * ventilation_fac !write(*,*) tunnel_ADT,tunnel_length,ratio,ventilation_fac endif !write(*,*) tunnel_pollutant_index,tunnel_length,ratio end subroutine tunnel_deposition_factor","tags":"","loc":"proc/tunnel_deposition_factor.html"},{"title":"save_gridded_lines_test_routine – uEMEP","text":"private  subroutine save_gridded_lines_test_routine() Uses uEMEP_definitions Arguments None Source Code subroutine save_gridded_lines_test_routine use uEMEP_definitions implicit none real :: x_grid ( 10 , 2 ), y_grid ( 10 , 2 ), x_line ( 50 , 2 ), y_line ( 50 , 2 ) real :: line ( 50 , 4 ), length_line ( 50 ) integer n_grid , n_line integer l , g real :: f ( 50 ) n_grid = 2 x_grid ( 1 ,:) = ( /- 1 , 1 / ) y_grid ( 1 ,:) = ( /- 1 , 1 / ) x_grid ( 2 ,:) = ( / 1 , 3 / ) y_grid ( 2 ,:) = ( / 1 , 3 / ) line ( 1 ,:) = ( / . 5 ,. 5 , 1. , 2. / ) !x1,y1,x2,y2 line ( 2 ,:) = ( / . 5 , 0. , - 2. , - 0. / ) !x1,y1,x2,y2 line ( 3 ,:) = ( / 0. , - 0.2 , - 0. , - 2. / ) !x1,y1,x2,y2 line ( 4 ,:) = ( / 2. , 3. , 0.5 , 2. / ) !x1,y1,x2,y2 line ( 5 ,:) = ( /- 2. , - 3. , 1.5 , 1.5 / ) !x1,y1,x2,y2 line ( 6 ,:) = ( / . 7 , - . 9 ,. 2 ,. 7 / ) !x1,y1,x2,y2 line ( 7 ,:) = ( /- 1. , - 3. , - 1. , + 1. / ) !x1,y1,x2,y2 line ( 8 ,:) = ( /- . 5 , - 1. , 3. , - 1. / ) !x1,y1,x2,y2 line ( 9 ,:) = ( /- . 5 , 1. , 3. , 1. / ) !x1,y1,x2,y2 line ( 10 ,:) = ( / 1. , - 3. , 1. , + 0. / ) !x1,y1,x2,y2 line ( 11 ,:) = ( /- . 7 , - 3. , - . 7 , + 2. / ) !x1,y1,x2,y2 line ( 12 ,:) = ( / . 5 , 1.5 , 1.5 ,. 6 / ) !x1,y1,x2,y2 line ( 13 ,:) = ( /- 1. , 1. , 1. , - 1. / ) !x1,y1,x2,y2 line ( 14 ,:) = ( /- 1. , - 1. , 1. , 1. / ) !x1,y1,x2,y2 line ( 15 ,:) = ( /- 1. , 1. , 1. , 1. / ) !x1,y1,x2,y2 line ( 16 ,:) = ( /- 1.5 ,. 3 , 1.5 ,. 3 / ) !x1,y1,x2,y2 line ( 17 ,:) = ( /- 3. , 2. , 1.5 , - 3. / ) !x1,y1,x2,y2 line ( 18 ,:) = ( /- 3. , - 2. , 1. , 1. / ) !x1,y1,x2,y2 line ( 19 ,:) = ( /+ 3. , - 2. , - 1. , 1. / ) !x1,y1,x2,y2 line ( 20 ,:) = ( /- 3. , 0. , 1. , - 1. / ) !x1,y1,x2,y2 n_line = 20 write ( * , * ) 'input data' g = 1 do l = 1 , n_line x_line ( l , 1 ) = line ( l , 1 ) x_line ( l , 2 ) = line ( l , 3 ) y_line ( l , 1 ) = line ( l , 2 ) y_line ( l , 2 ) = line ( l , 4 ) length_line ( l ) = sqrt (( x_line ( l , 1 ) - x_line ( l , 2 )) ** 2 + ( y_line ( l , 1 ) - y_line ( l , 2 )) ** 2 ) !write(*,*) g,l,x_grid(g,:),y_grid(g,:),x_line(l,:),y_line(l,:),length_line(l) enddo write ( * , * ) 'starting gridding' do g = 1 , n_grid do l = 1 , n_line f ( l ) = line_fraction_in_grid_func ( x_grid ( g ,:), y_grid ( g ,:), x_line ( l ,:), y_line ( l ,:)) write ( * , * ) g , l , f ( l ) enddo enddo stop end subroutine save_gridded_lines_test_routine","tags":"","loc":"proc/save_gridded_lines_test_routine.html"},{"title":"uEMEP_read_landuse_rivm_data – uEMEP","text":"public  subroutine uEMEP_read_landuse_rivm_data() Arguments None Source Code subroutine uEMEP_read_landuse_rivm_data implicit none integer i , j integer ncols_sub , nrows_sub real cellsize_sub , xll_corner_sub , yll_corner_sub real , allocatable :: landuse_array (:,:) integer depac_index ( 9 ) integer emep_landuse_index logical :: exists !landuse_subgrid=0 !landuse_subgrid(:,:,temp_decid_index)=1. pathfilename_landuse = trim ( pathname_landuse ) // trim ( filename_landuse ) inquire ( file = trim ( pathfilename_landuse ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Landuse file does not exist: ' , trim ( pathfilename_landuse ) stop endif call read_esri_ascii_header ( pathfilename_landuse , ncols_sub , nrows_sub , cellsize_sub , xll_corner_sub , yll_corner_sub ,. false .) landuse_subgrid_dim ( x_dim_index ) = ncols_sub landuse_subgrid_dim ( y_dim_index ) = nrows_sub landuse_subgrid_min ( x_dim_index ) = xll_corner_sub landuse_subgrid_min ( y_dim_index ) = yll_corner_sub landuse_subgrid_delta ( x_dim_index ) = cellsize_sub landuse_subgrid_delta ( y_dim_index ) = cellsize_sub !Deallocate grids if they are already allocated. if ( allocated ( landuse_subgrid )) deallocate ( landuse_subgrid ) if ( allocated ( x_landuse_subgrid )) deallocate ( x_landuse_subgrid ) if ( allocated ( y_landuse_subgrid )) deallocate ( y_landuse_subgrid ) if ( allocated ( lon_landuse_subgrid )) deallocate ( lon_landuse_subgrid ) if ( allocated ( lat_landuse_subgrid )) deallocate ( lat_landuse_subgrid ) if ( allocated ( xproj_landuse_subgrid )) deallocate ( xproj_landuse_subgrid ) if ( allocated ( yproj_landuse_subgrid )) deallocate ( yproj_landuse_subgrid ) !Reefine landuse grid if (. not . allocated ( landuse_subgrid )) allocate ( landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ), n_landuse_index )) if (. not . allocated ( x_landuse_subgrid )) allocate ( x_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_landuse_subgrid )) allocate ( y_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_landuse_subgrid )) allocate ( lon_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_landuse_subgrid )) allocate ( lat_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_landuse_subgrid )) allocate ( xproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_landuse_subgrid )) allocate ( yproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) !Set the depsoition grid to be the same dimensions as the landuse grid deposition_subgrid_dim ( x_dim_index ) = ncols_sub deposition_subgrid_dim ( y_dim_index ) = nrows_sub deposition_subgrid_min ( x_dim_index ) = xll_corner_sub deposition_subgrid_min ( y_dim_index ) = yll_corner_sub deposition_subgrid_delta ( x_dim_index ) = cellsize_sub deposition_subgrid_delta ( y_dim_index ) = cellsize_sub !Deallocate grids if they are already allocated. if ( allocated ( deposition_subgrid )) deallocate ( deposition_subgrid ) if ( allocated ( x_deposition_subgrid )) deallocate ( x_deposition_subgrid ) if ( allocated ( y_deposition_subgrid )) deallocate ( y_deposition_subgrid ) if ( allocated ( lon_deposition_subgrid )) deallocate ( lon_deposition_subgrid ) if ( allocated ( lat_deposition_subgrid )) deallocate ( lat_deposition_subgrid ) if ( allocated ( xproj_deposition_subgrid )) deallocate ( xproj_deposition_subgrid ) if ( allocated ( yproj_deposition_subgrid )) deallocate ( yproj_deposition_subgrid ) !Reefine deposition grid if (. not . allocated ( deposition_subgrid )) allocate ( deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), deposition_subgrid_dim ( t_dim_index ), n_deposition_index , n_pollutant_loop )) if (. not . allocated ( x_deposition_subgrid )) allocate ( x_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_deposition_subgrid )) allocate ( y_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_deposition_subgrid )) allocate ( lon_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_deposition_subgrid )) allocate ( lat_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_deposition_subgrid )) allocate ( xproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_deposition_subgrid )) allocate ( yproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) do j = 1 , landuse_subgrid_dim ( y_dim_index ) do i = 1 , landuse_subgrid_dim ( x_dim_index ) x_landuse_subgrid ( i , j ) = landuse_subgrid_min ( x_dim_index ) + landuse_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_landuse_subgrid ( i , j ) = landuse_subgrid_min ( y_dim_index ) + landuse_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the landuse call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_landuse_subgrid ( i , j ) = lon_landuse_subgrid ( i , j ) yproj_landuse_subgrid ( i , j ) = lat_landuse_subgrid ( i , j ) endif enddo enddo !Set the deposition x and y to be the same x_deposition_subgrid = x_landuse_subgrid y_deposition_subgrid = y_landuse_subgrid xproj_deposition_subgrid = xproj_landuse_subgrid yproj_deposition_subgrid = yproj_landuse_subgrid lon_deposition_subgrid = lon_landuse_subgrid lat_deposition_subgrid = lat_landuse_subgrid !Recalculate the cross references again since these could have changed call uEMEP_crossreference_grids !Read the landuse index into the temporary landuse array if (. not . allocated ( landuse_array )) allocate ( landuse_array ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) call read_esri_ascii_file ( pathfilename_landuse , ncols_sub , nrows_sub , cellsize_sub , landuse_array , x_landuse_subgrid , y_landuse_subgrid ,. false .) !set the depac indicies to the matching EMEP ones depac_index = 0 depac_index ( 4 ) = temp_conif_index depac_index ( 5 ) = temp_decid_index depac_index ( 2 ) = temp_crop_index depac_index ( 3 ) = temp_crop_index depac_index ( 8 ) = moorland_index depac_index ( 1 ) = grass_index depac_index ( 9 ) = desert_index depac_index ( 6 ) = water_index depac_index ( 7 ) = urban_index !Distribute to the depac indexes to the EMEP ones landuse_subgrid = 0 do j = 1 , landuse_subgrid_dim ( y_dim_index ) do i = 1 , landuse_subgrid_dim ( x_dim_index ) emep_landuse_index = depac_index ( int ( landuse_array ( i , j ))) landuse_subgrid ( i , j , emep_landuse_index ) = 1. !Put the landuse index in the last array landuse_subgrid ( i , j , grid_index ) = emep_landuse_index !write(*,*) i,j,int(landuse_array(i,j)), emep_landuse_index enddo enddo if ( allocated ( landuse_array )) deallocate ( landuse_array ) end subroutine uEMEP_read_landuse_rivm_data","tags":"","loc":"proc/uemep_read_landuse_rivm_data.html"},{"title":"uEMEP_read_netcdf_landuse_latlon – uEMEP","text":"public  subroutine uEMEP_read_netcdf_landuse_latlon() Uses uEMEP_definitions netcdf Arguments None Source Code subroutine uEMEP_read_netcdf_landuse_latlon use uEMEP_definitions use netcdf implicit none integer status_nc integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc integer i_landuse_index , j_landuse_index real delta_landuse_nc ( num_dims_landuse_nc ) integer dim_id_nc ( num_dims_landuse_nc ) logical reduce_landuse_region_flag real temp_lon ( 4 ), temp_lat ( 4 ), temp_x ( 4 ), temp_y ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max real temp_delta ( num_dims_landuse_nc ) real correct_lon ( 2 ) real temp_scale integer i_source , i_landuse real buffer_delta logical :: exists !Temporary reading variables real , allocatable :: landuse_nc_dp (:,:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: temp_var2d_nc_dp (:,:) !Functions !real area_weighted_extended_vectorgrid_interpolation_function write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading landuse data (uEMEP_read_netcdf_landuse_latlon)' write ( unit_logfile , '(A)' ) '================================================================' !Set the filename pathfilename_landuse = trim ( pathname_landuse ) // trim ( filename_landuse ) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_landuse ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_landuse ) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_landuse ) status_nc = NF90_OPEN ( pathfilename_landuse , nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the (lon,lat) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_landuse_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_landuse_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_landuse_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_landuse_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_landuse_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of landuse dimensions (lon,lat): ' , dim_length_landuse_nc !Reduce the size of the grid to the heating emission grid size reduce_landuse_region_flag = . true . if ( reduce_landuse_region_flag ) then write ( unit_logfile , '(A)' ) 'Reducing landuse domain for reading' !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon buffer_delta = 10 call PROJ2LL ( landuse_subgrid_min ( x_dim_index ) - buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_min ( y_dim_index ) - buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( landuse_subgrid_max ( x_dim_index ) + buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_max ( y_dim_index ) + buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( landuse_subgrid_min ( x_dim_index ) - buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_max ( y_dim_index ) + buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( landuse_subgrid_max ( x_dim_index ) + buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_min ( y_dim_index ) - buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 temp_x = temp_lon ; temp_y = temp_lat do i = 1 , 4 write ( * , * ) i , temp_x ( i ), temp_y ( i ) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo write ( unit_logfile , '(A,2f12.2)' ) 'Min: ' , temp_x_min , temp_y_min write ( unit_logfile , '(A,2f12.2)' ) 'Max: ' , temp_x_max , temp_y_max !Read the lon and lat values to get the delta and size. Put in temporary array !Allocate the temporary arrays for lat,lon and population if (. not . allocated ( temp_var2d_nc_dp )) allocate ( temp_var2d_nc_dp ( max ( dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index )), num_dims_landuse_nc )) !x and y dim_start_landuse_nc = 1 do i = 1 , num_dims_landuse_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_landuse_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var2d_nc_dp ( 1 : dim_length_landuse_nc ( i ), i ), start = ( / dim_start_landuse_nc ( i ) / ), count = ( / dim_length_landuse_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_landuse_nc = temp_var2d_nc_dp ( 2 ,:) - temp_var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Landuse grid delta (degrees): ' , delta_landuse_nc !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = delta_landuse_nc ( 1 ) temp_delta ( 2 ) = delta_landuse_nc ( 2 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max !Increase the region by 5 grids to be certain i_temp_min = max ( 1 , i_temp_min - 10 ) i_temp_max = min ( dim_length_landuse_nc ( x_dim_nc_index ), i_temp_max + 10 ) j_temp_min = max ( 1 , j_temp_min - 10 ) j_temp_max = min ( dim_length_landuse_nc ( y_dim_nc_index ), j_temp_max + 10 ) dim_length_landuse_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_landuse_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_landuse_nc ( x_dim_nc_index ) = i_temp_min dim_start_landuse_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading landuse i grids: ' , i_temp_min , i_temp_max , dim_length_landuse_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading landuse j grids: ' , j_temp_min , j_temp_max , dim_length_landuse_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading landuse lon grids (min,max): ' , temp_var2d_nc_dp ( i_temp_min , x_dim_nc_index ), temp_var2d_nc_dp ( i_temp_max , x_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading landuse lat grids (min,max): ' , temp_var2d_nc_dp ( j_temp_min , y_dim_nc_index ), temp_var2d_nc_dp ( j_temp_max , y_dim_nc_index ) !endif endif if ( i_temp_min . ge . i_temp_max . or . j_temp_min . ge . j_temp_max ) then !No population data available write ( unit_logfile , '(A)' ) ' WARNING: No landuse data available in this region. Setting to 0' landuse_subgrid (:,:, clc_index ) = 0 else if (. not . allocated ( landuse_nc_dp )) allocate ( landuse_nc_dp ( dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index ))) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index )), num_dims_landuse_nc )) !x and y !Read the lon and lat values to get the delta do i = 1 , num_dims_landuse_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_landuse_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_landuse_nc ( i ), i ), start = ( / dim_start_landuse_nc ( i ) / ), count = ( / dim_length_landuse_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_landuse_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Landuse grid delta (degrees): ' , delta_landuse_nc !write(*,*) var2d_nc_dp(1,1),var2d_nc_dp(dim_length_population_nc(x_dim_nc_index),1) !write(*,*) var2d_nc_dp(1,2),var2d_nc_dp(dim_length_population_nc(y_dim_nc_index),2) !Read the landuse data i = 1 !Uses the population_nc_index as index, =1, but not logical !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_landuse_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , landuse_nc_dp (:,:), start = ( / dim_start_landuse_nc ( x_dim_nc_index ), dim_start_landuse_nc ( y_dim_nc_index ) / ), count = ( / dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Landuse variable min and max: ' , trim ( var_name_nc_temp ), minval ( landuse_nc_dp (:,:)), maxval ( landuse_nc_dp (:,:)) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif !enddo !write(*,*) 'Finished reading landuse data' !Loop through the landuse data and put it in the landuse grid !Converting from lat lon to the subgrid coordinates and then finding the nearest neighbour landuse_subgrid (:,:, clc_index ) = 0 where ( landuse_nc_dp . lt . 0 ) landuse_nc_dp = 0. write ( unit_logfile , '(2a,2f12.2)' ) 'Landuse min and max: ' , trim ( var_name_nc_temp ), minval ( landuse_nc_dp (:,:)), maxval ( landuse_nc_dp (:,:)) !stop do j = 1 , landuse_subgrid_dim ( y_dim_nc_index ) do i = 1 , landuse_subgrid_dim ( x_dim_nc_index ) !Project the centre position to lat lon call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_landuse_subgrid ( i , j ) - landuse_subgrid_delta ( x_dim_index ) / 2. , y_landuse_subgrid ( i , j ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_landuse_subgrid ( i , j ) + landuse_subgrid_delta ( x_dim_index ) / 2. , y_landuse_subgrid ( i , j ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ) - landuse_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ) + landuse_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !Take the nearest instead i_landuse_index = 1 + floor (( temp_lon ( 1 ) - var2d_nc_dp ( 1 , x_dim_nc_index )) / delta_landuse_nc ( 1 ) + 0.5 ) j_landuse_index = 1 + floor (( temp_lat ( 1 ) - var2d_nc_dp ( 1 , y_dim_nc_index )) / delta_landuse_nc ( 2 ) + 0.5 ) !write(*,*) i,j,temp_lon(1),temp_lat(1) landuse_subgrid ( i , j , clc_index ) = landuse_nc_dp ( i_landuse_index , j_landuse_index ) !Place the clc landuse in the EMEP landuse if ( landuse_subgrid ( i , j , clc_index ). gt . 0 ) then landuse_subgrid ( i , j , Corine_to_EMEP_landuse ( landuse_subgrid ( i , j , clc_index ))) = 1 else landuse_subgrid ( i , j , Corine_to_EMEP_landuse ( NODATA_clc_value )) = 1 endif !Do the interpolation on the same grid then scale afterwards. Equivalent to interpolating density then rescaling with grid size !landuse_subgrid(i,j,clc_index)=area_weighted_extended_vectorgrid_interpolation_function( & !    real(var2d_nc_dp(1:dim_length_landuse_nc(x_dim_nc_index),x_dim_nc_index))*correct_lon(1),real(var2d_nc_dp(1:dim_length_landuse_nc(y_dim_nc_index),y_dim_nc_index)) & !    ,landuse_nc_dp(:,:,landuse_nc_index),dim_length_landuse_nc(x_dim_nc_index),dim_length_landuse_nc(y_dim_nc_index) & !    ,delta_landuse_nc*correct_lon,temp_lon(1)*correct_lon(1),temp_lat(1),delta_landuse_nc*correct_lon) !temp_scale=(temp_delta(1)*correct_lon(1)*temp_delta(2)*correct_lon(2))/(delta_landuse_nc(1)*correct_lon(1)*delta_landuse_nc(2)*correct_lon(2)) !write(*,*) temp_scale !landuse_subgrid(i,j,clc_index)=landuse_subgrid(i,j,clc_index)*temp_scale if ( isnan ( landuse_subgrid ( i , j , clc_index ))) then write ( * , * ) 'Stopping, nan in landuse_subgrid' write ( * , * ) temp_scale , correct_lon , delta_landuse_nc , temp_delta , temp_lon stop endif if ( landuse_subgrid ( i , j , clc_index ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in landuse_subgrid' write ( * , * ) temp_scale , correct_lon , delta_landuse_nc , temp_delta , temp_lon stop endif enddo enddo write ( unit_logfile , '(A,2f12.2)' ) 'Max and min landuse in read domain: ' , maxval ( landuse_nc_dp (:,:)), minval ( landuse_nc_dp (:,:)) write ( unit_logfile , '(A,2f12.2)' ) 'Max and min landuse in subgrid domain: ' , maxval ( landuse_subgrid (:,:, clc_index )), minval ( landuse_subgrid (:,:, clc_index )) if ( use_landuse_as_proxy ) then !Place the landuse as a proxy emission with the appropriate weights !loop through all sources and landuses do i_source = 1 , n_source_index !If source is to be downscaled and at least one landuse is selected then calculate the proxy emission weighting !write(*,*) i_source,calculate_source(i_source),sum(landuse_proxy_weighting(i_source,:)) if ( calculate_source ( i_source ). and . sum ( landuse_proxy_weighting ( i_source ,:)). gt . 0 ) then proxy_emission_subgrid (:,:, i_source ,:) = 0. do i_landuse = 1 , n_clc_landuse_index !write(*,*) i_source,i_landuse,landuse_proxy_weighting(i_source,i_landuse) if ( landuse_proxy_weighting ( i_source , i_landuse ). gt . 0 ) then write ( unit_logfile , '(A,i4,A,A,a,i4)' ) 'Distributing landuse index ' , i_landuse , ' to uEMEP sector \"' , trim ( source_file_str ( i_source )), '\" and GNFR sector ' , uEMEP_to_EMEP_sector ( i_source ) do j = 1 , emission_subgrid_dim ( y_dim_nc_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_nc_index , i_source ) i_landuse_index = crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ) j_landuse_index = crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ) if ( int ( landuse_subgrid ( i_landuse_index , j_landuse_index , clc_index )). eq . i_landuse ) then proxy_emission_subgrid ( i , j , i_source ,:) = proxy_emission_subgrid ( i , j , i_source ,:) + landuse_proxy_weighting ( i_source , i_landuse ) !write(*,'(6i,2f12.2)') i,j,i_landuse_index,j_landuse_index,i_source,i_landuse,landuse_proxy_weighting(i_source,i_landuse),proxy_emission_subgrid(i,j,i_source,1) endif !If there is no data (0 or greater than the maximum number of landuse categories) then distribute emissions evenly on the EMEP grid if ( int ( landuse_subgrid ( i_landuse_index , j_landuse_index , clc_index )). gt . n_clc_landuse_index . or . int ( landuse_subgrid ( i_landuse_index , j_landuse_index , clc_index )). lt . 1 ) then proxy_emission_subgrid ( i , j , i_source ,:) = 1. endif enddo enddo endif enddo endif enddo endif endif !No landuse available if ( allocated ( landuse_nc_dp )) deallocate ( landuse_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_var2d_nc_dp )) deallocate ( temp_var2d_nc_dp ) end subroutine uEMEP_read_netcdf_landuse_latlon","tags":"","loc":"proc/uemep_read_netcdf_landuse_latlon.html"},{"title":"uEMEP_set_landuse_classes – uEMEP","text":"public  subroutine uEMEP_set_landuse_classes() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_landuse_classes use uEMEP_definitions implicit none !test !landuse_proxy_weighting(heating_index,Continuous_urban_fabric_value)=1. !landuse_proxy_weighting(heating_index,Discontinuous_urban_fabric_value)=0.5 Continuous_urban_fabric_value = 1 Discontinuous_urban_fabric_value = 2 Industrial_or_commercial_units_value = 3 Road_and_rail_networks_and_associated_land_value = 4 Port_areas_value = 5 Airports_value = 6 Mineral_extraction_sites_value = 7 Dump_sites_value = 8 Construction_sites_value = 9 Green_urban_areas_value = 10 Sport_and_leisure_facilities_value = 11 Non_irrigated_arable_land_value = 12 Permanently_irrigated_land_value = 13 Rice_fields_value = 14 Vineyards_value = 15 Fruit_trees_and_berry_plantations_value = 16 Olive_groves_value = 17 Pastures_value = 18 Annual_crops_associated_with_permanent_crops_value = 19 Complex_cultivation_patterns_value = 20 Land_principally_occupied_by_agriculture_value = 21 Agro_forestry_areas_value = 22 Broad_leaved_forest_value = 23 Coniferous_forest_value = 24 Mixed_forest_value = 25 Natural_grasslands_value = 26 Moors_and_heathland_value = 27 Sclerophyllous_vegetation_value = 28 Transitional_woodland_shrub_value = 29 Beaches_dunes_sands_value = 30 Bare_rocks_value = 31 Sparsely_vegetated_areas_value = 32 Burnt_areas_value = 33 Glaciers_and_perpetual_snow_value = 34 Inland_marshes_value = 35 Peat_bogs_value = 36 Salt_marshes_value = 37 Salines_value = 38 Intertidal_flats_value = 39 Water_courses_value = 40 Water_bodies_value = 41 Coastal_lagoons_value = 42 Estuaries_value = 43 Sea_and_ocean_value = 44 NODATA_clc_value = 48 Corine_to_EMEP_landuse ( Continuous_urban_fabric_value ) = urban_index Corine_to_EMEP_landuse ( Discontinuous_urban_fabric_value ) = urban_index Corine_to_EMEP_landuse ( Industrial_or_commercial_units_value ) = urban_index Corine_to_EMEP_landuse ( Road_and_rail_networks_and_associated_land_value ) = urban_index Corine_to_EMEP_landuse ( Port_areas_value ) = urban_index Corine_to_EMEP_landuse ( Airports_value ) = urban_index Corine_to_EMEP_landuse ( Mineral_extraction_sites_value ) = urban_index Corine_to_EMEP_landuse ( Dump_sites_value ) = urban_index Corine_to_EMEP_landuse ( Construction_sites_value ) = urban_index Corine_to_EMEP_landuse ( Green_urban_areas_value ) = grass_index Corine_to_EMEP_landuse ( Sport_and_leisure_facilities_value ) = urban_index Corine_to_EMEP_landuse ( Non_irrigated_arable_land_value ) = grass_index Corine_to_EMEP_landuse ( Permanently_irrigated_land_value ) = grass_index Corine_to_EMEP_landuse ( Rice_fields_value ) = wetlands_index Corine_to_EMEP_landuse ( Vineyards_value ) = med_crop_index Corine_to_EMEP_landuse ( Fruit_trees_and_berry_plantations_value ) = med_crop_index Corine_to_EMEP_landuse ( Olive_groves_value ) = med_crop_index Corine_to_EMEP_landuse ( Pastures_value ) = grass_index Corine_to_EMEP_landuse ( Annual_crops_associated_with_permanent_crops_value ) = temp_crop_index Corine_to_EMEP_landuse ( Complex_cultivation_patterns_value ) = temp_crop_index Corine_to_EMEP_landuse ( Land_principally_occupied_by_agriculture_value ) = temp_crop_index Corine_to_EMEP_landuse ( Agro_forestry_areas_value ) = temp_decid_index Corine_to_EMEP_landuse ( Broad_leaved_forest_value ) = temp_decid_index Corine_to_EMEP_landuse ( Coniferous_forest_value ) = med_needle_index Corine_to_EMEP_landuse ( Mixed_forest_value ) = med_broadleaf_index Corine_to_EMEP_landuse ( Natural_grasslands_value ) = grass_index Corine_to_EMEP_landuse ( Moors_and_heathland_value ) = moorland_index Corine_to_EMEP_landuse ( Sclerophyllous_vegetation_value ) = medscrub_index Corine_to_EMEP_landuse ( Transitional_woodland_shrub_value ) = moorland_index Corine_to_EMEP_landuse ( Beaches_dunes_sands_value ) = desert_index Corine_to_EMEP_landuse ( Bare_rocks_value ) = urban_index Corine_to_EMEP_landuse ( Sparsely_vegetated_areas_value ) = medscrub_index Corine_to_EMEP_landuse ( Burnt_areas_value ) = medscrub_index Corine_to_EMEP_landuse ( Glaciers_and_perpetual_snow_value ) = ice_index Corine_to_EMEP_landuse ( Inland_marshes_value ) = wetlands_index Corine_to_EMEP_landuse ( Peat_bogs_value ) = wetlands_index Corine_to_EMEP_landuse ( Salt_marshes_value ) = wetlands_index Corine_to_EMEP_landuse ( Salines_value ) = wetlands_index Corine_to_EMEP_landuse ( Intertidal_flats_value ) = wetlands_index Corine_to_EMEP_landuse ( Water_courses_value ) = wetlands_index Corine_to_EMEP_landuse ( Water_bodies_value ) = water_index Corine_to_EMEP_landuse ( Coastal_lagoons_value ) = water_index Corine_to_EMEP_landuse ( Estuaries_value ) = water_index Corine_to_EMEP_landuse ( Sea_and_ocean_value ) = water_index Corine_to_EMEP_landuse ( NODATA_clc_value ) = grid_index end subroutine uEMEP_set_landuse_classes","tags":"","loc":"proc/uemep_set_landuse_classes.html"},{"title":"RDM2LL – uEMEP","text":"public  subroutine RDM2LL(y, x, lat, lon) Arguments Type Intent Optional Attributes Name real :: y real :: x real :: lat real :: lon Source Code subroutine RDM2LL ( y , x , lat , lon ) implicit none real x , y , lat , lon real referenceRdX , referenceRdY , referenceWgs84X , referenceWgs84Y real dX , dY real sumN , sumE !SOURCE:   https://www.roelvanlisdonk.nl/2012/11/21/simple-way-for-converting-rijksdriehoek-coordinates-to-lat-and-long-wgs84-in-c/ !referentie coordinated RDM referenceRdX = 155000 referenceRdY = 463000 !The city \"Amsterfoort\" is used as reference \"WGS84\" coordinate. referenceWgs84X = 5 2.15517 referenceWgs84Y = 5.387206 dX = ( x - referenceRdX ) * 10 ** ( - 5.0 ) dY = ( y - referenceRdY ) * 10 ** ( - 5.0 ) sumN = ( 323 5.65389 * dY ) + ( - 3 2.58297 * ( dX ** 2 )) + ( - 0.2475 * ( dY ** 2 )) + ( - 0.84978 * ( dX ** 2 ) * dY ) + ( - 0.0655 * ( dY ** 3 )) + ( - 0.01709 * ( dX ** 2 ) * ( dY ** 2 )) + ( - 0.00738 * dX ) + ( 0.0053 * ( dX ** 4 )) + ( - 0.00039 * ( dX ** 2 ) * ( dY ** 3 )) + ( 0.00033 * ( dX ** 4 ) * dY ) + ( - 0.00012 * dX * dY ) sumE = ( 526 0.52916 * dX ) + ( 10 5.94684 * dX * dY ) + ( 2.45656 * dX * ( dY ** 2 )) + ( - 0.81885 * ( dX ** 3 )) + ( 0.05594 * dX * ( dY ** 3 )) + ( - 0.05607 * ( dX ** 3 ) * dY ) + ( 0.01199 * dY ) + ( - 0.00256 * ( dX ** 3 ) * ( dY ** 2 )) + ( 0.00128 * dX * ( dY ** 4 )) + ( 0.00022 * ( dY ** 2 )) + ( - 0.00022 * ( dX ** 2 )) + ( 0.00026 * ( dX ** 5 )) lat = referenceWgs84X + ( sumN / 360 0. ) lon = referenceWgs84Y + ( sumE / 360 0. ) end subroutine RDM2LL","tags":"","loc":"proc/rdm2ll.html"},{"title":"uEMEP_crossreference_grids – uEMEP","text":"public  subroutine uEMEP_crossreference_grids() Arguments None Source Code subroutine uEMEP_crossreference_grids () integer :: i , j , k integer :: ii , jj integer :: i_source real :: x_temp , y_temp ! Cross referencing must be done for each new grid when using multiple grids if ( allocated ( crossreference_target_to_emep_subgrid )) then deallocate ( crossreference_target_to_emep_subgrid ) end if if ( allocated ( crossreference_target_to_localfraction_subgrid )) then deallocate ( crossreference_target_to_localfraction_subgrid ) end if if ( allocated ( crossreference_integral_to_emep_subgrid )) then deallocate ( crossreference_integral_to_emep_subgrid ) end if if ( allocated ( crossreference_target_to_integral_subgrid )) then deallocate ( crossreference_target_to_integral_subgrid ) end if if ( allocated ( crossreference_target_to_emission_subgrid )) then deallocate ( crossreference_target_to_emission_subgrid ) end if if ( allocated ( crossreference_emission_to_EMEP_subgrid )) then deallocate ( crossreference_emission_to_EMEP_subgrid ) end if if ( allocated ( crossreference_integral_to_emission_subgrid )) then deallocate ( crossreference_integral_to_emission_subgrid ) end if if ( allocated ( crossreference_emission_to_integral_subgrid )) then deallocate ( crossreference_emission_to_integral_subgrid ) end if if ( allocated ( crossreference_target_to_population_subgrid )) then deallocate ( crossreference_target_to_population_subgrid ) end if if ( use_alternative_meteorology_flag ) then if ( allocated ( crossreference_integral_to_meteo_nc_subgrid )) then deallocate ( crossreference_integral_to_meteo_nc_subgrid ) end if end if if ( calculate_deposition_flag ) then if ( allocated ( crossreference_emission_to_deposition_subgrid )) then deallocate ( crossreference_emission_to_deposition_subgrid ) end if if ( allocated ( crossreference_target_to_deposition_subgrid )) then deallocate ( crossreference_target_to_deposition_subgrid ) end if if ( allocated ( crossreference_deposition_to_emep_subgrid )) then deallocate ( crossreference_deposition_to_emep_subgrid ) end if end if if ( read_landuse_flag ) then if ( allocated ( crossreference_emission_to_landuse_subgrid )) then deallocate ( crossreference_emission_to_landuse_subgrid ) end if end if ! Allocate arrays allocate ( crossreference_target_to_emep_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_target_to_localfraction_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 , n_local_fraction_grids )) allocate ( crossreference_integral_to_emep_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_target_to_integral_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_target_to_emission_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_emission_to_EMEP_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_integral_to_emission_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_emission_to_integral_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_target_to_population_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) if ( use_alternative_meteorology_flag ) then allocate ( crossreference_integral_to_meteo_nc_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 )) end if if ( calculate_deposition_flag ) then allocate ( crossreference_emission_to_deposition_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_target_to_deposition_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_deposition_to_emep_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), 2 )) end if if ( read_landuse_flag ) then allocate ( crossreference_emission_to_landuse_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) end if write ( unit_logfile , '(A)' ) 'Allocating EMEP grid index to subgrid index' ! Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then ! When EMEP is read as x,y projection then var1d_nc(:,lon/lat_nc_index) are the x, y projection indexes, actually call lb2lambert2_uEMEP ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) = ii crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) = jj end do end do write ( unit_logfile , '(A)' ) 'Allocating EMEP local fraction grid index to subgrid index' ! Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. do k = 1 , n_local_fraction_grids do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) jj = 1 + floor (( lat_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then !When EMEP is read as x,y projection then var1d_nc(:,lon/lat_nc_index) are the x, y projection indexes, actually call lb2lambert2_uEMEP ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_target_to_localfraction_subgrid ( i , j , x_dim_index , k ) = ii crossreference_target_to_localfraction_subgrid ( i , j , y_dim_index , k ) = jj end do end do end do write ( unit_logfile , '(A)' ) 'Allocating integral grid index to subgrid index' do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_subgrid ( i , j ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_subgrid ( i , j ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) end do end do write ( unit_logfile , '(A)' ) 'Allocating population grid index to subgrid index' do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_population_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_subgrid ( i , j ) - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) crossreference_target_to_population_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_subgrid ( i , j ) - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) end do end do write ( unit_logfile , '(A)' ) 'Allocating EMEP grid index to integral subgrid index' do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_integral_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_integral_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) = ii crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) = jj end do end do if ( use_alternative_meteorology_flag ) then write ( unit_logfile , '(A)' ) 'Allocating alternative meteo nc grid index to integral subgrid index' do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) if ( meteo_nc_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_integral_subgrid ( i , j ) - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_integral_subgrid ( i , j ) - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( meteo_nc_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) ii = 1 + floor (( x_temp - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( meteo_nc_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) ii = 1 + floor (( x_temp - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) = ii crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) = jj end do end do end if do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_emission_subgrid ( i , j , i_source ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_emission_subgrid ( i , j , i_source ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) = ii crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) = jj end do end do do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_subgrid ( i , j ) - emission_subgrid_min ( x_dim_index , i_source )) / emission_subgrid_delta ( x_dim_index , i_source )) crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_subgrid ( i , j ) - emission_subgrid_min ( y_dim_index , i_source )) / emission_subgrid_delta ( y_dim_index , i_source )) end do end do do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) = max ( min ( crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ), integral_subgrid_dim ( x_dim_index )), 1 ) crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) = max ( min ( crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ), integral_subgrid_dim ( y_dim_index )), 1 ) if ( crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) . lt . 1 . or . crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) . gt . integral_subgrid_dim ( x_dim_index ) & . or . crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) . lt . 1 . or . crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) . gt . integral_subgrid_dim ( y_dim_index )) then write ( unit_logfile , '(A,4i,4f)' ) 'WARNING: crossreference_emission_to_integral_subgrid is out of bounds (i_emis,j_emis,i_integral,j_integral,x_emis,y_emis)' , i , j , & crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ), crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ), & x_emission_subgrid ( i , j , i_source ) / 1000 , y_emission_subgrid ( i , j , i_source ) / 1000 , ( x_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index ) + 0.5 , & ( y_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index ) + 0.5 end if end do end do do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) crossreference_integral_to_emission_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_integral_subgrid ( i , j ) - emission_subgrid_min ( x_dim_index , i_source )) / emission_subgrid_delta ( x_dim_index , i_source )) crossreference_integral_to_emission_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_integral_subgrid ( i , j ) - emission_subgrid_min ( y_dim_index , i_source )) / emission_subgrid_delta ( y_dim_index , i_source )) end do end do if ( calculate_deposition_flag ) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_deposition_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - deposition_subgrid_min ( x_dim_index )) / deposition_subgrid_delta ( x_dim_index )) crossreference_emission_to_deposition_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - deposition_subgrid_min ( y_dim_index )) / deposition_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_emission_to_deposition_subgrid ( i , j , x_dim_index , i_source ) = max ( min ( crossreference_emission_to_deposition_subgrid ( i , j , x_dim_index , i_source ), deposition_subgrid_dim ( x_dim_index )), 1 ) crossreference_emission_to_deposition_subgrid ( i , j , y_dim_index , i_source ) = max ( min ( crossreference_emission_to_deposition_subgrid ( i , j , y_dim_index , i_source ), deposition_subgrid_dim ( y_dim_index )), 1 ) end do end do end if if ( read_landuse_flag ) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - landuse_subgrid_min ( x_dim_index )) / landuse_subgrid_delta ( x_dim_index )) crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - landuse_subgrid_min ( y_dim_index )) / landuse_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ) = max ( min ( crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ), landuse_subgrid_dim ( x_dim_index )), 1 ) crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ) = max ( min ( crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ), landuse_subgrid_dim ( y_dim_index )), 1 ) end do end do end if end if end do if ( calculate_deposition_flag ) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_subgrid ( i , j ) - deposition_subgrid_min ( x_dim_index )) / deposition_subgrid_delta ( x_dim_index )) crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_subgrid ( i , j ) - deposition_subgrid_min ( y_dim_index )) / deposition_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ) = max ( min ( crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ), deposition_subgrid_dim ( x_dim_index )), 1 ) crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) = max ( min ( crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ), deposition_subgrid_dim ( y_dim_index )), 1 ) end do end do write ( unit_logfile , '(A)' ) 'Allocating EMEP grid index to deposition subgrid index' do j = 1 , deposition_subgrid_dim ( y_dim_index ) do i = 1 , deposition_subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_deposition_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_deposition_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_deposition_to_emep_subgrid ( i , j , x_dim_index ) = ii crossreference_deposition_to_emep_subgrid ( i , j , y_dim_index ) = jj end do end do end if end subroutine uEMEP_crossreference_grids","tags":"","loc":"proc/uemep_crossreference_grids.html"},{"title":"uEMEP_chemistry – uEMEP","text":"public  subroutine uEMEP_chemistry() Arguments None Source Code subroutine uEMEP_chemistry () ! Routine for doing the chemistry calculations in uEMEP integer :: i , j real :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature real :: nox_out , no2_out , o3_out , p_bg_out , p_out integer :: t , t_start , t_end integer :: i_source , i_subsource , emep_subsource integer :: i_pollutant logical :: nox_available = . false . integer :: i_integral , j_integral real :: FF_loc , distance_grid integer :: i_cross_integral , j_cross_integral , i_nc , j_nc real :: sum_p_bg_out , sum_p_out , count_p_out real :: max_p_bg_out , max_p_out , min_p_bg_out , min_p_out ! NB. Additional is calculated but not necessarily saved! real :: nox_bg_additional , no2_bg_additional , o3_bg_additional ! These are calculated in the Chemistry routine. Fist declared here. Are global variables if ( . not . allocated ( comp_source_subgrid )) then allocate ( comp_source_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( . not . allocated ( comp_source_EMEP_subgrid )) then allocate ( comp_source_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( . not . allocated ( comp_source_EMEP_additional_subgrid )) then allocate ( comp_source_EMEP_additional_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if ! Search for nox in the pollutants do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ) . eq . nox_nc_index ) nox_available = . true . end do ! Leave the chemistry routine if nox is not available if ( . not . nox_available ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating chemistry for NO2 (uEMEP_chemistry)' write ( unit_logfile , '(A)' ) '================================================================' if ( no2_chemistry_scheme_flag . eq . 0 ) then write ( unit_logfile , '(A)' ) 'No chemistry used' else if ( no2_chemistry_scheme_flag . eq . 1 ) then write ( unit_logfile , '(A)' ) 'Photostationary state used' else if ( no2_chemistry_scheme_flag . eq . 2 ) then write ( unit_logfile , '(A)' ) 'Photochemistry with time scale used' else if ( no2_chemistry_scheme_flag . eq . 3 ) then write ( unit_logfile , '(A)' ) 'Romberg parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 4 ) then write ( unit_logfile , '(A)' ) 'SRM parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'During parameterisation used' end if t_start = 1 t_end = subgrid_dim ( t_dim_index ) i_subsource = 1 emep_subsource = 1 comp_subgrid (:,:,:, no2_index ) = 0 comp_subgrid (:,:,:, nox_index ) = 0 comp_subgrid (:,:,:, o3_index ) = 0 nox_bg = 0.0 ; no2_bg = 0.0 ; o3_bg = 0.0 ; nox_loc = 0.0 ; f_no2_loc = 0.0 ; J_photo = 0.0 ; temperature = 0.0 ! Before calculating travel time then include the other EMEP sources not downscaled ! Travel time is set to EMEP Grid_width/FFgrid do t = t_start , t_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) i_cross_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) FF_loc = 1.0 if ( hourly_calculations ) then FF_loc = max ( FF_min_dispersion , meteo_subgrid ( i_cross_integral , j_cross_integral , t , FFgrid_subgrid_index )) else if ( annual_calculations ) then FF_loc = max ( FF_min_dispersion , 1.0 / meteo_subgrid ( i_cross_integral , j_cross_integral , t , inv_FFgrid_subgrid_index )) end if i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then distance_grid = 11100 0.0 * sqrt ( dgrid_nc ( lon_nc_index ) * cos ( var1d_nc ( j_nc , lat_nc_index ) * pi / 18 0.0 ) * dgrid_nc ( lat_nc_index )) else ! Assumed LCC or PS distance_grid = sqrt ( dgrid_nc ( lon_nc_index ) * dgrid_nc ( lat_nc_index )) end if end do end do end do sum_p_bg_out = 0.0 sum_p_out = 0.0 count_p_out = 0 max_p_bg_out = - 100 0.0 ; min_p_bg_out = 100 0.0 ; max_p_out = - 100 0.0 ; min_p_out = 100 0.0 do t = t_start , t_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) nox_bg = subgrid ( i , j , t , emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then nox_bg_additional = subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) end if o3_bg = comp_EMEP_subgrid ( i , j , t , o3_index ) f_no2_loc = 0.0 nox_loc = 0.0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) * subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if if ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source )) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end do if ( abs ( nox_loc ) > epsilon0 ) then f_no2_loc = f_no2_loc / nox_loc else f_no2_loc = 0.0 end if no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) ! Conserve Ox when removing NO2 in the background. Cannot be less than 0 ! Assume stationary state to derive no2 and o3 background if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg , o3_bg ) end if if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then no2_bg_additional = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg_additional / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg_additional , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg_additional , o3_bg_additional ) else o3_bg_additional = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg_additional )) ! Conserve Ox when removing NO2 in the background end if comp_source_EMEP_additional_subgrid ( i , j , t , o3_index , allsource_index ) = o3_bg_additional comp_source_EMEP_additional_subgrid ( i , j , t , no2_index , allsource_index ) = no2_bg_additional end if ! Set the background O3 level. use all_source for the nonlocal. comp_source_EMEP_subgrid ( i , j , t , o3_index , allsource_index ) = o3_bg comp_source_EMEP_subgrid ( i , j , t , no2_index , allsource_index ) = no2_bg if ( no2_chemistry_scheme_flag . eq . 0 ) then nox_out = nox_bg + nox_loc no2_out = no2_bg + nox_loc * f_no2_loc o3_out = o3_bg else if ( no2_chemistry_scheme_flag . eq . 1 ) then call uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 2 ) then call uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , traveltime_subgrid ( i , j , t , 3 , pollutant_loop_back_index ( nox_nc_index )) * traveltime_scaling , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 3 ) then call uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_parameters ) else if ( no2_chemistry_scheme_flag . eq . 4 ) then call uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_parameters ) else if ( no2_chemistry_scheme_flag . eq . 5 ) then call uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) end if sum_p_bg_out = sum_p_bg_out + p_bg_out sum_p_out = sum_p_out + p_out count_p_out = count_p_out + 1 max_p_bg_out = max ( max_p_bg_out , p_bg_out ); min_p_bg_out = min ( min_p_bg_out , p_bg_out ) max_p_out = max ( max_p_out , p_out ); min_p_out = min ( min_p_out , p_out ) comp_subgrid ( i , j , t , o3_index ) = o3_out comp_subgrid ( i , j , t , no2_index ) = no2_out comp_subgrid ( i , j , t , nox_index ) = nox_out else comp_subgrid ( i , j , t , o3_index ) = NODATA_value comp_subgrid ( i , j , t , no2_index ) = NODATA_value comp_subgrid ( i , j , t , nox_index ) = NODATA_value end if end do end do end do write ( * , '(A,2f12.3)' ) 'P value (nonlocal,local): ' , sum_p_bg_out / count_p_out , sum_p_out / count_p_out write ( * , '(A,2f12.3)' ) 'P max (nonlocal,local): ' , max_p_bg_out , max_p_out write ( * , '(A,2f12.3)' ) 'P min (nonlocal,local): ' , min_p_bg_out , min_p_out end subroutine uEMEP_chemistry","tags":"","loc":"proc/uemep_chemistry.html"},{"title":"uEMEP_source_fraction_chemistry – uEMEP","text":"public  subroutine uEMEP_source_fraction_chemistry() !!! for now, just use no2/nox ratio of the first subsource Arguments None Source Code subroutine uEMEP_source_fraction_chemistry () ! Special source allocation for no2 based on leaving out one source at a time in the chemistry calculation ! This will always give a sum less, but not much less than, the total no2 ! This is normalised in order for it to be used ! Vhemistry scheme must have been run prior to implementing this integer :: i , j real :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature real :: nox_out , no2_out , o3_out , p_bg_out , p_out integer :: t , t_start , t_end integer :: i_source , i_subsource , emep_subsource integer :: i_pollutant logical :: nox_available = . false . integer :: i_integral , j_integral integer :: remove_source real :: sum_no2_source_subgrid , sum_o3_source_subgrid real , allocatable :: comp_source_temp_subgrid (:,:,:,:,:) real , allocatable :: comp_source_EMEP_temp_subgrid (:,:,:,:,:) ! additional delarations needed for the in-region calculations integer , parameter :: inregion_index = 1 integer , parameter :: outregion_index = 2 integer :: k real :: f_no2_isource , nox_loc_isource_total , nox_loc_isource_from_in_region , nox_loc_isource real :: no2_inandout_region ( 2 ) real :: o3_inandout_region ( 2 ) real :: sum_no2_inregion_outregion , sum_o3_inregion_outregion real :: nox_semiloc_isource , f_no2_bg if ( trace_emissions_from_in_region . and . . not . calculate_EMEP_additional_grid_flag ) then if (. not . allocated ( comp_source_subgrid_from_in_region )) allocate ( comp_source_subgrid_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) comp_source_subgrid_from_in_region = 0.0 if (. not . allocated ( comp_semilocal_source_subgrid_from_in_region )) allocate ( comp_semilocal_source_subgrid_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) comp_semilocal_source_subgrid_from_in_region = 0.0 end if ! Search for nox in the pollutants do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ) . eq . nox_nc_index ) nox_available = . true . end do ! Leave the chemistry routine if nox is not available if ( . not . nox_available ) return if ( . not . allocated ( comp_source_subgrid )) then allocate ( comp_source_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( calculate_EMEP_additional_grid_flag ) then if ( . not . allocated ( comp_source_additional_subgrid )) then allocate ( comp_source_additional_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if ! Temporary array for storing the comp_source_subgrid to avoid rewriting large parts of the routine when running the additional version if ( . not . allocated ( comp_source_temp_subgrid )) then allocate ( comp_source_temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( . not . allocated ( comp_source_EMEP_temp_subgrid )) then allocate ( comp_source_EMEP_temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if comp_source_temp_subgrid = comp_source_subgrid comp_source_EMEP_temp_subgrid = comp_source_EMEP_subgrid comp_source_EMEP_subgrid = comp_source_EMEP_additional_subgrid end if write ( unit_logfile , '(A)' ) '--------------------------------------------------------' if (. not . calculate_EMEP_additional_grid_flag ) write ( unit_logfile , '(A)' ) 'Calculating chemistry source contributions for NO2 and O3 (uEMEP_source_fraction_chemistry)' if ( calculate_EMEP_additional_grid_flag ) write ( unit_logfile , '(A)' ) 'Calculating additional nonlocal for NO2 and O3 (uEMEP_source_fraction_chemistry)' write ( unit_logfile , '(A)' ) '--------------------------------------------------------' if ( no2_chemistry_scheme_flag . eq . 0 ) then write ( unit_logfile , '(A)' ) 'No chemistry used' else if ( no2_chemistry_scheme_flag . eq . 1 ) then write ( unit_logfile , '(A)' ) 'Photostationary state used' else if ( no2_chemistry_scheme_flag . eq . 2 ) then write ( unit_logfile , '(A)' ) 'Photochemistry with time scale used' else if ( no2_chemistry_scheme_flag . eq . 3 ) then write ( unit_logfile , '(A)' ) 'Romberg parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 4 ) then write ( unit_logfile , '(A)' ) 'SRM parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'During parameterisation used' end if t_start = 1 t_end = subgrid_dim ( t_dim_index ) i_subsource = 1 emep_subsource = 1 nox_bg = 0.0 ; no2_bg = 0.0 ; o3_bg = 0.0 ; nox_loc = 0.0 ; f_no2_loc = 0.0 ; J_photo = 0.0 ; temperature = 0.0 ! Weighted travel time already calculated do t = t_start , t_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) if ( calculate_EMEP_additional_grid_flag ) then nox_bg = subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) else nox_bg = subgrid ( i , j , t , emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) end if o3_bg = comp_EMEP_subgrid ( i , j , t , o3_index ) do remove_source = 1 , n_source_index if ( calculate_source ( remove_source ) . or . remove_source . eq . allsource_index . or . ( calculate_emep_source ( remove_source ) . and . . not . calculate_source ( remove_source ))) then f_no2_loc = 0.0 nox_loc = 0.0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) * subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if ! Include the local EMEP that are not being downscaled if ( . not . calculate_EMEP_additional_grid_flag ) then if ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if end if if ( calculate_EMEP_additional_grid_flag ) then ! If calculating the additional region then use the additional local EMEP not being downscaled if ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * subgrid ( i , j , t , emep_additional_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , emep_additional_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if !If calculating the additional region then include the difference BG-BG_additional to the local EMEP that is being downscaled if ( calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * & ( subgrid ( i , j , t , emep_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) & - subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index ))) nox_loc = nox_loc + subgrid ( i , j , t , emep_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) & - subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if end if end do if ( abs ( nox_loc ) > epsilon0 ) then f_no2_loc = f_no2_loc / nox_loc else f_no2_loc = 0.0 end if ! Use the all source index to calculate the contribution from the background ! This is done by removing all the sources, rather than the difference as done for the local sources ! This is because the chemistry is disturbed when removing background nox and no2 if ( remove_source . ne . allsource_index ) then no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) ! Conserve Ox when removing NO2 in the background. Cannot be less than 0 else no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) !Conserve Ox when removing NO2 in the background. Cannot be less than 0 nox_loc = 0.0 f_no2_loc = 0.0 end if ! Assume stationary state to derive no2 and o3 background. Overwrites the previous setting if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg , o3_bg ) end if if ( no2_chemistry_scheme_flag . eq . 0 ) then nox_out = nox_bg + nox_loc no2_out = no2_bg + nox_loc * f_no2_loc o3_out = o3_bg else if ( no2_chemistry_scheme_flag . eq . 1 ) then call uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 2 ) then call uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , traveltime_subgrid ( i , j , t , 3 , pollutant_loop_back_index ( nox_nc_index )) * traveltime_scaling , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 3 ) then call uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_parameters ) else if ( no2_chemistry_scheme_flag . eq . 4 ) then call uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_parameters ) else if ( no2_chemistry_scheme_flag . eq . 5 ) then call uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) end if ! For background just use the result without any sources. ! There is a problem disturbing the chemistry by removing the background nox and no2 but not changing the o3 if ( remove_source . eq . allsource_index ) then comp_source_subgrid ( i , j , t , no2_index , remove_source ) = no2_bg comp_source_subgrid ( i , j , t , o3_index , remove_source ) = o3_bg else !Avoid round off errors which can occur with small numbers comp_source_subgrid ( i , j , t , no2_index , remove_source ) = max ( 0.0 , comp_subgrid ( i , j , t , no2_index ) - no2_out ) !Can be negative and can be greater than 1 so do not limit comp_source_subgrid ( i , j , t , o3_index , remove_source ) = comp_subgrid ( i , j , t , o3_index ) - o3_out end if end if end do !Normalise the contributions !Calculate the sum sum_no2_source_subgrid = 0.0 sum_o3_source_subgrid = 0.0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source ))) then sum_no2_source_subgrid = sum_no2_source_subgrid + comp_source_subgrid ( i , j , t , no2_index , i_source ) sum_o3_source_subgrid = sum_o3_source_subgrid + comp_source_subgrid ( i , j , t , o3_index , i_source ) end if end do ! Set the background fractions so they will not be adjusted with normalisation do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source ))) then ! Adjust for the background and normalise if ( abs ( sum_no2_source_subgrid ) > epsilon0 ) then comp_source_subgrid ( i , j , t , no2_index , i_source ) = comp_source_subgrid ( i , j , t , no2_index , i_source ) / sum_no2_source_subgrid & * ( comp_subgrid ( i , j , t , no2_index ) - comp_source_EMEP_subgrid ( i , j , t , no2_index , allsource_index )) else comp_source_subgrid ( i , j , t , no2_index , i_source ) = 0 end if if ( abs ( sum_o3_source_subgrid ) > epsilon0 ) then comp_source_subgrid ( i , j , t , o3_index , i_source ) = comp_source_subgrid ( i , j , t , o3_index , i_source ) / sum_o3_source_subgrid & * ( comp_subgrid ( i , j , t , o3_index ) - comp_source_EMEP_subgrid ( i , j , t , o3_index , allsource_index )) else comp_source_subgrid ( i , j , t , o3_index , i_source ) = 0 end if ! Setting local sources to 0 if total concentration is zero: No longer do this, because nonlocal might be non-zero even if total is zero !if (comp_subgrid(i,j,t,no2_index) .le. 0) comp_source_subgrid(i,j,t,no2_index,i_source) = 0 !if (comp_subgrid(i,j,t,o3_index) .le. 0) comp_source_subgrid(i,j,t,o3_index,i_source) = 0 end if end do ! Calculate NO2 and O3 source contributions from-in-region ! ******************************************************** if ( trace_emissions_from_in_region . and . . not . calculate_EMEP_additional_grid_flag ) then ! Calculate downscaled contributions from-in-region do remove_source = 1 , n_source_index if ( calculate_source ( remove_source ) . or . calculate_EMEP_source ( remove_source )) then do k = 1 , 2 ! inregion and outregion ! add up all local sources to NOx, except 'remove_source' from either inregion or outregion f_no2_loc = 0 nox_loc = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . calculate_EMEP_source ( i_source )) then ! NB: loop over n_subsource is not logical, since we in practice weigh contributions from sources with 2 subsources more than sources with only 1, but I do it to follow Bruce's method above... do i_subsource = 1 , n_subsource ( i_source ) ! check whether to use downscaled or non-downscaled local contribution for this source if ( calculate_source ( i_source )) then ! downscaled contribution f_no2_isource = emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) nox_loc_isource_total = subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc_isource_from_in_region = subgrid_local_from_in_region ( i , j , t , i_source , pollutant_loop_back_index ( nox_nc_index )) else ! i.e. calculate_EMEP_source(i_source) .and. .not. calculate_source(i_source) ! EMEP contribution f_no2_isource = f_no2_emep nox_loc_isource_total = subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc_isource_from_in_region = subgrid_EMEP_local_from_in_region ( i , j , t , i_source , pollutant_loop_back_index ( nox_nc_index )) end if ! check if this source is the one we remove or not, to determine how to add it if ( i_source == remove_source ) then ! for the source to remove: We should then treat the inregion and outregion differently if ( k == inregion_index ) then ! in region: add only the local contribution from outside region nox_loc_isource = nox_loc_isource_total - nox_loc_isource_from_in_region else if ( k == outregion_index ) then ! out region: add only the local contribution from inside region nox_loc_isource = nox_loc_isource_from_in_region else write ( unit_logfile , '(A)' ) 'ERROR: value of k is not inregion_index or outregion_index' stop end if else ! for other sources, just add all the local contribution in both cases nox_loc_isource = nox_loc_isource_total end if f_no2_loc = f_no2_loc + f_no2_isource * nox_loc_isource nox_loc = nox_loc + nox_loc_isource end do end if end do ! divide f_no2_loc by total NOx contribution, in both cases if ( abs ( nox_loc ) > epsilon0 ) then f_no2_loc = f_no2_loc / nox_loc else f_no2_loc = 0.0 end if ! Calculate background concentrations (following Bruce's approach above) no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) !Conserve Ox when removing NO2 in the background. Cannot be less than 0 ! Assume stationary state to derive no2 and o3 background. Overwrites the previous setting if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg , o3_bg ) end if ! Calculate NO2 and O3 with the chemistry scheme if ( no2_chemistry_scheme_flag . eq . 0 ) then nox_out = nox_bg + nox_loc no2_out = no2_bg + nox_loc * f_no2_loc o3_out = o3_bg else if ( no2_chemistry_scheme_flag . eq . 1 ) then call uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 2 ) then call uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , traveltime_subgrid ( i , j , t , 3 , pollutant_loop_back_index ( nox_nc_index )) * traveltime_scaling , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 3 ) then call uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_parameters ) else if ( no2_chemistry_scheme_flag . eq . 4 ) then call uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_parameters ) else if ( no2_chemistry_scheme_flag . eq . 5 ) then call uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) end if !Avoid round off errors which can occur with small numbers no2_inandout_region ( k ) = max ( 0.0 , comp_subgrid ( i , j , t , no2_index ) - no2_out ) !Can be negative and can be greater than 1 so do not limit o3_inandout_region ( k ) = comp_subgrid ( i , j , t , o3_index ) - o3_out end do ! k=1,2 ! scale the contributions so the sum equals the total contribution from the source sum_no2_inregion_outregion = no2_inandout_region ( inregion_index ) + no2_inandout_region ( outregion_index ) sum_o3_inregion_outregion = o3_inandout_region ( inregion_index ) + o3_inandout_region ( outregion_index ) if ( abs ( sum_no2_inregion_outregion ) > epsilon0 ) then comp_source_subgrid_from_in_region ( i , j , t , no2_index , remove_source ) = comp_source_subgrid ( i , j , t , no2_index , remove_source ) * no2_inandout_region ( inregion_index ) / sum_no2_inregion_outregion else comp_source_subgrid_from_in_region ( i , j , t , no2_index , remove_source ) = 0 end if if ( abs ( sum_o3_inregion_outregion ) > epsilon0 ) then comp_source_subgrid_from_in_region ( i , j , t , o3_index , remove_source ) = comp_source_subgrid ( i , j , t , o3_index , remove_source ) * o3_inandout_region ( inregion_index ) / sum_o3_inregion_outregion else comp_source_subgrid_from_in_region ( i , j , t , o3_index , remove_source ) = 0 end if end if end do ! remove_source = 1, n_source_index ! Calculate semilocal contributions to NO2 and O3 ! This is approximated by assuming the same NO2/NOx ratio as for background as a whole nox_bg = subgrid ( i , j , t , emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) no2_bg = comp_source_EMEP_subgrid ( i , j , t , no2_index , allsource_index ) do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . calculate_EMEP_source ( i_source )) then ! get initial NO2/NOx ratio of this source if ( calculate_source ( i_source )) then i_subsource = 1 !!!!! for now, just use no2/nox ratio of the first subsource f_no2_isource = emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) else f_no2_isource = f_no2_emep end if ! calculate NO2/NOx ratio in the background f_no2_bg = no2_bg / nox_bg ! get semilocal contribution to NOx from this source nox_semiloc_isource = subgrid_EMEP_semilocal_from_in_region ( i , j , t , i_source , pollutant_loop_back_index ( nox_index )) ! calculate NO2 and O3 semilocal contribution from the source, assuming the NO2/NOx ratio is the same as in background comp_semilocal_source_subgrid_from_in_region ( i , j , t , no2_index , i_source ) = f_no2_bg * nox_semiloc_isource comp_semilocal_source_subgrid_from_in_region ( i , j , t , o3_index , i_source ) = - 4 8. / 4 6. * ( f_no2_bg - f_no2_isource ) * nox_semiloc_isource end if end do end if !(trace_emissions_from_in_region .and. .not. calculate_EMEP_additional_grid_flag) ! *************************************************************** ! done calculating NO2 and O3 source contributions from-in-region else ! i.e. if (.not. (use_subgrid(i,j,allsource_index))) comp_source_subgrid ( i , j , t ,:,:) = NODATA_value if ( trace_emissions_from_in_region . and . . not . calculate_EMEP_additional_grid_flag ) then comp_source_subgrid_from_in_region ( i , j , t ,:,:) = NODATA_value end if end if end do end do end do ! Transfer the arrays to the right outputs if ( calculate_EMEP_additional_grid_flag ) then comp_source_additional_subgrid = comp_source_subgrid comp_source_subgrid = comp_source_temp_subgrid comp_source_EMEP_subgrid = comp_source_EMEP_temp_subgrid ! EMEP_additional is unchanged if ( allocated ( comp_source_temp_subgrid )) deallocate ( comp_source_temp_subgrid ) if ( allocated ( comp_source_EMEP_temp_subgrid )) deallocate ( comp_source_EMEP_temp_subgrid ) end if end subroutine uEMEP_source_fraction_chemistry","tags":"","loc":"proc/uemep_source_fraction_chemistry.html"},{"title":"uEMEP_photostationary_NO2 – uEMEP","text":"private  subroutine uEMEP_photostationary_NO2(nox_bg, no2_bg, o3_bg, nox_loc, f_no2_loc, J_photo, temperature, nox_out, no2_out, o3_out, p_bg_out, p_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: o3_bg real, intent(in) :: nox_loc real, intent(in) :: f_no2_loc real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(out) :: p_bg_out real, intent(out) :: p_out Source Code subroutine uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) real , intent ( in ) :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature real , intent ( out ) :: nox_out , no2_out , o3_out , p_bg_out , p_out integer no2_i , no_i , nox_i , o3_i , ox_i , nox_bg_i , no2_bg_i integer , parameter :: n_i = 7 real :: Na , Na_fac , k1 real :: mass ( n_i ) real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 , 4 6.0 , 4 6.0 ] real :: mol ( n_i ) real :: f_no2 , f_ox , Jd , fac_sqrt real :: min_nox = 1.0e-6 no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 ; nox_bg_i = 6 ; no2_bg_i = 7 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 !Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ); !(cm&#94;3/s) and temperature in Kelvin mass ( 1 : n_i ) = 0.0 mol ( 1 : n_i ) = 0.0 ! Test for 0 NOx. If so leave the routine mass ( nox_i ) = nox_loc + nox_bg if ( mass ( nox_i ) . le . min_nox ) then nox_out = 0.0 no2_out = 0.0 o3_out = o3_bg return end if ! Check the photostationary assumption for the input data mass ( nox_i ) = nox_bg mass ( no2_i ) = no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) ! Test the photostationary state for the bg input data if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_bg_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_bg_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if ! Add the local contribution for calculation mass ( nox_i ) = nox_loc + nox_bg mass ( no2_i ) = f_no2_loc * nox_loc + no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) f_no2 = mol ( no2_i ) / mol ( nox_i ) f_ox = mol ( ox_i ) / mol ( nox_i ) ! Test the photostationary state for the input data. Will not be in equilibrium if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if ! Set the photolysis rate Jd = J_photo / k1 / mol ( nox_i ) ! Calculate fraction of NO2 in photostationary state fac_sqrt = max ( 0.0 , ( 1.0 + f_ox + Jd ) ** 2 - 4.0 * f_ox ) f_no2 = 0.5 * (( 1.0 + f_ox + Jd ) - sqrt ( fac_sqrt )) ! Convert back to mass mol ( no2_i ) = f_no2 * mol ( nox_i ); mol ( o3_i ) = max ( 0.0 , mol ( ox_i ) - mol ( no2_i )) ! Rounding errors possible mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) !Rounding errors possible mass = mol * mmass / Na_fac ! (ug/m3) no2_out = mass ( no2_i ) nox_out = mass ( nox_i ) o3_out = mass ( o3_i ) ! Check output if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if end subroutine uEMEP_photostationary_NO2","tags":"","loc":"proc/uemep_photostationary_no2.html"},{"title":"uEMEP_phototimescale_NO2 – uEMEP","text":"private  subroutine uEMEP_phototimescale_NO2(nox_bg, no2_bg, o3_bg, nox_loc, f_no2_loc, J_photo, temperature, time_scale, nox_out, no2_out, o3_out, p_bg_out, p_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: o3_bg real, intent(in) :: nox_loc real, intent(in) :: f_no2_loc real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(in) :: time_scale real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(out) :: p_bg_out real, intent(out) :: p_out Source Code subroutine uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , time_scale , nox_out , no2_out , o3_out , p_bg_out , p_out ) real , intent ( in ) :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , time_scale real , intent ( out ) :: nox_out , no2_out , o3_out , p_bg_out , p_out ! Local variables integer :: no2_i , no_i , nox_i , o3_i , ox_i , nox_bg_i , no2_bg_i integer , parameter :: n_i = 7 double precision :: Na , Na_fac , k1 double precision :: mass ( n_i ) double precision :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 , 4 6.0 , 4 6.0 ] double precision :: mol ( n_i ) double precision :: fac_sqrt double precision :: f_no2 , f_ox , Jd , Jd_bg double precision :: min_nox = 1.0e-6 double precision :: c , b , BB , td , f_no2_0 , f_no2_ps complex ( 8 ) :: AA double precision :: p_tot_out , f_ox_bg , f_no2_bg_ps , f_no2_bg no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 ; nox_bg_i = 6 ; no2_bg_i = 7 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ) ! (cm&#94;3/s) and temperature in Kelvin mass ( 1 : n_i ) = 0.0 mol ( 1 : n_i ) = 0.0 ! Test for 0 NOx. If so leave the routine mass ( nox_i ) = nox_loc + nox_bg if ( mass ( nox_i ) . le . min_nox ) then nox_out = 0.0 no2_out = 0.0 o3_out = o3_bg return end if ! Check the photostationary assumption for the input data mass ( nox_i ) = nox_bg mass ( no2_i ) = no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) f_ox_bg = mol ( ox_i ) / mol ( nox_i ) Jd_bg = J_photo / k1 / mol ( nox_i ) f_no2_bg_ps = 0.5 * (( 1 + f_ox_bg + Jd_bg ) - sqrt (( 1 + f_ox_bg + Jd_bg ) ** 2 - 4.0 * f_ox_bg )) f_no2_bg = mol ( no2_i ) / mol ( nox_i ) p_bg_out = f_no2_bg / f_no2_bg_ps ! Check input if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_bg_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_bg_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if ! Add the local contribution for calculation mass ( nox_i ) = nox_loc + nox_bg mass ( no2_i ) = f_no2_loc * nox_loc + no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) f_no2 = mol ( no2_i ) / mol ( nox_i ) f_ox = mol ( ox_i ) / mol ( nox_i ) ! Set the photolysis rate Jd = J_photo / k1 / mol ( nox_i ) ! Calculate photostationary for total nox, ox fac_sqrt = max ( 0.0 , ( 1 + f_ox + Jd ) ** 2 - 4.0 * f_ox ) f_no2_ps = 0.5 * (( 1 + f_ox + Jd ) - sqrt ( fac_sqrt )) p_tot_out = f_no2 / f_no2_ps ! Calculate fraction of NO2 based on the time scale c = f_ox b = 1 + f_ox + Jd BB = sqrt ( max ( 0.0 , b ** 2 - 4.0 * c )) ! max avoids roundoff errors td = time_scale * k1 * mol ( nox_i ) f_no2_0 = f_no2 AA = clog ( cmplx (( BB + b - 2.0 * f_no2_0 ) / ( BB - b + 2.0 * f_no2_0 ))) f_no2 = real ( - BB / 2.0 * (( exp ( AA + BB * td ) - 1.0 ) / ( exp ( AA + BB * td ) + 1.0 )) + b / 2.0 ) if ( isnan ( f_no2 )) f_no2 = - BB / 2.0 + b / 2.0 fac_sqrt = max ( 0.0 , ( 1 + f_ox + Jd ) ** 2 - 4.0 * f_ox ) f_no2_ps = 0.5 * (( 1.0 + f_ox + Jd ) - sqrt ( fac_sqrt )) p_out = f_no2 / f_no2_ps ! Convert back to mass mol ( no2_i ) = max ( 0.0 , f_no2 * mol ( nox_i )) mol ( o3_i ) = max ( 0.0 , mol ( ox_i ) - mol ( no2_i )) ! Rounding errors possible mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) ! Rounding errors possible mass = mol * mmass / Na_fac ! (ug/m3) no2_out = mass ( no2_i ) nox_out = mass ( nox_i ) o3_out = mass ( o3_i ) if ( isnan ( no2_out )) then write ( * , '(8a12)' ) 'nox_bg' , 'no2_bg' , 'o3_bg' , 'nox_loc' , 'f_no2_loc' , 'J_photo' , 'temperature' , 'time_scale' write ( * , '(8es12.2)' ) nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , time_scale write ( * , '(4a12)' ) 'f_no2' , 'BB' , 'b' , 'b**2-4.*c' write ( * , '(4es12.2)' ) f_no2 , BB , b , b ** 2 - 4.0 * c stop 1 end if ! Check output if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if end subroutine uEMEP_phototimescale_NO2","tags":"","loc":"proc/uemep_phototimescale_no2.html"},{"title":"uEMEP_Romberg_NO2 – uEMEP","text":"private  subroutine uEMEP_Romberg_NO2(nox_bg, no2_bg, nox_loc, o3_bg, f_no2_loc, nox_out, no2_out, o3_out, romberg_params) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: nox_loc real, intent(in) :: o3_bg real, intent(in) :: f_no2_loc real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(in) :: romberg_params (3) Source Code subroutine uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_params ) ! From Norwegian obs fit ! real :: a_rom=20 ! real :: b_rom=30 ! From model fit ! real :: a_rom=30 ! real :: b_rom=35 ! real :: c_rom=0.20 ! Gral values 30 35 0.18 ! B�chlin and B�singer (2008) 29 35 0.217 real , intent ( in ) :: nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc real , intent ( in ) :: romberg_params ( 3 ) real , intent ( out ) :: nox_out , no2_out , o3_out ! Local variables real :: a_rom = 3 0.0 real :: b_rom = 3 5.0 real :: c_rom = 0.20 real :: ox_init , no2_init , no2_equ ! If available, use custom parameter values if ( abs ( romberg_params ( 1 )) > epsilon0 ) then a_rom = romberg_params ( 1 ) b_rom = romberg_params ( 2 ) c_rom = romberg_params ( 3 ) end if nox_out = nox_bg + nox_loc no2_equ = a_rom * nox_bg / ( nox_bg + b_rom ) + nox_bg * c_rom no2_out = a_rom * nox_out / ( nox_out + b_rom ) + nox_out * c_rom no2_out = no2_out - no2_equ + no2_bg no2_out = max ( no2_bg , no2_out ) no2_init = no2_bg + f_no2_loc * nox_loc ! Small adjustments for molecular weights ox_init = no2_init * 4 7.0 / 4 6.0 + o3_bg * 4 7.0 / 4 8.0 o3_out = ox_init * 4 8.0 / 4 7.0 - no2_out * 4 8.0 / 4 6.0 end subroutine uEMEP_Romberg_NO2","tags":"","loc":"proc/uemep_romberg_no2.html"},{"title":"uEMEP_SRM_NO2 – uEMEP","text":"private  subroutine uEMEP_SRM_NO2(nox_bg, no2_bg, nox_loc, o3_bg, f_no2_loc, nox_out, no2_out, o3_out, SRM_params) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: nox_loc real, intent(in) :: o3_bg real, intent(in) :: f_no2_loc real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(in) :: SRM_params (3) Source Code subroutine uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_params ) ! From model fit ! real :: beta = 0.45 ! real :: K = 30.0 ! real :: F = 0.2 ! From RIVM Briefrapport 2014-0109 ! beta=1 ! K=100 ! F=0.2 ! ! Reference ! https://core.ac.uk/download/pdf/58774365.pdf real , intent ( in ) :: nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc real , intent ( in ) :: SRM_params ( 3 ) real , intent ( out ) :: nox_out , no2_out , o3_out ! Local variables real :: beta = 0.45 real :: K = 3 0.0 real :: F = 0.2 real :: ox_init , no2_init ! If available, use custom parameter values if ( abs ( SRM_params ( 1 )) > epsilon0 ) then beta = SRM_params ( 1 ) K = SRM_params ( 2 ) F = SRM_params ( 3 ) end if nox_out = nox_bg + nox_loc no2_out = no2_bg + beta * o3_bg * nox_loc / ( nox_loc + K / ( 1 - F )) + F * nox_loc no2_init = no2_bg + f_no2_loc * nox_loc ! Small adjustments for molecular weights ox_init = no2_init * 4 7.0 / 4 6.0 + o3_bg * 4 7.0 / 4 8.0 o3_out = ox_init * 4 8.0 / 4 7.0 - no2_out * 4 8.0 / 4 6.0 end subroutine uEMEP_SRM_NO2","tags":"","loc":"proc/uemep_srm_no2.html"},{"title":"uEMEP_During_NO2 – uEMEP","text":"private  subroutine uEMEP_During_NO2(nox_bg, no2_bg, nox_loc, o3_bg, f_no2_loc, nox_emep, no2_emep, o3_emep, J_photo, temperature, nox_out, no2_out, o3_out, p_bg_out, p_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: nox_loc real, intent(in) :: o3_bg real, intent(in) :: f_no2_loc real, intent(in) :: nox_emep real, intent(in) :: no2_emep real, intent(in) :: o3_emep real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(out) :: p_bg_out real, intent(out) :: p_out Source Code subroutine uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_emep , no2_emep , o3_emep , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) ! Reference ! D�ring, I., B�chlin, W., Ketzel, M., Baum, A., Friedrich, U., Wurzler, S., 2011. ! A new simplified NO/NO2 conversion model under consideration of direct NO2-emissions. ! Meteorol. Zeitschrift 20, 67�73. doi:10.1127/0941-2948/2011/0491 ! ! Improved Methodologies for NO2 Exposure Assessment in the EU, page 53 ! https://ec.europa.eu/environment/air/pdf/NO2_Exposure_Final_Report.pdf real , intent ( in ) :: nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , J_photo , temperature real , intent ( in ) :: nox_emep , no2_emep , o3_emep real , intent ( out ) :: nox_out , no2_out , o3_out real , intent ( out ) :: p_bg_out , p_out ! Local variables real :: mol_nox_bg , mol_no2_bg , mol_nox_loc , mol_o3_bg , mol_no2_loc , mol_ox_loc , mol_no_bg , mol_ox_bg real :: mol_no2_out , mol_o3_out , mol_no_out real :: mol_nox_emep , mol_no2_emep , mol_o3_emep , mol_no_emep , mol_ox_emep , p_emep_out real :: b , d , r , c , k1 real :: Na , Na_fac integer :: no2_i , no_i , nox_i , o3_i , ox_i integer , parameter :: n_i = 5 real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 ] no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ) ! (cm&#94;3/s) and temperature in Kelvin Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included ! Normally multiplied by *Na_fac but not necessary as it is just a scaling mol_no2_bg = no2_bg / mmass ( no2_i ) mol_no2_loc = f_no2_loc * nox_loc / mmass ( no2_i ) mol_nox_bg = nox_bg / mmass ( nox_i ) mol_nox_loc = nox_loc / mmass ( nox_i ) mol_o3_bg = o3_bg / mmass ( o3_i ) mol_no_bg = ( nox_bg - no2_bg ) / mmass ( nox_i ) mol_ox_bg = mol_o3_bg + mol_no2_bg mol_o3_emep = o3_emep / mmass ( o3_i ) mol_nox_emep = nox_emep / mmass ( nox_i ) mol_no2_emep = no2_emep / mmass ( no2_i ) mol_no_emep = max ( 0.0 , mol_nox_emep - mol_no2_emep ) mol_ox_emep = mol_o3_emep + mol_no2_emep mol_ox_loc = mol_o3_bg + mol_no2_bg + mol_no2_loc if ( mol_no2_emep . gt . 0 ) then r = mol_o3_emep * mol_no_emep / mol_no2_emep else r = 0.0 end if b = mol_ox_loc + mol_nox_bg + mol_nox_loc + r c = max ( 0.0 , b ** 2 - 4.0 * mol_ox_loc * ( mol_nox_bg + mol_nox_loc )) ! Should never be less than 0 but can be -0 d = sqrt ( c ) mol_no2_out = ( b - d ) / 2.0 mol_o3_out = mol_ox_loc - mol_no2_out mol_no_out = mol_nox_bg + mol_nox_loc - mol_no2_out nox_out = nox_bg + nox_loc no2_out = mol_no2_out * mmass ( no2_i ) o3_out = mol_o3_out * mmass ( o3_i ) ! Not correct as it does not calculate the actual photostationary equation p_out = r p_bg_out = mol_o3_bg * mol_no_bg / mol_no2_bg ! Check output if ( abs ( J_photo ) > epsilon0 . and . abs ( mol_no_out ) > epsilon0 . and . abs ( mol_o3_out ) > epsilon0 ) then p_out = J_photo * mol_no2_out / k1 / mol_o3_out / mol_no_out / Na_fac p_emep_out = J_photo * mol_no2_emep / k1 / mol_o3_emep / mol_no_emep / Na_fac p_bg_out = J_photo * mol_no2_bg / k1 / mol_o3_bg / mol_no_bg / Na_fac else p_out = mol_no2_out / ( mol_ox_loc + mol_nox_bg + mol_nox_loc - abs ( mol_ox_loc - mol_nox_bg - mol_nox_loc )) * 2.0 p_emep_out = mol_no2_emep / ( mol_ox_emep + mol_nox_emep - abs ( mol_ox_emep - mol_nox_emep )) * 2.0 p_bg_out = mol_no2_bg / ( mol_ox_bg + mol_nox_bg - abs ( mol_ox_bg - mol_nox_bg )) * 2.0 end if end subroutine uEMEP_During_NO2","tags":"","loc":"proc/uemep_during_no2.html"},{"title":"uEMEP_nonlocal_NO2_O3 – uEMEP","text":"private  subroutine uEMEP_nonlocal_NO2_O3(nox_bg, nox_emep, no2_emep, o3_emep, J_photo, temperature, f_no2, no2_out, o3_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: nox_emep real, intent(in) :: no2_emep real, intent(in) :: o3_emep real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(in) :: f_no2 real, intent(out) :: no2_out real, intent(out) :: o3_out Source Code subroutine uEMEP_nonlocal_NO2_O3 ( nox_bg , nox_emep , no2_emep , o3_emep , J_photo , temperature , f_no2 , no2_out , o3_out ) real , intent ( in ) :: J_photo , temperature , f_no2 real , intent ( in ) :: nox_bg real , intent ( in ) :: nox_emep , no2_emep , o3_emep real , intent ( out ) :: no2_out , o3_out ! Local variables real :: mol_nox_bg real :: mol_no2_out , mol_o3_out real :: mol_nox_emep , mol_no2_emep , mol_o3_emep , mol_ox_emep , mol_no_emep real :: b , d , r , c real :: Na , Na_fac , k1 real :: p_phot , r_phot integer no2_i , no_i , nox_i , o3_i , ox_i integer , parameter :: n_i = 5 real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 ] no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ) ! (cm&#94;3/s) and temperature in Kelvin ! Normally multiplied by *Na_fac but not necessary as it is just a scaling mol_o3_emep = o3_emep / mmass ( o3_i ) * Na_fac mol_no2_emep = no2_emep / mmass ( no2_i ) * Na_fac mol_nox_emep = nox_emep / mmass ( nox_i ) * Na_fac mol_ox_emep = mol_o3_emep + mol_no2_emep - f_no2 * mol_nox_emep mol_nox_bg = nox_bg / mmass ( nox_i ) * Na_fac mol_no_emep = max ( 0.0 , mol_nox_emep - mol_no2_emep ) if ( mol_no2_emep . gt . 0 ) then r = mol_o3_emep * mol_no_emep / mol_no2_emep p_phot = J_photo / k1 * mol_no2_emep / mol_o3_emep / mol_no_emep r_phot = J_photo / k1 / Na_fac r = r_phot * Na_fac b = mol_ox_emep + mol_nox_bg + r c = max ( 0.0 , b ** 2 - 4.0 * mol_ox_emep * mol_nox_bg ) ! Should never be less than 0 but can be -0.0 d = sqrt ( c ) mol_no2_out = ( b - d ) / 2.0 mol_o3_out = mol_ox_emep - mol_no2_out no2_out = max ( 0.0 , mol_no2_out * mmass ( no2_i ) / Na_fac ) o3_out = max ( 0.0 , mol_o3_out * mmass ( o3_i ) / Na_fac ) else no2_out = 0.0 o3_out = o3_emep end if end subroutine uEMEP_nonlocal_NO2_O3","tags":"","loc":"proc/uemep_nonlocal_no2_o3.html"},{"title":"correct_annual_mean_chemistry – uEMEP","text":"public  subroutine correct_annual_mean_chemistry() Arguments None Source Code subroutine correct_annual_mean_chemistry () integer :: i , j , t integer :: t_start , t_end integer :: i_integral , j_integral real :: o3_in , nox_in , no2_in , J_photo_in , temperature_in , lon_in , lat_in real :: ox_sigma_ratio_in , nox_sigma_ratio_in real :: o3_out , no2_out real :: sum_no2_in , sum_no2_out integer :: no2_count logical :: run_all_flag write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Correcting annual mean NO2 and O3 (correct_annual_mean_chemistry)' write ( unit_logfile , '(A)' ) '================================================================' t_start = 1 t_end = subgrid_dim ( t_dim_index ) sum_no2_in = 0.0 sum_no2_out = 0.0 no2_count = 0 do t = t_start , t_end !Run the conversion routine once to get the Jd distribution which is saved. This is to save time as this is slow. Done in the centre of the grid if ( quick_annual_mean_pdf_chemistry_correction ) then run_all_flag = . false . i = subgrid_dim ( x_dim_index ) / 2 j = subgrid_dim ( y_dim_index ) / 2 o3_in = comp_subgrid ( i , j , t , o3_index ) no2_in = comp_subgrid ( i , j , t , no2_index ) nox_in = comp_subgrid ( i , j , t , nox_index ) i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo_in = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature_in = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) lon_in = lon_subgrid ( i , j ) lat_in = lat_subgrid ( i , j ) ox_sigma_ratio_in = ox_sigma_ratio_pdf nox_sigma_ratio_in = nox_sigma_ratio_pdf call uEMEP_annual_mean_pdf_correction_NO2_O3 ( min_bin_pdf , max_bin_pdf , log10_step_bin_pdf , . true ., no2_in , nox_in , o3_in , J_photo_in , & temperature_in , ox_sigma_ratio_in , nox_sigma_ratio_in , lon_in , lat_in , no2_out , o3_out ) else run_all_flag = . true . end if do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) o3_in = comp_subgrid ( i , j , t , o3_index ) no2_in = comp_subgrid ( i , j , t , no2_index ) nox_in = comp_subgrid ( i , j , t , nox_index ) i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo_in = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature_in = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) lon_in = lon_subgrid ( i , j ) lat_in = lat_subgrid ( i , j ) ox_sigma_ratio_in = ox_sigma_ratio_pdf nox_sigma_ratio_in = nox_sigma_ratio_pdf if ( o3_in . le . 0 . or . nox_in . le . 0 . or . no2_in . le . 0 ) then o3_out = o3_in no2_out = no2_in else call uEMEP_annual_mean_pdf_correction_NO2_O3 ( min_bin_pdf , max_bin_pdf , log10_step_bin_pdf , run_all_flag , no2_in , nox_in , o3_in , J_photo_in , & temperature_in , ox_sigma_ratio_in , nox_sigma_ratio_in , lon_in , lat_in , no2_out , o3_out ) end if comp_subgrid ( i , j , t , o3_index ) = o3_out comp_subgrid ( i , j , t , no2_index ) = no2_out sum_no2_in = sum_no2_in + no2_in sum_no2_out = sum_no2_out + no2_out no2_count = no2_count + 1 if ( isnan ( no2_out )) then write ( unit_logfile , '(a,2i5,4f12.4)' ) 'NaN in pdf output. Stopping ' , i , j , no2_in , no2_out , o3_in , o3_out stop 1 end if end do end do end do write ( unit_logfile , '(a,f12.4)' ) 'Average NO2 scaling with pdf correction = ' , sum_no2_out / sum_no2_in end subroutine correct_annual_mean_chemistry","tags":"","loc":"proc/correct_annual_mean_chemistry.html"},{"title":"uEMEP_annual_mean_pdf_correction_NO2_O3 – uEMEP","text":"private  subroutine uEMEP_annual_mean_pdf_correction_NO2_O3(bin_min, bin_max, delta_log10_bin, run_all, no2_in, nox_in, o3_in, J_photo_in, temperature_in, ox_sigma_ratio_in, nox_sigma_ratio_in, lon_in, lat_in, no2_out, o3_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: bin_min real, intent(in) :: bin_max real, intent(in) :: delta_log10_bin logical, intent(in) :: run_all real, intent(in) :: no2_in real, intent(in) :: nox_in real, intent(in) :: o3_in real, intent(in) :: J_photo_in real, intent(in) :: temperature_in real, intent(in) :: ox_sigma_ratio_in real, intent(in) :: nox_sigma_ratio_in real, intent(in) :: lon_in real, intent(in) :: lat_in real, intent(out) :: no2_out real, intent(out) :: o3_out Source Code subroutine uEMEP_annual_mean_pdf_correction_NO2_O3 ( bin_min , bin_max , delta_log10_bin , run_all , no2_in , nox_in , o3_in , J_photo_in , temperature_in , ox_sigma_ratio_in , nox_sigma_ratio_in , lon_in , lat_in , no2_out , o3_out ) real , intent ( in ) :: bin_min , bin_max , delta_log10_bin logical , intent ( in ) :: run_all real , intent ( in ) :: J_photo_in , temperature_in real , intent ( in ) :: no2_in , nox_in , o3_in real , intent ( in ) :: ox_sigma_ratio_in , nox_sigma_ratio_in real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: no2_out , o3_out ! Loca variables real :: mol_no2_out , mol_o3_out real :: Na , Na_fac , k1 integer , parameter :: no2_i = 1 !integer, parameter :: no_i = 2 integer , parameter :: nox_i = 3 integer , parameter :: o3_i = 4 !integer, parameter :: ox_i = 5 integer , parameter :: n_i = 5 real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 ] real :: log10_bin_max , log10_bin_min real , allocatable :: log10_bin (:), bin (:), delta_bin (:) integer :: n_bin real :: nox_sigma_ratio , ox_sigma_ratio real :: ox_sigma , ox_sig_sqr , ox_mu , nox_sigma , nox_sig_sqr , nox_mu real , allocatable :: y_nox (:), y_ox (:), y_Jd (:) integer , parameter :: nbin_Jd = 8760 ! Hours in a year integer :: bin_temp real , save :: y_Jd_acc ( nbin_Jd ) real :: mean_y_Jd_acc , y_Jd_acc_temp , y_Jd_acc_temp_log10 real :: y_all_val , y_all_prob , y_all_sum , y_all_prob_sum , y_all , y_annual , y_scale real :: azimuth_ang , zenith_ang real :: mol_nox , mol_no2 , mol_ox , mol_o3 , Jd double precision :: date_num integer :: i , j , k , l integer :: date_array ( 6 ) real :: min_sigma_ratio = 0.01 real :: bin_temp2 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature_in ) ! (cm&#94;3/s) and temperature in Kelvin mol_nox = nox_in * Na_fac / mmass ( nox_i ) mol_no2 = no2_in * Na_fac / mmass ( no2_i ) mol_o3 = o3_in * Na_fac / mmass ( o3_i ) mol_ox = mol_no2 + mol_o3 Jd = J_photo_in / k1 no2_out = no2_in o3_out = o3_in !Create the bins for the pdf in (mol/cm3). ox, nox and J log10_bin_max = log10 ( bin_max ) log10_bin_min = log10 ( bin_min ) n_bin = int (( log10_bin_max - log10_bin_min ) / delta_log10_bin ) + 1 ! Creates 80 bins with these settings allocate ( log10_bin ( n_bin )) allocate ( bin ( n_bin )) allocate ( delta_bin ( n_bin )) do i = 1 , n_bin log10_bin ( i ) = log10_bin_min + ( i - 1 ) * delta_log10_bin end do do i = 1 , n_bin bin ( i ) = ( 1 0.0 ** log10_bin ( i )) * Na_fac / mmass ( nox_i ) delta_bin ( i ) = ( 1 0.0 ** ( log10_bin ( i ) + delta_log10_bin / 2.0 ) - 1 0.0 ** ( log10_bin ( i ) - delta_log10_bin / 2.0 )) * Na_fac / mmass ( nox_i ) end do ! Distribute concentrations into the pdf bins ! Minimum needed to avoid NaNs in the calculation nox_sigma_ratio = 1.14 ox_sigma_ratio = 0.21 if ( abs ( nox_sigma_ratio_in ) > epsilon0 ) nox_sigma_ratio = max ( nox_sigma_ratio_in , min_sigma_ratio ) if ( abs ( ox_sigma_ratio_in ) > epsilon0 ) ox_sigma_ratio = max ( ox_sigma_ratio_in , min_sigma_ratio ) ox_sigma = mol_ox * ox_sigma_ratio ox_sig_sqr = log ( 1.0 + ox_sigma ** 2.0 / mol_ox ** 2.0 ) ox_mu = log ( mol_ox ** 2.0 / sqrt ( mol_ox ** 2.0 + ox_sigma ** 2.0 )) nox_sigma = mol_nox * nox_sigma_ratio nox_sig_sqr = log ( 1.0 + nox_sigma ** 2.0 / mol_nox ** 2.0 ) nox_mu = log ( mol_nox ** 2.0 / sqrt ( mol_nox ** 2.0 + nox_sigma ** 2.0 )) allocate ( y_ox ( n_bin )) allocate ( y_nox ( n_bin )) if ( . not . allocated ( y_Jd )) allocate ( y_Jd ( n_bin )) y_Jd = 0.0 y_ox = 0.0 y_nox = 0.0 do i = 1 , n_bin y_ox ( i ) = 1.0 / bin ( i ) / sqrt ( ox_sig_sqr ) / sqrt ( 2.0 * pi ) * exp ( - (( log ( bin ( i )) - ox_mu ) ** 2 ) / 2.0 / ox_sig_sqr ) * delta_bin ( i ) y_nox ( i ) = 1.0 / bin ( i ) / sqrt ( nox_sig_sqr ) / sqrt ( 2.0 * pi ) * exp ( - (( log ( bin ( i )) - nox_mu ) ** 2 ) / 2.0 / nox_sig_sqr ) * delta_bin ( i ) end do ! Create the Jd_acc distribution by looping through every hour in the year and extracting the zenith angle ! Only do this if requested for the first time if ( run_all ) then y_Jd_acc = 0 do i = 1 , nbin_Jd date_num = 1.0 + i / 2 4.0 date_array = 0 zenith_ang = 0.0 call get_sun_angles ( lat_in , lon_in , date_array , date_num , 0.0 , azimuth_ang , zenith_ang ) if ( zenith_ang . ge . 9 0.0 ) then y_Jd_acc ( i ) = 0 else y_Jd_acc ( i ) = (( cosd ( zenith_ang )) ** 0.28 ) end if end do end if mean_y_Jd_acc = sum ( y_Jd_acc ) / nbin_Jd do i = 1 , nbin_Jd y_Jd_acc_temp = Jd * y_Jd_acc ( i ) / mean_y_Jd_acc if ( y_Jd_acc_temp / Na_fac * mmass ( nox_i ) < bin_min ) then bin_temp = 1 else y_Jd_acc_temp_log10 = log10 ( y_Jd_acc_temp / Na_fac * mmass ( nox_i )) bin_temp = floor (( y_Jd_acc_temp_log10 - log10_bin_min ) / delta_log10_bin + 0.5 ) + 1 bin_temp = min ( max ( bin_temp , 1 ), n_bin ) end if y_Jd ( bin_temp ) = y_Jd ( bin_temp ) + 1 end do ! Normalise all distributions y_Jd = y_Jd / sum ( y_Jd ) y_ox = y_ox / sum ( y_ox ) y_nox = y_nox / sum ( y_nox ) !Calculate scaling based on photostationary assumption y_all_sum = 0 y_all_prob_sum = 0 do j = 1 , n_bin do k = 1 , n_bin do l = 1 , n_bin ! Calculate weighting y_all_prob = y_nox ( j ) * y_Jd ( k ) * y_ox ( l ) if ( y_all_prob . gt . 0.0 ) then ! Calculate NO2 value bin_temp2 = bin ( j ) + bin ( k ) + bin ( l ) y_all_val = ( bin_temp2 - sqrt ( bin_temp2 * bin_temp2 - 4.0 * bin ( j ) * bin ( l ))) / 2.0 ! Add weighted value y_all_sum = y_all_sum + y_all_val * y_all_prob ! Calculate sum of weights for normalisation later y_all_prob_sum = y_all_prob_sum + y_all_prob end if end do end do end do y_all = y_all_sum / y_all_prob_sum ! Calculate the mean value y_annual = (( mol_nox + Jd + mol_ox ) - sqrt (( mol_nox + Jd + mol_ox ) ** 2 - 4.0 * mol_nox * mol_ox )) / 2.0 y_scale = y_all / y_annual mol_no2_out = y_scale * mol_no2 mol_o3_out = mol_ox - mol_no2_out no2_out = mol_no2_out / Na_fac * mmass ( no2_i ) o3_out = mol_o3_out / Na_fac * mmass ( o3_i ) deallocate ( log10_bin ) deallocate ( bin ) deallocate ( delta_bin ) deallocate ( y_ox ) deallocate ( y_nox ) deallocate ( y_Jd ) end subroutine uEMEP_annual_mean_pdf_correction_NO2_O3","tags":"","loc":"proc/uemep_annual_mean_pdf_correction_no2_o3.html"},{"title":"uEMEP_read_time_profiles – uEMEP","text":"public  subroutine uEMEP_read_time_profiles() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_time_profiles use uEMEP_definitions implicit none integer i , j character ( 256 ) temp_str integer unit_in logical :: exists integer week_day_temp double precision date_num_temp integer n_col !parameter (n_col=5) character ( 256 ), allocatable :: header_str (:) integer , allocatable :: source_index_in (:) integer temp_region_id integer n_hours_in_week , n_months_in_year integer , allocatable :: time_month_of_year_input (:), time_hour_of_week_input (:) real , allocatable :: val_month_of_year_input (:,:), val_hour_of_week_input (:,:) integer date_array ( 6 ) integer i_source , t , hour_of_week_index integer t_profile_loop integer emission_time_shift_temp integer i_cross , j_cross real hdd_temp integer col_val , index_val logical do_not_calculate_RWC_emissions !double precision date_to_number !emission_time_profile_subgrid=1. !Only read data if flag is correct if ( local_subgrid_method_flag . ne . 2 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading time profiles (uEMEP_read_time_profiles)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_timeprofile = trim ( pathname_timeprofile ) // trim ( filename_timeprofile ) !Test existence of the filename. If does not exist then use default inquire ( file = trim ( pathfilename_timeprofile ), exist = exists ) if (. not . exists ) then write ( * , '(A,A)' ) ' ERROR: Time profile data file does not exist: ' , trim ( pathfilename_timeprofile ) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_timeprofile , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening time profile file: ' // trim ( pathfilename_timeprofile ) !Find the number of commas in the header to determine columns read ( unit_in , '(a)' ) temp_str !write(*,*) trim(temp_str),index(temp_str,',') col_val = 0 do while ( index ( temp_str , ',' ). ne . 0 ) index_val = index ( temp_str , ',' ) temp_str = temp_str ( index_val + 1 :) col_val = col_val + 1 !write(*,*) col_val,trim(temp_str) enddo n_col = col_val + 1 allocate ( header_str ( n_col )) allocate ( source_index_in ( n_col - 1 )) write ( unit_logfile , '(a,i)' ) ' Number of columns read: ' , n_col !stop rewind ( unit_in ) !Read source header string read ( unit_in , * ) header_str !write(unit_logfile,*) header_str !Read source index, correpsonding to uEMEP source indexes (change to SNAP or NFR later) read ( unit_in , * ) temp_str , source_index_in write ( unit_logfile , * ) trim ( temp_str ), source_index_in !Read region read ( unit_in , * ) temp_str , temp_region_id write ( unit_logfile , '(a,i)' ) trim ( temp_str ), temp_region_id !Read Hour_of_week read ( unit_in , * ) temp_str , n_hours_in_week write ( unit_logfile , '(a,i)' ) trim ( temp_str ), n_hours_in_week !write(*,*) num_week_traffic,days_in_week,hours_in_day,n_roadlinks if (. not . allocated ( time_hour_of_week_input )) allocate ( time_hour_of_week_input ( n_hours_in_week )) if (. not . allocated ( val_hour_of_week_input )) allocate ( val_hour_of_week_input ( n_hours_in_week , n_col - 1 )) do i = 1 , n_hours_in_week read ( unit_in , * ) time_hour_of_week_input ( i ), val_hour_of_week_input ( i , 1 : n_col - 1 ) !write(*,*) time_hour_of_week_input(i),val_hour_of_week_input(i,1:n_col-1) enddo !Read Hour_of_week read ( unit_in , * ) temp_str , n_months_in_year write ( unit_logfile , '(a,i)' ) trim ( temp_str ), n_months_in_year !write(*,*) num_week_traffic,days_in_week,hours_in_day,n_roadlinks if (. not . allocated ( time_month_of_year_input )) allocate ( time_month_of_year_input ( n_months_in_year )) if (. not . allocated ( val_month_of_year_input )) allocate ( val_month_of_year_input ( n_months_in_year , n_col - 1 )) do i = 1 , n_months_in_year read ( unit_in , * ) time_month_of_year_input ( i ), val_month_of_year_input ( i , 1 : n_col - 1 ) !write(*,*) time_month_of_year_input(i),val_month_of_year_input(i,1:n_col-1) enddo close ( unit_in , status = 'keep' ) !close(unit_in) !Normalise the data to be used with average emmissions to give an hourly average value and a monthly average value do i_source = 1 , n_col - 1 val_hour_of_week_input (:, i_source ) = val_hour_of_week_input (:, i_source ) / sum ( val_hour_of_week_input (:, i_source )) * n_hours_in_week val_month_of_year_input (:, i_source ) = val_month_of_year_input (:, i_source ) / sum ( val_month_of_year_input (:, i_source )) * n_months_in_year enddo !do i=1,n_hours_in_week !    write(*,*) time_hour_of_week_input(i),val_hour_of_week_input(i,1:n_col-1) !enddo !stop !Get time information for the current calculation !    if (use_single_time_loop_flag) then !        t_profile_loop=end_time_loop_index !    else !        t_profile_loop=dim_length_nc(time_dim_nc_index) !    endif t_profile_loop = dim_length_nc ( time_dim_nc_index ) do t = 1 , t_profile_loop !if (t.eq.t_loop) then !EMEP date is days since 1900 !write(*,*) val_dim_nc(t,time_dim_nc_index) !Round up the hour. Not here, is done earlier now !date_num_temp=dble(ceiling(val_dim_nc(t,time_dim_nc_index)*24.))/24. date_num_temp = val_dim_nc ( t , time_dim_nc_index ) !write(*,*) real(ceiling(val_dim_nc(t,time_dim_nc_index)*24.)),date_num_temp call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) if ( t . eq . 1 ) write ( unit_logfile , '(a,6i6)' ) 'Date array start = ' , date_array if ( t . eq . t_profile_loop ) write ( unit_logfile , '(a,6i6)' ) 'Date array end = ' , date_array week_day_temp = day_of_week ( date_array ) !write(unit_logfile,*) 'Day of week = ',week_day_temp !write(*,*) t,date_array if ( summer_time_europe ( date_array )) then if ( auto_adjustment_for_summertime ) then emission_time_shift_temp = emission_timeprofile_hour_shift + 1 if ( t . eq . 1 ) write ( unit_logfile , '(a)' ) ' Emission profiles set to summer time. ' else emission_time_shift_temp = emission_timeprofile_hour_shift if ( t . eq . 1 ) write ( unit_logfile , '(a)' ) ' Emission profiles not adjusted for summer time. ' endif else emission_time_shift_temp = emission_timeprofile_hour_shift if ( t . eq . 1 ) write ( unit_logfile , '(a)' ) ' Emission profiles set to winter time. ' endif hour_of_week_index = ( week_day_temp - 1 ) * 24 + date_array ( 4 ) + emission_time_shift_temp if ( hour_of_week_index . gt . n_hours_in_week ) hour_of_week_index = hour_of_week_index - n_hours_in_week if ( hour_of_week_index . lt . 1 ) hour_of_week_index = hour_of_week_index + n_hours_in_week do i_source = 1 , n_col - 1 if ( calculate_source ( source_index_in ( i_source ))) then if ( source_index_in ( i_source ). eq . shipping_index . and . read_monthly_and_daily_shipping_data_flag ) then !Do nothing as the time profile has already been set in uEMEP_read_monthly_and_daily_shipping_asi_data subroutine !write(unit_logfile,'(a,i,es16.6)') 'Not resetting shipping time profiles: ',t,sum(emission_time_profile_subgrid(:,:,t,source_index_in(i_source),1)) else !Set the time profile emission_time_profile_subgrid (:,:, t , source_index_in ( i_source ),:) = val_hour_of_week_input ( hour_of_week_index , i_source ) * val_month_of_year_input ( date_array ( 2 ), i_source ) !if (source_index_in(i_source).eq.industry_index) write(*,*) 'TIME PROFILE: ',val_hour_of_week_input(hour_of_week_index,i_source),val_month_of_year_input(date_array(2),i_source) endif !write(*,*) hour_of_week_index,val_hour_of_week_input(hour_of_week_index,i_source),val_month_of_year_input(date_array(2),i_source) !write(*,*) emission_time_profile_subgrid(1,1,t,source_index_in(i_source),1) !Will  only do this calculation if for heat and only if meteorology exists !This is poorly poisitioned here because it can be called even when no meteorology is available, hence the allocation check do_not_calculate_RWC_emissions = . false . if ( source_index_in ( i_source ). eq . heating_index . and . use_RWC_emission_data ) then do j = 1 , emission_subgrid_dim ( y_dim_index , source_index_in ( i_source )) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index_in ( i_source )) if ( save_emissions_for_EMEP ( allsource_index )) then if ( allocated ( meteo_var1d_nc )) then !Need to cross reference the meteo grid to the emission grid as this is not done normally !Tricky using the two different emep grids? !Not certain if this 0.5 is correct. Not used else where i_cross = 1 + floor (( x_emission_subgrid ( i , j , source_index_in ( i_source )) - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) j_cross = 1 + floor (( y_emission_subgrid ( i , j , source_index_in ( i_source )) - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) !Because the meteo grid can be smaller than the EMEP grid then need to limit it !write(*,'(6i12)') i,j,i_cross,j_cross,dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index) i_cross = min ( max ( 1 , i_cross ), dim_length_meteo_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_meteo_nc ( y_dim_nc_index )) else !Do not do this calculation until the meteo data is available !write(unit_logfile,'(a)') ' No meteo data available for RWC heating emission calculations. Stopping' !stop !i_cross=1 !j_cross=1 do_not_calculate_RWC_emissions = . true . endif else !Use the EMEP meteorology i_cross = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , source_index_in ( i_source )) j_cross = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , source_index_in ( i_source )) i_cross = min ( max ( 1 , i_cross ), dim_length_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_nc ( y_dim_nc_index )) endif if (. not . do_not_calculate_RWC_emissions ) then hdd_temp = max ( 0. , HDD_threshold_value - max ( DMT_min_value , DMT_EMEP_grid_nc ( i_cross , j_cross , 1 ))) !write (*,*) hdd_temp,DMT_EMEP_grid_nc(i_cross,j_cross,1),max(DMT_min_value,DMT_EMEP_grid_nc(i_cross,j_cross,1)),HDD_threshold_value-max(DMT_min_value,DMT_EMEP_grid_nc(i_cross,j_cross,1)) !the heating emissions have already been normalised with RWC_grid_HDD in uEMEP_read_RWC_heating_data emission_time_profile_subgrid ( i , j , t , source_index_in ( i_source ),:) = val_hour_of_week_input ( hour_of_week_index , i_source ) / 2 4. * hdd_temp !if (i.eq.1.and.j.eq.1) write(*,*) t,hour_of_week_index,val_hour_of_week_input(hour_of_week_index,i_source)/24.,hdd_temp,HDD_threshold_value,DMT_EMEP_grid_nc(i_cross,j_cross,1) !if (i.eq.1.and.j.eq.1) write(*,*) t,hour_of_week_index,emission_time_profile_subgrid(i,j,t,source_index_in(i_source),1) endif enddo enddo endif endif enddo if ( annual_calculations ) then emission_time_profile_subgrid (:,:, t ,:,:) = 1. endif enddo deallocate ( time_hour_of_week_input ) deallocate ( val_hour_of_week_input ) deallocate ( time_month_of_year_input ) deallocate ( val_month_of_year_input ) end subroutine uEMEP_read_time_profiles","tags":"","loc":"proc/uemep_read_time_profiles.html"},{"title":"rargsort_original – uEMEP","text":"private  function rargsort_original(a) result(b) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (:) Return Value integer, (size(a))","tags":"","loc":"proc/rargsort_original.html"},{"title":"rargsort – uEMEP","text":"public  subroutine rargsort(a, b, n_a) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (n_a) integer, intent(out) :: b (n_a) integer :: n_a","tags":"","loc":"proc/rargsort.html"},{"title":"uEMEP_set_filenames – uEMEP","text":"public  subroutine uEMEP_set_filenames() Set filenames for all gridded data to be saved\nThese are the names now given in the netcdf files Arguments None Source Code subroutine uEMEP_set_filenames () !! Set filenames for all gridded data to be saved !! These are the names now given in the netcdf files ! Local variables integer :: i ! Set pathname for all gridded data to be saved pathname_grid (:) = pathname_output_grid do i = 1 , n_source_index filename_grid ( proxy_emission_file_index ( i )) = trim ( 'proxy_emission_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emission_file_index ( i )) = trim ( 'emission_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_file_index ( i )) = trim ( 'proxy_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_integral_file_index ( i )) = trim ( 'proxy_integral_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_file_index ( i )) = trim ( 'EMEP_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_nonlocal_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_local_file_index ( i )) = trim ( 'EMEP_local_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_additional_nonlocal_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_local_file_index ( i )) = trim ( 'EMEP_additional_local_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_frac_file_index ( i )) = trim ( 'EMEP_frac_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_local_file_index ( i )) = trim ( 'local_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_total_file_index ( i )) = trim ( 'total_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( use_subgrid_file_index ( i )) = trim ( 'use_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_emission_subgrid_file_index ( i )) = trim ( 'EMEP_emission_subgrid' ) // '_' // trim ( source_file_str ( i )) end do ! Alternative set of names for outputs to netcdf do i = 1 , n_source_index filename_grid ( proxy_emission_file_index ( i )) = trim ( 'proxy_emission' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emission_file_index ( i )) = trim ( 'emission' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_file_index ( i )) = trim ( 'proxy' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_integral_file_index ( i )) = trim ( 'proxy_integral' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_file_index ( i )) = trim ( 'EMEP' ) // '_' // trim ( source_file_str ( i )) if ( save_netcdf_fraction_as_contribution_flag ) then filename_grid ( emep_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_nonlocal_contribution' ) filename_grid ( emep_subgrid_local_file_index ( i )) = trim ( 'EMEP_local_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_additional_nonlocal_contribution' ) filename_grid ( emep_additional_subgrid_local_file_index ( i )) = trim ( 'EMEP_additional_local_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_frac_file_index ( i )) = trim ( 'EMEP_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_local_file_index ( i )) = trim ( 'local_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_semilocal_file_index ( i )) = trim ( 'EMEP_semilocal_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_inregion_file_index ( i )) = trim ( 'total_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_file_index ( i )) = trim ( 'total_contribution' ) // '_' // trim ( source_file_str ( i )) else filename_grid ( emep_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_nonlocal_fraction' ) filename_grid ( emep_subgrid_local_file_index ( i )) = trim ( 'EMEP_local_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_additional_nonlocal_fraction' ) filename_grid ( emep_additional_subgrid_local_file_index ( i )) = trim ( 'EMEP_additional_local_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_frac_file_index ( i )) = trim ( 'EMEP_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_local_file_index ( i )) = trim ( 'local_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_semilocal_file_index ( i )) = trim ( 'EMEP_semilocal_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_inregion_file_index ( i )) = trim ( 'total_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_file_index ( i )) = trim ( 'total_fraction' ) // '_' // trim ( source_file_str ( i )) end if filename_grid ( subgrid_total_file_index ( i )) = trim ( 'total' ) // '_' // trim ( source_file_str ( i )) filename_grid ( use_subgrid_file_index ( i )) = trim ( 'use_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_emission_subgrid_file_index ( i )) = trim ( 'EMEP_emission' ) // '_' // trim ( source_file_str ( i )) end do filename_grid ( population_file_index ( dwelling_index )) = trim ( 'dwelling' ) filename_grid ( population_file_index ( population_index )) = trim ( 'population' ) filename_grid ( population_file_index ( school_index )) = trim ( 'school' ) filename_grid ( population_file_index ( establishment_index )) = trim ( 'establishment' ) filename_grid ( population_file_index ( kindergaten_index )) = trim ( 'kindergaten' ) filename_grid ( population_file_index ( home_index )) = trim ( 'home' ) ! Meteo file names filename_grid ( subgrid_ugrid_file_index ) = 'xgrid_wind' filename_grid ( subgrid_vgrid_file_index ) = 'ygrid_wind' filename_grid ( subgrid_u10_file_index ) = 'x10_wind' filename_grid ( subgrid_v10_file_index ) = 'y10_wind' filename_grid ( subgrid_hmix_file_index ) = 'hmix' filename_grid ( subgrid_kz_file_index ) = 'kz' filename_grid ( subgrid_logz0_file_index ) = 'logz0' filename_grid ( subgrid_invL_file_index ) = 'inv_L' filename_grid ( subgrid_FFgrid_file_index ) = 'wind_speed_grid' filename_grid ( subgrid_DDgrid_file_index ) = 'wind_direction_grid' filename_grid ( subgrid_FF10_file_index ) = 'wind_speed_10m' filename_grid ( subgrid_DD10_file_index ) = 'wind_direction_10m' filename_grid ( subgrid_invFFgrid_file_index ) = 'inv_FFgrid' filename_grid ( subgrid_invFF10_file_index ) = 'inv_FF10' filename_grid ( subgrid_ustar_file_index ) = 'ustar' filename_grid ( subgrid_J_file_index ) = 'J_photo' filename_grid ( subgrid_t2m_file_index ) = 'air_temperature_2m' end subroutine uEMEP_set_filenames","tags":"","loc":"proc/uemep_set_filenames.html"},{"title":"uEMEP_read_receptor_data – uEMEP","text":"public  subroutine uEMEP_read_receptor_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_read_receptor_data use uEMEP_definitions implicit none integer k logical exists character ( 256 ) temp_str integer unit_in integer count logical unique_receptor ( n_receptor_max ) integer kk integer :: io use_receptor = . true . if ( use_receptor_positions_for_auto_subgrid_flag . or . use_multiple_receptor_grids_flag . or . save_netcdf_receptor_flag ) then else return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading receptor positions (uEMEP_read_receptor_data)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_receptor = trim ( pathname_receptor ) // trim ( filename_receptor ) !write(*,*) pathname_rl(2),filename_rl(2),pathfilename_rl(2) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_receptor ), exist = exists ) if (. not . exists ) then if ( use_multiple_receptor_grids_flag ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Receptor file does not exist. Cannot calculate: ' , trim ( pathfilename_receptor ) stop else write ( unit_logfile , '(A,A)' ) ' WARNING: Receptor file does not exist. Will not provide receptor output: ' , trim ( pathfilename_receptor ) n_receptor = 0 n_receptor_in = n_receptor n_valid_receptor = 0 n_valid_receptor_in = n_valid_receptor return endif endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_receptor , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening receptor file ' // trim ( pathfilename_receptor ) rewind ( unit_in ) !call NXTDAT(unit_in,nxtdat_flag) !read the header to find out how many links there are read ( unit_in , '(a)' , iostat = io ) temp_str if ( io == 0 ) then k = 0 do while ( k . lt . n_receptor_max ) k = k + 1 read ( unit_in , * , iostat = io ) name_receptor ( k , 1 ), lon_receptor ( k ), lat_receptor ( k ), height_receptor ( k ) !,name_receptor(k,2) if ( io /= 0 ) exit !write(*,*) trim(name_receptor(k,1)),lon_receptor(k),lat_receptor(k),trim(name_receptor(k,2)) enddo end if close ( unit_in ) n_receptor = k write ( unit_logfile , '(a,2i)' ) ' Number of receptor points and max allowable = ' , n_receptor , n_receptor_max !Convert to x,y positions do k = 1 , n_receptor if ( projection_type . eq . RDM_projection_index ) then !No conversion exists for RDM elseif ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , lat_receptor ( k ), lon_receptor ( k ), y_receptor ( k ), x_receptor ( k )) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , lat_receptor ( k ), lon_receptor ( k ), y_receptor ( k ), x_receptor ( k )) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_receptor ( k ), y_receptor ( k ), lon_receptor ( k ), lat_receptor ( k ), projection_attributes ) endif enddo !Save the receptor data in the 'in' array as the other arrays can be changed n_receptor_in = n_receptor if ( use_multiple_receptor_grids_flag ) then n_receptor_in = n_receptor name_receptor_in = name_receptor lon_receptor_in = lon_receptor lat_receptor_in = lat_receptor x_receptor_in = x_receptor y_receptor_in = y_receptor height_receptor_in = height_receptor endif !Identify receptors within the initial subgrid region and only calculate these init_subgrid_dim ( x_dim_index ) = floor (( init_subgrid_max ( x_dim_index ) - init_subgrid_min ( x_dim_index )) / init_subgrid_delta ( x_dim_index )) + 1 init_subgrid_dim ( y_dim_index ) = floor (( init_subgrid_max ( y_dim_index ) - init_subgrid_min ( y_dim_index )) / init_subgrid_delta ( y_dim_index )) + 1 write ( unit_logfile , '(a,2i)' ) ' Number of initial subgrid = ' , init_subgrid_dim ( x_dim_index ), init_subgrid_dim ( y_dim_index ) write ( unit_logfile , '(a,2f12.1)' ) ' Size of initial subgrid = ' , init_subgrid_max ( x_dim_index ) - init_subgrid_min ( x_dim_index ), init_subgrid_max ( y_dim_index ) - init_subgrid_min ( y_dim_index ) !Remove identically named receptors count = 0 unique_receptor = . true . do k = 1 , n_receptor do kk = 1 , n_receptor if ( trim ( name_receptor ( k , 1 )). eq . trim ( name_receptor ( kk , 1 )). and . unique_receptor ( k ). and . k . ne . kk ) then unique_receptor ( kk ) = . false . endif enddo enddo !Select receptors within the initial grid and with unique names do k = 1 , n_receptor i_receptor_subgrid ( k ) = 1 + floor (( x_receptor ( k ) - init_subgrid_min ( x_dim_index )) / init_subgrid_delta ( x_dim_index )) j_receptor_subgrid ( k ) = 1 + floor (( y_receptor ( k ) - init_subgrid_min ( y_dim_index )) / init_subgrid_delta ( y_dim_index )) !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) !Set subgrid use or not. At grid and surrounding grids in case of interpolation later if ( i_receptor_subgrid ( k ). gt . 1. and . i_receptor_subgrid ( k ). lt . init_subgrid_dim ( x_dim_index ). and . j_receptor_subgrid ( k ). gt . 1. and . j_receptor_subgrid ( k ). lt . init_subgrid_dim ( y_dim_index ). and . unique_receptor ( k )) then use_receptor ( k ) = . true . !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) count = count + 1 valid_receptor_index ( count ) = k valid_receptor_inverse_index ( k ) = count write ( unit_logfile , '(a,a12,3f12.1)' ) ' Receptor and grid positions (x,y,h) = ' , trim ( name_receptor ( k , 1 )), x_receptor ( k ) - init_subgrid_min ( x_dim_index ), y_receptor ( k ) - init_subgrid_min ( y_dim_index ), height_receptor ( k ) else use_receptor ( k ) = . false . valid_receptor_inverse_index ( k ) = 0 endif enddo n_valid_receptor = count n_valid_receptor_in = n_valid_receptor write ( unit_logfile , '(a,i)' ) ' Total number of receptors to be calculated = ' , n_valid_receptor end subroutine uEMEP_read_receptor_data","tags":"","loc":"proc/uemep_read_receptor_data.html"},{"title":"uEMEP_grid_receptor_data – uEMEP","text":"public  subroutine uEMEP_grid_receptor_data() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_grid_receptor_data use uEMEP_definitions implicit none integer i , j , k integer count logical use_receptor_temp !integer :: use_region=2 ! +/- number of grids to loop around so that receptor positions can be interpolated linearly if ( use_receptor_positions_for_auto_subgrid_flag . or . use_multiple_receptor_grids_flag ) then else return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Gridding receptor positions (uEMEP_grid_receptor_data)' write ( unit_logfile , '(A)' ) '================================================================' !Find the target grid positions of the receptor points use_subgrid = . false . count = 0 do k = 1 , n_receptor !Always true when using use_multiple_receptor_grids_flag as this is inside the use_receptor loop if ( use_multiple_receptor_grids_flag ) then use_receptor_temp = . true . else use_receptor_temp = use_receptor ( k ) endif if ( use_receptor_temp ) then i_receptor_subgrid ( k ) = 1 + floor (( x_receptor ( k ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) j_receptor_subgrid ( k ) = 1 + floor (( y_receptor ( k ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) !write(*,*) 'HERE2: ',i_receptor_subgrid(k),j_receptor_subgrid(k) !Set subgrid use or not. At grid and surrounding grids in case of interpolation later if ( i_receptor_subgrid ( k ). gt . use_receptor_region . and . i_receptor_subgrid ( k ). lt . subgrid_dim ( x_dim_index ) - use_receptor_region + 1. and . j_receptor_subgrid ( k ). gt . use_receptor_region . and . j_receptor_subgrid ( k ). lt . subgrid_dim ( y_dim_index ) - use_receptor_region + 1 ) then use_subgrid ( i_receptor_subgrid ( k ) - use_receptor_region : i_receptor_subgrid ( k ) + use_receptor_region , j_receptor_subgrid ( k ) - use_receptor_region : j_receptor_subgrid ( k ) + use_receptor_region ,:) = . true . !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) count = count + 1 endif endif enddo write ( unit_logfile , '(a,i)' ) ' Number of receptor points available in region = ' , count count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) count = count + 1 enddo enddo write ( unit_logfile , '(a,i)' ) ' Number of subgrids to be calculated = ' , count end subroutine uEMEP_grid_receptor_data","tags":"","loc":"proc/uemep_grid_receptor_data.html"},{"title":"uEMEP_set_loop_receptor_grid – uEMEP","text":"public  subroutine uEMEP_set_loop_receptor_grid() Uses uEMEP_definitions Arguments None Source Code subroutine uEMEP_set_loop_receptor_grid use uEMEP_definitions implicit none integer k integer count !integer :: use_region=2 ! +/- number of grids to loop around so that receptor positions can be interpolated linearly real x_ref , y_ref if (. not . use_multiple_receptor_grids_flag ) then return endif !if (g_loop.eq.start_grid_loop_index) then write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Starting receptor loop (uEMEP_set_loop_receptor_grid)' write ( unit_logfile , '(A)' ) '================================================================' ! endif k = 1 if ( use_multiple_receptor_grids_flag ) then name_receptor ( k ,:) = name_receptor_in ( g_loop ,:) lon_receptor ( k ) = lon_receptor_in ( g_loop ) lat_receptor ( k ) = lat_receptor_in ( g_loop ) x_receptor ( k ) = x_receptor_in ( g_loop ) y_receptor ( k ) = y_receptor_in ( g_loop ) height_receptor ( k ) = height_receptor_in ( g_loop ) endif !Set lowest left edge of subgrid receptor position would be in x_ref = ( floor (( x_receptor ( k ) - subgrid_receptor_offset ( x_dim_index )) / subgrid_delta ( x_dim_index ) + 0.0 )) * subgrid_delta ( x_dim_index ) + subgrid_receptor_offset ( x_dim_index ) y_ref = ( floor (( y_receptor ( k ) - subgrid_receptor_offset ( y_dim_index )) / subgrid_delta ( y_dim_index ) + 0.0 )) * subgrid_delta ( y_dim_index ) + subgrid_receptor_offset ( y_dim_index ) !Set limits subgrid_min ( x_dim_index ) = x_ref - subgrid_delta ( x_dim_index ) * ( use_receptor_region ) * 1.0 subgrid_min ( y_dim_index ) = y_ref - subgrid_delta ( y_dim_index ) * ( use_receptor_region ) * 1.0 subgrid_max ( x_dim_index ) = x_ref + subgrid_delta ( x_dim_index ) * ( use_receptor_region + 1 ) * 1.0 subgrid_max ( y_dim_index ) = y_ref + subgrid_delta ( y_dim_index ) * ( use_receptor_region + 1 ) * 1.0 subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) + 1 subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) + 1 z_rec = height_receptor ( k ) write ( unit_logfile , '(a,i12,a)' ) ' Receptor loop number = ' , g_loop , ' ' // trim ( name_receptor ( k , 1 )) write ( unit_logfile , '(a,4f12.1)' ) ' Receptor and grid positions (x,y) = ' , x_receptor ( k ), x_ref , y_receptor ( k ), y_ref write ( unit_logfile , '(a,2i)' ) ' Number of receptor subgrids = ' , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ) write ( unit_logfile , '(a,f12.1)' ) ' Receptor height (m) = ' , z_rec ( allsource_index , 1 ) !Find the target grid positions of the receptor points count = 0 !do k=1,n_receptor i_receptor_subgrid ( k ) = 1 + floor (( x_receptor ( k ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) j_receptor_subgrid ( k ) = 1 + floor (( y_receptor ( k ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) write ( unit_logfile , '(a,2i)' ) ' Receptor subgrid index = ' , i_receptor_subgrid ( k ), j_receptor_subgrid ( k ) !Set subgrid use or not. At grid and surrounding grids in case of interpolation later if ( i_receptor_subgrid ( k ). gt . use_receptor_region . and . i_receptor_subgrid ( k ). lt . subgrid_dim ( x_dim_index ) - use_receptor_region + 1. and . j_receptor_subgrid ( k ). gt . use_receptor_region . and . j_receptor_subgrid ( k ). lt . subgrid_dim ( y_dim_index ) - use_receptor_region + 1 ) then use_subgrid ( i_receptor_subgrid ( k ) - use_receptor_region : i_receptor_subgrid ( k ) + use_receptor_region , j_receptor_subgrid ( k ) - use_receptor_region : j_receptor_subgrid ( k ) + use_receptor_region ,:) = . true . !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) count = count + 1 endif !enddo write ( unit_logfile , '(a,i)' ) ' Number of receptor points available in region = ' , count !count=0 !do j=1,subgrid_dim(y_dim_index) !do i=1,subgrid_dim(x_dim_index) !    if (use_subgrid(i,j,allsource_index)) count=count+1 !enddo !enddo !write(unit_logfile,'(a,i)') ' Number of subgrids to be calculated = ', count end subroutine uEMEP_set_loop_receptor_grid","tags":"","loc":"proc/uemep_set_loop_receptor_grid.html"},{"title":"uEMEP_set_dispersion_params_simple – uEMEP","text":"public  subroutine uEMEP_set_dispersion_params_simple(source_index, subsource_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer :: source_index integer :: subsource_index Source Code subroutine uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) use uEMEP_definitions implicit none integer source_index , subsource_index !Set the psedo dispersion parameters here. ay ( source_index , subsource_index ) = 0.32 by ( source_index , subsource_index ) = 0.78 az ( source_index , subsource_index ) = 0.22 bz ( source_index , subsource_index ) = 0.78 !ay(source_index,subsource_index)=0.64!From Liu !by(source_index,subsource_index)=0.46!From Liu !az(source_index,subsource_index)=0.088!From Liu !bz(source_index,subsource_index)=0.72!From Liu 0.72 !ay(source_index,subsource_index)=0.32 !by(source_index,subsource_index)=0.78 az ( source_index , subsource_index ) = 0.2 bz ( source_index , subsource_index ) = 0.75 !Alternative to ASME !ay(source_index,subsource_index)=0.14 !by(source_index,subsource_index)=0.9 !az(source_index,subsource_index)=0.22 !bz(source_index,subsource_index)=0.85 !sig_y_0(source_index,subsource_index)=sig_y_00(source_index,subsource_index) !sig_z_0(source_index,subsource_index)=sig_z_00(source_index,subsource_index) !sig_y_0(source_index,subsource_index)=sig_y_00(source_index,subsource_index)+sqrt(emission_subgrid_delta(x_dim_index,source_index)*emission_subgrid_delta(y_dim_index,source_index))/2. !sig_z_0(source_index,subsource_index)=sig_z_00(source_index,subsource_index)+az(source_index,subsource_index)*exp(bz(source_index,subsource_index)*log(sig_y_0(source_index,subsource_index))) !h_emis(source_index,subsource_index)=1. !z_rec(source_index,subsource_index)=2. !Exceptions !ay=ay*3. !az=az*5. !bz=0.95 end subroutine uEMEP_set_dispersion_params_simple","tags":"","loc":"proc/uemep_set_dispersion_params_simple.html"},{"title":"uEMEP_set_dispersion_params_PG – uEMEP","text":"public  subroutine uEMEP_set_dispersion_params_PG(invL, source_index, subsource_index) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name real :: invL integer :: source_index integer :: subsource_index Source Code subroutine uEMEP_set_dispersion_params_PG ( invL , source_index , subsource_index ) use uEMEP_definitions implicit none integer source_index , subsource_index real invL integer class_index real min_xy real ay_pg ( 6 ), by_pg ( 6 ), az_pg ( 6 ), bz_pg ( 6 ) real L_class ( 5 ), invL_class ( 5 ) data ay_pg / 0.469 , 0.306 , 0.230 , 0.219 , 0.237 , 0.237 / data by_pg / 0.903 , 0.855 , 0.855 , 0.764 , 0.691 , 0.594 / data az_pg / 0.017 , 0.072 , 0.076 , 0.140 , 0.217 , 0.262 / data bz_pg / 1.38 , 1.021 , 0.879 , 0.727 , 0.610 , 0.500 / !data L_class /-10.,-25.,-200.,200.,25./ data L_class /- 1 0. , - 2 5. , - 10 0. , 5 0. , 5. / invL_class = 1. / L_class if ( invL . le . invL_class ( 1 )) then class_index = 1 elseif ( invL . gt . invL_class ( 1 ). and . invL . le . invL_class ( 2 )) then class_index = 2 elseif ( invL . gt . invL_class ( 2 ). and . invL . le . invL_class ( 3 )) then class_index = 3 elseif ( invL . gt . invL_class ( 3 ). and . invL . le . invL_class ( 4 )) then class_index = 4 elseif ( invL . gt . invL_class ( 4 ). and . invL . le . invL_class ( 5 )) then class_index = 5 elseif ( invL . gt . invL_class ( 5 )) then class_index = 6 else class_index = 0 write ( * , * ) 'No stability class found. Stopping' , invL write ( * , * ) 'No stability class found. Stopping' , 1. / invL stop endif !if (class_index.ne.4) write(*,*) invL,class_index !Set the dispersion parameters here. ay ( source_index , subsource_index ) = ay_pg ( class_index ) by ( source_index , subsource_index ) = by_pg ( class_index ) az ( source_index , subsource_index ) = az_pg ( class_index ) bz ( source_index , subsource_index ) = bz_pg ( class_index ) !if (bz(source_index,subsource_index).ne.0.727) write(*,*) invL,class_index,bz(source_index,subsource_index) !ay(source_index,subsource_index)=0.219 !by(source_index,subsource_index)=0.764 !az(source_index,subsource_index)=0.114 !bz(source_index,subsource_index)=0.727 !Changed this to use the min_xy value as in all other routines using sigy_0_subgid_width_scale (13.12.2019) !Not important because this is set properly in uEMEP_set_dispersion_sigma_PG which is called afterwards min_xy = ( emission_subgrid_delta ( x_dim_index , source_index ) + emission_subgrid_delta ( y_dim_index , source_index )) / 4. !sig_y_0(source_index,subsource_index)=sig_y_00(source_index,subsource_index)+sqrt(emission_subgrid_delta(x_dim_index,source_index)*emission_subgrid_delta(y_dim_index,source_index))/4.*sigy_0_subgid_width_scale sig_y_0 ( source_index , subsource_index ) = sig_y_00 ( source_index , subsource_index ) + min_xy * sigy_0_subgid_width_scale sig_z_0 ( source_index , subsource_index ) = sig_z_00 ( source_index , subsource_index ) + az ( source_index , subsource_index ) * exp ( bz ( source_index , subsource_index ) * log ( sig_y_0 ( source_index , subsource_index ))) end subroutine uEMEP_set_dispersion_params_PG","tags":"","loc":"proc/uemep_set_dispersion_params_pg.html"},{"title":"delta_wind_direction – uEMEP","text":"public  subroutine delta_wind_direction(i_cross, j_cross, tt, temp_FF_subgrid, angle_diff) Uses uEMEP_definitions Arguments Type Intent Optional Attributes Name integer, intent(in) :: i_cross integer, intent(in) :: j_cross integer, intent(in) :: tt real, intent(in) :: temp_FF_subgrid real, intent(out) :: angle_diff Source Code subroutine delta_wind_direction ( i_cross , j_cross , tt , temp_FF_subgrid , angle_diff ) use uEMEP_definitions implicit none integer , intent ( in ) :: i_cross , j_cross , tt real , intent ( in ) :: temp_FF_subgrid real , intent ( out ) :: angle_diff real :: meandering_degree_max = 2 0. real cos_subgrid_loc , sin_subgrid_loc if ( use_last_meteo_in_dispersion ) then cos_subgrid_loc = meteo_subgrid ( i_cross , j_cross , tt , cos_subgrid_index ) sin_subgrid_loc = meteo_subgrid ( i_cross , j_cross , tt , sin_subgrid_index ) angle_diff = abs ( asin ( meteo_subgrid ( i_cross , j_cross , tt , sin_subgrid_index ) * last_meteo_subgrid ( i_cross , j_cross , cos_subgrid_index ) & - meteo_subgrid ( i_cross , j_cross , tt , cos_subgrid_index ) * last_meteo_subgrid ( i_cross , j_cross , sin_subgrid_index ) )) / 2. angle_diff = min ( angle_diff , 3.14159 / 4. ) !Less than 45 degrees !write(*,*) i_cross,j_cross,angle_diff(i_cross,j_cross)*180/3.14159 else angle_diff = 0. endif if ( use_meandering_in_dispersion ) then angle_diff = angle_diff + ( meandering_degree_max * 3.14159 / 18 0. ) * exp ( - ( temp_FF_subgrid - FF_min_dispersion ) / ( FF_min_dispersion * 2. )) endif end subroutine delta_wind_direction","tags":"","loc":"proc/delta_wind_direction.html"},{"title":"uEMEP_set_dispersion_sigma_simple – uEMEP","text":"public  subroutine uEMEP_set_dispersion_sigma_simple(sig_z_00, sig_y_00, sigy_0_subgid_width_scale, subgrid_delta, delta_wind, x, sig_z, sig_y, sig_z_0, sig_y_0) Arguments Type Intent Optional Attributes Name real, intent(in) :: sig_z_00 real, intent(in) :: sig_y_00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: subgrid_delta (2) real, intent(in) :: delta_wind real, intent(in) :: x real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: sig_z_0 real, intent(out) :: sig_y_0 Source Code subroutine uEMEP_set_dispersion_sigma_simple ( sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta , delta_wind , x , sig_z , sig_y , sig_z_0 , sig_y_0 ) implicit none real , intent ( in ) :: sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta ( 2 ), delta_wind , x real , intent ( out ) :: sig_z , sig_y , sig_z_0 , sig_y_0 real ay , by , az , bz real min_xy !Set the psedo dispersion parameters for neutral conditions !From Klug !ay=0.32 !by=0.78 !az=0.22 !bz=0.78 !From Liu !ay=0.64 !by=0.46!From Liu !az=0.088!From Liu !bz=0.72!From Liu 0.72 !Alternative ASME !ay=0.14 !by=0.9 !az=0.22 !bz=0.85 !Update from K_z fitting ay = 0.32 by = 0.78 !az=0.19 !bz=0.77 az = 0.125 bz = 0.85 !For z0=0.1, corresponding to the same as K_z for wind height at emission source of 1 m az = 0.245 bz = 0.711 !For z0=0.3, corresponding to the same as K_z for wind height at average of emission source of 1 m and zc az = 0.21 bz = 0.79 !For z0=0.3, corresponding to the same as K_z for wind height at emission source of 1 m !Consistant with uEMEP_set_dispersion_params_PG needs to be fixed. Just one call to the parameters, one calle to the sigma calculation az = 0.2 bz = 0.75 min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. !Set sig_y_0 to be half of the average x,y grid size !Add this here ay*exp(by*log(min_xy)) to be the same as sig_z and the same as the  Kz calculation !Does not mean it is correct, just closer to the Kz which is perhaps not so correct sig_y_0 = sig_y_00 + min_xy * sigy_0_subgid_width_scale + ay * exp ( by * log ( min_xy )) !Set sig_z_0 to be the size of the plume after travelling half of the grid size sig_z_0 = sig_z_00 + az * exp ( bz * log ( min_xy )) !Set sig_y and sig_z = sig_0 + a*x&#94;b +x*delata_wind sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta_wind ) sig_z = sig_z_0 + az * exp ( bz * log ( x )) end subroutine uEMEP_set_dispersion_sigma_simple","tags":"","loc":"proc/uemep_set_dispersion_sigma_simple.html"},{"title":"uEMEP_set_dispersion_sigma_PG – uEMEP","text":"public  subroutine uEMEP_set_dispersion_sigma_PG(invL_in, logz0, sig_z_00, sig_y_00, sigy_0_subgid_width_scale, subgrid_delta, delta_wind, x, sig_z, sig_y, sig_z_0, sig_y_0) Arguments Type Intent Optional Attributes Name real, intent(in) :: invL_in real, intent(in) :: logz0 real, intent(in) :: sig_z_00 real, intent(in) :: sig_y_00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: subgrid_delta (2) real, intent(in) :: delta_wind real, intent(in) :: x real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: sig_z_0 real, intent(out) :: sig_y_0 Source Code subroutine uEMEP_set_dispersion_sigma_PG ( invL_in , logz0 , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta , delta_wind , x , sig_z , sig_y , sig_z_0 , sig_y_0 ) implicit none real , intent ( in ) :: invL_in , logz0 , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta ( 2 ), delta_wind , x real , intent ( out ) :: sig_z , sig_y , sig_z_0 , sig_y_0 integer i_bot , i_top , i real weight real ay , by , az , bz real min_xy real ay_pg ( 6 ), by_pg ( 6 ), az_pg ( 6 ), bz_pg ( 6 ) real a_invL ( 6 ), b_invL ( 6 ), invL ( 6 ) !Use ASME parameters data ay_pg / 0.40 , 0.36 , 0.34 , 0.32 , 0.315 , 0.31 / data by_pg / 0.91 , 0.86 , 0.82 , 0.78 , 0.75 , 0.71 / data az_pg / 0.40 , 0.33 , 0.27 , 0.22 , 0.14 , 0.06 / data bz_pg / 0.91 , 0.86 , 0.82 , 0.78 , 0.75 , 0.71 / !Conversion of classes to L data a_invL /- 0.096 , - 0.037 , - 0.002 , 0.0 , 0.004 , 0.035 / data b_invL / 0.029 , 0.029 , 0.018 , 0.0 , - 0.018 , - 0.036 / invL = a_invL + b_invL * logz0 min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. !Find and interpolate the stability class based on input invL if ( invL_in . le . invL ( 1 )) then i_bot = 1 i_top = 1 weight = 0. elseif ( invL_in . gt . invL ( 6 )) then i_bot = 6 i_top = 6 weight = 1. else do i = 1 , 5 if ( invL_in . gt . invL ( i ). and . invL_in . le . invL ( i + 1 )) then i_bot = i i_top = i + 1 weight = ( invL_in - invL ( i )) / ( invL ( i + 1 ) - invL ( i )) exit endif enddo endif ay = ay_pg ( i_bot ) * ( 1. - weight ) + ay_pg ( i_top ) * weight by = by_pg ( i_bot ) * ( 1. - weight ) + by_pg ( i_top ) * weight az = az_pg ( i_bot ) * ( 1. - weight ) + az_pg ( i_top ) * weight bz = bz_pg ( i_bot ) * ( 1. - weight ) + bz_pg ( i_top ) * weight !Set sig_y_0 to be half of the average x,y grid size !Add this here ay*exp(by*log(min_xy)) to be the same as sig_z and the same as the  Kz calculation !Does not mean it is correct, just closer to the Kz which is perhaps not so correct sig_y_0 = sig_y_00 + min_xy * sigy_0_subgid_width_scale + ay * exp ( by * log ( min_xy )) !Set sig_z_0 to be the size of the plume after travelling half of the grid size sig_z_0 = sig_z_00 + az * exp ( bz * log ( min_xy )) !Set sig_y and sig_z = sig_0 + a*x&#94;b +x*delata_wind !Changed this because of error when x=0, check the other similar routines if ( x . le . 0 ) then sig_y = sig_y_0 sig_z = sig_z_0 else sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta_wind ) sig_z = sig_z_0 + az * exp ( bz * log ( x )) endif !write(*,'(i,6f)') i,weight,sig_y,sig_z,az,bz,x end subroutine uEMEP_set_dispersion_sigma_PG","tags":"","loc":"proc/uemep_set_dispersion_sigma_pg.html"},{"title":"uEMEP_set_dispersion_sigma_Kz_emulator – uEMEP","text":"public  subroutine uEMEP_set_dispersion_sigma_Kz_emulator(z_emis, invL, logz0, z_pbl, sig_z_00, sig_y_00, sigy_0_subgid_width_scale, subgrid_delta, delta_wind, x, sig_z, sig_y, sig_z_0, sig_y_0) Arguments Type Intent Optional Attributes Name real, intent(in) :: z_emis real, intent(in) :: invL real, intent(in) :: logz0 real, intent(in) :: z_pbl real, intent(in) :: sig_z_00 real, intent(in) :: sig_y_00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: subgrid_delta (2) real, intent(in) :: delta_wind real, intent(in) :: x real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: sig_z_0 real, intent(out) :: sig_y_0 Source Code subroutine uEMEP_set_dispersion_sigma_Kz_emulator ( z_emis , invL , logz0 , z_pbl , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta , delta_wind , x , sig_z , sig_y , sig_z_0 , sig_y_0 ) implicit none real , intent ( in ) :: z_emis , invL , logz0 , z_pbl , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta ( 2 ), delta_wind , x real , intent ( out ) :: sig_z , sig_y , sig_z_0 , sig_y_0 real invL_in , zz_pbl , z0 real ay , by , az , bz real min_xy real z0_ref , zz_pbl_ref , zz_pbl_L , logz real x_val !invL_in=1./L min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. x_val = max ( x , min_xy ) !Remove the stable cases as these are not normally done in the full K_z formulation !invL_in=min(invL_in,1./100.) invL_in = min ( invL , 0. ) !invL_in=0. zz_pbl = min (. 95 , z_emis / z_pbl ) !Cannot be greater than 0.95 as it is outside the emulator region zz_pbl_L = z_pbl * invL_in ; logz = log ( z_emis ) z0 = exp ( logz0 ) !Original !az=0.15+0.52*(z0-0.02)-0.15*(1.-EXP(-zz_pbl/0.03))+0.16*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/5.)) !bz=0.77-0.15*(1.-EXP(-z0/0.3))+0.2*(1.-EXP(-zz_pbl/0.03))-0.4*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/8.)) !Alternative form z0_ref = 0.1 zz_pbl_ref = 0.001 !az=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))+0.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !bz=0.76-0.17*(1.-exp(-(z0-z0_ref)*.3))+0.2*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))-0.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !ay=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl)*10.))+.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !by=0.76-0.17*(1.-exp(-(z0-z0_ref)*3))+0.70*(1.-exp(-(zz_pbl)*1.))-.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) az = ( - tanh (( logz - 1.2 ) * 3. ) * 0.08 + 0.1 + ( 1 - exp ( - zz_pbl / 0.05 )) * 0.06 ) * ( 1 + ( z0 - z0_ref ) / ( z0 + 0.6 ) * 3. ) - . 02 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( zz_pbl_L ) * 1 0. )) bz = tanh (( logz - 1.2 ) * 3 ) * 0.14 + 0.88 - ( 1 - exp ( - zz_pbl / 0.05 )) * 0.11 - log ( z0 / z0_ref ) * 0.04 - . 20 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( invL_in ) * 1 0. )) if ( z_emis / z_pbl . gt . 1 ) then az = 0.001 bz = 1.0 endif !Limit to the values explored by the emulator, just in case az = min ( max ( az , 0.001 ), 0.7 ) bz = min ( max ( bz , 0.4 ), 1.2 ) !Calculate y values, taken as close to the maximum K height of z/z_pbl=0.25 zz_pbl = 0.25 zz_pbl = ( z_pbl * 0.25 + z_emis ) / 2. / z_pbl logz = log ( zz_pbl * z_pbl ) !ay=0.15+0.52*(z0-0.02)-0.15*(1.-EXP(-zz_pbl/0.03))+0.16*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/5.)) !by=0.77-0.15*(1.-EXP(-z0/0.3))+0.2*(1.-EXP(-zz_pbl/0.03))-0.4*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/8.)) !az=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))+0.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !bz=0.76-0.17*(1.-exp(-(z0-z0_ref)*.3))+0.2*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))-0.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !ay=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl)*10.))+.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !by=0.76-0.17*(1.-exp(-(z0-z0_ref)*3))+0.70*(1.-exp(-(zz_pbl)*1.))-.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) ay = ( - tanh (( logz - 1.2 ) * 3. ) * 0.08 + 0.1 + ( 1 - exp ( - zz_pbl / 0.05 )) * 0.06 ) * ( 1 + ( z0 - z0_ref ) / ( z0 + 0.6 ) * 3. ) - . 02 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( zz_pbl_L ) * 1 0. )) by = tanh (( logz - 1.2 ) * 3 ) * 0.14 + 0.88 - ( 1 - exp ( - zz_pbl / 0.05 )) * 0.11 - log ( z0 / z0_ref ) * 0.04 - . 20 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( invL_in ) * 1 0. )) if ( z_emis / z_pbl . ge . 1. ) then ay = 0.001 by = 1.0 endif ay = min ( max ( ay , 0.001 ), 0.7 ) by = min ( max ( by , 0.4 ), 1.2 ) !Set sig_y_0 to be half of the average x,y grid size !Mulitiply by the scale sig_y_0 = sig_y_00 + min_xy * sigy_0_subgid_width_scale !Set sig_z_0 to be the size of the plume after travelling half of the grid size !sig_z_0=sig_z_00+az*exp(bz*log(min_xy)) !Set sig_y and sig_z = sig_0 + a*x&#94;b +x*delata_wind sig_y = sig_y_0 + ay * exp ( by * log ( x + min_xy )) + ( x + min_xy ) * abs ( delta_wind ) !sig_z=sig_z_0+az*exp(bz*log(x)) !if (x.lt.10.) write(*,*) x,sig_z_00,sig_z sig_z_0 = sig_z_00 + az * exp ( bz * log ( min_xy )) sig_z = sig_z_00 + az * exp ( bz * log ( x + min_xy )) !if (x.lt.10.) write(*,*) x+min_xy,sig_z_00,sig_z !if (x.lt.10.) write(*,*) !if (zz_pbl.le.0.or.sig_z.le.0.or.sig_y.le.0) then !    write(*,'(7f)') az,bz,ay,by,sig_z,sig_y,x !    stop !endif end subroutine uEMEP_set_dispersion_sigma_Kz_emulator","tags":"","loc":"proc/uemep_set_dispersion_sigma_kz_emulator.html"},{"title":"testlambert – uEMEP","text":"private  subroutine testlambert() Arguments None Source Code subroutine testlambert () real :: gl , gb , x , y , lon0 , lat0 , y0 , k , F , earth_radius , lat_stand1 , GRIDWIDTH_M real :: deg2rad GRIDWIDTH_M = 250 0.0 lon0 = 1 5.0 lat0 = 6 3.0 deg2rad = PI / 18 0.0 earth_radius = 637100 0.0 lat_stand1 = lat0 k = sin ( PI / 18 0.0 * lat0 ) F = earth_radius * cos ( PI / 18 0.0 * lat_stand1 ) * tan ( PI / 4 + PI / 36 0.0 * lat_stand1 ) ** k / k y0 = F * tan ( PI / 4 - PI / 36 0.0 * lat0 ) ** k gl = 1 5.0 gb = 6 3.0 call lb2lambert ( x , y , gl , gb , lon0 , y0 , k , F ) write ( * , * ) 'lon = ' , gl , 'lat =' , gb write ( * , * ) 'give lambert x = ' , x , 'y =' , y write ( * , * ) 'lambert i = ' , ( x ) / GRIDWIDTH_M , 'j =' , y / GRIDWIDTH_M write ( * , * ) x = - 89244 2.2 y = 122067 8.0 call lambert2lb ( x , y , gl , gb , lon0 , y0 , k , F ) write ( * , * ) 'Lambert x = ' , x , 'y =' , y write ( * , * ) 'gives lon = ' , gl , 'lat =' , gb call lb2lambert ( x , y , gl , gb , lon0 , y0 , k , F ) write ( * , * ) 'and back to Lambert x = ' , x , 'y =' , y end subroutine testlambert","tags":"","loc":"proc/testlambert.html"},{"title":"lambert2lb – uEMEP","text":"private  subroutine lambert2lb(x, y, gl, gb, lon0, y0, k, F) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: gl real, intent(out) :: gb real, intent(in) :: lon0 real, intent(in) :: y0 real, intent(in) :: k real, intent(in) :: F Source Code subroutine lambert2lb ( x , y , gl , gb , lon0 , y0 , k , F ) real , intent ( in ) :: x , y , lon0 , y0 , k , F real , intent ( out ) :: gl , gb real :: r , t r = sqrt ( x * x + ( y0 - y ) * ( y0 - y )) t = atan ( x / ( y0 - y )) gb = 2.0 * 18 0.0 / PI * atan (( F / r ) ** ( 1.0 / k )) - 9 0.0 gl = lon0 + 18 0.0 / PI * t / k end subroutine lambert2lb","tags":"","loc":"proc/lambert2lb.html"},{"title":"lb2lambert – uEMEP","text":"private  subroutine lb2lambert(x, y, gl, gb, lon0, y0, k, F) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: gl real, intent(in) :: gb real, intent(in) :: lon0 real, intent(in) :: y0 real, intent(in) :: k real, intent(in) :: F Source Code subroutine lb2lambert ( x , y , gl , gb , lon0 , y0 , k , F ) real , intent ( in ) :: gl , gb , lon0 , y0 , k , F real , intent ( out ) :: x , y real :: r , dr2 , dr dr = PI / 18 0.0 dr2 = PI / 36 0.0 r = F * tan ( PI / 4 - dr2 * gb ) ** k x = r * sin ( dr * k * ( gl - lon0 )) y = y0 - r * cos ( dr * k * ( gl - lon0 )) end subroutine lb2lambert","tags":"","loc":"proc/lb2lambert.html"},{"title":"lambert2lb_uEMEP – uEMEP","text":"private  subroutine lambert2lb_uEMEP(x, y, gl, gb, lon0, lat0) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: gl real, intent(out) :: gb real, intent(in) :: lon0 real, intent(in) :: lat0 Source Code subroutine lambert2lb_uEMEP ( x , y , gl , gb , lon0 , lat0 ) real , intent ( in ) :: x , y , lon0 , lat0 real , intent ( out ) :: gl , gb real :: r , t real :: earth_radius , k , F , y0 earth_radius = 637100 0.0 k = sin ( PI / 18 0.0 * lat0 ) F = earth_radius * cos ( PI / 18 0.0 * lat0 ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat0 ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = sqrt ( x * x + ( y0 - y ) * ( y0 - y )) t = atan ( x / ( y0 - y )) gb = 2.0 * 18 0.0 / PI * atan (( F / r ) ** ( 1.0 / k )) - 9 0.0 gl = lon0 + 18 0.0 / PI * t / k end subroutine lambert2lb_uEMEP","tags":"","loc":"proc/lambert2lb_uemep.html"},{"title":"lambert2lb2_uEMEP – uEMEP","text":"public  subroutine lambert2lb2_uEMEP(x, y, gl, gb, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: gl real, intent(out) :: gb double precision, intent(in) :: projection_attr (10) Source Code subroutine lambert2lb2_uEMEP ( x , y , gl , gb , projection_attr ) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: x , y real , intent ( out ) :: gl , gb real :: r , t real :: earth_radius , k , F , y0 real :: deg2rad , rad2deg , k_lambert , lat0_lambert real :: lat0 real :: lat_stand1_lambert , lat_stand2_lambert , lon0 , lat0_in lat_stand1_lambert = projection_attr ( 1 ) lat_stand2_lambert = projection_attr ( 2 ) lon0 = projection_attr ( 3 ) lat0_in = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI if ( lat_stand1_lambert . eq . lat_stand2_lambert ) then k_lambert = sin ( PI / 18 0.0 * lat0_in ) else k_lambert = log ( cos ( deg2rad * lat_stand1_lambert ) / cos ( deg2rad * lat_stand2_lambert )) / & ( log ( tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand2_lambert ) / tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand1_lambert ))) end if lat0_lambert = rad2deg * asin ( k_lambert ) lat0 = lat0_in k = k_lambert F = earth_radius * cos ( PI / 18 0.0 * lat_stand1_lambert ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat_stand1_lambert ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = sqrt ( x * x + ( y0 - y ) * ( y0 - y )) t = atan ( x / ( y0 - y )) gb = 2 * 18 0.0 / PI * atan (( F / r ) ** ( 1.0 / k )) - 9 0.0 gl = lon0 + 18 0.0 / PI * t / k end subroutine lambert2lb2_uEMEP","tags":"","loc":"proc/lambert2lb2_uemep.html"},{"title":"lb2lambert_uEMEP – uEMEP","text":"public  subroutine lb2lambert_uEMEP(x, y, gl, gb, lon0, lat0) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: gl real, intent(in) :: gb real, intent(in) :: lon0 real, intent(in) :: lat0 Source Code subroutine lb2lambert_uEMEP ( x , y , gl , gb , lon0 , lat0 ) real , intent ( in ) :: gl , gb , lon0 , lat0 real , intent ( out ) :: x , y real :: r real :: earth_radius , k , F , y0 real :: rad2deg earth_radius = 637100 0.0 rad2deg = PI / 18 0.0 k = sin ( PI / 18 0.0 * lat0 ) F = earth_radius * cos ( PI / 18 0.0 * lat0 ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat0 ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = F * tan ( PI / 4.0 - PI / 36 0.0 * gb ) ** k x = r * sin ( PI / 18 0.0 * k * ( gl - lon0 )) y = y0 - r * cos ( PI / 18 0.0 * k * ( gl - lon0 )) end subroutine lb2lambert_uEMEP","tags":"","loc":"proc/lb2lambert_uemep.html"},{"title":"lb2lambert2_uEMEP – uEMEP","text":"public  subroutine lb2lambert2_uEMEP(x, y, gl, gb, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: gl real, intent(in) :: gb double precision, intent(in) :: projection_attr (10) Source Code subroutine lb2lambert2_uEMEP ( x , y , gl , gb , projection_attr ) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: gl , gb real , intent ( out ) :: x , y real :: r real :: earth_radius , k , F , y0 real :: deg2rad , rad2deg , k_lambert , lat0_lambert real :: lat0 real :: lat_stand1_lambert , lat_stand2_lambert , lon0 , lat0_in lat_stand1_lambert = projection_attr ( 1 ) lat_stand2_lambert = projection_attr ( 2 ) lon0 = projection_attr ( 3 ) lat0_in = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI if ( lat_stand1_lambert . eq . lat_stand2_lambert ) then k_lambert = sin ( PI / 18 0.0 * lat0_in ) else k_lambert = log ( cos ( deg2rad * lat_stand1_lambert ) / cos ( deg2rad * lat_stand2_lambert )) / & ( log ( tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand2_lambert ) / tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand1_lambert ))) end if lat0_lambert = rad2deg * asin ( k_lambert ) lat0 = lat0_in k = k_lambert F = earth_radius * cos ( PI / 18 0.0 * lat_stand1_lambert ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat_stand1_lambert ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = F * tan ( PI / 4.0 - PI / 36 0.0 * gb ) ** k x = r * sin ( PI / 18 0.0 * k * ( gl - lon0 )) y = y0 - r * cos ( PI / 18 0.0 * k * ( gl - lon0 )) end subroutine lb2lambert2_uEMEP","tags":"","loc":"proc/lb2lambert2_uemep.html"},{"title":"LL2LAEA_spherical – uEMEP","text":"private  subroutine LL2LAEA_spherical(x, y, lon_in, lat_in, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: lon_in real, intent(in) :: lat_in double precision, intent(in) :: projection_attr (10) Source Code subroutine LL2LAEA_spherical ( x , y , lon_in , lat_in , projection_attr ) ! https://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: x , y ! Local variables real :: r real :: earth_radius real :: deg2rad , rad2deg , k_lambert real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: lon , lat lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad lon = lon_in * deg2rad lat = lat_in * deg2rad k_lambert = sqrt ( 2.0 / ( 1.0 + sin ( lat0 ) * sin ( lat ) + cos ( lat0 ) * cos ( lat ) * cos ( lon - lon0 ))) x = false_easting + r * k_lambert * cos ( lat ) * sin ( lon - lon0 ) y = false_northing + r * k_lambert * ( cos ( lat0 ) * sin ( lat ) - sin ( lat0 ) * cos ( lat ) * cos ( lon - lon0 )) end subroutine LL2LAEA_spherical","tags":"","loc":"proc/ll2laea_spherical.html"},{"title":"LAEA2LL_spherical – uEMEP","text":"private  subroutine LAEA2LL_spherical(x, y, lon, lat, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: lon real, intent(out) :: lat double precision, intent(in) :: projection_attr (10) Source Code subroutine LAEA2LL_spherical ( x , y , lon , lat , projection_attr ) ! https://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( out ) :: lon , lat real , intent ( in ) :: x , y ! Local variables real :: r , rho , c real :: earth_radius real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad rho = sqrt (( x - false_easting ) * ( x - false_easting ) + ( y - false_northing ) * ( y - false_northing )) c = 2.0 * asin ( rho * 0.5 / r ) lat = asin ( cos ( c ) * sin ( lat0 ) + ( y - false_northing ) / rho * sin ( c ) * cos ( lat0 )) lon = lon0 + atan (( x - false_easting ) * sin ( c ) / ( rho * cos ( lat0 ) * cos ( c ) - ( y - false_northing ) * sin ( lat0 ) * sin ( c ))) lat = lat * rad2deg lon = lon * rad2deg end subroutine LAEA2LL_spherical","tags":"","loc":"proc/laea2ll_spherical.html"},{"title":"LL2LAEA – uEMEP","text":"public  subroutine LL2LAEA(x, y, lon_in, lat_in, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: lon_in real, intent(in) :: lat_in double precision, intent(in) :: projection_attr (10) Source Code subroutine LL2LAEA ( x , y , lon_in , lat_in , projection_attr ) ! https://epsg.io/3035 ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: x , y ! Local variables real :: semi_major_axis real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: lon , lat real :: inv_f , f , a , e , q_p , q_0 , q , beta , beta_0 , R_q , D , B lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) semi_major_axis = projection_attr ( 5 ) inv_f = projection_attr ( 6 ) !flattening deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI a = semi_major_axis f = 1.0 / inv_f e = sqrt ( 2.0 * f - f * f ) lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad lon = lon_in * deg2rad lat = lat_in * deg2rad q_p = ( 1.0 - e * e ) * ( 1.0 / ( 1.0 - e * e ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e ) / ( 1.0 + e ))) q_0 = ( 1.0 - e * e ) * ( sin ( lat0 ) / ( 1.0 - e * e * sin ( lat0 ) ** 2 ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e * sin ( lat0 )) / ( 1.0 + e * sin ( lat0 )))) q = ( 1.0 - e * e ) * ( sin ( lat ) / ( 1.0 - e * e * sin ( lat ) ** 2 ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e * sin ( lat )) / ( 1.0 + e * sin ( lat )))) beta_0 = asin ( q_0 / q_p ) beta = asin ( q / q_p ) R_q = a * sqrt ( q_p / 2.0 ) D = a * ( cos ( lat0 ) / sqrt ( 1.0 - e * e * sin ( lat0 ) ** 2 ) / ( R_q * cos ( beta_0 ))) B = R_q * sqrt ( 2.0 / ( 1.0 + sin ( beta_0 ) * sin ( beta ) + cos ( beta_0 ) * cos ( beta ) * cos ( lon - lon0 ))) x = false_easting + B * D * cos ( beta ) * sin ( lon - lon0 ) y = false_northing + B / D * ( cos ( beta_0 ) * sin ( beta ) - sin ( beta_0 ) * cos ( beta ) * cos ( lon - lon0 )) end subroutine LL2LAEA","tags":"","loc":"proc/ll2laea.html"},{"title":"LAEA2LL – uEMEP","text":"private  subroutine LAEA2LL(x, y, lon, lat, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: lon real, intent(out) :: lat double precision, intent(in) :: projection_attr (10) Source Code subroutine LAEA2LL ( x , y , lon , lat , projection_attr ) ! www.epsg.org ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( out ) :: lon , lat real , intent ( in ) :: x , y real :: rho real :: semi_major_axis real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: inv_f , f , a , e , q_p , q_0 , beta_0 , R_q , D real :: C , beta_d lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) semi_major_axis = projection_attr ( 5 ) inv_f = projection_attr ( 6 ) ! flattening deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI a = semi_major_axis f = 1.0 / inv_f e = sqrt ( 2.0 * f - f * f ) lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad q_p = ( 1.0 - e * e ) * ( 1.0 / ( 1.0 - e * e ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e ) / ( 1.0 + e ))) q_0 = ( 1.0 - e * e ) * ( sin ( lat0 ) / ( 1.0 - e * e * sin ( lat0 ) ** 2 ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e * sin ( lat0 )) / ( 1.0 + e * sin ( lat0 )))) beta_0 = asin ( q_0 / q_p ) R_q = a * sqrt ( q_p / 2.0 ) D = a * ( cos ( lat0 ) / sqrt ( 1.0 - e * e * sin ( lat0 ) ** 2 ) / ( R_q * cos ( beta_0 ))) rho = sqrt (( x - false_easting ) * ( x - false_easting ) / D / D + D * D * ( y - false_northing ) * ( y - false_northing )) C = 2.0 * asin ( rho / 2.0 / R_q ) beta_d = asin ( cos ( C ) * sin ( beta_0 ) + D * ( y - false_northing ) * sin ( C ) * cos ( beta_0 ) / rho ) lon = lon0 + atan2 (( x - false_easting ) * sin ( C ), & ( D * rho * cos ( beta_0 ) * cos ( C ) - D * D * ( y - false_northing ) * sin ( beta_0 ) * sin ( C ))) lat = beta_d + e ** 2 * ( 1.0 / 3.0 + 3 1.0 / 18 0.0 * e ** 2.0 + 51 7.0 / 504 0.0 * e ** 4 ) * sin ( 2.0 * beta_d ) & + e ** 4.0 * ( 2 3.0 / 36 0.0 + 25 1.0 / 378 0.0 * e ** 2 ) * sin ( 4.0 * beta_d ) + ( 76 1.0 / 4536 0.0 * e ** 6 ) * sin ( 6.0 * beta_d ) lat = lat * rad2deg lon = lon * rad2deg end subroutine LAEA2LL","tags":"","loc":"proc/laea2ll.html"},{"title":"PROJ2LL – uEMEP","text":"public  subroutine PROJ2LL(x_in, y_in, lon_out, lat_out, projection_attributes_in, projection_type_in) Arguments Type Intent Optional Attributes Name real, intent(in) :: x_in real, intent(in) :: y_in real, intent(out) :: lon_out real, intent(out) :: lat_out double precision, intent(in) :: projection_attributes_in (10) integer, intent(in) :: projection_type_in Source Code subroutine PROJ2LL ( x_in , y_in , lon_out , lat_out , projection_attributes_in , projection_type_in ) ! Definitions only needed for the identification indexes double precision , intent ( in ) :: projection_attributes_in ( 10 ) real , intent ( in ) :: x_in , y_in integer , intent ( in ) :: projection_type_in real , intent ( out ) :: lon_out , lat_out integer :: utm_zone_in real :: ltm_lon0_in if ( projection_type_in . eq . RDM_projection_index ) then call RDM2LL ( y_in , x_in , lat_out , lon_out ) else if ( projection_type_in . eq . UTM_projection_index ) then utm_zone_in = floor ( projection_attributes_in ( 1 ) + 0.5 ) call utm2ll ( 1 , utm_zone_in , y_in , x_in , lat_out , lon_out ) else if ( projection_type_in . eq . LTM_projection_index ) then utm_zone_in = floor ( projection_attributes_in ( 1 ) + 0.5 ) ltm_lon0_in = projection_attributes_in ( 2 ) call ltm2ll ( 1 , utm_zone_in , ltm_lon0_in , y_in , x_in , lat_out , lon_out ) else if ( projection_type_in . eq . LAEA_projection_index ) then call LAEA2LL ( x_in , y_in , lon_out , lat_out , projection_attributes_in ) else if ( projection_type_in . eq . LCC_projection_index ) then call lambert2lb2_uEMEP ( x_in , y_in , lon_out , lat_out , projection_attributes_in ) else if ( projection_type_in . eq . PS_projection_index ) then call PS2LL_spherical ( x_in , y_in , lon_out , lat_out , projection_attributes_in ) else if ( projection_type_in . eq . LL_projection_index ) then lon_out = x_in lat_out = y_in else write ( unit_logfile , '(A,I0)' ) 'ERROR: This projection type index is not implemented:' , projection_type_in stop end if end subroutine PROJ2LL","tags":"","loc":"proc/proj2ll.html"},{"title":"LL2PROJ – uEMEP","text":"public  subroutine LL2PROJ(lon_in, lat_in, x_out, y_out, projection_attributes_out, projection_type_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: lon_in real, intent(in) :: lat_in real, intent(out) :: x_out real, intent(out) :: y_out double precision, intent(in) :: projection_attributes_out (10) integer, intent(in) :: projection_type_out Source Code subroutine LL2PROJ ( lon_in , lat_in , x_out , y_out , projection_attributes_out , projection_type_out ) ! Definitions only needed for the identification indexes double precision , intent ( in ) :: projection_attributes_out ( 10 ) real , intent ( out ) :: x_out , y_out integer , intent ( in ) :: projection_type_out real , intent ( in ) :: lon_in , lat_in integer :: utm_zone_out real :: ltm_lon0_out if ( projection_type_out . eq . RDM_projection_index ) then write ( unit_logfile , '(A)' ) ' ERROR: Conversion from lon-lat to RDM projection is not implemented\"' stop else if ( projection_type_out . eq . UTM_projection_index ) then utm_zone_out = floor ( projection_attributes_out ( 1 ) + 0.5 ) call ll2utm ( 1 , utm_zone_out , lat_in , lon_in , y_out , x_out ) else if ( projection_type_out . eq . LTM_projection_index ) then utm_zone_out = floor ( projection_attributes_out ( 1 ) + 0.5 ) ltm_lon0_out = projection_attributes_out ( 2 ) call ll2ltm ( 1 , ltm_lon0_out , lat_in , lon_in , y_out , x_out ) !????????? else if ( projection_type_out . eq . LAEA_projection_index ) then call LL2LAEA ( x_out , y_out , lon_in , lat_in , projection_attributes_out ) else if ( projection_type_out . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_out , y_out , lon_in , lat_in , projection_attributes_out ) else if ( projection_type_out . eq . PS_projection_index ) then call LL2PS_spherical ( x_out , y_out , lon_in , lat_in , projection_attributes_out ) else if ( projection_type_out . eq . LL_projection_index ) then x_out = lon_in y_out = lat_in else write ( unit_logfile , '(A,I0)' ) 'ERROR: This projection type index is not implemented:' , projection_type_out stop end if end subroutine LL2PROJ","tags":"","loc":"proc/ll2proj.html"},{"title":"LL2PS_spherical – uEMEP","text":"public  subroutine LL2PS_spherical(x, y, lon_in, lat_in, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: lon_in real, intent(in) :: lat_in double precision, intent(in) :: projection_attr (10) Source Code subroutine LL2PS_spherical ( x , y , lon_in , lat_in , projection_attr ) ! https://mathworld.wolfram.com/StereographicProjection.html ! grid_mapping_name = Polar_Stereographic ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: x , y real :: r real :: earth_radius real deg2rad , rad2deg , k_ps real lat0 , lat0_in , lon0 , lon0_in real false_easting , false_northing real scaling real lon , lat lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) scaling = projection_attr ( 6 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad lon = lon_in * deg2rad lat = lat_in * deg2rad k_ps = 2.0 * r * scaling / ( 1.0 + sin ( lat0 ) * sin ( lat ) + cos ( lat0 ) * cos ( lat ) * cos ( lon - lon0 )) x = false_easting + k_ps * cos ( lat ) * sin ( lon - lon0 ) y = false_northing + k_ps * ( cos ( lat0 ) * sin ( lat ) - sin ( lat0 ) * cos ( lat ) * cos ( lon - lon0 )) end subroutine LL2PS_spherical","tags":"","loc":"proc/ll2ps_spherical.html"},{"title":"PS2LL_spherical – uEMEP","text":"private  subroutine PS2LL_spherical(x, y, lon, lat, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: lon real, intent(out) :: lat double precision, intent(in) :: projection_attr (10) Source Code subroutine PS2LL_spherical ( x , y , lon , lat , projection_attr ) ! https://mathworld.wolfram.com/StereographicProjection.html ! grid_mapping_name = Polar_Stereographic ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0) ! NOTE scale_factor_at_projection_origin =0.5(1+sin(Standard Parallel)) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( out ) :: lon , lat real , intent ( in ) :: x , y real :: r , rho , c real :: earth_radius real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: scaling lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) scaling = projection_attr ( 6 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad rho = sqrt (( x - false_easting ) * ( x - false_easting ) + ( y - false_northing ) * ( y - false_northing )) c = 2.0 * atan ( rho * 0.5 / r / scaling ) lat = asin ( cos ( c ) * sin ( lat0 ) + ( y - false_northing ) / rho * sin ( c ) * cos ( lat0 )) lon = lon0 + atan (( x - false_easting ) * sin ( c ) / ( rho * cos ( lat0 ) * cos ( c ) - ( y - false_northing ) * sin ( lat0 ) * sin ( c ))) lat = lat * rad2deg lon = lon * rad2deg end subroutine PS2LL_spherical","tags":"","loc":"proc/ps2ll_spherical.html"},{"title":"uemep_logger – uEMEP","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: DEBUG = 1 integer, public, parameter :: INFO = 2 integer, public, parameter :: WARNING = 3 integer, public, parameter :: ERROR = 4 integer, private, save :: log_level = INFO character(len=256), private, save :: log_name logical, private, save :: file_opened = .false. integer, private :: log_unit character(len=1028), public :: log_msg integer, private :: unit Subroutines public  subroutine open_log_file (logfile_name, io_err) Opens a new log file for writing Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: logfile_name integer, intent(inout), optional :: io_err public  subroutine close_log_file (io_err) Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: io_err Closes the log file public  subroutine set_log_level (level) Sets the log level Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: level public  subroutine log_header (message, level, upper_space, lower_space) Send a log header message to the log file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to log integer, intent(in) :: level Log level logical, intent(in), optional :: upper_space logical, intent(in), optional :: lower_space public  subroutine log_message (message, level) Send a log message to the log file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to log integer, intent(in) :: level Log level private  subroutine write_log (message) Writes the message to the log file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Message to log","tags":"","loc":"module/uemep_logger.html"},{"title":"subgrid_dispersion – uEMEP","text":"Uses uemep_configuration dispersion_functions local_trajectory kz_functions set_dispersion_parameters mod_area_interpolation Subroutines public  subroutine uEMEP_subgrid_dispersion (source_index) Arguments Type Intent Optional Attributes Name integer :: source_index private  subroutine uEMEP_subgrid_dispersion_integral (source_index) Arguments Type Intent Optional Attributes Name integer :: source_index","tags":"","loc":"module/subgrid_dispersion.html"},{"title":"read_command_line – uEMEP","text":"Routines for interacting with the command line Uses uemep_configuration uemep_logger uEMEP_definitions Subroutines public  subroutine check_command_line () Checks that a suitable number of command line arguments has been supplied\nand handles some special cases of command line inputs Read more… Arguments None public  subroutine uEMEP_read_command_line () Assigns the configuration file name(s) and substitution date_str from the command line Arguments None private  subroutine print_help_page () Prints a help message to the terminal console Arguments None private  subroutine print_version () Prints the program version to the terminal console Arguments None","tags":"","loc":"module/read_command_line.html"},{"title":"read_roadlink_data_ascii – uEMEP","text":"Uses time_functions uemep_configuration utility_functions mod_lambert_projection Subroutines public  subroutine uEMEP_read_roadlink_data_ascii () Arguments None public  subroutine uEMEP_read_roadlink_emission_data () Arguments None public  subroutine uEMEP_change_road_data () Arguments None public  subroutine read_country_bounding_box_data () Arguments None","tags":"","loc":"module/read_roadlink_data_ascii.html"},{"title":"aggregate_proxy_emission_in_emep_grid – uEMEP","text":"Uses uemep_configuration uEMEP_definitions mod_read_esri_ascii_file Subroutines private  subroutine uEMEP_aggregate_proxy_emission_in_EMEP_grid () Arguments None","tags":"","loc":"module/aggregate_proxy_emission_in_emep_grid.html"},{"title":"save_emission_netcdf – uEMEP","text":"Uses save_netcdf_file read_roadlink_data_ascii uemep_configuration read_time_profiles set_emission_factors grid_roads time_functions read_shipping_asi_data read_agriculture_asi_data read_rwc_heating_data mod_lambert_projection uEMEP_definitions read_industry_data read_meteo_nc Subroutines public  subroutine uEMEP_calculate_emissions_for_EMEP () Arguments None private  subroutine uEMEP_save_emission_netcdf () Arguments None private  subroutine uEMEP_save_for_EMEP_netcdf_file (filename_netcdf, nx, ny, nt, val_array, x_array, y_array, lon_array, lat_array, name_array, unit_array, title_str, create_file, valid_min, variable_type, scale_factor) Arguments Type Intent Optional Attributes Name character(len=256) :: filename_netcdf integer :: nx integer :: ny integer :: nt real :: val_array (nx,ny,nt) real :: x_array (nx,ny) real :: y_array (nx,ny) real :: lon_array (nx,ny) real :: lat_array (nx,ny) character(len=256) :: name_array character(len=256) :: unit_array character(len=256) :: title_str logical :: create_file real :: valid_min character(len=256) :: variable_type real :: scale_factor","tags":"","loc":"module/save_emission_netcdf.html"},{"title":"save_netcdf_file – uEMEP","text":"Uses chemistry_no2 uemep_configuration mod_area_interpolation mod_read_esri_ascii_file Functions private  function DIRECTION (UD, VD) Arguments Type Intent Optional Attributes Name real :: UD real :: VD Return Value real private  function mean_nodata (array, n1, n2, n3, nodata_num) Arguments Type Intent Optional Attributes Name real :: array (n1,n2,n3) integer :: n1 integer :: n2 integer :: n3 real :: nodata_num Return Value real public  function mean_mask (array, mask, n1, n2, n3) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (n1,n2,n3) logical, intent(in) :: mask (n1,n2) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 Return Value real Subroutines public  subroutine uEMEP_save_netcdf_control () .or. use_region_select_and_mask_flag ??\n!!!!! what to write here??? Arguments None private  subroutine uEMEP_save_netcdf_file (unit_logfile_in, filename_netcdf, nx, ny, nt_in, val_array_in, x_array, y_array, lon_array, lat_array, name_array, unit_array, title_str, create_file, valid_min, variable_type, scale_factor) Arguments Type Intent Optional Attributes Name integer :: unit_logfile_in character(len=256) :: filename_netcdf integer :: nx integer :: ny integer :: nt_in real :: val_array_in (nx,ny,nt_in) real :: x_array (nx,ny) real :: y_array (nx,ny) real :: lon_array (nx,ny) real :: lat_array (nx,ny) character(len=256) :: name_array character(len=256) :: unit_array character(len=256) :: title_str logical :: create_file real :: valid_min character(len=256) :: variable_type real :: scale_factor public  subroutine check (status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status private  subroutine uEMEP_save_netcdf_receptor_file (unit_logfile_in, filename_netcdf, nx, ny, nt_in, val_array_in, x_array, y_array, lon_array, lat_array, name_array, unit_array, title_str, create_file, valid_min, x_rec, y_rec, lon_rec, lat_rec, height_rec, name_rec_in, nr, variable_type, scale_factor) call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index), start=(/n_dims_start(2)/), count=(/n_dims_length(2)/)) )\ncall check( nf90_put_var(ncid, station_varid, name_rec(:), start = (/1,1/), count=(/n_dims(1),n_char/)) ) Read more… Arguments Type Intent Optional Attributes Name integer :: unit_logfile_in character(len=256) :: filename_netcdf integer :: nx integer :: ny integer :: nt_in real :: val_array_in (nx,ny,nt_in) real :: x_array (nx,ny) real :: y_array (nx,ny) real :: lon_array (nx,ny) real :: lat_array (nx,ny) character(len=256) :: name_array character(len=256) :: unit_array character(len=256) :: title_str logical :: create_file real :: valid_min real :: x_rec (nr) real :: y_rec (nr) real :: lon_rec (nr) real :: lat_rec (nr) real :: height_rec (nr) character(len=256) :: name_rec_in (nr) integer :: nr character(len=256) :: variable_type real :: scale_factor","tags":"","loc":"module/save_netcdf_file.html"},{"title":"read_config – uEMEP","text":"Uses time_functions read_namefile_routines uemep_configuration uEMEP_definitions Functions public  function replace_string_char (replace_str, match_str, read_str) Arguments Type Intent Optional Attributes Name character(len=*) :: replace_str character(len=*) :: match_str character(len=*) :: read_str Return Value character(len=256) Subroutines public  subroutine uEMEP_read_config () Arguments None","tags":"","loc":"module/read_config.html"},{"title":"set_subgrids – uEMEP","text":"Uses uemep_configuration utility_functions mod_lambert_projection uEMEP_definitions Subroutines public  subroutine uEMEP_set_subgrids () Arguments None public  subroutine uEMEP_set_subgrid_select_latlon_centre () Arguments None","tags":"","loc":"module/set_subgrids.html"},{"title":"read_industry_data – uEMEP","text":"Uses uemep_configuration utility_functions mod_lambert_projection Subroutines public  subroutine uEMEP_read_industry_data () Arguments None","tags":"","loc":"module/read_industry_data.html"},{"title":"read_meteo_nc – uEMEP","text":"Uses uemep_configuration netcdf time_functions read_config mod_lambert_projection uEMEP_definitions Subroutines public  subroutine uEMEP_read_meteo_nc () Arguments None","tags":"","loc":"module/read_meteo_nc.html"},{"title":"subgrid_emep – uEMEP","text":"Uses uemep_configuration uemep_constants mod_lambert_projection uEMEP_definitions Subroutines public  subroutine uEMEP_subgrid_EMEP () Arguments None public  subroutine uEMEP_subgrid_EMEP_from_in_region () Arguments None","tags":"","loc":"module/subgrid_emep.html"},{"title":"read_shipping_asi_data – uEMEP","text":"Uses uemep_configuration time_functions mod_lambert_projection utility_functions mod_area_interpolation Subroutines public  subroutine uEMEP_read_weekly_shipping_asi_data () Arguments None public  subroutine uEMEP_read_monthly_and_daily_shipping_asi_data () Arguments None public  subroutine uEMEP_read_shipping_asi_data () Arguments None public  subroutine uEMEP_read_netcdf_shipping_latlon () Arguments None private  subroutine match_string_multi_val (match_str, unit_in, unit_output, val, n_val) Arguments Type Intent Optional Attributes Name character(len=*) :: match_str integer :: unit_in integer :: unit_output real :: val (n_val) integer :: n_val public  subroutine uEMEP_preaggregate_shipping_asi_data () Arguments None","tags":"","loc":"module/read_shipping_asi_data.html"},{"title":"read_emep – uEMEP","text":"Uses time_functions uemep_configuration mod_lambert_projection kz_functions Subroutines public  subroutine uEMEP_read_EMEP () Arguments None","tags":"","loc":"module/read_emep.html"},{"title":"read_rwc_heating_data – uEMEP","text":"Uses uemep_configuration utility_functions mod_lambert_projection Subroutines public  subroutine uEMEP_read_RWC_heating_data () Arguments None","tags":"","loc":"module/read_rwc_heating_data.html"},{"title":"uEMEP_indices – uEMEP","text":"","tags":"","loc":"module/uemep_indices.html"},{"title":"redistribute_data – uEMEP","text":"Uses save_netcdf_file uemep_configuration Subroutines public  subroutine uEMEP_redistribute_local_source (source_index) Arguments Type Intent Optional Attributes Name integer :: source_index public  subroutine uEMEP_disperse_local_source (source_index) Arguments Type Intent Optional Attributes Name integer :: source_index public  subroutine uEMEP_combine_local_source () Arguments None","tags":"","loc":"module/redistribute_data.html"},{"title":"subgrid_meteo_emep – uEMEP","text":"Uses uemep_configuration uemep_constants uEMEP_definitions Subroutines public  subroutine uEMEP_subgrid_meteo_EMEP () Arguments None","tags":"","loc":"module/subgrid_meteo_emep.html"},{"title":"auto_subgrid – uEMEP","text":"Uses uemep_configuration netcdf mod_lambert_projection mod_area_interpolation uEMEP_definitions Subroutines public  subroutine uEMEP_auto_subgrid () uEMEP model uEMEP_auto_subgrid\nAutomatically creates a grid dependent on the distance to source Arguments None public  subroutine uEMEP_interpolate_auto_subgrid () Arguments None public  subroutine uEMEP_region_mask () Arguments None public  subroutine uEMEP_region_mask_new () Arguments None","tags":"","loc":"module/auto_subgrid.html"},{"title":"local_trajectory – uEMEP","text":"Uses uemep_constants utility_functions Subroutines private  subroutine uEMEP_local_trajectory (x_r, y_r, x_emis, y_emis, t, traj_max_index, dr_traj, x_loc, y_loc, valid_traj) Arguments Type Intent Optional Attributes Name real :: x_r real :: y_r real :: x_emis real :: y_emis integer :: t integer :: traj_max_index real :: dr_traj real :: x_loc real :: y_loc logical :: valid_traj public  subroutine uEMEP_calculate_all_trajectory (x_emis, y_emis, t, traj_max_index, dr_traj, x_traj, y_traj) Arguments Type Intent Optional Attributes Name real :: x_emis real :: y_emis integer :: t integer :: traj_max_index real :: dr_traj real :: x_traj (traj_max_index) real :: y_traj (traj_max_index) public  subroutine uEMEP_minimum_distance_trajectory_fast (x_r, y_r, traj_max_index_in, dr_traj, x_traj, y_traj, x_loc, y_loc, valid_traj) Arguments Type Intent Optional Attributes Name real, intent(in) :: x_r real, intent(in) :: y_r integer, intent(in) :: traj_max_index_in real, intent(in) :: dr_traj real, intent(in) :: x_traj (*) real, intent(in) :: y_traj (*) real, intent(out) :: x_loc real, intent(out) :: y_loc logical, intent(out) :: valid_traj","tags":"","loc":"module/local_trajectory.html"},{"title":"time_functions – uEMEP","text":"Various procedures for manipulating time Uses uemep_constants Functions public  function date_to_number (date_array, ref_year) result(res) Returns a date number from an array with date and time Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] integer, intent(in) :: ref_year Reference year Return Value real(kind=dp) Date number in seconds since ref_year public  function date_to_julian (date_array, ref_year) result(res) Returns Julian day from an array with date and time Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] integer, intent(in) :: ref_year Reference year Return Value integer Julian day public  function day_of_week (date_array) result(res) The subroutine calculates the day of week given current datetime,\nwhere DAYW = 1 corresponds to Monday and DAYW = 7 to Sunday. The\nalgorithm is based on the tables in \"Hvem Hva Hvor 1971\" (p. 121)\nand is valid for all years from 1800 to infinity Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] Return Value integer Day of week [1-7] public  function summer_time_europe (date_array) result(summer_time) Returns true if supplied date is during summer time in Europe, else false Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] Return Value logical True if summer time, else false Subroutines public  subroutine number_to_date (date_num, date_array, ref_year) Returns array with date and time from a date number Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: date_num Date number in seconds since ref_year integer, intent(out) :: date_array (6) Datetime [y,m,d,h,m,s] integer, intent(in) :: ref_year Reference year public  subroutine datestr_to_date (date_str, format_str, date_array) Converts date string to a date array based on the format string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: date_str Date string [yyyymmddHHMMSS] character(len=*), intent(in) :: format_str Format string integer, intent(out) :: date_array (6) Datetime [y,m,d,h,m,s] public  subroutine date_to_datestr (date_array, format_str, date_str) Returns a date string based on (yyyy.mm.dd HH:MM:SS) from a date array Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] character(len=*), intent(in) :: format_str Format string character(len=*), intent(out) :: date_str Date string private  subroutine date_to_datestr_new (date_array, in_format_str, out_a_str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] character(len=*), intent(in) :: in_format_str Format string character(len=*), intent(out) :: out_a_str Date string public  subroutine date_to_datestr_bracket (date_array, in_format_str, out_a_str) Converts a date array to a date string with brackets in format string Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) Datetime [y,m,d,h,m,s] character(len=*), intent(in) :: in_format_str Format string character(len=*), intent(out) :: out_a_str Date string public  subroutine date_to_datestr_squarebracket (date_array, in_format_str, out_a_str) Converts a date array to a date string with brackets in format string Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: date_array (6) character(len=*), intent(in) :: in_format_str character(len=*), intent(out) :: out_a_str public  subroutine get_sun_angles (lat, lon, date_a, date_num, difutc_h, azimuth_ang, zenith_ang) Returns the azimuth and zenith angles Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: lat real, intent(in) :: lon integer, intent(in) :: date_a (6) real(kind=dp), intent(in) :: date_num real, intent(in) :: difutc_h real, intent(out) :: azimuth_ang real, intent(out) :: zenith_ang","tags":"","loc":"module/time_functions.html"},{"title":"set_emission_factors – uEMEP","text":"Uses uemep_configuration Subroutines public  subroutine uEMEP_set_emission_factors () Arguments None public  subroutine uEMEP_convert_proxy_to_emissions () Arguments None public  subroutine uEMEP_nox_emission_temperature () Arguments None","tags":"","loc":"module/set_emission_factors.html"},{"title":"read_agriculture_asi_data – uEMEP","text":"Uses uemep_configuration mod_lambert_projection mod_area_interpolation Subroutines public  subroutine uEMEP_read_agriculture_rivm_data () Do not use!! Arguments None public  subroutine uEMEP_read_emission_rivm_data () Arguments None","tags":"","loc":"module/read_agriculture_asi_data.html"},{"title":"utility_functions – uEMEP","text":"Uses uemep_constants Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: pi = 3.141592653589793 Subroutines public  subroutine distrl (x0, y0, x1, y1, x2, y2, xm, ym, dm, wm) The subroutine calculates the minimum distance from a given receptor\npoint to a given line source. Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 Receptor point x-coordinate real, intent(in) :: y0 Receptor point y-coordinate real, intent(in) :: x1 Line source x-coordinate 1 real, intent(in) :: y1 Line source y-coordinate 1 real, intent(in) :: x2 Line source x-coordinate 2 real, intent(in) :: y2 Line source y-coordinate 2 real, intent(out) :: xm Minimum distance x-coordinate real, intent(out) :: ym Minimum distance y-coordinate real, intent(out) :: dm Minimum distance real :: wm public  subroutine distrl_sqr (x0, y0, x1, y1, x2, y2, xm, ym, dm_sqr, wm) Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 Receptor point x-coordinate real, intent(in) :: y0 Receptor point y-coordinate real, intent(in) :: x1 Line source x-coordinate 1 real, intent(in) :: y1 Line source y-coordinate 1 real, intent(in) :: x2 Line source x-coordinate 2 real, intent(in) :: y2 Line source y-coordinate 2 real, intent(out) :: xm Minimum distance x-coordinate real, intent(out) :: ym Minimum distance y-coordinate real, intent(out) :: dm_sqr Minimum distance real :: wm public  subroutine nxtdat (un, leof) The subroutine prepares for reading the next uncommented line of data from file Arguments Type Intent Optional Attributes Name integer, intent(inout) :: un logical, intent(out) :: leof public  subroutine ll2utm (iutm, isone_in, lat, lon, utmn, utme) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator integer, intent(in) :: isone_in UTM zone input? real, intent(in) :: lat Latitude in decimal degrees real, intent(in) :: lon Longitude in decimal degress real, intent(out) :: utmn UTM east-coordinate (y) (meter from west border) real, intent(out) :: utme UTM north-coordinate (x) (meter from equator) public  subroutine ll2ltm (iutm, lon0, lat, lon, utmn, utme) Local lon version (of ll2utm) without zone, so just typical Transverse\nMecantor (Local Transverse Mecantor) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator real, intent(in) :: lon0 Central meridian of UTM zone real, intent(in) :: lat Latitude in decimal degrees real, intent(in) :: lon Longitude in decimal degrees real, intent(out) :: utmn UTM north-coordinate (x) (meter from equator) real, intent(out) :: utme UTM  east-coordinate (y) (meter from west border) public  subroutine utm2ll (iutm, isone_in, utmn_in, utme, lat, lon) The subroutine converts UTM north- and east-coordinates to latitude\nand longitude Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator integer, intent(in) :: isone_in UTM zone real, intent(in) :: utmn_in UTM north-coordinate (X) (meter from equator) real, intent(in) :: utme UTM  east-coordinate (Y) (meter from west border) real, intent(out) :: lat Latitude in decimal degrees real, intent(out) :: lon Longitude in decimal degrees public  subroutine ltm2ll (iutm, isone_in, la0, utmn_in, utme, lat, lon) Local Transverse Mecantor version of utm2ll Arguments Type Intent Optional Attributes Name integer, intent(in) :: iutm UTM coordinate system indicator integer, intent(in) :: isone_in UTM zone real, intent(in) :: la0 Tangeringsmeridian real, intent(in) :: utmn_in UTM north-coordinate (X) (meter from equator) real, intent(in) :: utme UTM  east-coordinate (Y) (meter from west border) real, intent(out) :: lat Latitude in decimal degrees real, intent(out) :: lon Longitude in decimal degrees","tags":"","loc":"module/utility_functions.html"},{"title":"tiling_routines – uEMEP","text":"Uses uemep_configuration mod_lambert_projection Subroutines public  subroutine uEMEP_set_tile_grids () Arguments None public  subroutine uEMEP_set_region_tile_grids () Arguments None","tags":"","loc":"module/tiling_routines.html"},{"title":"subgrid_deposition – uEMEP","text":"Uses uemep_configuration dispersion_functions local_trajectory kz_functions mod_rargsort set_dispersion_parameters mod_area_interpolation Subroutines public  subroutine uEMEP_subgrid_deposition (source_index) Arguments Type Intent Optional Attributes Name integer :: source_index private  subroutine uEMEP_create_wind_field (temp_FF_subgrid, angle_diff, wind_level_flag_in, source_index_in, subsource_index_in, tt_in) Arguments Type Intent Optional Attributes Name real, intent(out) :: temp_FF_subgrid (integral_subgrid_dim(x_dim_index),integral_subgrid_dim(y_dim_index)) real, intent(in) :: angle_diff (integral_subgrid_dim(x_dim_index),integral_subgrid_dim(y_dim_index)) integer, intent(in) :: wind_level_flag_in integer, intent(in) :: source_index_in integer, intent(in) :: subsource_index_in integer, intent(in) :: tt_in","tags":"","loc":"module/subgrid_deposition.html"},{"title":"kz_functions – uEMEP","text":"Uses uemep_constants Subroutines public  subroutine uEMEP_set_dispersion_sigma_Kz (Kz_scheme_in, x_in, sig_z00, sig_y00, sigy_0_subgid_width_scale, sig_z_in, z_emis_loc, h_mix_loc, invL, u_val, z_val, logz0, subgrid_delta, u_star0_in, average_zc_h_in_Kz_flag, n_kz_iterations, sig_y_scaling_factor, sig_z, sig_y, u_zc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Kz_scheme_in real, intent(in) :: x_in real, intent(in) :: sig_z00 real, intent(in) :: sig_y00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: sig_z_in real, intent(in) :: z_emis_loc real, intent(in) :: h_mix_loc real, intent(in) :: invL real, intent(in) :: u_val real, intent(in) :: z_val real, intent(in) :: logz0 real, intent(in) :: subgrid_delta (2) real, intent(in) :: u_star0_in logical, intent(in) :: average_zc_h_in_Kz_flag integer, intent(in) :: n_kz_iterations real, intent(in) :: sig_y_scaling_factor real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: u_zc private  subroutine Kz_func (z_pbl, L, u_star0_in, z, K_min, K_z) Arguments Type Intent Optional Attributes Name real, intent(in) :: z_pbl real, intent(in) :: L real, intent(in) :: u_star0_in real, intent(in) :: z real, intent(in) :: K_min real, intent(out) :: K_z private  subroutine TROENKz (z, h, ustar, invL, Kdef, Kz, phih) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: h real, intent(in) :: ustar real, intent(in) :: invL real, intent(in) :: Kdef real, intent(out) :: Kz real, intent(out) :: phih public  subroutine TROENKz_invL_from_phi (z, phih, invL) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: phih real, intent(out) :: invL public  subroutine z_centremass_gauss_func (sigma, h, z_pbl, z_c) Arguments Type Intent Optional Attributes Name real, intent(in) :: sigma real, intent(in) :: h real, intent(in) :: z_pbl real, intent(out) :: z_c private  subroutine u_profile_val_func (z, L, u_val, z_val_in, z_pbl, z0, u, u_star0, u_pbl) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(in) :: u_val real, intent(in) :: z_val_in real, intent(in) :: z_pbl real, intent(in) :: z0 real, intent(out) :: u real, intent(out) :: u_star0 real, intent(out) :: u_pbl public  subroutine u_profile_neutral_val_func (z, u_val, z_val_in, z_pbl, z0, u, u_star0) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: u_val real, intent(in) :: z_val_in real, intent(in) :: z_pbl real, intent(in) :: z0 real, intent(out) :: u real, intent(out) :: u_star0 private  subroutine phi_func (z, L, phim, phih, phim_i, phih_i) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(out) :: phim real, intent(out) :: phih real, intent(out) :: phim_i real, intent(out) :: phih_i private  subroutine phim_func (z, L, phim, phim_i) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(out) :: phim real, intent(out) :: phim_i private  subroutine phih_func (z, L, phih, phih_i) Arguments Type Intent Optional Attributes Name real, intent(in) :: z real, intent(in) :: L real, intent(out) :: phih real, intent(out) :: phih_i private  subroutine z_centremass_gauss_array_func (sig_norm, h_norm, n_array, zc_array) Arguments Type Intent Optional Attributes Name real, intent(in) :: sig_norm real, intent(in) :: h_norm real, intent(in) :: n_array real, intent(out) :: zc_array (int(n_array))","tags":"","loc":"module/kz_functions.html"},{"title":"dispersion_functions – uEMEP","text":"Functions public  function gauss_plume_second_order_rotated_reflected_func (r, z, ay, by, az, bz, sig_y_0, sig_z_0, z_s, z_pbl) Arguments Type Intent Optional Attributes Name real :: r real :: z real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: z_s real :: z_pbl Return Value real private  function gauss_plume_second_order_rotated_func (r, z, ay, by, az, bz, sig_y_0, sig_z_0, h) Arguments Type Intent Optional Attributes Name real :: r real :: z real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: h Return Value real public  function gauss_plume_second_order_rotated_integral_func (r, ay, by, az, bz, sig_y_0, sig_z_0, h, H1, H2) Arguments Type Intent Optional Attributes Name real :: r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: h real :: H1 real :: H2 Return Value real public  function gauss_plume_second_order_rotated_reflected_integral_func (r, ay, by, az, bz, sig_y_0, sig_z_0, z_s, z_pbl, H1, H2) Arguments Type Intent Optional Attributes Name real :: r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: z_s real :: z_pbl real :: H1 real :: H2 Return Value real private  function gauss_plume_cartesian_func (x_s, y_s, z_s, cos_val, sin_val, x_r, y_r, z_r, ay, by, az, bz, sig_y_0, sig_z_0, delta) Arguments Type Intent Optional Attributes Name real :: x_s real :: y_s real :: z_s real :: cos_val real :: sin_val real :: x_r real :: y_r real :: z_r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: delta Return Value real private  function gauss_plume_cartesian_integral_func (x_s, y_s, z_s, cos_val, sin_val, x_r, y_r, ay, by, az, bz, sig_y_0, sig_z_0, H1, H2, delta) Arguments Type Intent Optional Attributes Name real :: x_s real :: y_s real :: z_s real :: cos_val real :: sin_val real :: x_r real :: y_r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: H1 real :: H2 real :: delta Return Value real private  function gauss_plume_cartesian_trajectory_func (x, y, z_s, z_r, ay, by, az, bz, sig_y_0, sig_z_0, delta) Arguments Type Intent Optional Attributes Name real :: x real :: y real :: z_s real :: z_r real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: delta Return Value real private  function gauss_plume_cartesian_trajectory_integral_func (x, y, z_s, ay, by, az, bz, sig_y_0, sig_z_0, H1, H2, delta) Arguments Type Intent Optional Attributes Name real :: x real :: y real :: z_s real :: ay real :: by real :: az real :: bz real :: sig_y_0 real :: sig_z_0 real :: H1 real :: H2 real :: delta Return Value real public  function gauss_plume_cartesian_sigma_func (x, y, z_s, z_r, sig_z, sig_y, z_pbl, FF) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z_s real, intent(in) :: z_r real, intent(in) :: sig_z real, intent(in) :: sig_y real, intent(in) :: z_pbl real, intent(in) :: FF Return Value real public  function gauss_plume_cartesian_sigma_integral_func (x, y, z_s, sig_z, sig_y, z_pbl, FF, H1, H2) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z_s real, intent(in) :: sig_z real, intent(in) :: sig_y real, intent(in) :: z_pbl real, intent(in) :: FF real, intent(in) :: H1 real, intent(in) :: H2 Return Value real","tags":"","loc":"module/dispersion_functions.html"},{"title":"read_ssb_data – uEMEP","text":"Uses uemep_configuration utility_functions mod_lambert_projection mod_area_interpolation Subroutines public  subroutine uEMEP_read_SSB_data () Arguments None public  subroutine uEMEP_read_netcdf_population () Arguments None public  subroutine uEMEP_read_netcdf_population_latlon () Arguments None","tags":"","loc":"module/read_ssb_data.html"},{"title":"define_subgrid – uEMEP","text":"Uses uemep_configuration uemep_constants mod_lambert_projection Subroutines public  subroutine uEMEP_define_subgrid_extent () Arguments None public  subroutine uEMEP_define_subgrid () Arguments None","tags":"","loc":"module/define_subgrid.html"},{"title":"calculate_exposure – uEMEP","text":"Uses uemep_configuration uEMEP_definitions Subroutines public  subroutine uEMEP_calculate_exposure () Arguments None","tags":"","loc":"module/calculate_exposure.html"},{"title":"mod_area_interpolation – uEMEP","text":"Functions public  function area_weighted_interpolation_function (xgrid, ygrid, zgrid, xdim, ydim, delta, xval, yval) result(res) Returns the area weight value for a a point at position xval, yval from the grid values xgrid,ygrid,zgrid Arguments Type Intent Optional Attributes Name real, intent(in) :: xgrid (xdim,ydim) real, intent(in) :: ygrid (xdim,ydim) real, intent(in) :: zgrid (xdim,ydim) integer, intent(in) :: xdim integer, intent(in) :: ydim real, intent(in) :: delta (2) real, intent(in) :: xval real, intent(in) :: yval Return Value real public  function area_weighted_extended_interpolation_function (xgrid, ygrid, zgrid, xdim, ydim, delta, xval, yval, delta_val) result(res) Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid\nDelta_val can be any size Arguments Type Intent Optional Attributes Name real, intent(in) :: xgrid (xdim,ydim) real, intent(in) :: ygrid (xdim,ydim) real, intent(in) :: zgrid (xdim,ydim) integer, intent(in) :: xdim integer, intent(in) :: ydim real, intent(in) :: delta (2) real, intent(in) :: xval real, intent(in) :: yval real, intent(in) :: delta_val (2) Return Value real public  function area_weighted_extended_vectorgrid_interpolation_function (xgrid, ygrid, zgrid, xdim, ydim, delta, xval, yval, delta_val) result(res) Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid\nDelta_val can be any size\nvectorgrid means the grid positions only have one dimension Arguments Type Intent Optional Attributes Name real, intent(in) :: xgrid (xdim) real, intent(in) :: ygrid (ydim) real, intent(in) :: zgrid (xdim,ydim) integer, intent(in) :: xdim integer, intent(in) :: ydim real, intent(in) :: delta (2) real, intent(in) :: xval real, intent(in) :: yval real, intent(in) :: delta_val (2) Return Value real","tags":"","loc":"module/mod_area_interpolation.html"},{"title":"set_constants – uEMEP","text":"Uses uemep_configuration Subroutines public  subroutine uEMEP_set_constants () Doesn't exist but name is used\nDoesn't exist but name is used\nDoesn't exist but name is used. Will be calculated Arguments None public  subroutine uEMEP_set_pollutant_loop () Arguments None public  subroutine uEMEP_set_species_loop () Arguments None public  subroutine uEMEP_reset_constants () Arguments None","tags":"","loc":"module/set_constants.html"},{"title":"read_namefile_routines – uEMEP","text":"Subroutines and functions for reading in name files Uses uemep_constants Interfaces private        interface read_name public  function read_name_real (name_str, default_val, unit_in, unit_out) result(res) Reads single precision value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real Value found in name file (or default value) public  function read_name_double (name_str, default_val, unit_in, unit_out) result(res) Reads double precision value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real(kind=dp), intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real(kind=dp) Value found in name file (or default value) public  function read_name_integer (name_str, default_val, unit_in, unit_out) result(res) Reads integer value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file integer, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value integer Value found in name file (or default value) public  function read_name_char (name_str, default_val, unit_in, unit_out) result(res) Reads string from name file Skips comments (!) and returns default string if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of string in name file character(len=*), intent(in) :: default_val Default string integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value character(len=:), allocatable String found in name file (or default string) public  function read_name_logical (name_str, default_val, unit_in, unit_out) result(res) Reads boolean value from name file Skips comments (!) and returns default value if name is not present in name file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file logical, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value logical Functions public  function read_name_real (name_str, default_val, unit_in, unit_out) result(res) Reads single precision value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real Value found in name file (or default value) public  function read_name_double (name_str, default_val, unit_in, unit_out) result(res) Reads double precision value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file real(kind=dp), intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value real(kind=dp) Value found in name file (or default value) public  function read_name_integer (name_str, default_val, unit_in, unit_out) result(res) Reads integer value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file integer, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value integer Value found in name file (or default value) public  function read_name_char (name_str, default_val, unit_in, unit_out) result(res) Reads string from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of string in name file character(len=*), intent(in) :: default_val Default string integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value character(len=:), allocatable String found in name file (or default string) public  function read_name_logical (name_str, default_val, unit_in, unit_out) result(res) Reads boolean value from name file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name_str Name of value in name file logical, intent(in) :: default_val Default value integer, intent(in) :: unit_in Name file unit integer, intent(in) :: unit_out Log file unit Return Value logical","tags":"","loc":"module/read_namefile_routines.html"},{"title":"subgrid_deposition_emep – uEMEP","text":"Uses uemep_configuration mod_area_interpolation Subroutines public  subroutine uEMEP_subgrid_deposition_EMEP () Arguments None public  subroutine uEMEP_calculate_deposition () Arguments None public  subroutine uEMEP_set_deposition_velocities () Arguments None","tags":"","loc":"module/subgrid_deposition_emep.html"},{"title":"uemep_constants – uEMEP","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15, 307) real, public, parameter :: pi = 3.14159265358979323 real, public, parameter :: secphour = 3600.0 real, public, parameter :: secpday = 86400.0 real, public, parameter :: NODATA_value = -128.0 real, public, parameter :: epsilon0 = 1.0e-6","tags":"","loc":"module/uemep_constants.html"},{"title":"subgrid_emission_emep – uEMEP","text":"Uses uemep_configuration mod_lambert_projection Subroutines public  subroutine uEMEP_subgrid_emission_EMEP () Arguments None","tags":"","loc":"module/subgrid_emission_emep.html"},{"title":"uEMEP_definitions – uEMEP","text":"Variables Type Visibility Attributes Name Initial character(len=1), public :: slash = '\\' character(len=256), public :: model_version_str = 'uEMEP_vx.x' logical, public :: read_EMEP_only_once_flag = .false. integer, public :: unit_logfile = 0 integer, public :: unit_finishedfile = 20 integer, public :: n_roadlinks = 0 integer, public :: n_roadlinks_major = 0 integer, public :: n_roadlinks_major_selected = 0 logical, public :: calculate_EMEP_additional_grid_flag = .false. integer, public :: t_loop integer, public :: start_time_loop_index = 1 integer, public :: end_time_loop_index = 1 integer, public, parameter :: num_dims_nc = 6 integer, public, parameter :: num_dims_meteo_nc = 4 integer, public :: dim_length_nc (num_dims_nc) integer, public :: dim_start_nc (num_dims_nc) = [1, 1, 1, 1, 1, 1] integer, public :: dim_length_meteo_nc (num_dims_meteo_nc) integer, public :: dim_start_meteo_nc (num_dims_meteo_nc) = [1, 1, 1, 1] integer, public :: dim_length_EMEP_nc (num_dims_nc) integer, public :: dim_start_EMEP_nc (num_dims_nc) integer, public :: end_dim_nc (num_dims_nc) integer, public :: start_dim_nc (num_dims_nc) integer, public, parameter :: lon_nc_index = 1 integer, public, parameter :: lat_nc_index = 2 integer, public, parameter :: ugrid_nc_index = 3 integer, public, parameter :: vgrid_nc_index = 4 integer, public, parameter :: FF10_nc_index = 5 integer, public, parameter :: FFgrid_nc_index = 6 integer, public, parameter :: inv_FFgrid_nc_index = 7 integer, public, parameter :: inv_FF10_nc_index = 8 integer, public, parameter :: hmix_nc_index = 9 integer, public, parameter :: kz_nc_index = 10 integer, public, parameter :: invL_nc_index = 11 integer, public, parameter :: ustar_nc_index = 12 integer, public, parameter :: logz0_nc_index = 13 integer, public, parameter :: J_nc_index = 14 integer, public, parameter :: conc_nc_index = 15 integer, public, parameter :: emis_nc_index = 18 integer, public, parameter :: x_nc_index = 19 integer, public, parameter :: y_nc_index = 20 integer, public, parameter :: ZTOP_nc_index = 21 integer, public, parameter :: u10_nc_index = 22 integer, public, parameter :: v10_nc_index = 23 integer, public, parameter :: uw_nc_index = 24 integer, public, parameter :: vw_nc_index = 25 integer, public, parameter :: Hflux_nc_index = 26 integer, public, parameter :: t2m_nc_index = 27 integer, public, parameter :: precip_nc_index = 28 integer, public, parameter :: wetdepo_nc_index = 29 integer, public, parameter :: drydepo_nc_index = 30 integer, public, parameter :: phi_nc_index = 31 integer, public :: num_var_nc integer, public, parameter :: num_var_nc_start = 31 integer, public, parameter :: num_var_nc_name = 51 integer, public, parameter :: num_var_meteo_nc = num_var_nc_start integer, public, parameter :: num_lc_var_nc_start = 2 integer, public :: frac_nc_index = num_var_nc_start+1 integer, public :: local_nc_index = num_var_nc_start+2 integer, public :: lc_frac_nc_index = 1 integer, public :: lc_local_nc_index = 2 integer, public :: num_lc_var_nc = num_lc_var_nc_start integer, public :: compound_index integer, public, parameter :: no2_nc_index = 1 integer, public, parameter :: nox_nc_index = 2 integer, public, parameter :: pm25_nc_index = 3 integer, public, parameter :: pm10_nc_index = 4 integer, public, parameter :: nh3_nc_index = 5 integer, public, parameter :: o3_nc_index = 6 integer, public, parameter :: so2_nc_index = 7 integer, public, parameter :: pmex_nc_index = 8 integer, public, parameter :: nh4_nc_index = 9 integer, public, parameter :: pm25_sand_nc_index = 10 integer, public, parameter :: pm10_sand_nc_index = 11 integer, public, parameter :: pm25_salt_nc_index = 12 integer, public, parameter :: pm10_salt_nc_index = 13 integer, public, parameter :: c6h6_nc_index = 14 integer, public, parameter :: bap_nc_index = 15 integer, public, parameter :: co_nc_index = 16 integer, public, parameter :: somo35_nc_index = 17 integer, public, parameter :: comax_nc_index = 18 integer, public, parameter :: o3max_nc_index = 19 integer, public, parameter :: o3_26th_nc_index = 20 integer, public, parameter :: n_compound_nc_index = 20 integer, public, parameter :: pmco_nc_index = 21 integer, public, parameter :: all_nc_index = 22 integer, public, parameter :: pm_nc_index = 23 integer, public, parameter :: all_sand_nc_index = 24 integer, public, parameter :: all_salt_nc_index = 25 integer, public, parameter :: all_sand_salt_nc_index = 26 integer, public, parameter :: all_totals_nc_index = 27 integer, public, parameter :: aaqd_totals_nc_index = 28 integer, public, parameter :: gp_totals_nc_index = 29 integer, public, parameter :: op_totals_nc_index = 30 integer, public, parameter :: allsource_nc_index = 1 integer, public, parameter :: traffic_nc_index = 2 integer, public, parameter :: shipping_nc_index = 3 integer, public, parameter :: heating_nc_index = 4 integer, public, parameter :: agriculture_nc_index = 5 integer, public, parameter :: industry_nc_index = 6 integer, public, parameter :: publicpower_nc_index = 7 integer, public, parameter :: fugitive_nc_index = 8 integer, public, parameter :: solvents_nc_index = 9 integer, public, parameter :: aviation_nc_index = 10 integer, public, parameter :: offroad_nc_index = 11 integer, public, parameter :: waste_nc_index = 12 integer, public, parameter :: livestock_nc_index = 13 integer, public, parameter :: other_nc_index = 14 integer, public, parameter :: traffic_exhaust_nc_index = 15 integer, public, parameter :: traffic_nonexhaust_nc_index = 16 integer, public, parameter :: traffic_gasoline_nc_index = 17 integer, public, parameter :: traffic_diesel_nc_index = 18 integer, public, parameter :: traffic_gas_nc_index = 19 integer, public, parameter :: publicpower_point_nc_index = 20 integer, public, parameter :: publicpower_area_nc_index = 21 integer, public, parameter :: extrasource_nc_index = 22 integer, public, parameter :: n_source_nc_index = 22 integer, public :: convert_GNFR_to_uEMEP_sector_index (n_source_nc_index) integer, public :: pollutant_index integer, public, parameter :: n_pollutant_nc_index = 30 integer, public :: n_pollutant_loop = 1 integer, public :: n_emep_pollutant_loop = 1 integer, public :: pollutant_loop_index (n_pollutant_nc_index) integer, public :: pollutant_loop_back_index (n_pollutant_nc_index) integer, public :: n_pollutant_compound_loop (n_pollutant_nc_index) = 0 integer, public :: pollutant_compound_loop_index (n_pollutant_nc_index,n_compound_nc_index) = 0 integer, public :: meteo_p_loop_index = 1 character(len=256), public :: pollutant_file_str (n_pollutant_nc_index) = '' character(len=256), public :: dim_name_nc (num_dims_nc) character(len=256), public :: var_name_meteo_nc (num_var_meteo_nc) character(len=256), public :: dim_name_meteo_nc (num_dims_meteo_nc) integer, public, parameter :: num_var_population_nc = 2 integer, public, parameter :: num_dims_population_nc = 2 integer, public, parameter :: population_nc_index = 1 integer, public, parameter :: dwelling_nc_index = 2 character(len=256), public :: dim_name_population_nc (num_dims_population_nc) integer, public, parameter :: num_var_shipping_nc = 1 integer, public, parameter :: num_dims_shipping_nc = 2 character(len=256), public :: var_name_shipping_nc (num_var_shipping_nc) character(len=256), public :: dim_name_shipping_nc (num_dims_shipping_nc) integer, public, parameter :: num_var_landuse_nc = 1 integer, public, parameter :: num_dims_landuse_nc = 2 character(len=256), public :: dim_name_landuse_nc (num_dims_landuse_nc) integer, public :: dim_length_landuse_nc (num_dims_landuse_nc) integer, public :: dim_start_landuse_nc (num_dims_landuse_nc) = [1, 1] integer, public, parameter :: x_dim_nc_index = 1 integer, public, parameter :: y_dim_nc_index = 2 integer, public, parameter :: z_dim_nc_index = 3 integer, public, parameter :: time_dim_nc_index = 4 integer, public, parameter :: xdist_dim_nc_index = 5 integer, public, parameter :: ydist_dim_nc_index = 6 real, public, allocatable :: var1d_nc (:,:) real, public, allocatable :: var2d_nc (:,:,:) real, public, allocatable :: var3d_nc (:,:,:,:,:,:) real, public, allocatable :: var4d_nc (:,:,:,:,:,:,:) real, public, allocatable :: lc_var3d_nc (:,:,:,:,:,:,:,:) real, public, allocatable :: lc_var4d_nc (:,:,:,:,:,:,:,:,:) real, public, allocatable :: comp_var3d_nc (:,:,:,:) real, public, allocatable :: comp_var4d_nc (:,:,:,:,:) real, public, allocatable :: meteo_var1d_nc (:,:) real, public, allocatable :: meteo_var2d_nc (:,:,:) real, public, allocatable :: meteo_var3d_nc (:,:,:,:) real, public, allocatable :: meteo_var4d_nc (:,:,:,:,:) real, public :: dgrid_nc (2) real, public :: meteo_dgrid_nc (2) double precision, public, allocatable :: val_dim_nc (:,:) double precision, public, allocatable :: val_dim_meteo_nc (:,:) character(len=256), public, allocatable :: unit_dim_nc (:) character(len=256), public, allocatable :: unit_dim_meteo_nc (:) integer, public :: surface_level_nc integer, public :: xdist_centre_nc = 0 integer, public :: ydist_centre_nc = 0 real, public, allocatable :: inputdata_rl (:,:) integer, public, allocatable :: inputdata_int_rl (:,:) real, public, allocatable :: inputdata_rl_emissions (:,:,:) logical, public, allocatable :: valid_link_flag (:) integer, public, parameter :: x1_rl_index = 1 integer, public, parameter :: x2_rl_index = 2 integer, public, parameter :: y1_rl_index = 3 integer, public, parameter :: y2_rl_index = 4 integer, public, parameter :: x0_rl_index = 5 integer, public, parameter :: y0_rl_index = 6 integer, public, parameter :: lon1_rl_index = 7 integer, public, parameter :: lon2_rl_index = 8 integer, public, parameter :: lat1_rl_index = 9 integer, public, parameter :: lat2_rl_index = 10 integer, public, parameter :: lon0_rl_index = 11 integer, public, parameter :: lat0_rl_index = 12 integer, public, parameter :: length_rl_index = 13 integer, public, parameter :: z0_rl_index = 14 integer, public, parameter :: width_rl_index = 15 integer, public, parameter :: adt_rl_index = 16 integer, public, parameter :: speed_rl_index = 17 integer, public, parameter :: hdv_rl_index = 18 integer, public, parameter :: tunnel_length_rl_index = 19 integer, public, parameter :: num_var_rl = 19 integer, public, parameter :: id_rl_index = 1 integer, public, parameter :: roadtype_rl_index = 2 integer, public, parameter :: nlanes_rl_index = 3 integer, public, parameter :: major_index_rl_index = 4 integer, public, parameter :: num_int_rl = 4 character(len=256), public :: pathfilename_rl (2) character(len=256), public :: pathfilename_mrl (50) integer, public, parameter :: lon_ship_index = 1 Ship longitude index integer, public, parameter :: lat_ship_index = 2 Ship latitude index integer, public, parameter :: nox_ship_index = 3 Ship total NOx emission index integer, public, parameter :: tpm_ship_index = 4 Ship total particulate matter emission integer, public, parameter :: num_var_ship = 4 Number of ship variables integer, public, parameter :: idloyds_ship_index = 1 integer, public, parameter :: idnorwegian_ship_index = 2 integer, public, parameter :: num_int_ship = 2 integer, public, parameter :: date_ship_index = 1 integer, public, parameter :: time_ship_index = 2 integer, public :: num_char_ship integer, public, parameter :: num_char_rl = 2 integer, public, parameter :: lon_agriculture_index = 1 integer, public, parameter :: lat_agriculture_index = 2 integer, public, parameter :: nh3_agriculture_index = 3 integer, public, parameter :: num_var_agriculture = 3 integer, public, parameter :: n_filenames_grid = 500 character(len=256), public :: filename_grid (n_filenames_grid) character(len=256), public :: pathname_grid (n_filenames_grid) character(len=256), public :: pathfilename_grid (n_filenames_grid) integer, public, parameter :: proxy_subgrid_index = 1 integer, public, parameter :: proxy_integral_subgrid_index = 2 integer, public, parameter :: scaling_factor_subgrid_index = 3 integer, public, parameter :: local_subgrid_index = 4 integer, public, parameter :: nonlocal_subgrid_index = 5 integer, public, parameter :: total_subgrid_index = 6 integer, public, parameter :: emep_subgrid_index = 7 integer, public, parameter :: emep_frac_subgrid_index = 8 integer, public, parameter :: emep_local_subgrid_index = 9 integer, public, parameter :: emep_nonlocal_subgrid_index = 10 integer, public, parameter :: emep_additional_local_subgrid_index = 11 integer, public, parameter :: emep_additional_nonlocal_subgrid_index = 12 integer, public, parameter :: drydepo_local_subgrid_index = 13 integer, public, parameter :: wetdepo_local_subgrid_index = 14 integer, public, parameter :: drydepo_nonlocal_subgrid_index = 15 integer, public, parameter :: wetdepo_nonlocal_subgrid_index = 16 integer, public, parameter :: n_subgrid_index = 16 integer, public, parameter :: ugrid_subgrid_index = 1 integer, public, parameter :: vgrid_subgrid_index = 2 integer, public, parameter :: FF10_subgrid_index = 3 integer, public, parameter :: FFgrid_subgrid_index = 4 integer, public, parameter :: inv_FFgrid_subgrid_index = 5 integer, public, parameter :: inv_FF10_subgrid_index = 6 integer, public, parameter :: hmix_subgrid_index = 7 integer, public, parameter :: kz_subgrid_index = 8 integer, public, parameter :: invL_subgrid_index = 9 integer, public, parameter :: ustar_subgrid_index = 10 integer, public, parameter :: logz0_subgrid_index = 11 integer, public, parameter :: J_subgrid_index = 12 integer, public, parameter :: t2m_subgrid_index = 13 integer, public, parameter :: cos_subgrid_index = 14 integer, public, parameter :: sin_subgrid_index = 15 integer, public, parameter :: precip_subgrid_index = 16 integer, public, parameter :: u10_subgrid_index = 17 integer, public, parameter :: v10_subgrid_index = 18 integer, public, parameter :: phi_index = 19 integer, public, parameter :: n_meteo_subgrid_index = 19 integer, public, parameter :: no2_index = 1 integer, public, parameter :: nox_index = 2 integer, public, parameter :: pm25_index = 3 integer, public, parameter :: pm10_index = 4 integer, public, parameter :: nh3_index = 5 integer, public, parameter :: o3_index = 6 integer, public, parameter :: so2_index = 7 integer, public, parameter :: pmex_index = 8 integer, public :: no_index TODO Does not seem to be defined or used anywhere, delete? integer, public, parameter :: nh4_index = 9 integer, public, parameter :: pm25_sand_index = 10 integer, public, parameter :: pm10_sand_index = 11 integer, public, parameter :: pm25_salt_index = 12 integer, public, parameter :: pm10_salt_index = 13 integer, public, parameter :: c6h6_index = 14 integer, public, parameter :: bap_index = 15 integer, public, parameter :: co_index = 16 integer, public, parameter :: somo35_index = 17 integer, public, parameter :: comax_index = 18 integer, public, parameter :: o3max_index = 19 integer, public, parameter :: o3_26th_index = 20 integer, public, parameter :: n_compound_index = 20 integer, public, parameter :: allsource_index = 1 integer, public, parameter :: traffic_index = 2 integer, public, parameter :: shipping_index = 3 integer, public, parameter :: heating_index = 4 integer, public, parameter :: agriculture_index = 5 integer, public, parameter :: industry_index = 6 integer, public, parameter :: publicpower_index = 7 integer, public, parameter :: fugitive_index = 8 integer, public, parameter :: solvents_index = 9 integer, public, parameter :: aviation_index = 10 integer, public, parameter :: offroad_index = 11 integer, public, parameter :: waste_index = 12 integer, public, parameter :: livestock_index = 13 integer, public, parameter :: other_index = 14 integer, public, parameter :: traffic_exhaust_index = 15 integer, public, parameter :: traffic_nonexhaust_index = 16 integer, public, parameter :: n_source_index = 16 integer, public, parameter :: n_source_calculate_index = 14 integer, public :: compound_source_index (n_compound_index,n_source_index) character(len=256), public :: source_file_postfix (n_source_nc_index) logical, public :: save_EMEP_source (n_source_nc_index) = .false. integer, public, parameter :: x_dim_index = 1 integer, public, parameter :: y_dim_index = 2 integer, public, parameter :: t_dim_index = 3 integer, public, parameter :: n_dim_index = 3 integer, public :: subgrid_dim (n_dim_index) real, public :: subgrid_proj_min (2) real, public :: subgrid_proj_max (2) integer, public :: init_subgrid_dim (n_dim_index) real, public, allocatable :: subgrid (:,:,:,:,:,:) real, public, allocatable :: meteo_subgrid (:,:,:,:) real, public, allocatable :: last_meteo_subgrid (:,:,:) real, public, allocatable :: comp_subgrid (:,:,:,:) real, public, allocatable :: comp_EMEP_subgrid (:,:,:,:) real, public, allocatable :: orig_EMEP_subgrid (:,:,:,:) real, public, allocatable :: x_subgrid (:,:) real, public, allocatable :: y_subgrid (:,:) real, public, allocatable :: lon_subgrid (:,:) real, public, allocatable :: lat_subgrid (:,:) real, public, allocatable :: xproj_subgrid (:,:) real, public, allocatable :: yproj_subgrid (:,:) real, public, allocatable :: traveltime_subgrid (:,:,:,:,:) real, public, allocatable :: exposure_subgrid (:,:,:,:,:) integer, public :: subgrid_loop_index (2) integer, public :: integral_subgrid_loop_index (2) integer, public :: emission_subgrid_loop_index (2,n_source_index) integer, public :: init_emission_subgrid_loop_index (2,n_source_index) logical, public, allocatable :: use_subgrid (:,:,:) integer, public, allocatable :: use_subgrid_val (:,:,:) integer, public, allocatable :: use_subgrid_interpolation_index (:,:,:) integer, public :: n_use_subgrid_levels (n_source_index) real, public :: loop_index_scale = 1.5 real, public :: buffer_index_scale = 1.5 integer, public, parameter :: n_possible_subsource = 2 character(len=2), public :: subsource_str (n_possible_subsource) integer, public, parameter :: emission_h_index = 1 integer, public :: emission integer, public, parameter :: emission_sigz00_index = 2 integer, public, parameter :: emission_sigy00_index = 3 integer, public, parameter :: emission_minFF_index = 4 integer, public, parameter :: n_emission_index = 4 integer, public :: emission_subgrid_dim (n_dim_index,n_source_index) integer, public :: emission_max_subgrid_dim (n_dim_index) real, public :: emission_subgrid_delta (2,n_source_index) real, public :: emission_subgrid_min (2,n_source_index) real, public :: emission_subgrid_max (2,n_source_index) integer, public :: init_emission_subgrid_dim (n_dim_index,n_source_index) real, public :: init_emission_subgrid_delta (2,n_source_index) real, public :: init_emission_subgrid_min (2,n_source_index) real, public :: init_emission_subgrid_max (2,n_source_index) real, public, allocatable :: emission_subgrid (:,:,:,:,:) real, public, allocatable :: proxy_emission_subgrid (:,:,:,:) real, public, allocatable :: emission_time_profile_subgrid (:,:,:,:,:) real, public, allocatable :: emission_properties_subgrid (:,:,:,:) real, public, allocatable :: x_emission_subgrid (:,:,:) real, public, allocatable :: y_emission_subgrid (:,:,:) real, public, allocatable :: lon_emission_subgrid (:,:,:) real, public, allocatable :: lat_emission_subgrid (:,:,:) real, public, allocatable :: xproj_emission_subgrid (:,:,:) real, public, allocatable :: yproj_emission_subgrid (:,:,:) logical, public :: use_buffer_zone = .true. integer, public :: buffer_index (2) real, public :: buffer_size (2) integer, public :: emission_buffer_index (2,n_source_index) real, public :: emission_buffer_size (2,n_source_index) integer, public :: init_emission_buffer_index (2,n_source_index) real, public :: init_emission_buffer_size (2,n_source_index) integer, public :: integral_buffer_index (2) real, public :: integral_buffer_size (2) integer, public, parameter :: hsurf_integral_subgrid_index = 1 integer, public, parameter :: hmix_integral_subgrid_index = 2 integer, public, parameter :: hsurf_average_subgrid_index = 3 integer, public, parameter :: n_integral_subgrid_index = 3 integer, public :: integral_subgrid_dim (n_dim_index) real, public :: integral_subgrid_delta (2) = 0. real, public :: integral_subgrid_min (2) real, public :: integral_subgrid_max (2) real, public, allocatable :: integral_subgrid (:,:,:,:,:,:) real, public, allocatable :: x_integral_subgrid (:,:) real, public, allocatable :: y_integral_subgrid (:,:) real, public, allocatable :: lon_integral_subgrid (:,:) real, public, allocatable :: lat_integral_subgrid (:,:) real, public, allocatable :: xproj_integral_subgrid (:,:) real, public, allocatable :: yproj_integral_subgrid (:,:) real, public, allocatable :: meteo_nc_xproj_integral_subgrid (:,:) real, public, allocatable :: meteo_nc_yproj_integral_subgrid (:,:) integer, public :: population_subgrid_dim (2) real, public :: population_subgrid_delta (2) real, public :: population_subgrid_min (2) real, public :: population_subgrid_max (2) real, public, allocatable :: population_subgrid (:,:,:) real, public, allocatable :: x_population_subgrid (:,:) real, public, allocatable :: y_population_subgrid (:,:) real, public, allocatable :: lon_population_subgrid (:,:) real, public, allocatable :: lat_population_subgrid (:,:) real, public, allocatable :: xproj_population_subgrid (:,:) real, public, allocatable :: yproj_population_subgrid (:,:) integer, public, allocatable :: crossreference_target_to_emep_subgrid (:,:,:) integer, public, allocatable :: crossreference_target_to_localfraction_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_integral_to_emep_subgrid (:,:,:) integer, public, allocatable :: crossreference_integral_to_meteo_nc_subgrid (:,:,:) integer, public, allocatable :: crossreference_target_to_integral_subgrid (:,:,:) integer, public, allocatable :: crossreference_target_to_emission_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_integral_to_emission_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_emission_to_emep_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_emission_to_integral_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_target_to_population_subgrid (:,:,:) integer, public, allocatable :: crossreference_emission_to_deposition_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_emission_to_landuse_subgrid (:,:,:,:) integer, public, allocatable :: crossreference_target_to_deposition_subgrid (:,:,:) integer, public, allocatable :: crossreference_deposition_to_emep_subgrid (:,:,:) real, public :: min_link_size = 50.0 real, public :: min_adt = 1000.0 real, public :: H_meteo = 45.0 integer, public :: start_month_in_annual_calculations = 1 integer, public :: end_month_in_annual_calculations = 12 real, public :: by (n_source_index,n_possible_subsource) real, public :: az (n_source_index,n_possible_subsource) real, public :: bz (n_source_index,n_possible_subsource) real, public :: sig_y_0 (n_source_index,n_possible_subsource) real, public :: sig_z_0 (n_source_index,n_possible_subsource) integer, public, parameter :: UTM_projection_index = 1 integer, public, parameter :: RDM_projection_index = 2 integer, public, parameter :: LCC_projection_index = 3 integer, public, parameter :: LL_projection_index = 4 integer, public, parameter :: LAEA_projection_index = 5 integer, public, parameter :: LTM_projection_index = 6 integer, public, parameter :: PS_projection_index = 7 double precision, public :: population_nc_projection_attributes (10) integer, public :: meteo_nc_projection_type = LCC_projection_index double precision, public :: meteo_nc_projection_attributes (10) logical, public :: use_alternative_LCC_projection_flag = .false. integer, public :: proxy_emission_file_index (n_source_index) integer, public :: emission_file_index (n_source_index) integer, public :: proxy_file_index (n_source_index) integer, public :: proxy_integral_file_index (n_source_index) integer, public :: emep_subgrid_file_index (n_source_index) integer, public :: emep_subgrid_nonlocal_file_index (n_source_index) integer, public :: emep_subgrid_local_file_index (n_source_index) integer, public :: emep_subgrid_frac_file_index (n_source_index) integer, public :: subgrid_local_file_index (n_source_index) integer, public :: subgrid_total_file_index (n_source_index) integer, public :: emep_additional_subgrid_nonlocal_file_index (n_source_index) integer, public :: emep_additional_subgrid_local_file_index (n_source_index) integer, public :: emep_subgrid_semilocal_file_index (n_source_index) integer, public :: subgrid_sourcetotal_inregion_file_index (n_source_index) integer, public :: subgrid_sourcetotal_file_index (n_source_index) integer, public :: subgrid_ugrid_file_index integer, public :: subgrid_vgrid_file_index integer, public :: subgrid_u10_file_index integer, public :: subgrid_v10_file_index integer, public :: subgrid_hmix_file_index integer, public :: subgrid_kz_file_index integer, public :: subgrid_logz0_file_index integer, public :: subgrid_invL_file_index integer, public :: subgrid_FF10_file_index integer, public :: subgrid_FFgrid_file_index integer, public :: subgrid_invFF10_file_index integer, public :: subgrid_invFFgrid_file_index integer, public :: subgrid_ustar_file_index integer, public :: subgrid_J_file_index integer, public :: subgrid_meteo_file_index integer, public :: subgrid_DD10_file_index integer, public :: subgrid_DDgrid_file_index integer, public :: subgrid_t2m_file_index integer, public :: use_subgrid_file_index (n_source_index) integer, public :: emep_emission_subgrid_file_index (n_source_index) character(len=256), public :: source_file_str (n_source_nc_index) = '' real, public :: unit_conversion (n_source_index) = 1.0 real, public :: emission_factor_conversion (n_compound_nc_index,n_source_index,n_possible_subsource) = 0.0 integer, public :: weighting_step = 1 integer, public :: ref_year_EMEP = 1900 integer, public :: ref_year_meteo = 1970 integer, public :: n_receptor integer, public :: n_receptor_in integer, public, parameter :: n_receptor_max = 20000 integer, public :: n_valid_receptor integer, public :: n_valid_receptor_in real, public :: lon_receptor (n_receptor_max) real, public :: lat_receptor (n_receptor_max) real, public :: x_receptor (n_receptor_max) real, public :: y_receptor (n_receptor_max) real, public :: height_receptor (n_receptor_max) real, public :: lon_receptor_in (n_receptor_max) real, public :: lat_receptor_in (n_receptor_max) real, public :: x_receptor_in (n_receptor_max) real, public :: y_receptor_in (n_receptor_max) real, public :: height_receptor_in (n_receptor_max) integer, public :: i_receptor_subgrid (n_receptor_max) integer, public :: j_receptor_subgrid (n_receptor_max) character(len=256), public :: name_receptor (n_receptor_max,2) character(len=256), public :: name_receptor_in (n_receptor_max,2) logical, public :: use_receptor (n_receptor_max) = .true. integer, public :: valid_receptor_index (n_receptor_max) integer, public :: valid_receptor_inverse_index (n_receptor_max) integer, public, parameter :: dwelling_index = 1 integer, public, parameter :: population_index = 2 integer, public, parameter :: establishment_index = 3 integer, public, parameter :: school_index = 4 integer, public, parameter :: kindergaten_index = 5 integer, public, parameter :: home_index = 6 integer, public, parameter :: municipality_index = 7 integer, public, parameter :: RWC_heating_index = 8 integer, public, parameter :: n_population_index = 8 integer, public :: population_file_index (n_population_index) integer, public :: SSB_data_type = dwelling_index integer, public :: n_receptor_grid integer, public :: start_grid_loop_index integer, public :: end_grid_loop_index integer, public :: g_loop integer(kind=4), public, allocatable :: time_seconds_output (:) integer, public :: n_RWC_grids real, public, allocatable :: RWC_grid_emission (:,:) real, public, allocatable :: RWC_grid_HDD (:,:) integer(kind=8), public, allocatable :: RWC_grid_id (:) integer, public, allocatable :: RWC_region_id (:) real, public, allocatable :: RWC_grid_height (:,:) real, public, allocatable :: DMT_EMEP_grid_nc (:,:,:) real, public :: aqi_hourly_limits (n_compound_index,1:3) real, public :: aqi_daily_limits (n_compound_index,1:3) real, public :: aqi_annual_limits (n_compound_index,1:3) real, public, allocatable :: comp_source_subgrid (:,:,:,:,:) real, public, allocatable :: comp_source_subgrid_from_in_region (:,:,:,:,:) real, public, allocatable :: comp_source_additional_subgrid (:,:,:,:,:) real, public, allocatable :: comp_source_EMEP_subgrid (:,:,:,:,:) real, public, allocatable :: comp_source_EMEP_additional_subgrid (:,:,:,:,:) real, public, allocatable :: comp_semilocal_source_subgrid_from_in_region (:,:,:,:,:) integer, public :: use_subgrid_step_delta (0:10) integer, public, parameter :: outside_region_index = -1 integer, public, parameter :: outside_interpolation_region_index = -2 integer, public, parameter :: inside_region_index = 0 real, public, allocatable :: val_array_av (:,:,:) integer(kind=8), public, allocatable :: time_seconds_output_av (:) integer, public :: counter_av = 0 integer, public, parameter :: pm10_sp_index = 1 integer, public, parameter :: pm25_sp_index = 2 integer, public, parameter :: pmco_sp_index = 3 integer, public, parameter :: n_pmxx_sp_index = 3 integer, public, parameter :: sp_soa_index = 1 integer, public, parameter :: sp_sia_index = 2 integer, public, parameter :: sp_dust_index = 3 integer, public, parameter :: sp_seasalt_index = 4 integer, public, parameter :: sp_ffire_index = 5 integer, public, parameter :: sp_ppm_index = 6 integer, public, parameter :: sp_water_index = 7 integer, public, parameter :: sp_pm_index = 8 integer, public, parameter :: sp_asoa_index = 9 integer, public, parameter :: sp_bsoa_index = 10 integer, public, parameter :: n_sp_index = 10 integer, public, parameter :: sp_BBOA_index = 11 integer, public, parameter :: sp_BBOA_RES_index = 12 integer, public, parameter :: n_sp_OP_index = 12 integer, public, parameter :: sp_no3_index = 13 integer, public, parameter :: sp_so4_index = 14 integer, public, parameter :: sp_nh4_index = 15 integer, public, parameter :: sp_dust_sah_index = 16 integer, public, parameter :: sp_dust_wb_index = 17 integer, public, parameter :: sp_ffire_bc_index = 18 integer, public, parameter :: sp_ffire_rem_index = 19 integer, public, parameter :: sp_soa_in_index = 20 integer, public, parameter :: sp_sia_in_index = 21 integer, public, parameter :: sp_dust_in_index = 22 integer, public, parameter :: sp_seasalt_in_index = 23 integer, public, parameter :: sp_ffire_in_index = 24 integer, public, parameter :: sp_ppm_in_index = 25 integer, public, parameter :: sp_water_in_index = 26 integer, public, parameter :: sp_pm_in_index = 27 integer, public, parameter :: sp_POM_RES_in_index = 28 integer, public, parameter :: sp_EC_RES_NEW_in_index = 29 integer, public, parameter :: sp_EC_RES_AGE_in_index = 30 integer, public, parameter :: sp_REM_RES_in_index = 31 integer, public, parameter :: sp_FFIRE_OM_in_index = 32 integer, public, parameter :: sp_FFIRE_BC_in_index = 33 integer, public, parameter :: sp_FFIRE_REM_in_index = 34 integer, public, parameter :: sp_EC_RES_in_index = 35 integer, public, parameter :: sp_asoa_in_index = 36 integer, public, parameter :: sp_bsoa_in_index = 37 integer, public, parameter :: n_sp_all_index = 37 real, public, allocatable :: species_var3d_nc (:,:,:,:,:) real, public, allocatable :: species_EMEP_subgrid (:,:,:,:,:) integer, public :: species_loop_index (n_sp_all_index) integer, public :: n_species_loop_index = n_sp_index character(len=256), public :: species_name_nc (n_pmxx_sp_index,n_sp_all_index) real, public, allocatable :: orig_EMEP_deposition_subgrid (:,:,:,:,:) real, public, allocatable :: depo_var3d_nc (:,:,:,:,:) integer, public :: deposition_subgrid_dim (n_dim_index) real, public :: deposition_subgrid_min (2) real, public :: deposition_subgrid_max (2) integer, public, parameter :: vd_index = 1 integer, public, parameter :: drydepo_index = 2 integer, public, parameter :: wetdepo_index = 3 integer, public, parameter :: n_deposition_index = 3 real, public, allocatable :: deposition_subgrid (:,:,:,:,:) real, public, allocatable :: x_deposition_subgrid (:,:) real, public, allocatable :: y_deposition_subgrid (:,:) real, public, allocatable :: lon_deposition_subgrid (:,:) real, public, allocatable :: lat_deposition_subgrid (:,:) real, public, allocatable :: xproj_deposition_subgrid (:,:) real, public, allocatable :: yproj_deposition_subgrid (:,:) integer, public :: deposition_subgrid_loop_index (2) integer, public :: deposition_buffer_index (2) real, public :: deposition_buffer_size (2) real, public :: wetdepo_scavanging_rate (n_compound_index) real, public :: drydepo_vd_default (n_compound_index) integer, public :: landuse_subgrid_dim (n_dim_index) real, public :: landuse_subgrid_min (2) real, public :: landuse_subgrid_max (2) integer, public, parameter :: temp_conif_index = 1 integer, public, parameter :: temp_decid_index = 2 integer, public, parameter :: med_needle_index = 3 integer, public, parameter :: med_broadleaf_index = 4 integer, public, parameter :: temp_crop_index = 5 integer, public, parameter :: med_crop_index = 6 integer, public, parameter :: root_crop_index = 7 integer, public, parameter :: moorland_index = 8 integer, public, parameter :: grass_index = 9 integer, public, parameter :: medscrub_index = 10 integer, public, parameter :: wetlands_index = 11 integer, public, parameter :: tundra_index = 12 integer, public, parameter :: desert_index = 13 integer, public, parameter :: water_index = 13 integer, public, parameter :: ice_index = 14 integer, public, parameter :: urban_index = 15 integer, public, parameter :: grid_index = 16 integer, public, parameter :: clc_index = 17 integer, public, parameter :: n_landuse_index = 17 real, public, allocatable :: landuse_subgrid (:,:,:) real, public, allocatable :: x_landuse_subgrid (:,:) real, public, allocatable :: y_landuse_subgrid (:,:) real, public, allocatable :: lon_landuse_subgrid (:,:) real, public, allocatable :: lat_landuse_subgrid (:,:) real, public, allocatable :: xproj_landuse_subgrid (:,:) real, public, allocatable :: yproj_landuse_subgrid (:,:) integer, public :: landuse_subgrid_loop_index (2) integer, public :: landuse_buffer_index (2) real, public :: landuse_buffer_size (2) character(len=256), public :: deposition_name_nc (n_landuse_index,n_compound_nc_index) real, public :: depo_scale_nc (n_compound_nc_index) logical, public :: first_g_loop = .true. integer, public :: uEMEP_to_EMEP_sector (n_source_nc_index) = 0 character(len=2), public :: uEMEP_to_EMEP_sector_str (n_source_nc_index) = '' character(len=2), public :: uEMEP_to_EMEP_emis_sector_str (n_source_nc_index) = '' integer, public :: population_nc_projection_type = LL_projection_index integer, public, parameter :: max_n_local_fraction_grids = 3 integer, public :: frac_nc_loop_index (max_n_local_fraction_grids) integer, public :: local_nc_loop_index (max_n_local_fraction_grids) integer, public :: lc_frac_nc_loop_index (max_n_local_fraction_grids) integer, public :: lc_local_nc_loop_index (max_n_local_fraction_grids) integer, public :: min_frac_nc_loop_index integer, public :: max_frac_nc_loop_index integer, public :: min_lc_frac_nc_loop_index integer, public :: max_lc_frac_nc_loop_index integer, public :: convert_frac_to_lc_frac_loop_index (num_var_nc_name) integer, public :: local_fraction_grid_for_EMEP_grid_interpolation_source (n_source_index) = 1 real, public :: local_fraction_grid_size_scaling = 1.0 real, public :: EMEP_grid_interpolation_size_original = 1.0 real, public :: EMEP_grid_interpolation_size_source (n_source_index) = 1.0 real, public :: local_fraction_additional_grid_size_scaling = 1.0 real, public :: EMEP_additional_grid_interpolation_size_original = 0.0 character(len=256), public :: finished_file = '' character(len=256), public :: finished_file_rec = '' integer, public, parameter :: n_clc_landuse_index = 44 logical, public :: extract_benzene_from_voc_emissions = .false. real, public :: benzene_split_voc_in_GNFR_sectors (13) = [0.0449, 0.0212, 0.0668, 0.0084, 0.0, 0.0266, 0.0226, 0.0214, 0.0223, 0.0362, 0.068, 0.0601, 0.068] logical, public :: wind_vectors_10m_available = .false. integer, public, allocatable :: subgrid_region_index (:,:) integer, public, allocatable :: emission_subgrid_region_index (:,:,:) integer, public :: n_regions = -1 integer, public, parameter :: maxvalue_region_index = 1000 integer, public, allocatable :: regionindex_loop_index (:) integer, public :: regionindex_loop_back_index (maxvalue_region_index) integer, public :: ngrid_extended_margin = 0 integer, public :: nx_EMEP_extended = 0 integer, public :: ny_EMEP_extended = 0 real, public, allocatable :: regionfraction_per_EMEP_extended_grid (:,:,:) integer, public, allocatable :: EMEP_extended_subsample_region_id (:,:,:,:) integer, public :: n_subsamples_per_EMEP_grid = 20 real, public, allocatable :: subgrid_proxy_from_in_region (:,:,:,:,:) real, public, allocatable :: subgrid_local_from_in_region (:,:,:,:,:) real, public, allocatable :: subgrid_EMEP_local_from_in_region (:,:,:,:,:) real, public, allocatable :: subgrid_EMEP_semilocal_from_in_region (:,:,:,:,:)","tags":"","loc":"module/uemep_definitions.html"},{"title":"mod_read_esri_ascii_file – uEMEP","text":"Uses uEMEP_definitions Subroutines public  subroutine read_esri_ascii_header (filename_ascii_sub, ncols_sub, nrows_sub, cellsize_sub, xllcorner, yllcorner, read_nodata_flag) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub real :: cellsize_sub real :: xllcorner real :: yllcorner logical :: read_nodata_flag public  subroutine read_esri_ascii_file (filename_ascii_sub, ncols_sub, nrows_sub, cellsize_sub, val_array, x_array, y_array, read_nodata_flag) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) logical :: read_nodata_flag public  subroutine write_esri_ascii_file (filename_ascii_sub, ncols_sub, nrows_sub, cellsize_sub, val_array, x_array, y_array) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) private  subroutine read_esri_ascii_3d_file (filename_ascii_sub, ncols_sub, nrows_sub, nblocks_sub, cellsize_sub, val_array, x_array, y_array) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub integer :: nblocks_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub,nblocks_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub) private  subroutine write_esri_ascii_3d_file (filename_ascii_sub, ncols_sub, nrows_sub, nblocks_sub, cellsize_sub, val_array, x_array, y_array) Arguments Type Intent Optional Attributes Name character(len=*) :: filename_ascii_sub integer :: ncols_sub integer :: nrows_sub integer :: nblocks_sub real :: cellsize_sub real :: val_array (ncols_sub,nrows_sub,nblocks_sub) real :: x_array (ncols_sub,nrows_sub) real :: y_array (ncols_sub,nrows_sub)","tags":"","loc":"module/mod_read_esri_ascii_file.html"},{"title":"grid_roads – uEMEP","text":"Uses uemep_configuration mod_lambert_projection Functions private  function sigma0_traffic_func (speed) Arguments Type Intent Optional Attributes Name real :: speed Return Value real private  function minFF_traffic_func (speed) Arguments Type Intent Optional Attributes Name real :: speed Return Value real private  function line_fraction_in_grid_func (x_grid, y_grid, x_line, y_line) Arguments Type Intent Optional Attributes Name real :: x_grid (2) real :: y_grid (2) real :: x_line (2) real :: y_line (2) Return Value real Subroutines public  subroutine uEMEP_grid_roads () Arguments None private  subroutine tunnel_deposition_factor (tunnel_pollutant_index, tunnel_length, tunnel_ADT, ventilation_fac, min_ADT_ventilation_fac, min_length_ventilation_fac, windspeed_tunnel_in, ratio) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tunnel_pollutant_index real, intent(in) :: tunnel_length real, intent(in) :: tunnel_ADT real, intent(in) :: ventilation_fac real, intent(in) :: min_ADT_ventilation_fac real, intent(in) :: min_length_ventilation_fac real, intent(in) :: windspeed_tunnel_in real, intent(out) :: ratio private  subroutine save_gridded_lines_test_routine () Arguments None","tags":"","loc":"module/grid_roads.html"},{"title":"read_landuse_rivm_data – uEMEP","text":"Uses uemep_configuration mod_lambert_projection uEMEP_definitions crossreference_grids mod_read_esri_ascii_file Variables Type Visibility Attributes Name Initial integer, private :: Continuous_urban_fabric_value integer, private :: Discontinuous_urban_fabric_value integer, private :: Industrial_or_commercial_units_value integer, private :: Road_and_rail_networks_and_associated_land_value integer, private :: Port_areas_value integer, private :: Airports_value integer, private :: Mineral_extraction_sites_value integer, private :: Dump_sites_value integer, private :: Construction_sites_value integer, private :: Green_urban_areas_value integer, private :: Sport_and_leisure_facilities_value integer, private :: Non_irrigated_arable_land_value integer, private :: Permanently_irrigated_land_value integer, private :: Rice_fields_value integer, private :: Vineyards_value integer, private :: Fruit_trees_and_berry_plantations_value integer, private :: Olive_groves_value integer, private :: Pastures_value integer, private :: Annual_crops_associated_with_permanent_crops_value integer, private :: Complex_cultivation_patterns_value integer, private :: Land_principally_occupied_by_agriculture_value integer, private :: Agro_forestry_areas_value integer, private :: Broad_leaved_forest_value integer, private :: Coniferous_forest_value integer, private :: Mixed_forest_value integer, private :: Natural_grasslands_value integer, private :: Moors_and_heathland_value integer, private :: Sclerophyllous_vegetation_value integer, private :: Transitional_woodland_shrub_value integer, private :: Beaches_dunes_sands_value integer, private :: Bare_rocks_value integer, private :: Sparsely_vegetated_areas_value integer, private :: Burnt_areas_value integer, private :: Glaciers_and_perpetual_snow_value integer, private :: Inland_marshes_value integer, private :: Peat_bogs_value integer, private :: Salt_marshes_value integer, private :: Salines_value integer, private :: Intertidal_flats_value integer, private :: Water_courses_value integer, private :: Water_bodies_value integer, private :: Coastal_lagoons_value integer, private :: Estuaries_value integer, private :: Sea_and_ocean_value integer, private :: NODATA_clc_value integer, private, parameter :: n_corine_landuse_index = 48 integer, private :: Corine_to_EMEP_landuse (n_corine_landuse_index) Subroutines public  subroutine uEMEP_read_landuse_rivm_data () Arguments None public  subroutine uEMEP_read_netcdf_landuse_latlon () Arguments None public  subroutine uEMEP_set_landuse_classes () Arguments None","tags":"","loc":"module/read_landuse_rivm_data.html"},{"title":"uemep_configuration – uEMEP","text":"Uses uemep_constants uemep_logger uEMEP_definitions Variables Type Visibility Attributes Name Initial integer, public, parameter :: n_max_config_files = 10 character(len=256), public :: name_config_file (n_max_config_files) = '' character(len=256), public :: emission_date_str = '' integer, public :: n_config_files = 0 character(len=256), public :: config_date_str = '' character(len=256), public :: filename_log_file = 'uEMEP_log.txt' character(len=256), public :: pathname_log_file = '' character(len=256), public :: file_tag character(len=256), public :: replacement_date_str = '<>' character(len=256), public :: replacement_yesterday_date_str = '[]' character(len=256), public :: replacement_hour_str = '<>' character(len=256), public :: NORTRIP_replacement_hour_str = '<>' character(len=256), public :: input_comp_name character(len=256), public :: pathname_output_grid character(len=256), public :: filename_date_output_grid = '<replace_date>_<replace_hour>' character(len=256), public :: pathname_rl (2) character(len=256), public :: filename_rl (2) character(len=256), public :: pathname_mrl (50) character(len=256), public :: filename_mrl (50) character(len=256), public :: pathname_EMEP (4) character(len=256), public :: filename_EMEP (4) character(len=256), public :: pathfilename_EMEP (4) character(len=256), public :: original_filename_EMEP (4) character(len=256), public :: original_pathname_EMEP (4) character(len=256), public :: filename_ship (2) character(len=256), public :: pathname_ship (2) character(len=256), public :: pathfilename_ship (2) character(len=256), public :: filename_agriculture (2) character(len=256), public :: pathname_agriculture (2) character(len=256), public :: pathfilename_agriculture (2) character(len=256), public :: filename_emission_rivm (2) character(len=256), public :: pathname_emission_rivm (2) character(len=256), public :: pathfilename_emission_rivm (2) character(len=256), public :: filename_industry (10) character(len=256), public :: pathname_industry (10) character(len=256), public :: pathfilename_industry (10) character(len=256), public :: filename_heating (10) character(len=256), public :: pathname_heating (10) character(len=256), public :: pathfilename_heating (10) character(len=256), public :: filename_population (n_population_index) character(len=256), public :: pathname_population (n_population_index) character(len=256), public :: pathfilename_population (n_population_index) character(len=256), public :: filename_receptor character(len=256), public :: pathname_receptor character(len=256), public :: pathfilename_receptor character(len=256), public :: filename_timeprofile character(len=256), public :: pathname_timeprofile character(len=256), public :: pathfilename_timeprofile character(len=256), public :: alternative_meteorology_type = 'meps' character(len=256), public :: pathname_region_id = '' character(len=256), public :: filename_region_id = '' character(len=256), public :: region_name = '' character(len=256), public :: pathfilename_region_id = '' character(len=256), public :: pathname_tiles = '' character(len=256), public :: filename_tiles = '' character(len=256), public :: tile_tag = '' character(len=256), public :: save_tile_tag = '' character(len=256), public :: inpath_region_heating_scaling = '' character(len=256), public :: infile_region_heating_scaling = '' character(len=256), public :: pathfilename_region_heating_scaling = '' character(len=256), public :: pathname_rl_change = '' character(len=256), public :: filename_rl_change = '' character(len=256), public :: forecast_hour_str = '00' character(len=256), public :: NORTRIP_hour_str = '01' character(len=256), public :: pathname_emissions_for_EMEP = '' character(len=256), public :: save_emissions_for_EMEP_projection = 'lambert' character(len=256), public :: save_emissions_for_EMEP_region = 'NO' character(len=256), public :: var_name_nc (num_var_nc_name,n_pollutant_nc_index,n_source_nc_index) character(len=256), public :: filename_landuse = '' character(len=256), public :: pathname_landuse = '' character(len=256), public :: pathfilename_landuse = '' character(len=256), public :: emission_naming_template_str = 'Sec<n>_Emis_mgm2_' character(len=256), public :: pathname_boundingbox = '' character(len=256), public :: filename_boundingbox = '' character(len=256), public :: pathfilename_boundingbox = '' character(len=256), public :: select_country_by_name = '' character(len=256), public :: comp_name_nc (n_compound_nc_index) character(len=256), public :: var_name_population_nc (num_var_population_nc) character(len=256), public :: local_fraction_naming_template_str = 'sec<n>_local_fraction' character(len=256), public :: finished_filename = '' character(len=256), public :: finished_subpath = 'finished/' character(len=256), public :: var_name_landuse_nc (num_var_landuse_nc) character(len=256), public :: pathname_region_mask = '' character(len=256), public :: filename_region_mask = '' character(len=256), public :: varname_region_mask = 'region_index' logical, public :: hourly_calculations = .false. logical, public :: annual_calculations = .false. logical, public :: use_single_time_loop_flag = .false. logical, public :: reduce_EMEP_region_flag = .false. logical, public :: use_multiple_receptor_grids_flag = .false. logical, public :: reduce_roadlink_region_flag = .true. logical, public :: calculate_source (n_source_nc_index) = .false. logical, public :: calculate_EMEP_source (n_source_nc_index) = .false. logical, public :: make_EMEP_grid_emission_data (n_source_nc_index) = .false. logical, public :: replace_EMEP_local_with_subgrid_local (n_source_nc_index) = .false. logical, public :: subgrid_emission_distribution_flag = .false. logical, public :: EMEP_grid_interpolation_simple_flag = .false. logical, public :: use_downwind_position_flag = .false. logical, public :: average_zc_h_in_Kz_flag = .true. logical, public :: use_emission_positions_for_auto_subgrid_flag (n_source_index) = .false. logical, public :: use_receptor_positions_for_auto_subgrid_flag = .false. logical, public :: use_population_positions_for_auto_subgrid_flag = .false. logical, public :: interpolate_subgrids_flag = .false. logical, public :: use_trajectory_flag (n_source_index) = .false. logical, public :: calculate_aggregated_shipping_emissions_flag = .false. logical, public :: use_aggregated_shipping_emissions_flag = .true. logical, public :: calculate_population_exposure_flag = .false. logical, public :: use_last_meteo_in_dispersion = .false. logical, public :: use_meandering_in_dispersion = .false. logical, public :: use_traffic_for_sigma0_flag = .false. logical, public :: use_alternative_meteorology_flag = .false. logical, public :: use_alternative_z0_flag = .false. logical, public :: save_netcdf_file_flag = .false. logical, public :: save_netcdf_receptor_flag = .false. logical, public :: save_netcdf_fraction_as_contribution_flag = .false. logical, public :: calculate_tiling_flag = .false. logical, public :: calculate_region_tiling_flag = .false. logical, public :: use_region_select_and_mask_flag = .false. logical, public :: use_NORTRIP_emission_data = .false. logical, public :: use_NORTRIP_emission_pollutant (n_pollutant_nc_index) = .true. logical, public :: use_RWC_emission_data = .false. logical, public :: include_o3_in_aqi_index = .false. logical, public :: read_weekly_shipping_data_flag = .false. logical, public :: read_monthly_and_daily_shipping_data_flag = .false. logical, public :: use_tunnel_emissions_flag = .true. logical, public :: use_tunnel_deposition_flag = .false. logical, public :: save_emissions_for_EMEP (n_source_index) = .false. logical, public :: save_compounds = .true. logical, public :: save_source_contributions = .true. logical, public :: save_emep_source_contributions = .false. logical, public :: save_emep_additional_source_contributions = .false. logical, public :: save_total_source_contributions = .false. logical, public :: save_local_source_contributions_from_in_region = .false. logical, public :: save_semilocal_source_contributions_from_in_region = .false. logical, public :: save_total_source_contributions_from_in_region = .false. logical, public :: save_no2_source_contributions = .true. logical, public :: save_o3_source_contributions = .true. logical, public :: save_wind_vectors = .false. logical, public :: save_other_meteo = .false. logical, public :: save_emep_original = .true. logical, public :: save_emissions = .false. logical, public :: save_for_chemistry = .false. logical, public :: save_population = .false. logical, public :: save_aqi = .true. logical, public :: save_emep_species = .false. logical, public :: save_deposition = .false. logical, public :: save_seasalt = .false. logical, public :: save_netcdf_average_flag = .false. logical, public :: use_traffic_nox_emission_temperature_dependency = .false. logical, public :: calculate_deposition_flag = .false. logical, public :: calculate_source_depletion_flag = .false. logical, public :: read_landuse_flag = .false. logical, public :: use_plume_dispersion_deposition_flag = .false. logical, public :: adjust_wetdepo_integral_to_lowest_layer_flag = .false. logical, public :: auto_adjustment_for_summertime = .true. logical, public :: use_EMEP_surface_ozone_flag = .false. logical, public :: use_EMEP_surface_compounds_flag = .false. logical, public :: use_water_in_EMEP_surface_pm_flag = .false. logical, public :: save_compounds_as_ascii = .false. logical, public :: use_GNFR_emissions_from_EMEP_flag = .false. logical, public :: use_GNFR19_emissions_from_EMEP_flag = .false. logical, public :: use_alphabetic_GNFR_emissions_from_EMEP_flag = .false. logical, public :: use_emission_naming_template_flag = .false. logical, public :: read_OSM_roadlink_data_flag = .false. logical, public :: no_header_roadlink_data_flag = .false. logical, public :: use_user_specified_sectors_flag = .false. logical, public :: read_population_from_netcdf_flag = .false. logical, public :: read_population_from_netcdf_local_flag = .false. logical, public :: auto_select_OSM_country_flag = .false. logical, public :: select_latlon_centre_domain_position_flag = .false. logical, public :: read_shipping_from_netcdf_flag = .false. logical, public :: read_RWC_file_with_extra_HDD = .false. logical, public :: read_RWC_file_with_extra_HDD_and_height = .false. logical, public :: use_alternative_traveltime_weighting = .false. logical, public :: use_straightline_traveltime_distance = .false. logical, public :: limit_emep_grid_interpolation_region_to_calculation_region = .false. logical, public :: use_local_fraction_naming_template_flag = .false. logical, public :: use_local_fraction_grid_size_in_template_flag = .false. logical, public :: save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag = .false. logical, public :: use_annual_mean_pdf_chemistry_correction = .false. logical, public :: quick_annual_mean_pdf_chemistry_correction = .true. logical, public :: use_landuse_as_proxy = .false. logical, public :: read_rivm_landuse_flag = .false. logical, public :: use_rivm_agricuture_emission_data = .false. logical, public :: read_subgrid_emission_data = .false. logical, public :: use_rivm_subgrid_emission_format = .false. logical, public :: save_EMEP_somo35 = .false. logical, public :: save_EMEP_comax = .false. logical, public :: save_EMEP_o3max = .false. logical, public :: save_EMEP_o3_26th = .false. logical, public :: save_EMEP_so2 = .false. logical, public :: derive_SOA_from_other_species = .false. logical, public :: use_phi_for_invL = .false. logical, public :: trace_emissions_from_in_region = .false. logical, public :: calc_grid_vertical_average_concentration_annual_flag = .false. logical, public :: wind_level_zc_flag = .false. logical, public :: use_alternative_ppm_variable_for_lf = .false. logical, public :: save_emep_OP_species = .false. integer, public :: start_time_nc_index = 1 integer, public :: end_time_nc_index = 1 integer, public :: start_time_meteo_nc_index = 1 integer, public :: end_time_meteo_nc_index = 1 integer, public :: use_receptor_region = 1 integer, public :: projection_type = UTM_projection_index integer, public :: EMEP_projection_type = LCC_projection_index integer, public :: utm_zone = 33 integer, public :: EMEP_grid_interpolation_flag = 0 integer, public :: EMEP_meteo_grid_interpolation_flag = 1 integer, public :: EMEP_emission_grid_interpolation_flag = 0 integer, public :: local_subgrid_method_flag = 1 integer, public :: stability_scheme_flag integer, public :: wind_level_flag = 3 integer, public :: wind_level_integral_flag = 3 integer, public :: no2_chemistry_scheme_flag = 1 integer, public :: no2_background_chemistry_scheme_flag = 0 integer, public :: integral_subgrid_step = 1 integer, public :: n_subsource (n_source_index) = 1 integer, public :: num_multiple_roadlink_files = 0 integer, public :: population_data_type = population_index integer, public :: emission_timeprofile_hour_shift = 1 integer, public :: region_id = 0 integer, public :: region_index = 0 integer, public :: HDD_threshold_value = 15 integer, public :: n_kz_iterations = 2 integer, public :: save_emissions_start_index = 1 integer, public :: save_emissions_end_index = 24 integer, public :: EMEP_surface_level_nc = 1 integer, public :: EMEP_surface_level_nc_2 = 1 integer, public :: uEMEP_to_EMEP_replace_sector (n_source_nc_index) = 0 integer, public :: local_fraction_grid_size (max_n_local_fraction_grids) = 1 integer, public :: n_local_fraction_grids = 1 integer, public :: local_fraction_grid_for_EMEP_grid_interpolation = 1 integer, public :: local_fraction_grid_for_EMEP_additional_grid_interpolation = 1 integer, public :: n_var_av = 100 integer, public :: convert_uEMEP_to_GNFR_sector_index (n_source_nc_index) integer, public :: Kz_scheme = 2 integer, public :: save_emission_subgrid_dim (n_dim_index) integer, public :: alternative_ppm_variable_for_lf_dim = 4 real, public :: utm_lon0 = 15. real, public :: ltm_lon0 = 0. real, public :: EMEP_grid_interpolation_size = 1. real, public :: EMEP_additional_grid_interpolation_size = 0. real, public :: traj_step_scale = 2.0 real, public :: subgrid_delta (2) real, public :: subgrid_min (2) real, public :: subgrid_max (2) real, public :: init_subgrid_delta (2) real, public :: init_subgrid_min (2) real, public :: init_subgrid_max (2) real, public :: deposition_subgrid_delta (2) = 0.0 real, public :: landuse_subgrid_delta (2) = 0.0 real, public :: h_emis (n_source_index,n_possible_subsource) real, public :: sig_y_00 (n_source_index,n_possible_subsource) real, public :: sigy_0_subgid_width_scale = 0.25 real, public :: sig_z_00 (n_source_index,n_possible_subsource) real, public :: FF_min_dispersion = 0.1 real, public :: ustar_min = 0.001 real, public :: hmix_min = 25.0 real, public :: hmix_max = 2000.0 real, public :: emission_factor (n_compound_nc_index,n_source_index,n_possible_subsource) = 1.0 real, public :: ratio_truck_car_emission (n_compound_nc_index) = 10.0 real, public :: z_rec (n_source_index,n_possible_subsource) real, public :: ay (n_source_index,n_possible_subsource) real, public :: replace_invL = NODATA_value real, public :: replace_hmix = NODATA_value real, public :: FF_scale = NODATA_value real, public :: FF10_offset = NODATA_value real, public :: DD_offset = NODATA_value real, public :: J_scale = NODATA_value real, public :: replace_z0 = NODATA_value real, public :: region_subgrid_delta = 50.0 real, public :: max_interpolation_subgrid_size = 1000.0 real, public :: DMT_min_value = -20.0 real, public :: integral_subgrid_delta_ref = 0. real, public :: ventilation_factor = 1.0 real, public :: min_ADT_ventilation_factor = 0.0 real, public :: min_length_ventilation_factor = 0.0 real, public :: windspeed_tunnel = 1.0 real, public :: lowest_stable_L = 1.0e6 real, public :: lowest_unstable_L = -10.0 real, public :: tunnel_sig_z_00 = 5.0 real, public :: bridge_h_emis = 10.0 real, public :: traffic_nox_emission_temperature_ref_temperature (2) real, public :: traffic_nox_emission_temperature_ref_scaling (2) real, public :: limit_industry_delta = 250.0 real, public :: limit_shipping_delta = 250.0 real, public :: limit_heating_delta = 250.0 real, public :: limit_population_delta = 250.0 real, public :: EMEP_emission_aggregation_period = 1.0 real, public :: select_lat_centre_position = 60.0 real, public :: select_lon_centre_position = 11.0 real, public :: select_domain_width_EW_km = 20.0 real, public :: select_domain_height_NS_km = 20.0 real, public :: osm_adt_power_scale = 1.0 real, public :: romberg_parameters (3) = 0.0 real, public :: SRM_parameters (3) = 0.0 real, public :: sig_y_scaling_factor = 2.0 real, public :: min_proxy_emission_shipping_value = 0.0 real, public :: population_power_scale = 1.0 real, public :: H_emep = 90.0 real, public :: comp_scale_nc (n_compound_nc_index) real, public :: traveltime_power = 1. real, public :: traveltime_scaling = 1.0 real, public :: f_no2_emep = 0.1 real, public :: ox_sigma_ratio_pdf = 0.0 real, public :: nox_sigma_ratio_pdf = 0.0 real, public :: max_bin_pdf = 1000.0 real, public :: min_bin_pdf = 0.0001 real, public :: log10_step_bin_pdf = 0.05 real, public :: landuse_proxy_weighting (n_source_index,n_clc_landuse_index) = 0.0 real, public :: scale_GNFR_emission_source (n_source_index) = 1.0 real, public :: subgrid_receptor_offset (2) = 0.0 real, public :: z_invL = 10.0 real, public :: save_emission_subgrid_min (2) real, public :: save_emission_subgrid_delta (2) double precision, public :: projection_attributes (10) double precision, public :: EMEP_projection_attributes (10)","tags":"","loc":"module/uemep_configuration.html"},{"title":"mod_rdm2ll – uEMEP","text":"Subroutines public  subroutine RDM2LL (y, x, lat, lon) Arguments Type Intent Optional Attributes Name real :: y real :: x real :: lat real :: lon","tags":"","loc":"module/mod_rdm2ll.html"},{"title":"crossreference_grids – uEMEP","text":"Uses uemep_configuration mod_lambert_projection uEMEP_definitions Subroutines public  subroutine uEMEP_crossreference_grids () Arguments None","tags":"","loc":"module/crossreference_grids.html"},{"title":"chemistry_no2 – uEMEP","text":"Uses time_functions uemep_configuration uemep_constants uEMEP_definitions Subroutines public  subroutine uEMEP_chemistry () Arguments None public  subroutine uEMEP_source_fraction_chemistry () !!! for now, just use no2/nox ratio of the first subsource Arguments None private  subroutine uEMEP_photostationary_NO2 (nox_bg, no2_bg, o3_bg, nox_loc, f_no2_loc, J_photo, temperature, nox_out, no2_out, o3_out, p_bg_out, p_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: o3_bg real, intent(in) :: nox_loc real, intent(in) :: f_no2_loc real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(out) :: p_bg_out real, intent(out) :: p_out private  subroutine uEMEP_phototimescale_NO2 (nox_bg, no2_bg, o3_bg, nox_loc, f_no2_loc, J_photo, temperature, time_scale, nox_out, no2_out, o3_out, p_bg_out, p_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: o3_bg real, intent(in) :: nox_loc real, intent(in) :: f_no2_loc real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(in) :: time_scale real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(out) :: p_bg_out real, intent(out) :: p_out private  subroutine uEMEP_Romberg_NO2 (nox_bg, no2_bg, nox_loc, o3_bg, f_no2_loc, nox_out, no2_out, o3_out, romberg_params) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: nox_loc real, intent(in) :: o3_bg real, intent(in) :: f_no2_loc real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(in) :: romberg_params (3) private  subroutine uEMEP_SRM_NO2 (nox_bg, no2_bg, nox_loc, o3_bg, f_no2_loc, nox_out, no2_out, o3_out, SRM_params) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: nox_loc real, intent(in) :: o3_bg real, intent(in) :: f_no2_loc real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(in) :: SRM_params (3) private  subroutine uEMEP_During_NO2 (nox_bg, no2_bg, nox_loc, o3_bg, f_no2_loc, nox_emep, no2_emep, o3_emep, J_photo, temperature, nox_out, no2_out, o3_out, p_bg_out, p_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: no2_bg real, intent(in) :: nox_loc real, intent(in) :: o3_bg real, intent(in) :: f_no2_loc real, intent(in) :: nox_emep real, intent(in) :: no2_emep real, intent(in) :: o3_emep real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(out) :: nox_out real, intent(out) :: no2_out real, intent(out) :: o3_out real, intent(out) :: p_bg_out real, intent(out) :: p_out private  subroutine uEMEP_nonlocal_NO2_O3 (nox_bg, nox_emep, no2_emep, o3_emep, J_photo, temperature, f_no2, no2_out, o3_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: nox_bg real, intent(in) :: nox_emep real, intent(in) :: no2_emep real, intent(in) :: o3_emep real, intent(in) :: J_photo real, intent(in) :: temperature real, intent(in) :: f_no2 real, intent(out) :: no2_out real, intent(out) :: o3_out public  subroutine correct_annual_mean_chemistry () Arguments None private  subroutine uEMEP_annual_mean_pdf_correction_NO2_O3 (bin_min, bin_max, delta_log10_bin, run_all, no2_in, nox_in, o3_in, J_photo_in, temperature_in, ox_sigma_ratio_in, nox_sigma_ratio_in, lon_in, lat_in, no2_out, o3_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: bin_min real, intent(in) :: bin_max real, intent(in) :: delta_log10_bin logical, intent(in) :: run_all real, intent(in) :: no2_in real, intent(in) :: nox_in real, intent(in) :: o3_in real, intent(in) :: J_photo_in real, intent(in) :: temperature_in real, intent(in) :: ox_sigma_ratio_in real, intent(in) :: nox_sigma_ratio_in real, intent(in) :: lon_in real, intent(in) :: lat_in real, intent(out) :: no2_out real, intent(out) :: o3_out","tags":"","loc":"module/chemistry_no2.html"},{"title":"read_time_profiles – uEMEP","text":"Uses time_functions uemep_configuration Subroutines public  subroutine uEMEP_read_time_profiles () Arguments None","tags":"","loc":"module/read_time_profiles.html"},{"title":"mod_rargsort – uEMEP","text":"Functions private  function rargsort_original (a) result(b) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (:) Return Value integer, (size(a)) Subroutines public  subroutine rargsort (a, b, n_a) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (n_a) integer, intent(out) :: b (n_a) integer :: n_a","tags":"","loc":"module/mod_rargsort.html"},{"title":"set_filenames – uEMEP","text":"Uses uemep_configuration uEMEP_definitions Subroutines public  subroutine uEMEP_set_filenames () Set filenames for all gridded data to be saved\nThese are the names now given in the netcdf files Arguments None","tags":"","loc":"module/set_filenames.html"},{"title":"read_receptor_data – uEMEP","text":"Uses uemep_configuration utility_functions mod_lambert_projection Subroutines public  subroutine uEMEP_read_receptor_data () Arguments None public  subroutine uEMEP_grid_receptor_data () Arguments None public  subroutine uEMEP_set_loop_receptor_grid () Arguments None","tags":"","loc":"module/read_receptor_data.html"},{"title":"set_dispersion_parameters – uEMEP","text":"Uses uemep_configuration Subroutines public  subroutine uEMEP_set_dispersion_params_simple (source_index, subsource_index) Arguments Type Intent Optional Attributes Name integer :: source_index integer :: subsource_index public  subroutine uEMEP_set_dispersion_params_PG (invL, source_index, subsource_index) Arguments Type Intent Optional Attributes Name real :: invL integer :: source_index integer :: subsource_index public  subroutine delta_wind_direction (i_cross, j_cross, tt, temp_FF_subgrid, angle_diff) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i_cross integer, intent(in) :: j_cross integer, intent(in) :: tt real, intent(in) :: temp_FF_subgrid real, intent(out) :: angle_diff public  subroutine uEMEP_set_dispersion_sigma_simple (sig_z_00, sig_y_00, sigy_0_subgid_width_scale, subgrid_delta, delta_wind, x, sig_z, sig_y, sig_z_0, sig_y_0) Arguments Type Intent Optional Attributes Name real, intent(in) :: sig_z_00 real, intent(in) :: sig_y_00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: subgrid_delta (2) real, intent(in) :: delta_wind real, intent(in) :: x real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: sig_z_0 real, intent(out) :: sig_y_0 public  subroutine uEMEP_set_dispersion_sigma_PG (invL_in, logz0, sig_z_00, sig_y_00, sigy_0_subgid_width_scale, subgrid_delta, delta_wind, x, sig_z, sig_y, sig_z_0, sig_y_0) Arguments Type Intent Optional Attributes Name real, intent(in) :: invL_in real, intent(in) :: logz0 real, intent(in) :: sig_z_00 real, intent(in) :: sig_y_00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: subgrid_delta (2) real, intent(in) :: delta_wind real, intent(in) :: x real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: sig_z_0 real, intent(out) :: sig_y_0 public  subroutine uEMEP_set_dispersion_sigma_Kz_emulator (z_emis, invL, logz0, z_pbl, sig_z_00, sig_y_00, sigy_0_subgid_width_scale, subgrid_delta, delta_wind, x, sig_z, sig_y, sig_z_0, sig_y_0) Arguments Type Intent Optional Attributes Name real, intent(in) :: z_emis real, intent(in) :: invL real, intent(in) :: logz0 real, intent(in) :: z_pbl real, intent(in) :: sig_z_00 real, intent(in) :: sig_y_00 real, intent(in) :: sigy_0_subgid_width_scale real, intent(in) :: subgrid_delta (2) real, intent(in) :: delta_wind real, intent(in) :: x real, intent(out) :: sig_z real, intent(out) :: sig_y real, intent(out) :: sig_z_0 real, intent(out) :: sig_y_0","tags":"","loc":"module/set_dispersion_parameters.html"},{"title":"mod_lambert_projection – uEMEP","text":"Uses mod_rdm2ll uemep_constants utility_functions uEMEP_definitions Subroutines private  subroutine testlambert () Arguments None private  subroutine lambert2lb (x, y, gl, gb, lon0, y0, k, F) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: gl real, intent(out) :: gb real, intent(in) :: lon0 real, intent(in) :: y0 real, intent(in) :: k real, intent(in) :: F private  subroutine lb2lambert (x, y, gl, gb, lon0, y0, k, F) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: gl real, intent(in) :: gb real, intent(in) :: lon0 real, intent(in) :: y0 real, intent(in) :: k real, intent(in) :: F private  subroutine lambert2lb_uEMEP (x, y, gl, gb, lon0, lat0) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: gl real, intent(out) :: gb real, intent(in) :: lon0 real, intent(in) :: lat0 public  subroutine lambert2lb2_uEMEP (x, y, gl, gb, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: gl real, intent(out) :: gb double precision, intent(in) :: projection_attr (10) public  subroutine lb2lambert_uEMEP (x, y, gl, gb, lon0, lat0) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: gl real, intent(in) :: gb real, intent(in) :: lon0 real, intent(in) :: lat0 public  subroutine lb2lambert2_uEMEP (x, y, gl, gb, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: gl real, intent(in) :: gb double precision, intent(in) :: projection_attr (10) private  subroutine LL2LAEA_spherical (x, y, lon_in, lat_in, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: lon_in real, intent(in) :: lat_in double precision, intent(in) :: projection_attr (10) private  subroutine LAEA2LL_spherical (x, y, lon, lat, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: lon real, intent(out) :: lat double precision, intent(in) :: projection_attr (10) public  subroutine LL2LAEA (x, y, lon_in, lat_in, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: lon_in real, intent(in) :: lat_in double precision, intent(in) :: projection_attr (10) private  subroutine LAEA2LL (x, y, lon, lat, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: lon real, intent(out) :: lat double precision, intent(in) :: projection_attr (10) public  subroutine PROJ2LL (x_in, y_in, lon_out, lat_out, projection_attributes_in, projection_type_in) Arguments Type Intent Optional Attributes Name real, intent(in) :: x_in real, intent(in) :: y_in real, intent(out) :: lon_out real, intent(out) :: lat_out double precision, intent(in) :: projection_attributes_in (10) integer, intent(in) :: projection_type_in public  subroutine LL2PROJ (lon_in, lat_in, x_out, y_out, projection_attributes_out, projection_type_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: lon_in real, intent(in) :: lat_in real, intent(out) :: x_out real, intent(out) :: y_out double precision, intent(in) :: projection_attributes_out (10) integer, intent(in) :: projection_type_out public  subroutine LL2PS_spherical (x, y, lon_in, lat_in, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(out) :: x real, intent(out) :: y real, intent(in) :: lon_in real, intent(in) :: lat_in double precision, intent(in) :: projection_attr (10) private  subroutine PS2LL_spherical (x, y, lon, lat, projection_attr) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(out) :: lon real, intent(out) :: lat double precision, intent(in) :: projection_attr (10)","tags":"","loc":"module/mod_lambert_projection.html"},{"title":"uEMEP_v6 – uEMEP","text":"Uses save_netcdf_file read_roadlink_data_ascii tiling_routines uemep_logger subgrid_deposition subgrid_emission_emep save_emission_netcdf read_meteo_nc subgrid_deposition_emep uemep_configuration set_subgrids set_emission_factors subgrid_meteo_emep uEMEP_definitions crossreference_grids auto_subgrid set_constants read_time_profiles redistribute_data set_filenames read_receptor_data read_shipping_asi_data read_config read_rwc_heating_data read_emep define_subgrid grid_roads read_agriculture_asi_data subgrid_emep read_ssb_data calculate_exposure read_industry_data read_landuse_rivm_data subgrid_dispersion chemistry_no2 read_command_line uEMEP control v2 Bruce rolstad Denby (brucerd@met.no)\n  MET Norway Reminder note for compilation on Intel\nTo add this library to your linker input in the IDE, open the context menu for the project node, choose Properties, then in the Project Properties dialog box, choose Linker\n, and edit the Linker Input to add legacy_stdio_definitions.lib to the semi-colon-separated list\nTools/options/intel compilers and tools/visual fortran/compilers and add bin, include and lib, e.g. C:\\Program Files (x86)\\netcdf 4.3.3.1\\bin;\n  Control programme for running the downscaling routine uEMEP To link to netcdf in visual studio\nTools - options - Intel compilers - VisusalFortran - Compilers - Libraries/includes/executables\nC:\\Program Files (x86)\\netcdf 4.3.3.1\\include\nC:\\Program Files (x86)\\netcdf 4.3.3.1\\bin\nC:\\Program Files (x86)\\netcdf 4.3.3.1\\lib Variables Type Attributes Name Initial integer :: source_index real :: start_time_cpu real :: end_time_cpu logical :: have_read_emep = .false. character(len=64) :: logfile_name = \"logfile.txt\" character(len=64) :: program_name Source Code program uEMEP_v6 !! **************************************************************************** !!   uEMEP control v2 !! !!   Bruce rolstad Denby (brucerd@met.no) !!   MET Norway !! **************************************************************************** !! Reminder note for compilation on Intel !! To add this library to your linker input in the IDE, open the context menu for the project node, choose Properties, then in the Project Properties dialog box, choose Linker !! , and edit the Linker Input to add legacy_stdio_definitions.lib to the semi-colon-separated list !! Tools/options/intel compilers and tools/visual fortran/compilers and add bin, include and lib, e.g. C:\\Program Files (x86)\\netcdf 4.3.3.1\\bin; !!   Control programme for running the downscaling routine uEMEP !! **************************************************************************** !! !! **************************************************************************** !! To link to netcdf in visual studio !! Tools - options - Intel compilers - VisusalFortran - Compilers - Libraries/includes/executables !! C:\\Program Files (x86)\\netcdf 4.3.3.1\\include !! C:\\Program Files (x86)\\netcdf 4.3.3.1\\bin !! C:\\Program Files (x86)\\netcdf 4.3.3.1\\lib use uemep_configuration use uEMEP_definitions use read_command_line , only : uEMEP_read_command_line , check_command_line use set_constants , only : uEMEP_set_constants , uEMEP_set_pollutant_loop , & uEMEP_reset_constants , uEMEP_set_species_loop use read_config , only : uEMEP_read_config use read_emep , only : uEMEP_read_EMEP use read_meteo_nc , only : uEMEP_read_meteo_nc use read_rwc_heating_data , only : uEMEP_read_RWC_heating_data use save_emission_netcdf , only : uEMEP_calculate_emissions_for_EMEP use set_subgrids , only : uEMEP_set_subgrids , uEMEP_set_subgrid_select_latlon_centre use read_landuse_rivm_data , only : uEMEP_read_landuse_rivm_data , & uEMEP_set_landuse_classes , uEMEP_read_netcdf_landuse_latlon use read_roadlink_data_ascii , only : read_country_bounding_box_data , & uEMEP_read_roadlink_data_ascii , uEMEP_change_road_data , uEMEP_read_roadlink_emission_data use set_filenames , only : uEMEP_set_filenames use read_receptor_data , only : uEMEP_read_receptor_data , uEMEP_set_loop_receptor_grid , & uEMEP_grid_receptor_data use read_ssb_data , only : uEMEP_read_netcdf_population , uEMEP_read_SSB_data , & uEMEP_read_netcdf_population_latlon use read_agriculture_asi_data , only : uEMEP_read_agriculture_rivm_data , & uEMEP_read_emission_rivm_data use read_industry_data , only : uEMEP_read_industry_data use read_shipping_asi_data , only : uEMEP_preaggregate_shipping_asi_data , & uEMEP_read_netcdf_shipping_latlon , uEMEP_read_weekly_shipping_asi_data , & uEMEP_read_monthly_and_daily_shipping_asi_data , uEMEP_read_shipping_asi_data use read_time_profiles , only : uEMEP_read_time_profiles use redistribute_data , only : uEMEP_redistribute_local_source , uEMEP_disperse_local_source , & uEMEP_combine_local_source use save_netcdf_file , only : uEMEP_save_netcdf_control use subgrid_deposition , only : uEMEP_subgrid_deposition use subgrid_dispersion , only : uEMEP_subgrid_dispersion use set_emission_factors , only : uEMEP_set_emission_factors , uEMEP_convert_proxy_to_emissions , & uEMEP_nox_emission_temperature use subgrid_emep , only : uEMEP_subgrid_EMEP , uEMEP_subgrid_EMEP_from_in_region use subgrid_deposition_emep , only : uEMEP_set_deposition_velocities , & uEMEP_subgrid_deposition_EMEP , uEMEP_calculate_deposition use subgrid_emission_emep , only : uEMEP_subgrid_emission_EMEP use subgrid_meteo_emep , only : uEMEP_subgrid_meteo_EMEP use tiling_routines , only : uEMEP_set_tile_grids , uEMEP_set_region_tile_grids use chemistry_no2 , only : uEMEP_chemistry , correct_annual_mean_chemistry use crossreference_grids , only : uEMEP_crossreference_grids use grid_roads , only : uEMEP_grid_roads use define_subgrid , only : uEMEP_define_subgrid_extent , uEMEP_define_subgrid use calculate_exposure , only : uEMEP_calculate_exposure use auto_subgrid , only : uEMEP_region_mask_new use uemep_logger implicit none integer :: source_index real :: start_time_cpu , end_time_cpu logical :: have_read_emep = . false . character ( len = 64 ) :: logfile_name = \"logfile.txt\" , program_name ! Start timer call cpu_Time ( start_time_cpu ) ! Check command line arguments and handle special cases that have to be printed to stdout call check_command_line () ! Set model version model_version_str = 'uEMEP_v6.3' write ( * , * ) '' write ( * , * ) '------------------------------------------------------------------------' write ( * , * ) 'Starting program ' // trim ( model_version_str ) write ( * , * ) '------------------------------------------------------------------------' ! Read the command line, assigning the configuration file names and the substitution date_str call uEMEP_read_command_line () ! Set constants and variable names to be read from EMEP and meteo files call uEMEP_set_constants () ! Read the configuration files. Hard coded to be up to 5 files. Log file opened in this routine call uEMEP_read_config () ! If selected then specify subgrid using the lat and lon coordinates if ( select_latlon_centre_domain_position_flag ) then call uEMEP_set_subgrid_select_latlon_centre () end if ! Set the landuse if required if ( use_landuse_as_proxy . or . read_landuse_flag ) then call uEMEP_set_landuse_classes () end if ! Set the pollutant and compound loop definitions call uEMEP_set_pollutant_loop () !Reset any constants needed based on the configuration input call uEMEP_reset_constants () ! Autoselect files and countries if required. Place here because it changes config data if ( auto_select_OSM_country_flag . or . trim ( select_country_by_name ) . ne . '' ) then call read_country_bounding_box_data () end if ! Set the EMEP species definitions if they are to be read call uEMEP_set_species_loop () ! Set the names of files to be written to when saving intermediate files call uEMEP_set_filenames () ! Read positions of receptor points (usually observations) for specifying multiple receptor grids or calculation points within a single grid call uEMEP_read_receptor_data () ! Enter the routine for saving emissions used in uEMEP for EMEP in netcdf files defined for the Norwegian domain in Lambert coordinates. Will stop after this if ( save_emissions_for_EMEP ( allsource_index )) then call uEMEP_calculate_emissions_for_EMEP () end if ! We set up an initial emission grid parameter set that can be used to first select the outester region ! This has been done to enable reading of multiple road link files but only keeping those in the initial defined emission area call uEMEP_set_subgrids () init_emission_subgrid_min = emission_subgrid_min init_emission_subgrid_max = emission_subgrid_max init_emission_subgrid_dim = emission_subgrid_dim init_emission_subgrid_delta = emission_subgrid_delta ! Set the grid loop (g_loop) extent based on use_multiple_receptor_grids_flag or not if ( use_multiple_receptor_grids_flag ) then start_grid_loop_index = 1 end_grid_loop_index = n_receptor_in n_receptor = 1 n_valid_receptor = 1 valid_receptor_index ( 1 ) = 1 else start_grid_loop_index = 1 end_grid_loop_index = 1 n_receptor = n_receptor_in use_receptor ( start_grid_loop_index ) = . true . end if first_g_loop = . true . ! If the use_single_time_loop_flag is true (Reads and calculates one time step at a time to save memory) then set these parameters if ( use_single_time_loop_flag ) then start_time_loop_index = 1 end_time_loop_index = end_time_nc_index - start_time_nc_index + 1 subgrid_dim ( t_dim_index ) = 1 dim_length_nc ( time_dim_nc_index ) = 1 else start_time_loop_index = 1 end_time_loop_index = 1 subgrid_dim ( t_dim_index ) = end_time_nc_index - start_time_nc_index + 1 dim_length_nc ( time_dim_nc_index ) = subgrid_dim ( t_dim_index ) end if ! Start internal grid receptor loop using only those receptor grids specified in uEMEP_read_receptor_data do g_loop = start_grid_loop_index , end_grid_loop_index if ( use_receptor ( g_loop )) then ! Set the grid definitions according to the receptor/observation positions call uEMEP_set_loop_receptor_grid () ! Create the subgrid call uEMEP_set_subgrids () ! Set emission factors for the current subgrid call uEMEP_set_emission_factors () ! Start the internal time loop do t_loop = start_time_loop_index , end_time_loop_index ! Write progress in time and receptor grid loop to screen write ( * , * ) 'REC LOOP= ' , g_loop , ' OF ' , end_grid_loop_index if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) 'REC LOOP= ' , g_loop , ' OF ' , end_grid_loop_index end if write ( * , * ) 'TIME LOOP=' , t_loop , ' OF ' , end_time_loop_index if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) 'TIME LOOP=' , t_loop , ' OF ' , end_time_loop_index end if ! For the first time loop set the initial subgrid range values used in reading EMEP and meteo data if ( t_loop . ge . start_time_loop_index ) then init_subgrid_min = subgrid_min init_subgrid_max = subgrid_max end if ! Read EMEP data from netcdf files. Time stamps based on this if ( . not . have_read_emep ) then call uEMEP_read_EMEP () end if ! If read EMEP only once flag is on then turn off the EMEP reading ! This is intended for use with multiple receptor files and requires alot of memory so is permanently turned off if ( read_EMEP_only_once_flag ) have_read_emep = . true . ! Read meteo grid from netcdf files if required if ( use_alternative_meteorology_flag . or . use_alternative_z0_flag ) then call uEMEP_read_meteo_nc () end if ! Set the following for the first internal time step only if ( t_loop . eq . start_time_loop_index ) then ! Define subgrid positions and buffer zones. Must be done after reading EMEP data as is based on EMEP grid sizes call uEMEP_define_subgrid_extent () call uEMEP_define_subgrid () ! Define and allocate cross reference subgrids used to transfer data between different subgrids call uEMEP_crossreference_grids () ! Read all road link data from ascii files if ( calculate_source ( traffic_index ) . and . . not . read_subgrid_emission_data ) then ! Do this only for the first receptor grid loop if ( first_g_loop ) then call uEMEP_read_roadlink_data_ascii () call uEMEP_change_road_data () ! Read in the NORTRIP emission data for traffic in the first g_loop if required if ( use_NORTRIP_emission_data ) then call uEMEP_read_roadlink_emission_data () end if end if end if ! Read in and grid industry data if ( calculate_source ( industry_index ) . and . . not . read_subgrid_emission_data ) then call uEMEP_read_industry_data () end if ! Read and subgrid shipping data if ( calculate_source ( shipping_index ) . and . . not . read_subgrid_emission_data ) then ! If necessary aggregate shipping data first call uEMEP_preaggregate_shipping_asi_data () ! Read in shipping data if ( read_shipping_from_netcdf_flag ) then call uEMEP_read_netcdf_shipping_latlon () else if ( read_weekly_shipping_data_flag ) then call uEMEP_read_weekly_shipping_asi_data () else if ( read_monthly_and_daily_shipping_data_flag ) then call uEMEP_read_monthly_and_daily_shipping_asi_data () else call uEMEP_read_shipping_asi_data () end if end if end if ! Read in proxy data for home heating. Currently dwelling density if ( calculate_source ( heating_index ) . and . . not . read_subgrid_emission_data ) then ! If calculating tiles then read only the dwelling data if ( calculate_tiling_flag . or . calculate_region_tiling_flag ) then use_RWC_emission_data = . false . end if ! Read the Residential Wood Combustion data from MetVed if ( use_RWC_emission_data ) then call uEMEP_read_RWC_heating_data () else ! Read and subgrid SSB dwelling data SSB_data_type = dwelling_index if ( read_population_from_netcdf_flag ) then call uEMEP_read_netcdf_population_latlon () else if ( read_population_from_netcdf_local_flag ) then call uEMEP_read_netcdf_population () else call uEMEP_read_SSB_data () end if end if end if ! Read and subgrid agriculture data if ( calculate_source ( agriculture_index ) . and . use_rivm_agricuture_emission_data . and . . not . read_subgrid_emission_data ) then ! Currently only data from RIVM here call uEMEP_read_agriculture_rivm_data () end if if ( read_rivm_landuse_flag ) then call uEMEP_read_landuse_rivm_data () end if if ( read_subgrid_emission_data ) then ! Special routine for reading in RIVM point source emission data if ( use_rivm_subgrid_emission_format ) then call uEMEP_read_emission_rivm_data () else ! Nothing else available yet end if end if ! Read in population data if ( calculate_population_exposure_flag . or . use_population_positions_for_auto_subgrid_flag . or . save_population ) then ! Read and subgrid SSB population data SSB_data_type = population_data_type if ( read_population_from_netcdf_flag ) then call uEMEP_read_netcdf_population_latlon () else if ( read_population_from_netcdf_local_flag ) then call uEMEP_read_netcdf_population () else call uEMEP_read_SSB_data () end if end if if ( use_landuse_as_proxy . or . read_landuse_flag ) then call uEMEP_read_netcdf_landuse_latlon () end if ! Autogrid setting for selecting which subgrids to calculate if ( use_emission_positions_for_auto_subgrid_flag ( allsource_index )) then call uEMEP_grid_roads () write ( unit_logfile , * ) \"'uEMEP_auto_subgrid' has been disabled, because array 'use_subgrid_val' is disabled\" stop !call uEMEP_auto_subgrid() end if ! No longer call uEMEP_region_mask, as use_subgrid_val is deactivated and use_subgrid is set elsewhere !if (use_region_select_and_mask_flag) then !    call uEMEP_region_mask() !end if ! New subroutine for reading region mask and region fraction if ( trace_emissions_from_in_region . or . use_region_select_and_mask_flag ) then call uEMEP_region_mask_new () endif ! Specify the subgrids sizes to be calculated using use_receptor_region call uEMEP_grid_receptor_data ! Carry out tiling. Programme will stop here if ( calculate_tiling_flag ) then call uEMEP_grid_roads () call uEMEP_set_tile_grids () end if ! Carry out regional tiling. Programme will stop here if ( calculate_region_tiling_flag ) then call uEMEP_set_region_tile_grids () end if end if ! Read time profiles for emissions call uEMEP_read_time_profiles () ! Call grid_roads again to include the time variation from NORTRIP if ( . not . read_subgrid_emission_data ) then call uEMEP_grid_roads () end if ! Interpolate meteo data to subgrid. Placed on the integral subgrid call uEMEP_subgrid_meteo_EMEP () ! Replaces proxy emissions with distributed EMEP emissions call uEMEP_subgrid_emission_EMEP () ! Convert proxies to emissions including time profiles call uEMEP_convert_proxy_to_emissions () ! Adjust traffic emissions of NOx based on temperature if ( use_traffic_nox_emission_temperature_dependency ) then call uEMEP_nox_emission_temperature () end if ! Places EMEP deposition velocities into the deposition_subgrid if ( calculate_deposition_flag ) then call uEMEP_set_deposition_velocities () end if ! Set travel_time values to 0 outside of the source loop as these are aggregated over all sources traveltime_subgrid = 0.0 ! Subgrid dispersion calculation do source_index = 1 , n_source_index if ( calculate_source ( source_index ) . and . . not . use_plume_dispersion_deposition_flag ) then call uEMEP_subgrid_dispersion ( source_index ) end if end do do source_index = 1 , n_source_index if ( calculate_source ( source_index ) . and . use_plume_dispersion_deposition_flag ) then call uEMEP_subgrid_deposition ( source_index ) end if end do ! Interpolate local_subgrid if necessary if ( interpolate_subgrids_flag ) then write ( unit_logfile , * ) \"'uEMEP_interpolate_auto_subgrid' has been disabled, because array 'use_subgrid_val' is disabled\" stop !call uEMEP_interpolate_auto_subgrid() end if ! Old diagnostic for comparing EMEP and proxy data emissions. Working only on lat lon EMEP grids. Do not use if ( make_EMEP_grid_emission_data ( allsource_index )) then !call uEMEP_aggregate_proxy_emission_in_EMEP_grid end if ! Put EMEP data into the additional subgrids for all sources. ! Must be run first if ( EMEP_additional_grid_interpolation_size . gt . 0.0 ) then calculate_EMEP_additional_grid_flag = . true . call uEMEP_subgrid_EMEP () calculate_EMEP_additional_grid_flag = . false . end if ! Put EMEP data into subgrids for all sources call uEMEP_subgrid_EMEP () ! Call the new subroutine for calculating more precise estimates of the contributions from outside moving window but within region if ( trace_emissions_from_in_region ) then if ( EMEP_grid_interpolation_flag == 0 . or . EMEP_grid_interpolation_flag == 6 ) then call uEMEP_subgrid_EMEP_from_in_region () end if ! NB: Only implemented to be consistent with interpolation flag 0 and 6 end if if ( calculate_deposition_flag ) then call uEMEP_subgrid_deposition_EMEP () end if ! Interpolate EMEP to sub-grid do source_index = 1 , n_source_index if ( calculate_source ( source_index )) then ! Redistributes proxy subgrid data into the EMEP grid concentrations only when local_subgrid_method_flag=1 (based on EMEP concentration redistribution scaling factor) call uEMEP_redistribute_local_source ( source_index ) ! Places the proxy_subgrid data into the local_subgrid when local_subgrid_method_flag<>1 call uEMEP_disperse_local_source ( source_index ) end if end do ! Combine and save sources in local and total values call uEMEP_combine_local_source () ! Calculate the nonlocal depositions if ( calculate_deposition_flag ) then call uEMEP_calculate_deposition () end if ! Calculate chemistry for NO2 and O3 call uEMEP_chemistry () ! Correct annual mean chemistry for pdf if ( use_annual_mean_pdf_chemistry_correction ) then call correct_annual_mean_chemistry () end if ! Calculate exposure if ( calculate_population_exposure_flag ) then call uEMEP_calculate_exposure () end if ! Save results to netcdf if ( save_netcdf_file_flag . or . save_netcdf_receptor_flag ) then call uEMEP_save_netcdf_control () end if end do ! t_loop ! Update first_g_loop flag if ( first_g_loop ) first_g_loop = . false . end if ! use_receptor end do ! g_loop call cpu_time ( end_time_cpu ) if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) '' write ( unit_logfile , * ) '------------------------------------------------------------------------' write ( unit_logfile , * ) 'Ending program ' // trim ( model_version_str ) write ( unit_logfile , '(a,i5,a,i2)' ) ' CPU time taken (MM:SS): ' , floor (( end_time_cpu - start_time_cpu ) / 6 0.0 ), ':' , floor ( mod ( end_time_cpu - start_time_cpu , 6 0.0 )) write ( unit_logfile , * ) '------------------------------------------------------------------------' end if if ( unit_logfile . gt . 0 ) then close ( unit_logfile , status = 'keep' ) end if ! Save finished file if ( trim ( finished_filename ) . ne . '' ) then if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( * , '(2A)' ) 'Writing finished file for uEMEP output: ' , trim ( finished_file_rec ) open ( unit_finishedfile , file = finished_file_rec , status = 'replace' ) close ( unit_finishedfile ) end if if ( save_netcdf_file_flag ) then write ( * , '(2A)' ) 'Writing finished file for uEMEP output: ' , trim ( finished_file ) open ( unit_finishedfile , file = finished_file , status = 'replace' ) close ( unit_finishedfile ) end if end if write ( * , * ) '' write ( * , * ) '------------------------------------------------------------------------' write ( * , * ) 'Ending program ' // trim ( model_version_str ) write ( * , '(a,i5,a,i2)' ) ' CPU time taken (MM:SS): ' , floor (( end_time_cpu - start_time_cpu ) / 6 0.0 ), ':' , floor ( mod ( end_time_cpu - start_time_cpu , 6 0.0 )) write ( * , * ) '------------------------------------------------------------------------' end program uEMEP_v6","tags":"","loc":"program/uemep_v6.html"},{"title":"uemep_logger.f90 – uEMEP","text":"Source Code module uemep_logger ! A simple logger module for uEMEP implicit none private public :: DEBUG , INFO , WARNING , ERROR public :: open_log_file , close_log_file , set_log_level , log_message , log_header public :: log_msg integer , parameter :: DEBUG = 1 integer , parameter :: INFO = 2 integer , parameter :: WARNING = 3 integer , parameter :: ERROR = 4 integer , save :: log_level = INFO character ( len = 256 ), save :: log_name logical , save :: file_opened = . false . integer :: log_unit character ( len = 1028 ) :: log_msg integer :: unit contains subroutine open_log_file ( logfile_name , io_err ) !! Opens a new log file for writing character ( len =* ), intent ( in ) :: logfile_name integer , intent ( inout ), optional :: io_err ! Store unit and file name information in module log_name = trim ( logfile_name ) ! Open log file if ( present ( io_err )) then open ( newunit = log_unit , file = log_name , status = \"replace\" , iostat = io_err ) else open ( newunit = log_unit , file = log_name , status = \"replace\" ) end if file_opened = . true . end subroutine open_log_file subroutine close_log_file ( io_err ) integer , intent ( inout ), optional :: io_err !! Closes the log file if ( file_opened ) then if ( present ( io_err )) then close ( log_unit , iostat = io_err ) else close ( log_unit ) end if log_unit = - 1 end if end subroutine close_log_file subroutine set_log_level ( level ) !! Sets the log level !! !! The logger will write all message at or above this level integer , intent ( in ) :: level if ( level >= DEBUG . and . level <= ERROR ) then log_level = level else print * , \"ERROR! Invalid log level: \" , level stop 1 end if end subroutine set_log_level subroutine log_header ( message , level , upper_space , lower_space ) !! Send a log header message to the log file !! !! Log levels: DEBUG, INFO, WARNING and ERROR character ( len =* ), intent ( in ) :: message !! Message to log integer , intent ( in ) :: level !! Log level logical , intent ( in ), optional :: upper_space , lower_space ! Local variables logical :: u_space , l_space if ( present ( upper_space )) then u_space = upper_space else u_space = . true . end if if ( present ( lower_space )) then l_space = lower_space else l_space = . true . end if if ( u_space ) call log_message ( \"\" , level ) call log_message ( \"================================================================\" , level ) call log_message ( message , level ) call log_message ( \"================================================================\" , level ) if ( l_space ) call log_message ( \"\" , level ) end subroutine log_header subroutine log_message ( message , level ) !! Send a log message to the log file !! !! Log levels: DEBUG, INFO, WARNING and ERROR character ( len =* ), intent ( in ) :: message !! Message to log integer , intent ( in ) :: level !! Log level ! Local variables character ( len = 18 ) :: timestamp character ( len = 8 ) :: datestr character ( len = 10 ) :: timestr ! Get current date and time call date_and_time ( date = datestr , time = timestr ) timestamp = '[' // datestr // ' ' // timestr ( 1 : 6 ) // '] ' if ( level >= log_level ) then select case ( level ) case ( DEBUG ) call write_log ( timestamp // '[DEBUG] ' // message ) case ( INFO ) call write_log ( timestamp // '[INFO]  ' // message ) case ( WARNING ) call write_log ( timestamp // '[WARN]  ' // message ) case ( ERROR ) call write_log ( timestamp // '[ERROR] ' // message ) case default print \"(a)\" , \"ERROR: Invalid log level: \" , level stop 1 end select end if end subroutine log_message subroutine write_log ( message ) !! Writes the message to the log file character ( len =* ), intent ( in ) :: message !! Message to log if (. not . file_opened ) then print \"(a)\" , \"ERROR: No file has been opened for writing\" stop 1 end if write ( log_unit , \"(a)\" ) trim ( adjustl ( message )) end subroutine write_log end module uemep_logger","tags":"","loc":"sourcefile/uemep_logger.f90.html"},{"title":"uEMEP_subgrid_dispersion.f90 – uEMEP","text":"Source Code module subgrid_dispersion use uemep_configuration use set_dispersion_parameters , only : delta_wind_direction , & uEMEP_set_dispersion_sigma_simple , uEMEP_set_dispersion_params_PG , & uEMEP_set_dispersion_sigma_Kz_emulator , uEMEP_set_dispersion_params_simple , & uEMEP_set_dispersion_sigma_PG use local_trajectory , only : uEMEP_calculate_all_trajectory , & uEMEP_minimum_distance_trajectory_fast use dispersion_functions , only : gauss_plume_second_order_rotated_reflected_integral_func , & gauss_plume_second_order_rotated_reflected_func , gauss_plume_cartesian_sigma_func , & gauss_plume_cartesian_sigma_integral_func , & gauss_plume_second_order_rotated_reflected_integral_func , & gauss_plume_second_order_rotated_integral_func use kz_functions , only : z_centremass_gauss_func , u_profile_neutral_val_func , & uEMEP_set_dispersion_sigma_Kz use mod_area_interpolation , only : area_weighted_interpolation_function implicit none private public :: uEMEP_subgrid_dispersion contains !uEMEP_subgrid_dispersion.f90 !========================================================================== !   uEMEP model save_gridded_proxy !   Calculates proxy concentrations based on Gaussian distribution !   Generic for all sources and subsources !========================================================================== subroutine uEMEP_subgrid_dispersion ( source_index ) use uEMEP_definitions implicit none integer i , j integer source_index integer jj , ii , tt real distance_subgrid integer i_start , i_end , j_start , j_end , t_start , t_end integer i_cross , j_cross integer i_cross_integral , j_cross_integral , i_cross_target_integral , j_cross_target_integral real cos_subgrid_loc , sin_subgrid_loc , FF_loc , FF_zc_loc integer subsource_index real ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , sig_y_00_loc , sig_z_00_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc real xpos_limit , ypos_limit real xpos_limit2 , ypos_limit2 real time_weight ( subgrid_dim ( t_dim_index ), n_pollutant_loop ), time_total ( subgrid_dim ( t_dim_index ), n_pollutant_loop ) real x_downwind , y_downwind real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real distance_subgrid_min real xpos_subgrid , ypos_subgrid real xpos_emission_subgrid , ypos_emission_subgrid real temp_subgrid_internal real distance_emission_subgrid_min real temp_sum_subgrid ( n_pollutant_loop ) real temp_sum_subgrid_from_in_region_new ( n_pollutant_loop ) integer count real , allocatable :: temp_emission_subgrid (:,:,:) real , allocatable :: temp_subgrid (:,:,:) !real, allocatable :: diagnostic_subgrid(:,:,:) real , allocatable :: temp_FF_subgrid (:,:) real , allocatable :: temp_FF_emission_subgrid (:,:) real , allocatable :: trajectory_subgrid (:,:,:,:) real , allocatable :: angle_diff (:,:) integer traj_max_index logical valid_traj real traj_step_size , x_loc , y_loc , FFgrid_loc , logz0_loc , u_star0_loc , FF10_loc , zc_loc , invL_loc real z0_temp , h_temp real , allocatable :: temp_target_subgrid (:,:,:) real , allocatable :: x_target_subgrid (:,:) real , allocatable :: y_target_subgrid (:,:) real , allocatable :: traveltime_temp_target_subgrid (:,:,:,:) integer temp_target_subgrid_dim_min ( 2 ), temp_target_subgrid_dim_max ( 2 ) integer temp_target_subgrid_dim_length ( 2 ) real temp_target_subgrid_delta ( 2 ) logical :: use_target_subgrid = . true . integer i_target_start , i_target_end , j_target_start , j_target_end logical temp_use_subgrid integer i_pollutant real temp_subgrid_internal_pollutant ( n_pollutant_loop ) integer i_cross_deposition , j_cross_deposition real temp_subgrid_rotated ( n_pollutant_loop ) real temp_subgrid_rotated_integrated ( n_pollutant_loop ) real precip_loc real deposition_subgrid_scale real plume_vertical_integral ( n_integral_subgrid_index , n_pollutant_loop ) !Fitting Kz calculation real x_loc_fit ( 2 ) real sig_z_loc_fit ( 2 ) real sig_y_loc_fit ( 2 ) real FF_zc_loc_fit ( 2 ) !Not used real az_loc_fit , bz_loc_fit real ay_loc_fit , by_loc_fit real sig_z_0_loc_fit , sig_y_0_loc_fit integer f_loop !functions !real gauss_plume_second_order_rotated_integral_func !real gauss_plume_cartesian_integral_func ! Arrays for the new way to calculate from-in-region, by matching emission region with region in each subgrid of the target grid real , allocatable :: subgrid_from_in_region_new (:,:,:) real , allocatable :: temp_target_subgrid_per_source_region (:,:,:,:) !x,y,pollutant,region integer i_region integer emission_region_index write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating dispersion of proxy (uEMEP_subgrid_dispersion)' write ( unit_logfile , '(A)' ) '================================================================' !First call the integral dispersion routine if it is needed. Only when using the concentration redistribution or the EMEP grid interpolation with proxy if ( local_subgrid_method_flag . eq . 1. or . EMEP_grid_interpolation_flag . eq . 4 ) then call uEMEP_subgrid_dispersion_integral ( source_index ) endif allocate ( temp_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) allocate ( temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_pollutant_loop )) !allocate (diagnostic_subgrid(subgrid_dim(x_dim_index),subgrid_dim(y_dim_index),n_pollutant_loop)) allocate ( temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( temp_FF_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) allocate ( angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if ( trace_emissions_from_in_region ) then allocate ( subgrid_from_in_region_new ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_pollutant_loop )) subgrid_from_in_region_new = 0. endif temp_subgrid = 0. temp_emission_subgrid = 0. temp_FF_subgrid = 0. temp_FF_emission_subgrid = 0. angle_diff = 0. !Set the x and y position limits to coincide to half the EMEP grid (refered here as lon and lat but can be also LCC projection) times the number of grids xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling xpos_limit2 = dgrid_nc ( lon_nc_index ) / 2. ypos_limit2 = dgrid_nc ( lat_nc_index ) / 2. !write(unit_logfile,'(A,2f12.2)') 'xpos_limit and ypos_limit: ',xpos_limit,ypos_limit !Minimum distance for travel time calculation set to  half of a grid diagonal weighted so the circle has the same area as the square with that diagonal distance_subgrid_min = sqrt ( subgrid_delta ( x_dim_index ) * subgrid_delta ( x_dim_index ) + subgrid_delta ( y_dim_index ) * subgrid_delta ( y_dim_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 !Minimum distance for dispersion set to  half of an emission grid diagonal weighted so the circle has the same area as the square with that diagonal distance_emission_subgrid_min = sqrt ( emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( x_dim_index , source_index ) & + emission_subgrid_delta ( y_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 do subsource_index = 1 , n_subsource ( source_index ) !Do not use target subgrid if the grid is auto selected !if (emission_subgrid_delta(x_dim_index,source_index).le.subgrid_delta(x_dim_index).or. & if ( use_emission_positions_for_auto_subgrid_flag ( source_index )) then !If auto positions using emissions for that source then do not use the interpolation target grid use_target_subgrid = . false . write ( unit_logfile , * ) 'Using auto subgrid for source ' , trim ( source_file_str ( source_index )) elseif ( emission_subgrid_delta ( x_dim_index , source_index ). le . subgrid_delta ( x_dim_index )) then !If the subgrid emissions are less than or equal to the dispersion grid then do not use the target interpolation grid !No matter what auto subgrid is used use_target_subgrid = . false . else !Use the target subgrid even when the other auto subgrids are on. Slows it down but is necessary to get the right interpolation !(use_population_positions_for_auto_subgrid_flag.or.use_receptor_positions_for_auto_subgrid_flag) use_target_subgrid = . true . endif if ( use_target_subgrid ) then write ( unit_logfile , * ) 'Using emission subgrid with interpolation for source ' , trim ( source_file_str ( source_index )) else write ( unit_logfile , * ) 'Using normal subgrid with no interpolation for source ' , trim ( source_file_str ( source_index )) endif call uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) !Set local dispersion parameters to be used only in the annual calculation, overwritten in the hourly files ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) sig_y_00_loc = sig_y_00 ( source_index , subsource_index ) sig_z_00_loc = sig_z_00 ( source_index , subsource_index ) h_emis_loc = h_emis ( source_index , subsource_index ) z_rec_loc = z_rec ( source_index , subsource_index ) write ( unit_logfile , '(a,i3)' ) 'Calculating proxy concentration data for ' // trim ( source_file_str ( source_index )) // ' with subsource index ' , subsource_index !Set up a target grid that matches the emissions grid and is just slightly bigger than it !Find the grid index it belongs to if ( use_target_subgrid ) then temp_target_subgrid_dim_min ( x_dim_index ) =- 1 + 1 + floor (( subgrid_min ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) temp_target_subgrid_dim_min ( y_dim_index ) =- 1 + 1 + floor (( subgrid_min ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) temp_target_subgrid_dim_max ( x_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) temp_target_subgrid_dim_max ( y_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) temp_target_subgrid_dim_length ( x_dim_index ) = temp_target_subgrid_dim_max ( x_dim_index ) - temp_target_subgrid_dim_min ( x_dim_index ) + 1 temp_target_subgrid_dim_length ( y_dim_index ) = temp_target_subgrid_dim_max ( y_dim_index ) - temp_target_subgrid_dim_min ( y_dim_index ) + 1 temp_target_subgrid_delta ( x_dim_index ) = emission_subgrid_delta ( x_dim_index , source_index ) temp_target_subgrid_delta ( y_dim_index ) = emission_subgrid_delta ( y_dim_index , source_index ) !Reallocate internal target arrays for each source if ( allocated ( temp_target_subgrid )) deallocate ( temp_target_subgrid ) if ( allocated ( x_target_subgrid )) deallocate ( x_target_subgrid ) if ( allocated ( y_target_subgrid )) deallocate ( y_target_subgrid ) if ( allocated ( traveltime_temp_target_subgrid )) deallocate ( traveltime_temp_target_subgrid ) if (. not . allocated ( temp_target_subgrid )) allocate ( temp_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) if (. not . allocated ( traveltime_temp_target_subgrid )) allocate ( traveltime_temp_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_pollutant_loop )) if (. not . allocated ( x_target_subgrid )) allocate ( x_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_target_subgrid )) allocate ( y_target_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) x_target_subgrid (:,:) = x_emission_subgrid (:,:, source_index ) y_target_subgrid (:,:) = y_emission_subgrid (:,:, source_index ) if ( trace_emissions_from_in_region ) then if ( allocated ( temp_target_subgrid_per_source_region )) deallocate ( temp_target_subgrid_per_source_region ) allocate ( temp_target_subgrid_per_source_region ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop , n_regions )) endif endif !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) !Loop through the time do tt = t_start , t_end subgrid (:,:, tt , proxy_subgrid_index , source_index ,:) = 0. if ( use_target_subgrid ) temp_target_subgrid = 0. if ( use_target_subgrid ) traveltime_temp_target_subgrid = 0. if ( trace_emissions_from_in_region ) then temp_target_subgrid_per_source_region = 0. endif !Set a temporary emission array temp_emission_subgrid = emission_subgrid (:,:, tt , source_index ,:) temp_subgrid = 0. temp_FF_subgrid = 0. !diagnostic_subgrid=0. if ( trace_emissions_from_in_region ) then subgrid_from_in_region_new = 0. endif if ( calculate_deposition_flag ) then subgrid (:,:, tt , drydepo_local_subgrid_index , source_index ,:) = 0. subgrid (:,:, tt , wetdepo_local_subgrid_index , source_index ,:) = 0. endif !Set the last meteo data subgrid in the case when the internal time loop is used if (. not . use_single_time_loop_flag ) then if ( tt . gt . t_start ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt - 1 ,:) else last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt ,:) endif endif !Precalculate information for the trajectory model !Maxium number of trajectory steps and size of steps based on the integral (meteorology) loop size if ( use_trajectory_flag ( source_index )) then traj_step_size = min ( integral_subgrid_delta ( x_dim_index ), integral_subgrid_delta ( y_dim_index )) * traj_step_scale traj_max_index = floor ( max ( integral_subgrid_loop_index ( x_dim_index ), integral_subgrid_loop_index ( y_dim_index )) / traj_step_scale ) if ( tt . eq . t_start ) write ( unit_logfile , '(a,f12.1,i)' ) 'Trajectory step (m) and dimensions: ' , traj_step_size , traj_max_index if (. not . allocated ( trajectory_subgrid )) allocate ( trajectory_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), traj_max_index , 2 )) trajectory_subgrid = NODATA_value !Loop through the emissions and create trajectories for all emissions source grids do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( sum ( temp_emission_subgrid ( i , j ,:)). ne . 0 ) then call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), tt , & traj_max_index , traj_step_size , trajectory_subgrid ( i , j ,:, x_dim_index ), trajectory_subgrid ( i , j ,:, y_dim_index )) endif enddo enddo endif !Create a temporary wind speed subgrid for each hour temp_FF_subgrid = 0. do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) z0_temp = exp ( meteo_subgrid ( i_cross , j_cross , tt , logz0_subgrid_index )) h_temp = h_emis ( source_index , subsource_index ) !if (source_index.eq.industry_index) then !    write(*,*) z0_temp,h_temp,1./meteo_subgrid(i_cross,j_cross,tt,inv_FFgrid_subgrid_index),H_meteo !    stop !endif if ( annual_calculations . and . wind_level_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( annual_calculations . and . wind_level_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( wind_level_flag . eq . 0 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag . eq . 5 ) then !Will set based on sigma z centre of mass temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag . eq . 6 ) then !Will set based on sigma z centre of mass and emission height temp_FF_subgrid ( i_cross , j_cross ) = 1. else write ( unit_logfile , '(a)' ) 'No valid wind_level_flag selected. Stopping (uEMEP_subgrid_dispersion)' stop endif !Setting a minimum value for wind for dispersion purposes (cannot be zero) temp_FF_subgrid ( i_cross , j_cross ) = sqrt ( temp_FF_subgrid ( i_cross , j_cross ) * temp_FF_subgrid ( i_cross , j_cross ) + FF_min_dispersion * FF_min_dispersion ) if ( temp_FF_subgrid ( i_cross , j_cross ). eq . 0 ) then write ( unit_logfile , '(a,2i)' ) 'Zero wind speed at integral grid (stopping): ' , i_cross , j_cross stop endif !Finds the angle difference between the current and last meteo field for dispersion and implements meandering if selected if ( hourly_calculations ) then call delta_wind_direction ( i_cross , j_cross , tt , meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ), angle_diff ( i_cross , j_cross )) else angle_diff ( i_cross , j_cross ) = 0. endif enddo enddo !If wind level flag is set to 5, use of initial plume centre of mass, then set wind speed for each non-zero emission grid if ( wind_level_flag . eq . 5 ) then temp_FF_emission_subgrid = 0. do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( sum ( temp_emission_subgrid ( ii , jj ,:)). ne . 0 ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) !Set the local variables logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) if ( annual_calculations ) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) endif !Set sig_0's at the emission position x_loc = 0. call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Use the initial plume centre of mass to determine wind advection height call z_centremass_gauss_func ( sig_z_0_loc , h_emis_loc , h_mix_loc , zc_loc ) call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) !Set a minimum wind speed based on traffic (if use_traffic_for_minFF_flag=T) !                FF_loc=sqrt(FF_loc*FF_loc+emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)*emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)) !Set the minimum wind speed FF_loc = sqrt ( FF_loc * FF_loc + FF_min_dispersion * FF_min_dispersion ) temp_FF_emission_subgrid ( ii , jj ) = FF_loc !write(*,*) FF10_loc,FF_loc,zc_loc,sig_z_0_loc endif enddo enddo endif !Loop through the target grid if ( use_target_subgrid ) then j_target_start = temp_target_subgrid_dim_min ( y_dim_index ); j_target_end = temp_target_subgrid_dim_max ( y_dim_index ) i_target_start = temp_target_subgrid_dim_min ( x_dim_index ); i_target_end = temp_target_subgrid_dim_max ( x_dim_index ) else j_target_start = 1 ; j_target_end = subgrid_dim ( y_dim_index ) i_target_start = 1 ; i_target_end = subgrid_dim ( x_dim_index ) endif !write(*,*) i_target_start,i_target_end,j_target_start,j_target_end do j = j_target_start , j_target_end do i = i_target_start , i_target_end !do j=1,subgrid_dim(y_dim_index) !do i=1,subgrid_dim(x_dim_index) !Only use those that are marked for use if ( use_target_subgrid ) then !Always use the grids because they cannot be tested temp_use_subgrid = . true . else temp_use_subgrid = use_subgrid ( i , j , source_index ) endif if ( temp_use_subgrid ) then !Set the position of the target grid in terms of the EMEP projection if ( use_target_subgrid ) then xpos_subgrid = xproj_emission_subgrid ( i , j , source_index ) ypos_subgrid = yproj_emission_subgrid ( i , j , source_index ) else xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) endif !Find the cross reference to the emission grid from the target grid if ( use_target_subgrid ) then i_cross = i j_cross = j else i_cross = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , source_index ) j_cross = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , source_index ) endif !Find the cross reference for the meteo grid at the target grid if ( use_target_subgrid ) then i_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , source_index ) j_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , source_index ) else i_cross_target_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross_target_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) endif !Set the travel time integral values to 0 time_weight ( tt ,:) = 0. time_total ( tt ,:) = 0. !Use the wind direction to move the target area downwind. To reduce the search loop if ( use_downwind_position_flag . and . hourly_calculations ) then !Set the emission grid loop region based on the downwind position x_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , cos_subgrid_index ) * sqrt ( 2. ))) y_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , sin_subgrid_index ) * sqrt ( 2. ))) i_end = min ( ceiling ( i_cross + 1 + ( 1. - x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), emission_subgrid_dim ( x_dim_index , source_index )) i_start = max ( floor ( i_cross - 1 - ( 1. + x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), 1 ) j_end = min ( ceiling ( j_cross + 1 + ( 1. - y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), emission_subgrid_dim ( y_dim_index , source_index )) j_start = max ( floor ( j_cross - 1 - ( 1. + y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), 1 ) !Set the EMEP projection limits to include the upwind source region xpos_area_max = xpos_subgrid + ( 1. - x_downwind ) * xpos_limit / 2. + emission_subgrid_dim ( x_dim_index , source_index ) xpos_area_min = xpos_subgrid - ( 1. + x_downwind ) * xpos_limit / 2. - emission_subgrid_dim ( x_dim_index , source_index ) ypos_area_max = ypos_subgrid + ( 1. - y_downwind ) * ypos_limit / 2. + emission_subgrid_dim ( y_dim_index , source_index ) ypos_area_min = ypos_subgrid - ( 1. + y_downwind ) * ypos_limit / 2. - emission_subgrid_dim ( y_dim_index , source_index ) else !Set the size of the loop region around the target cell to be up to subgrid_loop_index i_start = max ( 1 , i_cross - emission_subgrid_loop_index ( x_dim_index , source_index )) i_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), i_cross + emission_subgrid_loop_index ( x_dim_index , source_index )) j_start = max ( 1 , j_cross - emission_subgrid_loop_index ( y_dim_index , source_index )) j_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), j_cross + emission_subgrid_loop_index ( y_dim_index , source_index )) !Set the emission limits (EMEP projection ) surrounding the target grid xpos_area_max = xpos_subgrid + xpos_limit xpos_area_min = xpos_subgrid - xpos_limit ypos_area_max = ypos_subgrid + ypos_limit ypos_area_min = ypos_subgrid - ypos_limit endif !Limit the region. This will still allow a contribution from half an EMEP grid away if ( limit_emep_grid_interpolation_region_to_calculation_region ) then xpos_area_min = max ( xpos_area_min , subgrid_proj_min ( x_dim_index ) - xpos_limit2 ) xpos_area_max = min ( xpos_area_max , subgrid_proj_max ( x_dim_index ) + xpos_limit2 ) ypos_area_min = max ( ypos_area_min , subgrid_proj_min ( y_dim_index ) - ypos_limit2 ) ypos_area_max = min ( ypos_area_max , subgrid_proj_max ( y_dim_index ) + ypos_limit2 ) endif !Loop through emission sub_grids in the nearby region do jj = j_start , j_end do ii = i_start , i_end !Only non zero emissions to be calculated if ( sum ( temp_emission_subgrid ( ii , jj ,:)). ne . 0 ) then !Set the EMEP projection position of the emission grid xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , source_index ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , source_index ) !Select only emissions within the predefined region if ( xpos_emission_subgrid . ge . xpos_area_min . and . xpos_emission_subgrid . le . xpos_area_max & . and . ypos_emission_subgrid . ge . ypos_area_min . and . ypos_emission_subgrid . le . ypos_area_max ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) i_cross_integral = min ( max ( 1 , i_cross_integral ), integral_subgrid_dim ( x_dim_index )) j_cross_integral = min ( max ( 1 , j_cross_integral ), integral_subgrid_dim ( y_dim_index )) if ( hourly_calculations ) then if ( use_trajectory_flag ( source_index )) then !Calculate the minimum distance to the trajectory. Time consuming if ( use_target_subgrid ) then call uEMEP_minimum_distance_trajectory_fast ( x_target_subgrid ( i , j ), y_target_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_subgrid ( ii , jj ,:, x_dim_index ), trajectory_subgrid ( ii , jj ,:, y_dim_index ), x_loc , y_loc , valid_traj ) else call uEMEP_minimum_distance_trajectory_fast ( x_subgrid ( i , j ), y_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_subgrid ( ii , jj ,:, x_dim_index ), trajectory_subgrid ( ii , jj ,:, y_dim_index ), x_loc , y_loc , valid_traj ) endif else !Set the local wind cos and sin values cos_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , cos_subgrid_index ) sin_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , sin_subgrid_index ) !Determine the rotated position along wind values if ( use_target_subgrid ) then x_loc = ( x_target_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc + ( y_target_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc y_loc =- ( x_target_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc + ( y_target_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc else x_loc = ( x_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc + ( y_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc y_loc =- ( x_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc + ( y_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc endif !write(*,*) x_loc,x_subgrid(i,j)-x_emission_subgrid(ii,jj,source_index),y_subgrid(i,j)-y_emission_subgrid(ii,jj,source_index) !If x is downwind then it is valid if ( x_loc . ge . 0. ) then valid_traj = . true . else valid_traj = . false . endif endif !Calculate dispersion if ( valid_traj ) then !Set the mixing height at the average of the emission and target position h_mix_loc = ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) + meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , hmix_subgrid_index )) / 2. !Set the local wind speed and other parameters at emission position FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) !L_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,invL_subgrid_index) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) !u_star0_loc=max(meteo_subgrid(i_cross_integral,j_cross_integral,tt,ustar_subgrid_index),ustar_min) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) !Set ustar 0 to be consistent with FF10 and z0 call u_profile_neutral_val_func ( 1 0. , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) u_star0_loc = max ( u_star0_loc , ustar_min ) if ( wind_level_flag . eq . 5. or . wind_level_flag . eq . 6 ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) endif !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif !Make the wind level to be at emission height for emissions greater than 10 m, if meteoflag 1 or 3 is called h_temp = h_emis_loc if ( wind_level_flag . eq . 2. or .( h_temp . gt . H_meteo . and . wind_level_flag . eq . 1 )) then FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FFgrid_loc , H_meteo , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif if ( wind_level_flag . eq . 4. or .( h_temp . gt . 1 0. and . wind_level_flag . eq . 3 )) then FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 3 ) then !Need to make 10 m winds if they are not selected by the wind_level_flag.  and do not exist is not included any more if ( hourly_calculations . and .( wind_level_flag . eq . 1. or . wind_level_flag . eq . 2 )) then call u_profile_neutral_val_func ( 1 0. , meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ), H_meteo , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) endif !Set initial values for sigma. Initial sig_y is set here as well but is overridden by Kz dispersion call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !call uEMEP_set_dispersion_sigma_Kz_emulator(h_emis_loc,invL_loc,logz0_loc,h_mix_loc,sig_z_00_loc,sig_y_00_loc,emission_subgrid_delta(:,source_index),0.,x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) !write(*,*) 'H0: ',sig_z_loc call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !write(*,*) 'H1: ',sig_z_loc !Add the meandering and change in wind angle to the plume since not included in Kz calculation sig_y_loc = sig_y_loc + x_loc * angle_diff ( i_cross_integral , j_cross_integral ) !Use the average of the emision height and zc to determine wind speed. Is true if wind_level_flag=6 or if wind_level_zc_flag is true then it will do this for all other types of wind flags as well if ( wind_level_flag . eq . 6. or . wind_level_zc_flag ) then !FF_loc=FF_zc_loc !Set the minimum wind speed FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif if ( stability_scheme_flag . eq . 4 ) then call uEMEP_set_dispersion_sigma_Kz_emulator ( h_emis_loc , invL_loc , logz0_loc , h_mix_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif !Adjust the height of the wind to the average of the emission and plume centre of mass height. !This is already the case in the Kz calculation so not repeated here. if ( wind_level_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then !if (wind_level_flag.eq.6) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !Calculate the dispersion temp_subgrid_internal = gauss_plume_cartesian_sigma_func ( x_loc , y_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc ) !if (ii.eq.i_cross.and.jj.eq.j_cross) write(*,'(10es12.2)') x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,temp_subgrid_internal,temp_emission_subgrid(ii,jj,1) !if (tt.ge.18.and.tt.le.18.and.temp_subgrid_internal.gt.1.e-3) then !write(*,'(2i,12es12.2)') ii,jj,x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,temp_emission_subgrid(ii,jj,1),temp_subgrid_internal,sin_subgrid_loc,cos_subgrid_loc !endif !if (source_index.eq.traffic_index.and.x_loc.eq.0) write(*,'(16es12.2)') sigy_0_subgid_width_scale,x_loc,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_00_loc,sig_z_00_loc,sig_y_0_loc,sig_z_0_loc,sig_y_loc,sig_z_loc,h_emis_loc,FF_loc,meteo_subgrid(i_cross_integral,j_cross_integral,tt,FF10_subgrid_index) !For diagnostics only!! !diagnostic_subgrid(i,j,1)=diagnostic_subgrid(i,j,1)+temp_subgrid_internal !diagnostic_subgrid(i,j,2)=diagnostic_subgrid(i,j,2)+temp_emission_subgrid(ii,jj,1) do i_pollutant = 1 , n_pollutant_loop !Multiply by the emission factor temp_subgrid_internal_pollutant ( i_pollutant ) = temp_subgrid_internal * temp_emission_subgrid ( ii , jj , i_pollutant ) !Add to the receptor subgrid position if ( use_target_subgrid ) then temp_target_subgrid ( i , j , i_pollutant ) = temp_target_subgrid ( i , j , i_pollutant ) + temp_subgrid_internal_pollutant ( i_pollutant ) else temp_subgrid ( i , j , i_pollutant ) = temp_subgrid ( i , j , i_pollutant ) + temp_subgrid_internal_pollutant ( i_pollutant ) endif if ( trace_emissions_from_in_region ) then ! New version of in-region calculations: allowing target region to vary with the target grid ! **************** emission_region_index = emission_subgrid_region_index ( ii , jj , source_index ) if ( use_target_subgrid ) then ! one temp_target_subgrid may contain multiple regions in the finer resolution, so we must store results in a per-region array ! -> add this contribution to the region index that matches the current emission grid if ( emission_region_index > 0 ) then i_region = regionindex_loop_back_index ( emission_region_index ) if ( i_region > 0 ) then temp_target_subgrid_per_source_region ( i , j , i_pollutant , i_region ) = temp_target_subgrid_per_source_region ( i , j , i_pollutant , i_region ) + temp_subgrid_internal_pollutant ( i_pollutant ) end if end if else ! dispersion calculation is done directly on the fine-resolution target grid, so there is only one target region ! -> we can directly check if the target subgrid region ID matches the current emission grid region ID if ( emission_region_index > 0 . and . emission_region_index == subgrid_region_index ( i , j )) then subgrid_from_in_region_new ( i , j , i_pollutant ) = subgrid_from_in_region_new ( i , j , i_pollutant ) + temp_subgrid_internal_pollutant ( i_pollutant ) end if end if ! ************************ endif enddo !Determine the distance for the travel time calculation if ( use_straightline_traveltime_distance ) then distance_subgrid = x_loc else distance_subgrid = sqrt ( x_loc * x_loc + y_loc * y_loc ) endif else temp_subgrid_internal = 0. temp_subgrid_internal_pollutant = 0. endif !Calculate weighted time based on the selected temp_FF_subgrid wind level if ( temp_subgrid_internal . gt . 0 ) then distance_subgrid = max ( distance_subgrid , distance_subgrid_min ) !Alternative heavier weighting to higher concentrations (pollutant&#94;2). Not in deposition_dispersion routine if ( use_alternative_traveltime_weighting ) then time_weight ( tt ,:) = time_weight ( tt ,:) + distance_subgrid / FF_loc * temp_subgrid_internal_pollutant ** traveltime_power time_total ( tt ,:) = time_total ( tt ,:) + temp_subgrid_internal_pollutant ** traveltime_power else !Take weighted average (weighted by concentration) of the time time_weight ( tt ,:) = time_weight ( tt ,:) + distance_subgrid / FF_loc * temp_subgrid_internal_pollutant !Calculate sum of the concentration for normalisation time_total ( tt ,:) = time_total ( tt ,:) + temp_subgrid_internal_pollutant endif endif else !Annual calculations sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) u_star0_loc = max ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , ustar_subgrid_index ), ustar_min ) !FF10_loc=meteo_subgrid(i_cross_integral,j_cross_integral,tt,FF10_subgrid_index) FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) !Recalculate utar0 based on 10 m wind speed for consistency with current z0 and FF profile call u_profile_neutral_val_func ( 1 0. , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) u_star0_loc = max ( u_star0_loc , ustar_min ) !write(*,*) ii,jj,sig_y_00_loc,sig_z_00_loc !If not hourly concentration then use the annual dispersion function if ( use_target_subgrid ) then distance_subgrid = sqrt (( x_emission_subgrid ( ii , jj , source_index ) - x_target_subgrid ( i , j )) * ( x_emission_subgrid ( ii , jj , source_index ) - x_target_subgrid ( i , j )) & + ( y_emission_subgrid ( ii , jj , source_index ) - y_target_subgrid ( i , j )) * ( y_emission_subgrid ( ii , jj , source_index ) - y_target_subgrid ( i , j ))) else distance_subgrid = sqrt (( x_emission_subgrid ( ii , jj , source_index ) - x_subgrid ( i , j )) * ( x_emission_subgrid ( ii , jj , source_index ) - x_subgrid ( i , j )) & + ( y_emission_subgrid ( ii , jj , source_index ) - y_subgrid ( i , j )) * ( y_emission_subgrid ( ii , jj , source_index ) - y_subgrid ( i , j ))) endif !Set the simple as default at the receptor grid x_loc = distance_subgrid call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then !These are already set at the start as the default !call uEMEP_set_dispersion_params_simple(source_index,subsource_index) !call uEMEP_set_dispersion_sigma_simple(sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) !call uEMEP_set_dispersion_sigma_PG(invL_loc,logz0_loc,sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) endif if ( stability_scheme_flag . eq . 3 ) then !Fit the Kz curve at 100 and 2000 m to get an estimate of sigma that can be used in the calculations !Set sig z,y 00 and sig z,y 0 to 0 for the fitting x_loc_fit ( 1 ) = 10 0. x_loc_fit ( 2 ) = 200 0. do f_loop = 1 , 2 !Set initial values for sigma. Initial sig_y is set here as well but is overridden by Kz dispersion call uEMEP_set_dispersion_sigma_simple ( 0. , 0. , 0. , emission_subgrid_delta (:, source_index ) * 0. , angle_diff ( i_cross_integral , j_cross_integral ) * 0. , x_loc_fit ( f_loop ), sig_z_loc_fit ( f_loop ), sig_y_loc_fit ( f_loop ), sig_z_0_loc_fit , sig_y_0_loc_fit ) call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc_fit ( f_loop ), 0. , 0. , 0. , sig_z_loc_fit ( f_loop ), h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ) * 0. , u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc_fit ( f_loop ), sig_y_loc_fit ( f_loop ), FF_zc_loc_fit ( f_loop )) enddo !Fit bz_loc_fit = ( log ( sig_z_loc_fit ( 2 )) - log ( sig_z_loc_fit ( 1 ))) / ( log ( x_loc_fit ( 2 )) - log ( x_loc_fit ( 1 ))) az_loc_fit = exp ( log ( sig_z_loc_fit ( 1 )) - bz_loc_fit * log ( x_loc_fit ( 1 ))) by_loc_fit = ( log ( sig_y_loc_fit ( 2 )) - log ( sig_y_loc_fit ( 1 ))) / ( log ( x_loc_fit ( 2 )) - log ( x_loc_fit ( 1 ))) ay_loc_fit = exp ( log ( sig_y_loc_fit ( 1 )) - by_loc_fit * log ( x_loc_fit ( 1 ))) ay_loc = ay_loc_fit by_loc = by_loc_fit az_loc = az_loc_fit bz_loc = bz_loc_fit !Having made the fit need also to calculate sig_z,y if wind flag 6 is used if ( wind_level_flag . eq . 6 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !Use the average of the emision height and zc to determine wind speed. Is set to true if wind_level_flag=6 !FF_loc=FF_zc_loc !Set the minimum wind speed FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !If this flag set then use the centre of mass wind speed no matter which wind flag is called !This is actually overwritten to be the wind speed at the emission height in the next commands if ( wind_level_zc_flag ) then FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif h_temp = h_emis_loc if ( wind_level_flag . eq . 5. or . wind_level_zc_flag ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) else FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) endif !In the annual case then make the wind level to be at emission height for emissions greater than 10 m, if meteoflag 1 or 3 is called if ( wind_level_flag . eq . 2. or .( h_temp . gt . H_meteo . and . wind_level_flag . eq . 1 )) then !FF_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FFgrid_subgrid_index)*(1.-(log((H_meteo+z0_temp)/z0_temp)-log((h_temp+z0_temp)/z0_temp))/log((H_meteo+z0_temp)/z0_temp)) FFgrid_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FFgrid_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FFgrid_loc , H_meteo , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif if ( wind_level_flag . eq . 4. or .( h_temp . gt . 1 0. and . wind_level_flag . eq . 3 )) then !FF_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FF10_subgrid_index)*(1.-(log((10.+z0_temp)/z0_temp)-log((h_temp+z0_temp)/z0_temp))/log((10.+z0_temp)/z0_temp)) FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) call u_profile_neutral_val_func ( h_temp , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) endif !if (source_index.eq.industry_index) write(*,'(5es12.2)') meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FFgrid_subgrid_index),H_meteo,z0_temp,h_temp,FF_loc !if (source_index.eq.industry_index) write(*,'(6ES12.2)') sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc !if (source_index.eq.traffic_index.and.distance_subgrid.eq.0) write(*,'(16es12.2)') sigy_0_subgid_width_scale,distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_00_loc,sig_z_00_loc,sig_y_0_loc,sig_z_0_loc,sig_y_loc,sig_z_loc,h_emis_loc,FF_loc,1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,inv_FF10_subgrid_index) !Divide by wind speed at receptor position if ( calc_grid_vertical_average_concentration_annual_flag ) then temp_subgrid_rotated = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc , 0. , H_emep ) else temp_subgrid_rotated = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_func ( distance_subgrid , z_rec_loc , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc ) endif !If wind level flag is 6 in annual means then the average height is not calculated because a fit is used so valid for all stability types now !Needs to be calculated after sig_z_loc is calculated if ( wind_level_flag . eq . 6. or . wind_level_zc_flag ) then !if (wind_level_flag.eq.6.and.stability_scheme_flag.ne.3) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) !write(*,'(2i,7es12.2)') ii,jj,zc_loc,FF10_loc,10.,h_mix_loc,exp(logz0_loc),FF_zc_loc,u_star0_loc endif !write(*,'(a,5f12.3)') 'INFO:   ',h_mix_loc,invL_loc,exp(logz0_loc),FF_loc,u_star0_loc !write(*,'(a,8f12.3)') 'Z and h:',x_loc,az_loc,bz_loc,sig_z_loc_fit(1),sig_z_loc_fit(2),sig_z_loc,h_emis_loc,zc_loc !write(*,'(a,8f12.3)') 'Y and U:',x_loc,ay_loc,by_loc,sig_y_loc_fit(1),sig_y_loc_fit(2),sig_y_loc,FF10_loc,FF_loc !write(*,'(11f12.3)') distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_0_loc,sig_z_0_loc,h_emis_loc,h_mix_loc,FF_loc !Add the wind to the calculation temp_subgrid_rotated = temp_subgrid_rotated / FF_loc !Changed from 00 to 0 in the sigmas if ( use_target_subgrid ) then temp_target_subgrid ( i , j ,:) = temp_target_subgrid ( i , j ,:) + temp_subgrid_rotated else temp_subgrid ( i , j ,:) = temp_subgrid ( i , j ,:) + temp_subgrid_rotated endif if ( trace_emissions_from_in_region ) then ! New version of in-region calculations: allowing target region to vary with the target grid ! **************** emission_region_index = emission_subgrid_region_index ( ii , jj , source_index ) if ( use_target_subgrid ) then ! one temp_target_subgrid may contain multiple regions in the finer resolution, so we must store results in a per-region array ! -> add this contribution to the region ID that matches the current emission grid if ( emission_region_index > 0 ) then i_region = regionindex_loop_back_index ( emission_region_index ) if ( i_region > 0 ) then temp_target_subgrid_per_source_region ( i , j ,:, i_region ) = temp_target_subgrid_per_source_region ( i , j ,:, i_region ) + temp_subgrid_rotated end if end if else ! dispersion calculation is done directly on the fine-resolution target grid, so there is only one target region ! -> we can directly check if the target subgrid region ID matches the current emission grid region ID if ( emission_region_index > 0 . and . emission_region_index == subgrid_region_index ( i , j )) then subgrid_from_in_region_new ( i , j ,:) = subgrid_from_in_region_new ( i , j ,:) + temp_subgrid_rotated end if end if ! ************************ endif !write(*,'(4i5,2es12.2,4f12.3)') i,j,ii,jj,temp_subgrid(i,j,:), & !    gauss_plume_second_order_rotated_func(distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_00_loc,sig_z_00_loc,h_emis_loc)/FF_loc & !    ,distance_subgrid,az_loc,bz_loc,sig_z_00_loc !Calculate deposition only when it is not using the alternative tarrget subgrid. Fix later to be more general if ( calculate_deposition_flag . and .. not . use_target_subgrid ) then !Only use half of the source grid for deposition and depletion if ( distance_subgrid . eq . 0 ) then !s/m3 *m2=s/m deposition_subgrid_scale = 0.5 else deposition_subgrid_scale = 1.0 endif !Find the deposition grid index. Can be moved outside the loop i_cross_deposition = crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ) j_cross_deposition = crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index ,:) = subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index ,:) & + temp_subgrid_rotated * deposition_subgrid ( i_cross_deposition , j_cross_deposition , tt , vd_index ,:) * deposition_subgrid_scale !Wet deposition precip_loc = meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , precip_subgrid_index ) temp_subgrid_rotated_integrated = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc , 0. , h_mix_loc ) / FF_loc * h_mix_loc !write(*,*) temp_emission_subgrid(ii,jj,:),gauss_plume_second_order_rotated_reflected_integral_func(distance_subgrid,z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_0_loc,sig_z_0_loc,h_emis_loc,h_mix_loc,0,H_emep)/FF_loc !Set the scavenging (s/m2 /m *m/s = /m2). 1e-3/3600 converts mm/hr to m/s subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index ,:) = subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index ,:) & + temp_subgrid_rotated_integrated * wetdepo_scavanging_rate ( pollutant_loop_index (:)) * ( precip_loc / 100 0. / 360 0. ) * deposition_subgrid_scale !write(*,*) subgrid(i,j,tt,wetdepo_local_subgrid_index,source_index,:),temp_subgrid_rotated_integrated,wetdepo_scavanging_rate(nh3_index),precip_loc if ( adjust_wetdepo_integral_to_lowest_layer_flag ) then plume_vertical_integral ( 1 ,:) = temp_emission_subgrid ( ii , jj ,:) * gauss_plume_second_order_rotated_reflected_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , h_mix_loc , 0. , H_emep ) / FF_loc * H_emep plume_vertical_integral ( 2 ,:) = temp_subgrid_rotated_integrated plume_vertical_integral ( 3 ,:) = plume_vertical_integral ( 1 ,:) / H_emep endif integral_subgrid ( i_cross_target_integral , j_cross_target_integral , tt ,:, source_index ,:) = integral_subgrid ( i_cross_target_integral , j_cross_target_integral , tt ,:, source_index ,:) & + plume_vertical_integral (:,:) !write(*,*) integral_subgrid(i_cross_target_integral,j_cross_target_integral,tt,:,source_index,:) endif do i_pollutant = 1 , n_pollutant_loop if ( temp_subgrid_rotated ( i_pollutant ). gt . 0 ) then distance_subgrid = max ( distance_subgrid , distance_subgrid_min ) !Alternative heavier weighting to higher concentrations (pollutant&#94;2). Not in deposition_dispersion routine if ( use_alternative_traveltime_weighting ) then time_weight ( tt , i_pollutant ) = time_weight ( tt , i_pollutant ) + distance_subgrid / FF_loc * temp_subgrid_rotated ( i_pollutant ) ** traveltime_power time_total ( tt , i_pollutant ) = time_total ( tt , i_pollutant ) + temp_subgrid_rotated ( i_pollutant ) ** traveltime_power else !Take weighted average (weighted by concentration) of the time time_weight ( tt , i_pollutant ) = time_weight ( tt , i_pollutant ) + distance_subgrid / FF_loc * temp_subgrid_rotated ( i_pollutant ) !Calculate sum of the concentration for normalisation time_total ( tt , i_pollutant ) = time_total ( tt , i_pollutant ) + temp_subgrid_rotated ( i_pollutant ) endif endif enddo endif endif endif enddo enddo !Add to the travel time array if ( use_target_subgrid ) then traveltime_temp_target_subgrid ( i , j , 1 ,:) = traveltime_temp_target_subgrid ( i , j , 1 ,:) + time_weight ( tt ,:) traveltime_temp_target_subgrid ( i , j , 2 ,:) = traveltime_temp_target_subgrid ( i , j , 2 ,:) + time_total ( tt ,:) else traveltime_subgrid ( i , j , tt , 1 ,:) = traveltime_subgrid ( i , j , tt , 1 ,:) + time_weight ( tt ,:) traveltime_subgrid ( i , j , tt , 2 ,:) = traveltime_subgrid ( i , j , tt , 2 ,:) + time_total ( tt ,:) endif else !Set to nodata value for grids that should not be used for all pollutants temp_subgrid ( i , j ,:) = NODATA_value if ( trace_emissions_from_in_region ) subgrid_from_in_region_new ( i , j ,:) = NODATA_value endif if (. not . use_target_subgrid ) then !write(*,'(3i,3es12.2)') tt,i,j,temp_subgrid(i,j,pollutant_loop_index(nox_index)),diagnostic_subgrid(i,j,1),diagnostic_subgrid(i,j,2) else !write(*,'(3i,3es12.2)') tt,i,j,temp_target_subgrid(i,j,pollutant_loop_index(nox_index)),diagnostic_subgrid(i,j,1),diagnostic_subgrid(i,j,2) endif enddo !if (mod(j,10).eq.0) write(*,'(3a,i5,a,i5,a,i3,a,i3)') 'Gridding ',trim(source_file_str(source_index)),' proxy',j,' of ',subgrid_dim(2),' and ',subsource_index,' of ',n_subsource(source_index) enddo if ( mod ( j , 1 ). eq . 0 ) write ( * , '(3a,i5,a,i5,a,i3,a,i3)' ) 'Gridding ' , trim ( source_file_str ( source_index )), ' proxy for hour ' , tt , ' of ' , subgrid_dim ( t_dim_index ), ' and subsource ' , subsource_index , ' of ' , n_subsource ( source_index ) !Put the temporary subgrid back into the subgrid array only for the selected grids if ( use_target_subgrid ) then !write(*,*) 'Mean temp traveltime target grid',tt,sum(traveltime_temp_target_subgrid(i_target_start:i_target_end,j_target_start:j_target_end,1))/temp_target_subgrid_dim_length(x_dim_index)/temp_target_subgrid_dim_length(y_dim_index) !write(*,*) 'Mean temp target grid',tt,sum(temp_target_subgrid(i_target_start:i_target_end,j_target_start:j_target_end,n_target_comp))/temp_target_subgrid_dim_length(x_dim_index)/temp_target_subgrid_dim_length(y_dim_index) !write(*,*) shape(traveltime_temp_target_subgrid),shape(traveltime_subgrid) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then do i_pollutant = 1 , n_pollutant_loop temp_subgrid ( i , j , i_pollutant ) = area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , temp_target_subgrid (:,:, i_pollutant ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_temp_target_subgrid (:,:, 1 , i_pollutant ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_temp_target_subgrid (:,:, 2 , i_pollutant ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) !write(*,*) tt,i,j,temp_subgrid(i,j) ! New version of in-region, allowing target region to vary within the target grid ! **************** if ( trace_emissions_from_in_region . and . subgrid_region_index ( i , j ) > 0 ) then ! interpolate the contribution corresponding to the region index of this target grid i_region = regionindex_loop_back_index ( subgrid_region_index ( i , j )) subgrid_from_in_region_new ( i , j , i_pollutant ) = area_weighted_interpolation_function ( & x_target_subgrid , y_target_subgrid , temp_target_subgrid_per_source_region (:,:, i_pollutant , i_region ) & , emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ) & , emission_subgrid_delta (:, source_index ), x_subgrid ( i , j ), y_subgrid ( i , j )) end if ! *************** enddo else temp_subgrid ( i , j ,:) = NODATA_value traveltime_subgrid ( i , j , tt ,:,:) = NODATA_value if ( trace_emissions_from_in_region ) then subgrid_from_in_region_new ( i , j ,:) = NODATA_value endif endif enddo enddo endif !Add to allsource integral_subgrid (:,:, tt ,:, allsource_index ,:) = integral_subgrid (:,:, tt ,:, allsource_index ,:) + integral_subgrid (:,:, tt ,:, source_index ,:) !write(*,*) integral_subgrid(:,:,tt,hmix_integral_subgrid_index,allsource_index,i_pollutant) !write(unit_logfile,'(a,3f12.3)') 'Mean, min and max grid concentration: ',sum(temp_subgrid)/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index),minval(temp_subgrid),maxval(temp_subgrid) do i_pollutant = 1 , n_pollutant_loop temp_sum_subgrid ( i_pollutant ) = 0. if ( trace_emissions_from_in_region ) temp_sum_subgrid_from_in_region_new = 0. count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) + temp_subgrid ( i , j , i_pollutant ) if ( trace_emissions_from_in_region ) then temp_sum_subgrid_from_in_region_new ( i_pollutant ) = temp_sum_subgrid_from_in_region_new ( i_pollutant ) + subgrid_from_in_region_new ( i , j , i_pollutant ) endif count = count + 1 endif enddo enddo if ( count . gt . 0 ) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) / count else temp_sum_subgrid ( i_pollutant ) = 0 endif if ( trace_emissions_from_in_region ) then if ( count . gt . 0 ) then temp_sum_subgrid_from_in_region_new ( i_pollutant ) = temp_sum_subgrid_from_in_region_new ( i_pollutant ) / count else temp_sum_subgrid_from_in_region_new ( i_pollutant ) = 0 endif write ( unit_logfile , '(a,2f12.3)' ) 'Mean concentration (total, inregion) ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , temp_sum_subgrid ( i_pollutant ), temp_sum_subgrid_from_in_region_new ( i_pollutant ) else write ( unit_logfile , '(a,3f12.3)' ) 'Mean concentration ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , temp_sum_subgrid ( i_pollutant ) endif enddo subgrid (:,:, tt , proxy_subgrid_index , source_index ,:) = temp_subgrid if ( trace_emissions_from_in_region ) then subgrid_proxy_from_in_region (:,:, tt , source_index ,:) = subgrid_from_in_region_new endif !Determine the final travel time traveltime_subgrid (:,:, tt , 3 ,:) = traveltime_subgrid (:,:, tt , 1 ,:) / traveltime_subgrid (:,:, tt , 2 ,:) where ( traveltime_subgrid (:,:, tt , 2 ,:). eq . 0 ) traveltime_subgrid (:,:, tt , 3 ,:) = 360 0. * 1 2. enddo !time loop enddo !subsource_index !Combine the subsources in the dispersion if required !if (combine_emission_subsources_during_dispersion(source_index).and.n_subsource(source_index).gt.1) then !    do subsource_index=2,n_subsource(n_source_index) !        subgrid(:,:,:,proxy_subgrid_index,source_index,1)=subgrid(:,:,:,proxy_subgrid_index,source_index,1)+subgrid(:,:,:,proxy_subgrid_index,source_index,subsource_index) !    enddo !    n_subsource(source_index)=1 !endif if ( allocated ( trajectory_subgrid )) deallocate ( trajectory_subgrid ) if ( allocated ( temp_emission_subgrid )) deallocate ( temp_emission_subgrid ) if ( allocated ( temp_subgrid )) deallocate ( temp_subgrid ) if ( allocated ( temp_FF_subgrid )) deallocate ( temp_FF_subgrid ) if ( allocated ( temp_FF_emission_subgrid )) deallocate ( temp_FF_emission_subgrid ) if ( allocated ( temp_subgrid )) deallocate ( temp_subgrid ) if ( allocated ( traveltime_temp_target_subgrid )) deallocate ( traveltime_temp_target_subgrid ) if ( allocated ( temp_target_subgrid )) deallocate ( temp_target_subgrid ) if ( allocated ( subgrid_from_in_region_new )) deallocate ( subgrid_from_in_region_new ) if ( allocated ( temp_target_subgrid_per_source_region )) deallocate ( temp_target_subgrid_per_source_region ) end subroutine uEMEP_subgrid_dispersion !========================================================================== !   uEMEP model grid_proxy_integral !   Calculates the vertically integrated proxy concentrations based on Gaussian distribution !   Generic for all sources and subsources !   Seperate routine to the target grid as the integrated form may be of lower resolution !   Is outdated and should not be used any more !========================================================================== subroutine uEMEP_subgrid_dispersion_integral ( source_index ) use uEMEP_definitions implicit none integer i , j integer source_index integer jj , ii , tt real distance_subgrid integer i_start , i_end , j_start , j_end , t_start , t_end integer i_cross , j_cross integer i_cross_integral , j_cross_integral , i_cross_target_integral , j_cross_target_integral real cos_subgrid_loc , sin_subgrid_loc , FF_loc , FF_zc_loc , zc_loc integer subsource_index real ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , sig_y_00_loc , sig_z_00_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc real xpos_limit , ypos_limit real x_downwind , y_downwind real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_emission_subgrid , ypos_emission_subgrid real xpos_integral_subgrid , ypos_integral_subgrid real distance_emission_subgrid_min integer traj_max_index logical valid_traj real traj_step_size , x_loc , y_loc , invL_loc , FFgrid_loc , logz0_loc , u_star0_loc , FF10_loc real z0_temp , h_temp !real, allocatable :: temp_emission_subgrid(:,:) !real, allocatable :: temp_subgrid(:,:) real , allocatable :: temp_FF_subgrid (:,:) real , allocatable :: temp_FF_emission_subgrid (:,:) real , allocatable :: trajectory_subgrid (:,:,:,:) real , allocatable :: angle_diff (:,:) !functions !real gauss_plume_second_order_rotated_func !real gauss_plume_cartesian_func allocate ( temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( temp_FF_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) temp_FF_subgrid = 0. temp_FF_emission_subgrid = 0. angle_diff = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Minimum distance for dispersion set to  half of an emission grid diagonal weighted so the circle has the same area as the square with that diagonal distance_emission_subgrid_min = sqrt ( emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( x_dim_index , source_index ) & + emission_subgrid_delta ( y_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 do subsource_index = 1 , n_subsource ( source_index ) call uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) !Set local dispersion parameters prior to time loop for use in annual data ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) sig_y_00_loc = sig_y_00 ( source_index , subsource_index ) sig_z_00_loc = sig_z_00 ( source_index , subsource_index ) h_emis_loc = h_emis ( source_index , subsource_index ) z_rec_loc = z_rec ( source_index , subsource_index ) !write(*,*) z_rec_loc,ay_loc,by_loc,az_loc,bz_loc,sig_y_0_loc,sig_z_0_loc write ( unit_logfile , '(a,i3)' ) 'Calculating proxy integral concentration data for ' // trim ( source_file_str ( source_index )) // ' with subsource index ' , subsource_index !Set the start and end times of the loop t_start = 1 t_end = integral_subgrid_dim ( t_dim_index ) !Loop through the time do tt = t_start , t_end integral_subgrid (:,:, tt ,:, source_index ,:) = 0. temp_FF_subgrid = 0. !Set the last meteo data subgrid in the case when the internal time loop is used if (. not . use_single_time_loop_flag ) then if ( tt . gt . t_start ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt - 1 ,:) else last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt ,:) endif endif !Precalculate information for the trajectory model !Maxium number of trajectory steps and size of steps based on the integral (meteorology) loop size if ( use_trajectory_flag ( source_index )) then traj_step_size = min ( integral_subgrid_delta ( x_dim_index ), integral_subgrid_delta ( y_dim_index )) * traj_step_scale traj_max_index = floor ( max ( integral_subgrid_loop_index ( x_dim_index ), integral_subgrid_loop_index ( y_dim_index )) / traj_step_scale ) !if (use_downwind_position_flag) traj_max_index=traj_max_index*2 if ( tt . eq . t_start ) write ( unit_logfile , '(a,f12.1,i)' ) 'Trajectory step (m) and dimensions: ' , traj_step_size , traj_max_index if (. not . allocated ( trajectory_subgrid )) allocate ( trajectory_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), traj_max_index , 2 )) trajectory_subgrid = NODATA_value !Loop through the emissions and create trajectories for all emissions source grids do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( emission_subgrid ( i , j , tt , source_index , subsource_index ). ne . 0 ) then call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), tt , & traj_max_index , traj_step_size , trajectory_subgrid ( i , j ,:, x_dim_index ), trajectory_subgrid ( i , j ,:, y_dim_index )) endif enddo enddo endif !Create a temporary wind speed subgrid for each hour temp_FF_subgrid = 0. do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) z0_temp = exp ( meteo_subgrid ( i_cross , j_cross , tt , logz0_subgrid_index )) h_temp = h_emis ( source_index , subsource_index ) if ( annual_calculations . and . wind_level_integral_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) elseif ( annual_calculations . and . wind_level_integral_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( annual_calculations . and . wind_level_integral_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) elseif ( annual_calculations . and . wind_level_integral_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt , inv_FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) elseif ( hourly_calculations . and . wind_level_integral_flag . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( wind_level_integral_flag . eq . 0 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_integral_flag . eq . 5 ) then !Will set later based on sigma z centre of mass temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_integral_flag . eq . 6 ) then !Will set later based on average sigma z centre of mass and z_emis temp_FF_subgrid ( i_cross , j_cross ) = 1. else write ( unit_logfile , '(a)' ) 'No valid wind_level_integral_flag selected. Stopping (uEMEP_subgrid_dispersion)' stop endif !Setting a minimum value for wind for dispersion purposes (cannot be zero) temp_FF_subgrid ( i_cross , j_cross ) = sqrt ( temp_FF_subgrid ( i_cross , j_cross ) * temp_FF_subgrid ( i_cross , j_cross ) + FF_min_dispersion * FF_min_dispersion ) !Finds the angle difference between the current and last meteo field for dispersion and implements meandering if selected if ( hourly_calculations ) then call delta_wind_direction ( i_cross , j_cross , tt , meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ), angle_diff ( i_cross , j_cross )) else angle_diff ( i_cross , j_cross ) = 0. endif enddo enddo !If wind level flag is set to 5, use of initial plume centre of mass, then set wind speed for each non-zero emission grid if ( wind_level_integral_flag . eq . 5 ) then temp_FF_emission_subgrid = 0. do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) if ( sum ( emission_subgrid ( ii , jj , tt , source_index ,:)). ne . 0 ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) !Set the local variables logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) if ( annual_calculations ) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt , inv_FF10_subgrid_index ) endif !Set sig_0's at the emission position x_loc = 0. call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Use the initial plume centre of mass to determine wind advection height call z_centremass_gauss_func ( sig_z_0_loc , h_emis_loc , h_mix_loc , zc_loc ) call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) !Set a minimum wind speed based on traffic (if use_traffic_for_minFF_flag=T) !                FF_loc=sqrt(FF_loc*FF_loc+emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)*emission_properties_subgrid(ii,jj,emission_minFF_index,source_index,subsource_index)) !Set the minimum wind speed FF_loc = sqrt ( FF_loc * FF_loc + FF_min_dispersion * FF_min_dispersion ) temp_FF_emission_subgrid ( ii , jj ) = FF_loc !write(*,*) FF10_loc,FF_loc,zc_loc,sig_z_0_loc endif enddo enddo endif !Loop through the proxy integral grid do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) xpos_integral_subgrid = xproj_integral_subgrid ( i , j ) ypos_integral_subgrid = yproj_integral_subgrid ( i , j ) !Find the cross reference to the integral grid from the emission grid i_cross = crossreference_integral_to_emission_subgrid ( i , j , x_dim_index , source_index ) j_cross = crossreference_integral_to_emission_subgrid ( i , j , y_dim_index , source_index ) i_cross_target_integral = i j_cross_target_integral = j if ( use_downwind_position_flag . and . hourly_calculations ) then x_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , cos_subgrid_index ) * sqrt ( 2. ))) y_downwind = max ( - 1. , min ( 1. , meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , sin_subgrid_index ) * sqrt ( 2. ))) i_end = min ( ceiling ( i_cross + 1 + ( 1. - x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), emission_subgrid_dim ( x_dim_index , source_index )) i_start = max ( floor ( i_cross - 1 - ( 1. + x_downwind ) * emission_subgrid_loop_index ( x_dim_index , source_index )), 1 ) j_end = min ( ceiling ( j_cross + 1 + ( 1. - y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), emission_subgrid_dim ( y_dim_index , source_index )) j_start = max ( floor ( j_cross - 1 - ( 1. + y_downwind ) * emission_subgrid_loop_index ( y_dim_index , source_index )), 1 ) !Set new lon and lat limits to include the upwind source region xpos_area_max = xpos_integral_subgrid + ( 1. - x_downwind ) * xpos_limit / 2. + emission_subgrid_dim ( x_dim_index , source_index ) xpos_area_min = xpos_integral_subgrid - ( 1. + x_downwind ) * xpos_limit / 2. - emission_subgrid_dim ( x_dim_index , source_index ) ypos_area_max = ypos_integral_subgrid + ( 1. - y_downwind ) * ypos_limit / 2. + emission_subgrid_dim ( y_dim_index , source_index ) ypos_area_min = ypos_integral_subgrid - ( 1. + y_downwind ) * ypos_limit / 2. - emission_subgrid_dim ( y_dim_index , source_index ) else !Set the size of the loop region around the target cell to be up to integral_subgrid_loop_index i_start = max ( 1 , i_cross - emission_subgrid_loop_index ( x_dim_index , source_index )) i_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), i_cross + emission_subgrid_loop_index ( x_dim_index , source_index )) j_start = max ( 1 , j_cross - emission_subgrid_loop_index ( y_dim_index , source_index )) j_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), j_cross + emission_subgrid_loop_index ( y_dim_index , source_index )) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit endif !Loop through emission sub_grids in the nearby region do jj = j_start , j_end do ii = i_start , i_end if ( sum ( emission_subgrid ( ii , jj , tt , source_index ,:)). ne . 0 ) then ! xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , source_index ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , source_index ) if ( xpos_emission_subgrid . ge . xpos_area_min . and . xpos_emission_subgrid . le . xpos_area_max & . and . ypos_emission_subgrid . ge . ypos_area_min . and . ypos_emission_subgrid . le . ypos_area_max ) then !Determine meteorology grid position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) if ( hourly_calculations ) then if ( use_trajectory_flag ( source_index )) then !Calculate the minimum distance to the trajectory. Time consuming call uEMEP_minimum_distance_trajectory_fast ( x_integral_subgrid ( i , j ), y_integral_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_subgrid ( ii , jj ,:, x_dim_index ), trajectory_subgrid ( ii , jj ,:, y_dim_index ), x_loc , y_loc , valid_traj ) else !Set the local wind cos and sin values cos_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , cos_subgrid_index ) sin_subgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , sin_subgrid_index ) !Determine the rotated along wind values x_loc = ( x_integral_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc + ( y_integral_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc y_loc =- ( x_integral_subgrid ( i , j ) - x_emission_subgrid ( ii , jj , source_index )) * sin_subgrid_loc + ( y_integral_subgrid ( i , j ) - y_emission_subgrid ( ii , jj , source_index )) * cos_subgrid_loc !If x is downwind then it is valid if ( x_loc . ge . 0 ) then valid_traj = . true . else valid_traj = . false . endif endif !Calculate dispersion if ( valid_traj ) then !Set the mixing height at the average of the emission and target position h_mix_loc = ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) + meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , hmix_subgrid_index )) / 2. !Set the local wind speed and other parameters at emission position FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) !L_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,invL_subgrid_index) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) !u_star0_loc=max(meteo_subgrid(i_cross_integral,j_cross_integral,tt,ustar_subgrid_index),ustar_min) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) !Set ustar 0 to be consistent with FF10 and z0 call u_profile_neutral_val_func ( 1 0. , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF10_loc , u_star0_loc ) u_star0_loc = max ( u_star0_loc , ustar_min ) if ( wind_level_integral_flag . eq . 5 ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) endif !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 3 ) then !Set initial values for sigma. Sig_y is set here call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !write(*,*) 'IN:  ',x_loc,sig_z_loc,FF_loc call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_0_loc , sig_y_0_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !write(*,*) 'OUT: ',x_loc,sig_z_loc,FF_loc sig_y_loc = sig_y_loc + x_loc * abs ( angle_diff ( i_cross_integral , j_cross_integral )) !Use the average of the emisiion height and zc to determine wind speed. Is set to true if wind_level_flag=6 if ( wind_level_integral_flag . eq . 6 ) then FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif if ( stability_scheme_flag . eq . 4 ) then call uEMEP_set_dispersion_sigma_Kz_emulator ( h_emis_loc , invL_loc , logz0_loc , h_mix_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( wind_level_integral_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !Calculate the dispersion integral_subgrid ( i , j , tt , hsurf_average_subgrid_index , source_index ,:) = integral_subgrid ( i , j , tt , hsurf_average_subgrid_index , source_index ,:) & + gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc , 0. , H_emep ) & * emission_subgrid ( ii , jj , tt , source_index ,:) !write(*,*) i,j,integral_subgrid(i,j,tt,hsurf_average_subgrid_index,source_index,1) endif else !If annual calculations !Only works withthe simple dispersion parameters distance_subgrid = sqrt (( x_emission_subgrid ( ii , jj , source_index ) - x_integral_subgrid ( i , j )) * ( x_emission_subgrid ( ii , jj , source_index ) - x_integral_subgrid ( i , j )) & + ( y_emission_subgrid ( ii , jj , source_index ) - y_integral_subgrid ( i , j )) * ( y_emission_subgrid ( ii , jj , source_index ) - y_integral_subgrid ( i , j ))) if ( wind_level_integral_flag . eq . 5 ) then FF_loc = temp_FF_emission_subgrid ( ii , jj ) else FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) endif integral_subgrid ( i , j , tt , hsurf_average_subgrid_index , source_index ,:) = integral_subgrid ( i , j , hsurf_average_subgrid_index , tt , source_index ,:) & + emission_subgrid ( ii , jj , tt , source_index ,:) & * gauss_plume_second_order_rotated_integral_func ( distance_subgrid , ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , h_emis_loc , 0. , H_emep ) & / FF_loc endif endif endif enddo enddo !write(*,'(6i6,f)') i,j,i_start,i_end,j_start,j_end,integral_subgrid(i,j,tt,source_index,subsource_index) enddo !write(*,'(3a,i5,a,i5,a,i3,a,i3)') 'Gridding ',trim(source_file_str(source_index)),' integral proxy',j,' of ',integral_subgrid_dim(y_dim_index),' and ',subsource_index,' of ',n_subsource(source_index) enddo if ( mod ( j , 1 ). eq . 0 ) write ( * , '(3a,i5,a,i5,a,i3,a,i3)' ) 'Integral gridding ' , trim ( source_file_str ( source_index )), ' proxy for hour ' , tt , ' of ' , subgrid_dim ( t_dim_index ), ' and ' , subsource_index , ' of ' , n_subsource ( source_index ) enddo !time loop enddo !subsource_index !if (combine_emission_subsources_during_dispersion(source_index).and.n_subsource(source_index).gt.1) then !    do subsource_index=2,n_subsource(n_source_index) !        integral_subgrid(:,:,:,:,source_index,1)=integral_subgrid(:,:,:,:,source_index,1)+integral_subgrid(:,:,:,:,source_index,subsource_index) !    enddo !    n_subsource(source_index)=1 !endif if ( allocated ( trajectory_subgrid )) deallocate ( trajectory_subgrid ) !if (allocated(temp_emission_subgrid)) deallocate(temp_emission_subgrid) !if (allocated(temp_subgrid)) deallocate(temp_subgrid) if ( allocated ( temp_FF_subgrid )) deallocate ( temp_FF_subgrid ) end subroutine uEMEP_subgrid_dispersion_integral end module subgrid_dispersion","tags":"","loc":"sourcefile/uemep_subgrid_dispersion.f90.html"},{"title":"uEMEP_read_command_line.f90 – uEMEP","text":"Source Code module read_command_line !! Routines for interacting with the command line use uemep_configuration , only : name_config_file , config_date_str , n_config_files , n_max_config_files use uEMEP_definitions , only : model_version_str use uemep_logger implicit none private public :: uEMEP_read_command_line , check_command_line contains subroutine check_command_line () !! Checks that a suitable number of command line arguments has been supplied !! and handles some special cases of command line inputs !! !! 'check_command_line' will write to stdout instead of the log file !! to give direct feedback to the user ! Local variables integer :: n_args , i character ( len = 256 ) :: arg ! Check if no arguments are found n_args = command_argument_count () if ( n_args <= 0 ) then write ( * , \"(a)\" ) \" Insufficient number of command line arguments\" write ( * , \"(a)\" ) \" Try 'uemep --help' for more information\" stop end if ! Loop over input arguments to handle special cases do i = 1 , n_args call get_command_argument ( i , arg ) select case ( adjustl ( arg )) case ( \"--help\" ) call print_help_page () stop case ( \"--version\" ) call print_version () stop end select end do ! After checking that no special cases are found, check if the number of ! arguments are within acceptable bounds (2:n_max_config_files+1) if ( n_args < 2 ) then write ( * , \"(a)\" ) \" Insufficient number of command line arguments\" write ( * , \"(a)\" ) \" Try 'uemep --help' for more information\" stop else if ( n_args > n_max_config_files + 1 ) then write ( * , \"(a)\" ) \" Too many command line arguments\" write ( * , \"(a)\" ) \" Try 'uemep --help' for more information\" stop end if end subroutine check_command_line subroutine uEMEP_read_command_line () !! Assigns the configuration file name(s) and substitution date_str from the command line ! Local variables integer :: n_args , i ! Get number of command line arguments n_args = command_argument_count () n_config_files = n_args - 1 ! Read file names do i = 1 , n_config_files call get_command_argument ( i , name_config_file ( i )) write ( * , \"(a,i0,2a)\" ), \"name_config_file(\" , i , \") = \" , trim ( name_config_file ( i )) end do ! Read date string call get_command_argument ( n_args , config_date_str ) write ( * , \"(2a)\" ) \"config_date_str = \" , trim ( config_date_str ) end subroutine uEMEP_read_command_line subroutine print_help_page () !! Prints a help message to the terminal console write ( * , \"(a)\" ) \" uEMEP: Air quality dispersion model for high resolution downscaling of EMEP MSC-W\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" To run the uEMEP model:\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" ./uemep config_file_1 config_file_2 ... config_file_10 date_string\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" Where config_file_n is the name of the configuration file(s) which specify\" write ( * , \"(a)\" ) \" the model calculations and with a maximum number of 10 config files, and\" write ( * , \"(a)\" ) \" the date_string, required, takes the form 'yyyymmdd'.\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" Please read the manual on how to configure uEMEP at: <URL>.\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" --help                     displays this help message and exits\" write ( * , \"(a)\" ) \" --version                  outputs the uEMEP version and exits\" end subroutine print_help_page subroutine print_version () !! Prints the program version to the terminal console write ( * , \"(a)\" ) \" uEMEP: Air quality dispersion model for high resolution downscaling of EMEP MSC-W\" write ( * , \"(a)\" ) \" \" write ( * , \"(2a)\" ) \" Version: \" , trim ( model_version_str ) write ( * , \"(a)\" ) \" Copyright (C) 2007 Free Software Foundation.\" write ( * , \"(a)\" ) \" License GNU LGPL-3.0 <https://www.gnu.org/licenses/lgpl-3.0.html>.\" write ( * , \"(a)\" ) \" This is free software: you are free to change and redistribute it.\" write ( * , \"(a)\" ) \" \" write ( * , \"(a)\" ) \" Developed and maintained at the Norwegian Meteorological Institute.\" write ( * , \"(a)\" ) \" Contribute at: <https://github.com/metno/uEMEP>\" end subroutine print_version end module read_command_line","tags":"","loc":"sourcefile/uemep_read_command_line.f90.html"},{"title":"uEMEP_read_roadlink_data_ascii.f90 – uEMEP","text":"Source Code module read_roadlink_data_ascii use uemep_configuration use utility_functions , only : nxtdat , ll2utm , ll2ltm use time_functions , only : date_to_number , number_to_date , datestr_to_date use mod_lambert_projection , only : LL2LAEA , PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: read_country_bounding_box_data , uEMEP_read_roadlink_data_ascii , & uEMEP_change_road_data , uEMEP_read_roadlink_emission_data contains subroutine uEMEP_read_roadlink_data_ascii use uEMEP_definitions implicit none integer i , j integer unit_in integer rl_length_short logical :: exists logical nxtdat_flag real sub_nodes_x ( 5000 ), sub_nodes_y ( 5000 ), sub_nodes_lon ( 5000 ), sub_nodes_lat ( 5000 ) integer temp_id , n_subnodes , temp_road_type , temp_nlanes real temp_adt , temp_hdv , temp_speed , temp_width integer counter real size_major ( 3 ) integer n_loop , loop_step real x_grid_min , x_grid_max , y_grid_min , y_grid_max integer counter_major , counter_sub logical :: show_diagnostics = . false . real diagnostic_val ( 10 ) integer temp_category , temp_structure_type , temp_region_id , temp_surface_id , temp_route_id real temp_length , temp_tunnel_length logical :: road_data_in_latlon = . false . real temp_real real , allocatable :: inputdata_rl_temp (:,:) integer , allocatable :: inputdata_int_rl_temp (:,:) real , allocatable :: inputdata_rl_multi (:,:) integer , allocatable :: inputdata_int_rl_multi (:,:) real , allocatable :: inputdata_rl_multi_new (:,:) integer , allocatable :: inputdata_int_rl_multi_new (:,:) integer n_multi_roadlinks_new , n_multi_roadlinks integer m integer n_road_link_file_loop logical :: first_road_link_file_read = . false . integer temp_int integer :: io write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading road link data ascii (uEMEP_read_roadlink_data_ascii)' write ( unit_logfile , '(A)' ) '================================================================' min_adt = 1 0. min_link_size = 1. if ( num_multiple_roadlink_files . eq . 0 ) then n_road_link_file_loop = 1 else n_road_link_file_loop = num_multiple_roadlink_files endif !Start the file loop here !--------------------------- n_multi_roadlinks_new = 0 n_multi_roadlinks = 0 first_road_link_file_read = . false . do m = 1 , n_road_link_file_loop if ( num_multiple_roadlink_files . gt . 0 ) then !pathname_rl(1)=pathname_mrl(m) filename_rl ( 1 ) = filename_mrl ( m ) write ( * , * ) m , n_road_link_file_loop , trim ( filename_rl ( 1 )) endif pathfilename_rl ( 1 ) = trim ( pathname_rl ( 1 )) // trim ( filename_rl ( 1 )) !write(*,*) pathname_rl(2),filename_rl(2),pathfilename_rl(2) !Test existence of the road link filename (2). If does not exist then stop inquire ( file = trim ( pathfilename_rl ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Road link file ascii does not exist: ' , trim ( pathfilename_rl ( 1 )) stop endif !Check filename for the string 'latlon' that specifies if the data is in lat lon coordinates if ( index ( filename_rl ( 1 ), 'latlon' ). gt . 0 ) then road_data_in_latlon = . true . write ( unit_logfile , '(A,A)' ) ' Reading road data positions as lat lon: ' , trim ( pathfilename_rl ( 1 )) endif !Open the file for reading to test the available links in the region if ( reduce_roadlink_region_flag ) then unit_in = 20 open ( unit_in , file = pathfilename_rl ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link file(ascii) ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !read the header to find out how many links there are !read(unit_in,'(a)',ERR=20) temp_str if ( no_header_roadlink_data_flag ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) without header: ' // trim ( pathfilename_rl ( 1 )) i = 0 do read ( unit_in , * , iostat = io ) temp_real , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if if ( temp_real . gt . 0 ) then i = i + 1 n_roadlinks = n_roadlinks + n_subnodes - 1 endif if ( int ( temp_real ). ne . temp_real ) then write ( unit_logfile , '(a,i,f)' ) ' Problem with record at point with ID: ' , i , temp_real stop endif enddo n_roadlinks_major = i !n_roadlinks=0 rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) else read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks endif if ( n_roadlinks . eq . 0 ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) with header but without subnode counts: ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks i = 0 do read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !Read attributes up to n_subnodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if if ( temp_id . gt . 0 ) then i = i + 1 n_roadlinks = n_roadlinks + n_subnodes - 1 endif enddo !Have commented out this in the cases where the number of links are not as written. Can happen with OSM data !n_roadlinks_major=i rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) temp_int , temp_int endif write ( unit_logfile , '(a,i)' ) ' Number of major road links in header = ' , n_roadlinks_major write ( unit_logfile , '(a,i)' ) ' Number of sub road links in header= ' , n_roadlinks !Allocate the arrays after reading in the number of roads !allocate (inputdata_rl_temp(n_roadlinks,num_var_rl)) !allocate (inputdata_int_rl_temp(n_roadlinks,num_int_rl)) if ( allocated ( valid_link_flag )) deallocate ( valid_link_flag ) allocate ( valid_link_flag ( n_roadlinks_major )) valid_link_flag = . false . !Initialise !inputdata_rl_temp=0. !inputdata_int_rl_temp=0 counter_major = 0 counter_sub = 0 !Read the data to find roads in the tile !x_grid_min=emission_subgrid_min(x_dim_index,traffic_index) !x_grid_max=emission_subgrid_min(x_dim_index,traffic_index)+(emission_subgrid_dim(x_dim_index,traffic_index)+1)*emission_subgrid_delta(x_dim_index,traffic_index) !y_grid_min=emission_subgrid_min(y_dim_index,traffic_index) !y_grid_max=emission_subgrid_min(y_dim_index,traffic_index)+(emission_subgrid_dim(y_dim_index,traffic_index)+1)*emission_subgrid_delta(y_dim_index,traffic_index) x_grid_min = init_emission_subgrid_min ( x_dim_index , traffic_index ) x_grid_max = init_emission_subgrid_min ( x_dim_index , traffic_index ) + ( init_emission_subgrid_dim ( x_dim_index , traffic_index ) + 1 ) * init_emission_subgrid_delta ( x_dim_index , traffic_index ) y_grid_min = init_emission_subgrid_min ( y_dim_index , traffic_index ) y_grid_max = init_emission_subgrid_min ( y_dim_index , traffic_index ) + ( init_emission_subgrid_dim ( y_dim_index , traffic_index ) + 1 ) * init_emission_subgrid_delta ( y_dim_index , traffic_index ) !Under the special case where multiple roads are read from different countries then us the intital grid to determine which to keep !This is not implemented yet but needs to select the region when reading multiple files !if !init_subgrid_min(x_dim_index)=subgrid_min(x_dim_index) !init_subgrid_min(y_dim_index)=subgrid_min(y_dim_index) !init_subgrid_max(x_dim_index)=subgrid_max(x_dim_index) !init_subgrid_max(y_dim_index)=subgrid_max(y_dim_index) !endif !rewind(unit_in) !call nxtdat_modern(unit_in,nxtdat_flag) !read(unit_in,*,ERR=20) temp_int,temp_int do i = 1 , n_roadlinks_major !ID ADT HDV ROAD_TYPE SPEED N_SUBLINKS read ( unit_in , * , ERR = 20 ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !read(unit_in,*,ERR=20) !temp_id !write(*,*) temp_id,temp_adt,n_subnodes if ( road_data_in_latlon ) then !Order is reversed in these files read ( unit_in , * ) sub_nodes_y ( 1 ) read ( unit_in , * ) sub_nodes_x ( 1 ) if ( projection_type . eq . UTM_projection_index ) then !write(*,*) i,sub_nodes_x(1),sub_nodes_y(1) call ll2utm ( 1 , utm_zone , sub_nodes_y ( 1 ), sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_x ( 1 )) !write(*,*) i,sub_nodes_x(1),sub_nodes_y(1) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , sub_nodes_y ( 1 ), sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_x ( 1 )) elseif ( projection_type . eq . LCC_projection_index ) then elseif ( projection_type . eq . PS_projection_index ) then elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), projection_attributes ) endif else read ( unit_in , * ) sub_nodes_x ( 1 ) read ( unit_in , * ) sub_nodes_y ( 1 ) endif !Convert to EMEP coordinates from UTM to lambert. No choices here. Special case but should be changed if ( save_emissions_for_EMEP ( traffic_index )) then call PROJ2LL ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_lon ( 1 ), sub_nodes_lat ( 1 ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,sub_nodes_y(1),sub_nodes_x(1),sub_nodes_lat(1),sub_nodes_lon(1)) if ( projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_lon ( 1 ), sub_nodes_lat ( 1 ), EMEP_projection_attributes ) elseif ( projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( sub_nodes_x ( 1 ), sub_nodes_y ( 1 ), sub_nodes_lon ( 1 ), sub_nodes_lat ( 1 ), EMEP_projection_attributes ) else !Remains as lat lon endif !write(*,*) sub_nodes_x(1),sub_nodes_y(1),sub_nodes_lon(1),sub_nodes_lat(1) endif !write(*,*) sub_nodes_x(1),sub_nodes_y(1) !write(*,*) x_grid_min,x_grid_max,y_grid_min,y_grid_max !Test position within emission region if ( sub_nodes_x ( 1 ). ge . x_grid_min . and . sub_nodes_x ( 1 ). le . x_grid_max & . and . sub_nodes_y ( 1 ). ge . y_grid_min . and . sub_nodes_y ( 1 ). le . y_grid_max ) then counter_major = counter_major + 1 counter_sub = counter_sub + n_subnodes - 1 valid_link_flag ( i ) = . true . else valid_link_flag ( i ) = . false . endif enddo close ( unit_in , status = 'keep' ) write ( unit_logfile , '(a,i,i)' ) ' Number of major and sub road links within the region = ' , counter_major , counter_sub endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_rl ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link file(ascii) ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !read the header to find out how many links there are !read(unit_in,'(a)',ERR=20) temp_str if ( no_header_roadlink_data_flag ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) without header: ' // trim ( pathfilename_rl ( 1 )) i = 0 do read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !Read attributes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if if ( temp_id . gt . 0 ) then i = i + 1 endif enddo n_roadlinks_major = i n_roadlinks = n_roadlinks + n_subnodes - 1 rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) else read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks endif if ( n_roadlinks . eq . 0. and .. not . reduce_roadlink_region_flag ) then write ( unit_logfile , '(a)' ) ' Reading road link file(ascii) with header but without subnode counts: ' // trim ( pathfilename_rl ( 1 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlinks_major , n_roadlinks i = 0 do read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes !Read attributes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 ) !Read x nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 ) !Read y nodes if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if !write(*,*) temp_id if ( temp_id . gt . 0 ) then i = i + 1 n_roadlinks = n_roadlinks + n_subnodes - 1 endif enddo !n_roadlinks_major=i rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) endif write ( unit_logfile , '(a,i)' ) ' Number of major road links= ' , n_roadlinks_major write ( unit_logfile , '(a,i)' ) ' Number of sub road links= ' , n_roadlinks !Allocate the arrays after reading in the number of roads if ( reduce_roadlink_region_flag ) then n_roadlinks = counter_sub n_roadlinks_major_selected = counter_major else !Set all road links to valid when not regionally selecting. THis will fail because already allocated if ( allocated ( valid_link_flag )) deallocate ( valid_link_flag ) allocate ( valid_link_flag ( n_roadlinks_major )) valid_link_flag = . true . endif if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_temp )) deallocate ( inputdata_int_rl_temp ) allocate ( inputdata_rl_temp ( n_roadlinks , num_var_rl )) allocate ( inputdata_int_rl_temp ( n_roadlinks , num_int_rl )) !Initialise inputdata_rl_temp = 0. inputdata_int_rl_temp = 0 counter = 0 counter_major = 0 !rewind(unit_in) !call nxtdat_modern(unit_in,nxtdat_flag) !read(unit_in,*,ERR=20) temp_int,temp_int !Read the data do i = 1 , n_roadlinks_major !    if (.not.valid_link_flag(i)) then !        if (read_OSM_roadlink_data_flag) then !ID ADT HDV ROAD_TYPE SPEED N_SUBLINKS !            if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_id,temp_adt,temp_hdv,temp_road_type,temp_speed,temp_width,temp_nlanes,n_subnodes !        else !ID ADT HDV ROAD_ACTIVITY_TYPE SPEED ROAD_WIDTH N_LANES N_SUBNODES ROAD_CATEGORY ROAD_LENGTH ROAD_STRUCTURE_TYPE REGION_ID ROAD_SURFACE_ID TUNNEL_LENGTH ROUTE_ID !            if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_id,temp_adt,temp_hdv,temp_road_type,temp_speed,temp_width,temp_nlanes,n_subnodes & !            ,temp_category,temp_length,temp_structure_type,temp_region_id,temp_surface_id,temp_tunnel_length,temp_route_id !        endif !write(*,*) temp_id,temp_adt,n_subnodes !        if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_val !        if (.not.eof(unit_in)) read(unit_in,*,ERR=20) temp_val !    else if ( read_OSM_roadlink_data_flag ) then !ID ADT HDV ROAD_TYPE SPEED N_SUBLINKS read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if temp_category = 0 ; temp_length = 0 ; temp_structure_type = 0 ; temp_region_id = 0 ; temp_surface_id = 0 ; temp_tunnel_length = 0 ; temp_route_id = 0 else !ID ADT HDV ROAD_ACTIVITY_TYPE SPEED ROAD_WIDTH N_LANES N_SUBNODES ROAD_CATEGORY ROAD_LENGTH ROAD_STRUCTURE_TYPE REGION_ID ROAD_SURFACE_ID TUNNEL_LENGTH ROUTE_ID read ( unit_in , * , iostat = io ) temp_id , temp_adt , temp_hdv , temp_road_type , temp_speed , temp_width , temp_nlanes , n_subnodes & , temp_category , temp_length , temp_structure_type , temp_region_id , temp_surface_id , temp_tunnel_length , temp_route_id if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if endif !write(*,*) i,temp_id,temp_adt,n_subnodes read ( unit_in , * , iostat = io ) sub_nodes_x ( 1 : n_subnodes ) if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if read ( unit_in , * , iostat = io ) sub_nodes_y ( 1 : n_subnodes ) if ( io /= 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading road link file: \" , trim ( pathfilename_rl ( 1 )) stop 1 end if !write(*,*) sub_nodes_x(1:n_subnodes),sub_nodes_y(1:n_subnodes) !put in the road link data !Test size of major link. If less than min_link_size then treat it as a single link from the start sub_node to the end sub_node if ( valid_link_flag ( i )) then !Do not do this with latlon input data as it does not work if (. not . road_data_in_latlon ) then size_major ( 1 ) = maxval ( sub_nodes_x ( 1 : n_subnodes )) - minval ( sub_nodes_x ( 1 : n_subnodes )) size_major ( 2 ) = maxval ( sub_nodes_y ( 1 : n_subnodes )) - minval ( sub_nodes_y ( 1 : n_subnodes )) size_major ( 3 ) = sqrt ( size_major ( 1 ) ** 2 + size_major ( 2 ) ** 2 ) if ( size_major ( 3 ). gt . min_link_size ) then n_loop = n_subnodes - 1 loop_step = 1 else n_loop = 1 loop_step = n_subnodes - 1 !write(*,*) size_major(3) endif else n_loop = n_subnodes - 1 loop_step = 1 endif counter_major = counter_major + 1 !if (n_subnodes.gt.5000) then !    write(*,*) 'Greater than 5000 ',i !endif !Place the data in the road links if ( temp_adt . ge . min_adt ) then do j = 1 , n_loop counter = counter + 1 if ( counter . le . n_roadlinks ) then inputdata_int_rl_temp ( counter , major_index_rl_index ) = counter_major inputdata_int_rl_temp ( counter , id_rl_index ) = temp_id inputdata_rl_temp ( counter , adt_rl_index ) = temp_adt ** osm_adt_power_scale inputdata_rl_temp ( counter , hdv_rl_index ) = temp_hdv inputdata_int_rl_temp ( counter , roadtype_rl_index ) = temp_road_type inputdata_rl_temp ( counter , speed_rl_index ) = temp_speed inputdata_rl_temp ( counter , width_rl_index ) = temp_width inputdata_int_rl_temp ( counter , nlanes_rl_index ) = temp_nlanes inputdata_rl_temp ( counter , x1_rl_index ) = sub_nodes_x ( j ) inputdata_rl_temp ( counter , x2_rl_index ) = sub_nodes_x ( j + loop_step ) inputdata_rl_temp ( counter , y1_rl_index ) = sub_nodes_y ( j ) inputdata_rl_temp ( counter , y2_rl_index ) = sub_nodes_y ( j + loop_step ) !write(*,*) inputdata_int_rl(counter,id_rl_index),inputdata_rl(counter,x1_rl_index),inputdata_rl(counter,y2_rl_index) inputdata_rl_temp ( counter , tunnel_length_rl_index ) = temp_tunnel_length endif enddo !write(*,*) counter, inputdata_int_rl_temp(counter,major_index_rl_index) endif endif enddo write ( unit_logfile , '(a,i)' ) ' Number of counted road links= ' , counter write ( unit_logfile , '(a,i)' ) ' Number of road links allocated = ' , n_roadlinks n_roadlinks = min ( counter , n_roadlinks ) close ( unit_in , status = 'keep' ) !Allocate the arrays after reading in the number of roads if ( allocated ( inputdata_rl )) deallocate ( inputdata_rl ) if ( allocated ( inputdata_int_rl )) deallocate ( inputdata_int_rl ) allocate ( inputdata_rl ( n_roadlinks , num_var_rl )) allocate ( inputdata_int_rl ( n_roadlinks , num_int_rl )) inputdata_rl = inputdata_rl_temp ( 1 : n_roadlinks ,:) inputdata_int_rl = inputdata_int_rl_temp ( 1 : n_roadlinks ,:) if ( road_data_in_latlon ) then !Order is reversed in these files so they are reversed in the projection calls as well do i = 1 , n_roadlinks if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , inputdata_rl_temp ( i , x1_rl_index ), inputdata_rl_temp ( i , y1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , x1_rl_index )) call ll2utm ( 1 , utm_zone , inputdata_rl_temp ( i , x2_rl_index ), inputdata_rl_temp ( i , y2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , x2_rl_index )) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , inputdata_rl_temp ( i , x1_rl_index ), inputdata_rl_temp ( i , y1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , x1_rl_index )) call ll2ltm ( 1 , ltm_lon0 , inputdata_rl_temp ( i , x2_rl_index ), inputdata_rl_temp ( i , y2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , x2_rl_index )) elseif ( projection_type . eq . LCC_projection_index ) then elseif ( projection_type . eq . PS_projection_index ) then elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl_temp ( i , y1_rl_index ), inputdata_rl_temp ( i , x1_rl_index ), projection_attributes ) call LL2LAEA ( inputdata_rl ( i , x2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl_temp ( i , y2_rl_index ), inputdata_rl_temp ( i , x2_rl_index ), projection_attributes ) endif enddo endif if ( num_multiple_roadlink_files . gt . 1 ) then if ( n_roadlinks . gt . 0 ) then n_multi_roadlinks_new = n_multi_roadlinks + n_roadlinks !For the first roadloop if (. not . first_road_link_file_read ) then !Allocate the multi road array for the first time n_multi_roadlinks_new = n_roadlinks n_multi_roadlinks = n_multi_roadlinks_new if (. not . allocated ( inputdata_rl_multi )) allocate ( inputdata_rl_multi ( n_multi_roadlinks , num_var_rl )) if (. not . allocated ( inputdata_int_rl_multi )) allocate ( inputdata_int_rl_multi ( n_multi_roadlinks , num_int_rl )) inputdata_rl_multi ( 1 : n_multi_roadlinks ,:) = inputdata_rl ( 1 : n_multi_roadlinks ,:) inputdata_int_rl_multi ( 1 : n_multi_roadlinks ,:) = inputdata_int_rl ( 1 : n_roadlinks ,:) first_road_link_file_read = . true . else !Allocate the new multi array with all roads so far allocate ( inputdata_rl_multi_new ( n_multi_roadlinks_new , num_var_rl )) allocate ( inputdata_int_rl_multi_new ( n_multi_roadlinks_new , num_int_rl )) !Place the current multi roads in the new multiroads !NOTE: inputdata_rl_multi is not allocated until later, debugging error but do not use this anyway! inputdata_rl_multi_new ( 1 : n_multi_roadlinks ,:) = inputdata_rl_multi ( 1 : n_multi_roadlinks ,:) inputdata_int_rl_multi_new ( 1 : n_multi_roadlinks ,:) = inputdata_int_rl_multi ( 1 : n_roadlinks ,:) !Place the last read road links in the new multiroads inputdata_rl_multi_new ( n_multi_roadlinks + 1 : n_multi_roadlinks_new ,:) = inputdata_rl ( 1 : n_roadlinks ,:) inputdata_int_rl_multi_new ( n_multi_roadlinks + 1 : n_multi_roadlinks_new ,:) = inputdata_int_rl ( 1 : n_roadlinks ,:) !Deallocate the old multi road arrays if ( allocated ( inputdata_rl_multi )) deallocate ( inputdata_rl_multi ) if ( allocated ( inputdata_int_rl_multi )) deallocate ( inputdata_int_rl_multi ) n_multi_roadlinks = n_multi_roadlinks_new !Allocate the multi road array allocate ( inputdata_rl_multi ( n_multi_roadlinks , num_var_rl )) allocate ( inputdata_int_rl_multi ( n_multi_roadlinks , num_int_rl )) !Put the new data in the old one inputdata_rl_multi = inputdata_rl_multi_new inputdata_int_rl_multi = inputdata_int_rl_multi_new !Deallocate the new multi road arrays if ( allocated ( inputdata_rl_multi_new )) deallocate ( inputdata_rl_multi_new ) if ( allocated ( inputdata_int_rl_multi_new )) deallocate ( inputdata_int_rl_multi_new ) endif endif !Deallocate the other arrays as well if ( allocated ( inputdata_rl )) deallocate ( inputdata_rl ) if ( allocated ( inputdata_int_rl )) deallocate ( inputdata_int_rl ) if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_temp )) deallocate ( inputdata_int_rl_temp ) if ( allocated ( valid_link_flag )) deallocate ( valid_link_flag ) write ( unit_logfile , '(a,i)' ) ' Number of accumulated multi-road links used = ' , n_multi_roadlinks_new endif !End the multiloop here enddo if ( num_multiple_roadlink_files . gt . 1 ) then allocate ( inputdata_rl ( n_multi_roadlinks , num_var_rl )) allocate ( inputdata_int_rl ( n_multi_roadlinks , num_int_rl )) inputdata_rl = inputdata_rl_multi inputdata_int_rl = inputdata_int_rl_multi if ( allocated ( inputdata_rl_multi )) deallocate ( inputdata_rl_multi ) if ( allocated ( inputdata_int_rl_multi )) deallocate ( inputdata_int_rl_multi ) n_roadlinks = n_multi_roadlinks_new write ( unit_logfile , '(a,i)' ) ' Number of accumulated multi-road links used = ' , n_multi_roadlinks endif if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_temp )) deallocate ( inputdata_int_rl_temp ) !No speed in the files currently. Set all to 50 km/hr. Temporary !inputdata_rl(:,speed_rl_index)=50. !inputdata_rl(:,width_rl_index)=10. !inputdata_int_rl(:,nlanes_rl_index)=2 !Set the road type, normal or tunnel (tunnel or jet). When a tunnel then there is no retention, always dry !do i=1,n_roadlinks !    if (inputdata_int_rl(i,roadtype_rl_index).eq.5.or.inputdata_int_rl(i,roadtype_rl_index).eq.6) then !        inputdata_int_rl(i,roadtype_rl_index)=tunnel_roadtype !    else !        inputdata_int_rl(i,roadtype_rl_index)=normal_roadtype !    endif !enddo !Calculate some additional values inputdata_rl (:, x0_rl_index ) = ( inputdata_rl (:, x1_rl_index ) + inputdata_rl (:, x2_rl_index )) / 2. inputdata_rl (:, y0_rl_index ) = ( inputdata_rl (:, y1_rl_index ) + inputdata_rl (:, y2_rl_index )) / 2. inputdata_rl (:, length_rl_index ) = sqrt (( inputdata_rl (:, x1_rl_index ) - inputdata_rl (:, x2_rl_index )) ** 2 + ( inputdata_rl (:, y1_rl_index ) - inputdata_rl (:, y2_rl_index )) ** 2 ) !Calculate road orientation and check for range overflows for length as well !inputdata_rl(angle_rl_index,:)=180./3.14159*acos((inputdata_rl(y2_rl_index,:)-inputdata_rl(y1_rl_index,:))/inputdata_rl(length_rl_index,:)) do i = 1 , n_roadlinks call PROJ2LL ( inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , lon1_rl_index ), inputdata_rl ( i , lat1_rl_index ), projection_attributes , projection_type ) call PROJ2LL ( inputdata_rl ( i , x2_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , lon2_rl_index ), inputdata_rl ( i , lat2_rl_index ), projection_attributes , projection_type ) call PROJ2LL ( inputdata_rl ( i , x0_rl_index ), inputdata_rl ( i , y0_rl_index ), inputdata_rl ( i , lon0_rl_index ), inputdata_rl ( i , lat0_rl_index ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,inputdata_rl(i,y1_rl_index),inputdata_rl(i,x1_rl_index),inputdata_rl(i,lat1_rl_index),inputdata_rl(i,lon1_rl_index)) !call UTM2LL(utm_zone,inputdata_rl(i,y2_rl_index),inputdata_rl(i,x2_rl_index),inputdata_rl(i,lat2_rl_index),inputdata_rl(i,lon2_rl_index)) !call UTM2LL(utm_zone,inputdata_rl(i,y0_rl_index),inputdata_rl(i,x0_rl_index),inputdata_rl(i,lat0_rl_index),inputdata_rl(i,lon0_rl_index)) enddo !Check lengths rl_length_short = 0 do i = 1 , n_roadlinks if ( inputdata_rl ( i , length_rl_index ). eq . 0.0 ) then rl_length_short = rl_length_short + 1 !write(unit_logfile,'(a,2i,f12.5)') ' WARNING: Zero link length, setting to 1 m ',i,inputdata_int_rl(i,id_rl_index),inputdata_rl(i,length_rl_index) inputdata_rl ( i , length_rl_index ) = 1. endif enddo !write(*,*) 'Max length: ',maxval(inputdata_rl(:,length_rl_index)),inputdata_rl(maxloc(inputdata_rl(:,length_rl_index)),lat0_rl_index),inputdata_rl(maxloc(inputdata_rl(:,length_rl_index)),lon0_rl_index) write ( unit_logfile , * ) 'Number of road links with 0 length: ' , rl_length_short , '  Setting to 1 m' write ( unit_logfile , * ) 'Max road link x and y: ' , maxval ( inputdata_rl (:, x0_rl_index )), maxval ( inputdata_rl (:, y0_rl_index )) write ( unit_logfile , * ) 'Min road link x and y: ' , minval ( inputdata_rl (:, x0_rl_index )), minval ( inputdata_rl (:, y0_rl_index )) if ( n_roadlinks . gt . 0 ) then write ( unit_logfile , '(a14,12a10)' ) ' LINK ' , 'ID' , 'X1' , 'X2' , 'Y1' , 'Y2' , 'WIDTH' , 'LENGTH' , 'ADT' , 'LON' , 'LAT' , 'N_LANES' , 'TYPE' i = 1 write ( unit_logfile , '(a14,i10,7f10.1,2f10.4,2i10)' ) ' First link = ' , inputdata_int_rl ( i , id_rl_index ), inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , x2_rl_index ) & , inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , width_rl_index ) & , inputdata_rl ( i , length_rl_index ), inputdata_rl ( i , adt_rl_index ) & , inputdata_rl ( i , lon0_rl_index ), inputdata_rl ( i , lat0_rl_index ) & , inputdata_int_rl ( i , nlanes_rl_index ), inputdata_int_rl ( i , roadtype_rl_index ) i = n_roadlinks write ( unit_logfile , '(a14,i10,7f10.1,2f10.4,2i10)' ) ' Last link = ' , inputdata_int_rl ( i , id_rl_index ), inputdata_rl ( i , x1_rl_index ), inputdata_rl ( i , x2_rl_index ) & , inputdata_rl ( i , y1_rl_index ), inputdata_rl ( i , y2_rl_index ), inputdata_rl ( i , width_rl_index ) & , inputdata_rl ( i , length_rl_index ), inputdata_rl ( i , adt_rl_index ) & , inputdata_rl ( i , lon0_rl_index ), inputdata_rl ( i , lat0_rl_index ) & , inputdata_int_rl ( i , nlanes_rl_index ), inputdata_int_rl ( i , roadtype_rl_index ) else write ( unit_logfile , '(a)' ) 'No road links available in this region' endif !Calculate the veh km totals if ( show_diagnostics ) then diagnostic_val = 0. do i = 1 , n_roadlinks !Total kilometres diagnostic_val ( 1 ) = diagnostic_val ( 1 ) + inputdata_rl ( i , length_rl_index ) / 100 0. !Total veh kilometres diagnostic_val ( 2 ) = diagnostic_val ( 2 ) + inputdata_rl ( i , length_rl_index ) / 100 0. * inputdata_rl ( i , adt_rl_index ) * 36 5. !Light veh kilometres diagnostic_val ( 3 ) = diagnostic_val ( 3 ) + ( 1. - inputdata_rl ( i , hdv_rl_index ) / 10 0. ) * inputdata_rl ( i , length_rl_index ) / 100 0. * inputdata_rl ( i , adt_rl_index ) * 36 5. !Light veh kilometres diagnostic_val ( 4 ) = diagnostic_val ( 4 ) + ( inputdata_rl ( i , hdv_rl_index ) / 10 0. ) * inputdata_rl ( i , length_rl_index ) / 100 0. * inputdata_rl ( i , adt_rl_index ) * 36 5. enddo write ( unit_logfile , '(a,es12.4)' ) 'Total km= ' , diagnostic_val ( 1 ) write ( unit_logfile , '(a,es12.4)' ) 'Total veh.km= ' , diagnostic_val ( 2 ) write ( unit_logfile , '(a,es12.4)' ) 'Total light veh.km= ' , diagnostic_val ( 3 ) write ( unit_logfile , '(a,es12.4)' ) 'Total heavy veh.km= ' , diagnostic_val ( 4 ) endif return 20 write ( unit_logfile , '(2A)' ) 'ERROR reading road link file: ' , trim ( pathfilename_rl ( 2 )) stop end subroutine uEMEP_read_roadlink_data_ascii subroutine uEMEP_read_roadlink_emission_data !Reads in NORTRIP formatted emission data and places it in the correct road links use uEMEP_definitions implicit none integer i , j integer unit_in logical :: exists logical nxtdat_flag integer counter real , allocatable :: inputdata_rl_temp (:) integer , allocatable :: inputdata_int_rl_id (:) integer emission_date_array ( 6 ) integer n_roadlink_emission_compound character ( 16 ) n_roadlink_emission_compound_str ( 10 ) character ( 256 ) n_roadlink_emission_unit_str character ( 256 ) n_roadlink_emission_date_str integer n_roadlink_emission , n_roadlink_emission_time integer time_index_temp , t_match_index , t integer date_array_temp ( 6 ) integer n_roadlink_emission_selected character ( 256 ) format_temp character ( len = 32 ) :: fmt double precision emission_date_number_start , emission_date_number write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading road link emission data (uEMEP_read_roadlink_emission_data)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_rl ( 2 ) = trim ( pathname_rl ( 2 )) // trim ( filename_rl ( 2 )) !write(*,*) pathname_rl(2),filename_rl(2),pathfilename_rl(2) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_rl ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Road link emission file does not exist: ' , trim ( pathfilename_rl ( 2 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_rl ( 2 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link file(ascii) ' // trim ( pathfilename_rl ( 2 )) rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !read the header to find out how many links there are !read(unit_in,'(a)',ERR=20) temp_str read ( unit_in , * , ERR = 20 ) n_roadlink_emission_compound write ( unit_logfile , '(a,i)' ) ' Number of road link emission compounds= ' , n_roadlink_emission_compound call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission_compound_str ( 1 : n_roadlink_emission_compound ) write ( fmt , '(a,i0,a)' ) '(a,' , n_roadlink_emission_compound , 'a16)' write ( unit_logfile , fmt ) ' Road link emission compounds= ' , n_roadlink_emission_compound_str ( 1 : n_roadlink_emission_compound ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission_unit_str write ( unit_logfile , '(a,a)' ) ' Road link emission units= ' , trim ( n_roadlink_emission_unit_str ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission_date_str write ( unit_logfile , '(a,a)' ) ' Road link emission start date= ' , trim ( n_roadlink_emission_date_str ) call nxtdat ( unit_in , nxtdat_flag ) read ( unit_in , * , ERR = 20 ) n_roadlink_emission , n_roadlink_emission_time write ( unit_logfile , '(a,i)' ) ' Number of road links= ' , n_roadlink_emission write ( unit_logfile , '(a,i)' ) ' Number of time steps= ' , n_roadlink_emission_time if ( n_roadlink_emission . ne . n_roadlinks_major ) then write ( unit_logfile , '(A,2i12)' ) 'ERROR: Number of emission road links is not the same as the static road links: ' , n_roadlink_emission , n_roadlinks_major stop endif !Check that start time and end time are covered in the emission data before progressing further format_temp = 'yyyymmddHH' call datestr_to_date ( n_roadlink_emission_date_str , format_temp , emission_date_array ) if ( use_single_time_loop_flag ) then time_index_temp = end_time_loop_index else time_index_temp = subgrid_dim ( t_dim_index ) endif t_match_index = 0 !write(*,*) shape(val_dim_nc) !do t=1,time_index_temp !    call number_to_date(val_dim_nc(t,time_dim_nc_index),date_array_temp,ref_year_EMEP) !    if (date_array_temp(1).eq.emission_date_array(1).and.date_array_temp(2).eq.emission_date_array(2).and. & !        date_array_temp(3).eq.emission_date_array(3).and.date_array_temp(4).eq.emission_date_array(4)) then !        t_match_index=t !    endif !    write(*,'(4i)') date_array_temp(1:4) !enddo emission_date_number_start = date_to_number ( emission_date_array , ref_year_EMEP ) call number_to_date ( val_dim_nc ( 1 , time_dim_nc_index ), date_array_temp , ref_year_EMEP ) do t = 1 , n_roadlink_emission_time emission_date_number = emission_date_number_start + ( t - 1 ) / 2 4. call number_to_date ( emission_date_number , emission_date_array , ref_year_EMEP ) if ( date_array_temp ( 1 ). eq . emission_date_array ( 1 ). and . date_array_temp ( 2 ). eq . emission_date_array ( 2 ). and . & date_array_temp ( 3 ). eq . emission_date_array ( 3 ). and . date_array_temp ( 4 ). eq . emission_date_array ( 4 )) then t_match_index = t endif !write(*,'(4i)') emission_date_array(1:4) enddo if ( t_match_index . eq . 0 ) then write ( unit_logfile , '(A,6i6)' ) 'ERROR: No starting date found in road emission data: ' , emission_date_array stop else write ( unit_logfile , '(A,6i6)' ) ' Road link emission starting date found. Index: ' , t_match_index write ( unit_logfile , '(A,6i6)' ) ' Road link emission starting date found. Index: ' , t_match_index endif if ( n_roadlink_emission_time - t_match_index + 1. lt . time_index_temp ) then write ( unit_logfile , '(A,2i6)' ) 'ERROR: Not enough time data in road link emission files: ' , n_roadlink_emission_time - t_match_index + 1 , time_index_temp stop else write ( unit_logfile , '(A,6i6)' ) ' Road link emission ending date found. Index: ' , t_match_index + time_index_temp - 1 endif !endif !Allocate the arrays after reading in the number of roads n_roadlink_emission_selected = n_roadlink_emission if ( reduce_roadlink_region_flag ) then n_roadlink_emission_selected = n_roadlinks_major_selected endif allocate ( inputdata_rl_emissions ( n_roadlink_emission_selected , n_roadlink_emission_time , n_roadlink_emission_compound )) allocate ( inputdata_rl_temp ( n_roadlink_emission_time )) allocate ( inputdata_int_rl_id ( n_roadlink_emission_selected )) !Initialise inputdata_rl_temp = 0. counter = 0 !Read the data call nxtdat ( unit_in , nxtdat_flag ) do i = 1 , n_roadlink_emission if ( valid_link_flag ( i )) then counter = counter + 1 read ( unit_in , * , ERR = 20 ) inputdata_int_rl_id ( counter ) !write(*,*) i,inputdata_int_rl_id(i) do j = 1 , n_roadlink_emission_compound read ( unit_in , * ) inputdata_rl_temp ( 1 : n_roadlink_emission_time ) if ( j . le . n_pollutant_loop ) then inputdata_rl_emissions ( counter , 1 : time_index_temp , j ) = inputdata_rl_temp ( t_match_index : t_match_index + time_index_temp - 1 ) endif enddo !write(*,*) counter,inputdata_rl_emissions(counter,10,1),inputdata_rl_emissions(counter,10,2) else read ( unit_in , * , ERR = 20 ) do j = 1 , n_roadlink_emission_compound read ( unit_in , * ) enddo endif enddo write ( unit_logfile , '(a,i)' ) ' Number of road links that should be read = ' , n_roadlink_emission_selected write ( unit_logfile , '(a,i)' ) ' Number of road links read = ' , counter close ( unit_in , status = 'keep' ) !Check that road link ID's match do i = 1 , n_roadlinks if ( inputdata_int_rl ( i , id_rl_index ). ne . inputdata_int_rl_id ( inputdata_int_rl ( i , major_index_rl_index ))) then write ( unit_logfile , '(A,3i12)' ) 'ERROR: Mismatch of road link IDs in the emission files: ' , i , inputdata_int_rl ( i , id_rl_index ), inputdata_int_rl_id ( i ) stop endif enddo if ( allocated ( inputdata_rl_temp )) deallocate ( inputdata_rl_temp ) if ( allocated ( inputdata_int_rl_id )) deallocate ( inputdata_int_rl_id ) return 20 write ( unit_logfile , '(2A)' ) 'ERROR reading road link emission file: ' , trim ( pathfilename_rl ( 2 )) stop end subroutine uEMEP_read_roadlink_emission_data subroutine uEMEP_change_road_data use uEMEP_definitions implicit none integer i , j character ( 256 ) pathfilename_rl_change integer unit_in integer change_offset_index , change_scale_index , change_replace_index parameter ( change_offset_index = 1 , change_scale_index = 2 , change_replace_index = 3 ) !integer change_adt_index,change_hdv_index,change_speed_index !parameter (change_adt_index=1,change_hdv_index=2,change_speed_index=3) real change_val ( num_var_rl , 3 ) character ( 256 ) temp_str real change_x ( 2 ), change_y ( 2 ) integer count integer change_loop ( 3 ), change_index integer :: n_change_loop = 3 logical :: exists change_loop ( 1 ) = adt_rl_index change_loop ( 2 ) = hdv_rl_index change_loop ( 3 ) = speed_rl_index !If there is no path or file name for the replacement file then do not calculate if ( pathname_rl_change . eq . '' . or . filename_rl_change . eq . '' ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Changing road link data (uEMEP_change_road_data)' write ( unit_logfile , '(A)' ) '================================================================' !Read in replacement file pathfilename_rl_change = trim ( pathname_rl_change ) // trim ( filename_rl_change ) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_rl_change ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Road link change file does not exist: ' , trim ( pathfilename_rl_change ) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_rl_change , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening road link change file(ascii) ' // trim ( pathfilename_rl_change ) rewind ( unit_in ) !Skip over coordinates header read ( unit_in , * ) temp_str !Read coordinates read ( unit_in , * ) change_x ( 1 ), change_y ( 1 ), change_x ( 2 ), change_y ( 2 ) !write(*,*) change_x(1),change_y(1),change_x(2),change_y(2) !Skip over values header read ( unit_in , * ) temp_str !Read values do j = 1 , n_change_loop change_index = change_loop ( j ) !write(*,*) change_index read ( unit_in , * ) temp_str , change_val ( change_index , change_offset_index ), change_val ( change_index , change_scale_index ), change_val ( change_index , change_replace_index ) !write(*,*) trim(temp_str),change_val(change_index,change_offset_index),change_val(change_index,change_scale_index),change_val(change_index,change_replace_index) enddo close ( unit_in ) !Search for road links. If found change them count = 0 do i = 1 , n_roadlinks if ( inputdata_rl ( i , x0_rl_index ). ge . change_x ( 1 ). and . inputdata_rl ( i , x0_rl_index ). le . change_x ( 2 ). and . & inputdata_rl ( i , y0_rl_index ). ge . change_y ( 1 ). and . inputdata_rl ( i , y0_rl_index ). le . change_y ( 2 )) then count = count + 1 do j = 1 , n_change_loop change_index = change_loop ( j ) inputdata_rl ( i , change_index ) = change_val ( change_index , change_offset_index ) + change_val ( change_index , change_scale_index ) * inputdata_rl ( i , change_index ) if ( change_val ( change_index , change_replace_index ). ne . 0 ) inputdata_rl ( i , change_index ) = change_val ( change_index , change_replace_index ) enddo endif enddo write ( unit_logfile , '(A,i)' ) 'Number of road links changed = ' , count end subroutine uEMEP_change_road_data subroutine read_country_bounding_box_data !This routine reads in a file that provides information on the country bounding box !as well as reference to the filename used in the OSM files !Is also useful for other purposes but used here only for OSM file names use uEMEP_definitions implicit none logical :: exists integer i character ( 256 ) CNTR_ID character ( 256 ) OSM_country , Long_name real min_lat , min_lon , max_lat , max_lon , min_y_3035 , min_x_3035 , max_y_3035 , max_x_3035 real lon_grid_min , lat_grid_min , lon_grid_max , lat_grid_max real lon_grid_min2 , lat_grid_min2 , lon_grid_max2 , lat_grid_max2 real lon_new_min , lat_new_min , lon_new_max , lat_new_max integer unit_in character ( 256 ) temp_str integer count logical found_country real x_out ( 4 ), y_out ( 4 ) integer :: io !Will fail at lon=-180 !Read in replacement file pathfilename_boundingbox = trim ( pathname_boundingbox ) // trim ( filename_boundingbox ) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_boundingbox ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Bounding box file does not exist: ' , trim ( pathfilename_boundingbox ) stop endif if ( trim ( select_country_by_name ). ne . '' ) then !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_boundingbox , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening Bounding box file  ' // trim ( filename_boundingbox ) rewind ( unit_in ) !Skip over the header !Index\tCNTR_ID\tOSM_country\tmin_lat\tmin_lon\tmax_lat\tmax_lon\tmin_y_3035\tmin_x_3035\tmax_y_3035\tmax_x_3035\t\tLong_name read ( unit_in , * ) temp_str !Read coordinates found_country = . false . do read ( unit_in , * , iostat = io ) i , CNTR_ID , OSM_country , min_lon , min_lat , max_lon , max_lat , min_x_3035 , min_y_3035 , max_x_3035 , max_y_3035 , Long_name if ( io < 0 ) then exit else if ( io > 0 ) then write ( unit_logfile , \"(2a)\" ) \"ERROR reading file: \" , trim ( pathfilename_boundingbox ) stop 1 end if !write(*,*) i,trim(CNTR_ID),trim(OSM_country),min_lon,min_lat,max_lon,max_lat,min_x_3035,min_y_3035,max_x_3035,max_y_3035,trim(Long_name) if ( index ( trim ( select_country_by_name ), trim ( CNTR_ID )). gt . 0 ) then !Set the min and max lat and lon values for the current grid if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , min_lat , min_lon , y_out ( 1 ), x_out ( 1 )) call ll2utm ( 1 , utm_zone , max_lat , max_lon , y_out ( 2 ), x_out ( 2 )) call ll2utm ( 1 , utm_zone , max_lat , min_lon , y_out ( 3 ), x_out ( 3 )) call ll2utm ( 1 , utm_zone , min_lat , max_lon , y_out ( 4 ), x_out ( 4 )) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , min_lat , min_lon , y_out ( 1 ), x_out ( 1 )) call ll2ltm ( 1 , ltm_lon0 , max_lat , max_lon , y_out ( 2 ), x_out ( 2 )) call ll2ltm ( 1 , ltm_lon0 , max_lat , min_lon , y_out ( 3 ), x_out ( 3 )) call ll2ltm ( 1 , ltm_lon0 , min_lat , max_lon , y_out ( 4 ), x_out ( 4 )) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_out ( 1 ), y_out ( 1 ), min_lon , min_lat , projection_attributes ) call LL2LAEA ( x_out ( 2 ), y_out ( 2 ), max_lon , max_lat , projection_attributes ) call LL2LAEA ( x_out ( 3 ), y_out ( 3 ), min_lon , max_lat , projection_attributes ) call LL2LAEA ( x_out ( 4 ), y_out ( 4 ), max_lon , min_lat , projection_attributes ) endif subgrid_min ( x_dim_index ) = minval ( x_out ) subgrid_max ( x_dim_index ) = maxval ( x_out ) subgrid_min ( y_dim_index ) = minval ( y_out ) subgrid_max ( y_dim_index ) = maxval ( y_out ) !Snap to nearest 10 km subgrid_min ( x_dim_index ) = floor ( subgrid_min ( x_dim_index ) / 1000 0. ) * 10000 subgrid_min ( y_dim_index ) = floor ( subgrid_min ( y_dim_index ) / 1000 0. ) * 10000 subgrid_max ( x_dim_index ) = ceiling ( subgrid_max ( x_dim_index ) / 1000 0. ) * 10000 subgrid_max ( y_dim_index ) = ceiling ( subgrid_max ( y_dim_index ) / 1000 0. ) * 10000 write ( unit_logfile , '(i,a)' ) i , ' Setting grid for ID: ' // trim ( CNTR_ID ) // '   OSM name: ' // trim ( OSM_country ) // '   Name: ' // trim ( Long_name ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_min(x_dim_index)=' , subgrid_min ( x_dim_index ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_min(y_dim_index)=' , subgrid_min ( y_dim_index ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_max(x_dim_index)=' , subgrid_max ( x_dim_index ) write ( unit_logfile , '(a,f12.1)' ) 'subgrid_max(y_dim_index)=' , subgrid_max ( y_dim_index ) found_country = . true . endif !Reset the initial subgrid as well, needed for EMEP and receptor selection init_subgrid_min ( x_dim_index ) = subgrid_min ( x_dim_index ) init_subgrid_min ( y_dim_index ) = subgrid_min ( y_dim_index ) init_subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) init_subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) enddo close ( unit_in ) if (. not . found_country ) then write ( unit_logfile , '(a)' ) ' No country with this ID found: ' // trim ( select_country_by_name ) endif endif !Open the file for reading if ( auto_select_OSM_country_flag ) then !Set the min and max lat and lon values for the current grid call PROJ2LL ( subgrid_min ( x_dim_index ), subgrid_min ( y_dim_index ), lon_grid_min , lat_grid_min , projection_attributes , projection_type ) call PROJ2LL ( subgrid_max ( x_dim_index ), subgrid_max ( y_dim_index ), lon_grid_max , lat_grid_max , projection_attributes , projection_type ) call PROJ2LL ( subgrid_min ( x_dim_index ), subgrid_max ( y_dim_index ), lon_grid_min2 , lat_grid_max2 , projection_attributes , projection_type ) call PROJ2LL ( subgrid_max ( x_dim_index ), subgrid_min ( y_dim_index ), lon_grid_max2 , lat_grid_min2 , projection_attributes , projection_type ) lon_grid_max = max ( lon_grid_max , lon_grid_max2 ) lon_grid_min = min ( lon_grid_min , lon_grid_min2 ) lat_grid_max = max ( lat_grid_max , lat_grid_max2 ) lat_grid_min = min ( lat_grid_min , lat_grid_min2 ) !write(*,*) projection_attributes !write(*,*) projection_type !Test !lon_grid_max=5.;lat_grid_max=50. !call LL2LAEA(subgrid_max(x_dim_index),subgrid_max(y_dim_index),lon_grid_max,lat_grid_max,projection_attributes,projection_type) !call LAEA2LL(subgrid_max(x_dim_index),subgrid_max(y_dim_index),lon_grid_max,lat_grid_max,projection_attributes,projection_type) write ( unit_logfile , '(a)' ) ' Opening Bounding box file  ' // trim ( filename_boundingbox ) write ( unit_logfile , '(a,2f12.6)' ) ' Lon (min,max)  ' , lon_grid_min , lon_grid_max write ( unit_logfile , '(a,2f12.6)' ) ' Lat (min,max)  ' , lat_grid_min , lat_grid_max unit_in = 20 open ( unit_in , file = pathfilename_boundingbox , access = 'sequential' , status = 'old' , readonly ) rewind ( unit_in ) !Skip over the header !Index\tCNTR_ID\tOSM_country\tmin_lat\tmin_lon\tmax_lat\tmax_lon\tmin_y_3035\tmin_x_3035\tmax_y_3035\tmax_x_3035\t\tLong_name read ( unit_in , * ) temp_str !Read coordinates count = 0 filename_mrl = '' do read ( unit_in , * , iostat = io ) i , CNTR_ID , OSM_country , min_lon , min_lat , max_lon , max_lat , min_x_3035 , min_y_3035 , max_x_3035 , max_y_3035 , Long_name if ( io /= 0 ) exit !write(*,*) i,trim(CNTR_ID),trim(OSM_country),min_lon,min_lat,max_lon,max_lat,min_x_3035,min_y_3035,max_x_3035,max_y_3035,trim(Long_name) !test the bounding box in lat lon coordinates lon_new_min = max ( min_lon , lon_grid_min ) lat_new_min = max ( min_lat , lat_grid_min ) lon_new_max = min ( max_lon , lon_grid_max ) lat_new_max = min ( max_lat , lat_grid_max ) if ( lon_new_min . gt . lon_new_max . or . lat_new_min . gt . lat_new_max ) then !No intersection so do nothing elseif ( index ( 'none' , trim ( OSM_country )). le . 0 ) then !update and attribute the filename count = count + 1 if ( count . gt . 50 ) then write ( unit_logfile , '(a)' ) ' Max files are 50. Stopping  ' stop endif filename_mrl ( count ) = 'Road_data_OSM_' // trim ( OSM_country ) // '_latlon.txt' write ( unit_logfile , '(2i,a)' ) count , i , ' Including OSM file:  ' // trim ( filename_mrl ( count )) endif enddo if ( count . eq . 0 ) then write ( unit_logfile , '(a)' ) ' No countries overlap this area. Setting OSM to default file andorra' OSM_country = 'andorra' ; count = 1 filename_mrl ( count ) = 'Road_data_OSM_' // trim ( OSM_country ) // '_latlon.txt' num_multiple_roadlink_files = count else write ( unit_logfile , '(a,i)' ) ' Specifying this many OSM road link files to be read' , count num_multiple_roadlink_files = count endif close ( unit_in ) endif !stop end subroutine read_country_bounding_box_data end module read_roadlink_data_ascii","tags":"","loc":"sourcefile/uemep_read_roadlink_data_ascii.f90.html"},{"title":"uEMEP_aggregate_proxy_emission_in_EMEP_grid.f90 – uEMEP","text":"Source Code module aggregate_proxy_emission_in_emep_grid ! NOTE This module is not currently in use. Should it be deleted? use uemep_configuration use uEMEP_definitions use mod_read_esri_ascii_file , only : write_esri_ascii_file implicit none private contains subroutine uEMEP_aggregate_proxy_emission_in_EMEP_grid () ! This routine takes subgrid emissions and aggregates them in the EMEP grid ! This is used for cross checking emissions integer :: i , j integer :: i_source real , allocatable :: EMEP_aggregated_subgid_emission (:,:) real , allocatable :: EMEP_aggregated_emission (:,:) integer , allocatable :: EMEP_aggregated_subgid_emission_count (:,:) real , allocatable :: lon_array (:,:), lat_array (:,:) integer :: iii , jjj character ( 256 ) :: temp_name real :: var3d_nc_local_temp integer :: t integer :: i_nc_source integer :: i_subsource = 1 integer :: i_pollutant , p_loop allocate ( EMEP_aggregated_subgid_emission_count ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( EMEP_aggregated_subgid_emission ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( EMEP_aggregated_emission ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( lon_array ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) allocate ( lat_array ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) EMEP_aggregated_subgid_emission = 0.0 EMEP_aggregated_subgid_emission_count = 0 t = 1 unit_conversion = 1.0 ! Units should be specified in the reading emission files ! Loop through the emission grid and aggregate data ! Units are the same as EMEP mg/m2 do i_pollutant = 1 , n_pollutant_loop p_loop = pollutant_loop_index ( i_pollutant ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then if ( make_EMEP_grid_emission_data ( i_source )) then write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Aggregating proxy emissions in EMEP grids for diagnostics (uEMEP_aggregate_proxy_emission_in_EMEP_grid)' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving proxy subgrid emissions in EMEP grid (' // trim ( source_file_str ( i_source )) // '_' // trim ( pollutant_file_str ( p_loop )) // ')' if ( i_source . eq . agriculture_index ) then i_nc_source = agriculture_nc_index elseif ( i_source . eq . traffic_index ) then i_nc_source = traffic_nc_index elseif ( i_source . eq . shipping_index ) then i_nc_source = shipping_nc_index elseif ( i_source . eq . heating_index ) then i_nc_source = heating_nc_index else write ( unit_logfile , '(A)' ) 'Undefined source in routine uEMEP_aggregate_proxy_emission_in_EMEP_grid. Stopping' stop 1 end if EMEP_aggregated_subgid_emission = 0.0 EMEP_aggregated_emission = 0.0 EMEP_aggregated_subgid_emission_count = 0 do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) ! Get indexes iii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) jjj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) EMEP_aggregated_subgid_emission_count ( iii , jjj ) = EMEP_aggregated_subgid_emission_count ( iii , jjj ) + 1 ! Calculate as tonnes per year EMEP_aggregated_subgid_emission ( iii , jjj ) = EMEP_aggregated_subgid_emission ( iii , jjj ) & + proxy_emission_subgrid ( i , j , i_source , i_pollutant ) * emission_factor_conversion ( compound_index , i_source , i_subsource ) & * 1.0e-12 * 360 0.0 * 2 4.0 * 36 5.0 ! Conversion from ug/sec/subgrid to ton/year if ( hourly_calculations ) then EMEP_aggregated_emission ( iii , jjj ) = EMEP_aggregated_emission ( iii , jjj ) & + sum ( var3d_nc ( iii , jjj ,:, emis_nc_index , allsource_index , i_pollutant )) / dim_length_nc ( time_dim_nc_index ) & * ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) * 1.0e-9 * 2 4.0 * 36 5.0 ! Conversion from mg/m2/hr to ton/year (EMEP) ! NOTE: Have put in allsource_index because on this occasion there were no sectors in the EMEP file for this. Beware for later comparisons!!! end if if ( annual_calculations ) then EMEP_aggregated_emission ( iii , jjj ) = EMEP_aggregated_emission ( iii , jjj ) + sum ( var3d_nc ( iii , jjj ,:, emis_nc_index , i_nc_source , i_pollutant )) / dim_length_nc ( time_dim_nc_index ) & * ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) * 1.0e-9 ! Conversion from mg/m2/yr to ton/year (EMEP) end if end do end do do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) if ( EMEP_aggregated_subgid_emission_count ( i , j ) . gt . 0 ) then EMEP_aggregated_subgid_emission ( i , j ) = EMEP_aggregated_subgid_emission ( i , j ) !/EMEP_aggregated_subgid_emission_count(i,j) EMEP_aggregated_emission ( i , j ) = EMEP_aggregated_emission ( i , j ) !/EMEP_aggregated_subgid_emission_count(i,j) else EMEP_aggregated_subgid_emission ( i , j ) = 0.0 EMEP_aggregated_emission ( i , j ) = 0.0 end if lon_array ( i , j ) = var1d_nc ( i , x_dim_nc_index ) lat_array ( i , j ) = var1d_nc ( j , y_dim_nc_index ) end do end do ! Check this. This is no longer valid and does not take into account neighbouring grids. Do not use if ( replace_EMEP_local_with_subgrid_local ( i_source )) then do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) if ( EMEP_aggregated_subgid_emission ( i , j ) . ge . 0 . and . var3d_nc ( i , j , t , emis_nc_index , i_nc_source , i_pollutant ) . gt . 0 ) then var3d_nc_local_temp = var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) * ( 1.0 - var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant )) ! nonlocal contribution var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant ) = EMEP_aggregated_subgid_emission ( i , j ) / var3d_nc ( i , j , t , emis_nc_index , i_nc_source , i_pollutant ) * var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant ) ! New local fraction var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) = var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) * var3d_nc ( i , j , t , frac_nc_index , i_nc_source , i_pollutant ) + var3d_nc_local_temp ! new total contribution var3d_nc ( i , j , t , conc_nc_index , allsource_index , i_pollutant ) = var3d_nc ( i , j , t , conc_nc_index , i_nc_source , i_pollutant ) end if end do end do end if temp_name = trim ( pathname_grid ( emission_file_index ( i_source ))) // trim ( filename_grid ( emission_file_index ( i_source ))) // '_' // trim ( pollutant_file_str ( p_loop )) // '_aggregated_proxy_EMEP_' // trim ( file_tag ) // '.asc' write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name ) write ( unit_logfile , '(a,f12.2)' ) 'Total local emissions (ton/year): ' , sum ( EMEP_aggregated_subgid_emission ) call write_esri_ascii_file ( temp_name , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dgrid_nc ( lat_nc_index ), EMEP_aggregated_subgid_emission (:,:), lon_array , lat_array ) temp_name = trim ( pathname_grid ( emission_file_index ( i_source ))) // trim ( filename_grid ( emission_file_index ( i_source ))) // '_' // trim ( pollutant_file_str ( p_loop )) // '_EMEP_' // trim ( file_tag ) // '.asc' write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name ) write ( unit_logfile , '(a,f12.2)' ) 'Total EMEP emissions (ton/year): ' , sum ( EMEP_aggregated_emission ) call write_esri_ascii_file ( temp_name , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dgrid_nc ( lat_nc_index ), EMEP_aggregated_emission (:,:), lon_array , lat_array ) write ( unit_logfile , '(a,f12.4)' ) 'Ratio of local to EMEP emissions: ' , sum ( EMEP_aggregated_subgid_emission ) / sum ( EMEP_aggregated_emission ) end if end if end do end do if ( allocated ( EMEP_aggregated_subgid_emission_count )) deallocate ( EMEP_aggregated_subgid_emission_count ) if ( allocated ( EMEP_aggregated_subgid_emission )) deallocate ( EMEP_aggregated_subgid_emission ) if ( allocated ( EMEP_aggregated_emission )) deallocate ( EMEP_aggregated_emission ) if ( allocated ( lon_array )) deallocate ( lon_array ) if ( allocated ( lat_array )) deallocate ( lat_array ) end subroutine uEMEP_aggregate_proxy_emission_in_EMEP_grid end module aggregate_proxy_emission_in_emep_grid","tags":"","loc":"sourcefile/uemep_aggregate_proxy_emission_in_emep_grid.f90.html"},{"title":"uEMEP_save_emission_netcdf.f90 – uEMEP","text":"Source Code module save_emission_netcdf use uemep_configuration use uEMEP_definitions use read_rwc_heating_data , only : uEMEP_read_RWC_heating_data use read_meteo_nc , only : uEMEP_read_meteo_nc use read_roadlink_data_ascii , only : uEMEP_read_roadlink_data_ascii , & uEMEP_read_roadlink_emission_data use read_agriculture_asi_data , only : uEMEP_read_agriculture_rivm_data use read_industry_data , only : uEMEP_read_industry_data use read_shipping_asi_data , only : uEMEP_read_weekly_shipping_asi_data , & uEMEP_read_monthly_and_daily_shipping_asi_data , uEMEP_read_shipping_asi_data use read_time_profiles , only : uEMEP_read_time_profiles use save_netcdf_file , only : check use set_emission_factors , only : uEMEP_convert_proxy_to_emissions , & uEMEP_set_emission_factors , uEMEP_nox_emission_temperature use time_functions , only : date_to_number , number_to_date , date_to_datestr , & datestr_to_date use grid_roads , only : uEMEP_grid_roads use mod_lambert_projection , only : lambert2lb2_uEMEP implicit none private public :: uEMEP_calculate_emissions_for_EMEP contains !uEMEP_save_emission_netcdf.f90 !This routine saves the various emission sources in the EMEP grid !It first reads in an example EMEP file (z0 file) to get projections and x,y grid dimensions !Then extracts the emission data from its original form !It should run independently and stop when it is finished subroutine uEMEP_calculate_emissions_for_EMEP implicit none !double precision :: EMEP_projection_attributes(10) !real, allocatable :: EMEP_emissions_grid(:,:,:,:,:) !x,y,t,source,pollutant integer a_start ( 6 ), date_array ( 6 ), a_start_emission ( 6 ) character ( 256 ) format_temp double precision date_num_temp , date_num_start , date_num_start_emission integer t , i_source , i , j write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving emission data for EMEP (uEMEP_calculate_emissions_for_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !Read in example EMEP file for dimensions and projection information !Or just defne them here without reading if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then EMEP_projection_type = LCC_projection_index !grid_mapping_name = \"lambert_conformal_conic\"; !float i(i=531); !standard_name = \"projection_x_coordinate\"; !long_name = \"x-coordinate in Cartesian system\"; !units = \"m\"; !axis = \"X\"; if ( trim ( save_emissions_for_EMEP_region ). eq . 'NO' ) then emission_subgrid_min ( x_dim_index ,:) = save_emission_subgrid_min ( x_dim_index ) emission_subgrid_delta ( x_dim_index ,:) = save_emission_subgrid_delta ( x_dim_index ) emission_subgrid_dim ( x_dim_index ,:) = save_emission_subgrid_dim ( x_dim_index ) emission_max_subgrid_dim ( x_dim_index ) = save_emission_subgrid_dim ( x_dim_index ) !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( x_dim_index ,:) = emission_subgrid_min ( x_dim_index ,:) - emission_subgrid_delta ( x_dim_index ,:) / 2. !float j(j=671); !standard_name = \"projection_y_coordinate\"; !long_name = \"y-coordinate in Cartesian system\"; !units = \"m\"; !axis = \"Y\"; emission_subgrid_min ( y_dim_index ,:) = save_emission_subgrid_min ( y_dim_index ) emission_subgrid_delta ( y_dim_index ,:) = save_emission_subgrid_delta ( y_dim_index ) emission_subgrid_dim ( y_dim_index ,:) = save_emission_subgrid_dim ( y_dim_index ) emission_max_subgrid_dim ( y_dim_index ) = save_emission_subgrid_dim ( y_dim_index ) !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( y_dim_index ,:) = emission_subgrid_min ( y_dim_index ,:) - emission_subgrid_delta ( y_dim_index ,:) / 2. !if(use_meteo_file_for_emission_gridding_flag) then !   call uEMEP_read_meteo_nc !    emission_subgrid_min(x_dim_index,:)=-6.498834E+05 ! 6.751166E+05 !   emission_subgrid_delta(x_dim_index,:)=2500. !   emission_subgrid_dim(x_dim_index,:)=531 !    emission_max_subgrid_dim(x_dim_index)=531 !Move minium to edge, for consistency with normal subgrid definition !    emission_subgrid_min(x_dim_index,:)=emission_subgrid_min(x_dim_index,:)-emission_subgrid_delta(x_dim_index,:)/2. !endif else write ( unit_logfile , '(A)' ) 'ERROR: Emission region ' // trim ( save_emissions_for_EMEP_region ) // ' not currently defined for lambert coordinates' stop endif elseif ( trim ( save_emissions_for_EMEP_projection ). eq . 'latlon' ) then EMEP_projection_type = LL_projection_index write ( unit_logfile , '(A,i)' ) 'Projection of emission grid set to ' // trim ( save_emissions_for_EMEP_projection ), EMEP_projection_type if ( trim ( save_emissions_for_EMEP_region ). eq . 'NL' ) then emission_subgrid_min ( x_dim_index ,:) = 3.0 emission_subgrid_delta ( x_dim_index ,:) = 0.25 emission_subgrid_dim ( x_dim_index ,:) = floor (( 8. - 3. ) / 0.25 ) + 1 emission_max_subgrid_dim ( x_dim_index ) = floor (( 8. - 3. ) / 0.25 ) + 1 !Full EMEP European domain emission_subgrid_min ( x_dim_index ,:) =- 3 0. emission_subgrid_delta ( x_dim_index ,:) = 0.25 emission_subgrid_dim ( x_dim_index ,:) = floor (( 4 5. + 3 0. ) / 0.25 ) + 1 emission_max_subgrid_dim ( x_dim_index ) = floor (( 4 5. + 3 0. ) / 0.25 ) + 1 !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( x_dim_index ,:) = emission_subgrid_min ( x_dim_index ,:) - emission_subgrid_delta ( x_dim_index ,:) / 2. !float j(j=671); !standard_name = \"projection_y_coordinate\"; !long_name = \"y-coordinate in Cartesian system\"; !units = \"m\"; !axis = \"Y\"; emission_subgrid_min ( y_dim_index ,:) = 5 0. emission_subgrid_delta ( y_dim_index ,:) = 0.125 emission_subgrid_dim ( y_dim_index ,:) = floor (( 5 4. - 5 0. ) / 0.125 ) + 1 emission_max_subgrid_dim ( y_dim_index ) = floor (( 5 4. - 5 0. ) / 0.125 ) + 1 !Full EMEP European domain emission_subgrid_min ( y_dim_index ,:) = 3 0. emission_subgrid_delta ( y_dim_index ,:) = 0.125 emission_subgrid_dim ( y_dim_index ,:) = floor (( 7 6. - 3 0. ) / 0.125 ) + 1 emission_max_subgrid_dim ( y_dim_index ) = floor (( 7 6. - 3 0. ) / 0.125 ) + 1 !Move minium to edge, for consistency with normal subgrid definition emission_subgrid_min ( y_dim_index ,:) = emission_subgrid_min ( y_dim_index ,:) - emission_subgrid_delta ( y_dim_index ,:) / 2. else write ( unit_logfile , '(A)' ) 'ERROR: Emission region ' // trim ( save_emissions_for_EMEP_region ) // ' not currently defined for lat lon coordinates' stop endif else write ( unit_logfile , '(A)' ) 'ERROR: Emission projection ' // trim ( save_emissions_for_EMEP_projection ) // ' not currently defined' stop endif !subgrid_dim(t_dim_index)=save_emissions_end_index-save_emissions_start_index+1 subgrid_dim ( t_dim_index ) = save_emissions_end_index dim_length_nc ( x_dim_nc_index ) = emission_subgrid_dim ( x_dim_index , allsource_index ) dim_length_nc ( y_dim_nc_index ) = emission_subgrid_dim ( y_dim_index , allsource_index ) dim_length_nc ( time_dim_nc_index ) = subgrid_dim ( t_dim_index ) write ( unit_logfile , '(a,3i6)' ) 'EMEP emission grid dimensions: ' , emission_subgrid_dim ( x_dim_index , allsource_index ), emission_subgrid_dim ( y_dim_index , allsource_index ), dim_length_nc ( time_dim_nc_index ) if (. not . allocated ( val_dim_nc )) allocate ( val_dim_nc ( maxval ( dim_length_nc ), num_dims_nc )) !x, y, z and time dimension values if (. not . allocated ( unit_dim_nc )) allocate ( unit_dim_nc ( num_dims_nc )) !x, y, z and time dimension values !Define the emission subgrid to correspond to the EMEP grid if (. not . allocated ( emission_subgrid )) allocate ( emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( proxy_emission_subgrid )) allocate ( proxy_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( x_emission_subgrid )) allocate ( x_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( y_emission_subgrid )) allocate ( y_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lon_emission_subgrid )) allocate ( lon_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lat_emission_subgrid )) allocate ( lat_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( emission_time_profile_subgrid )) allocate ( emission_time_profile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( emission_properties_subgrid )) allocate ( emission_properties_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_emission_index , n_source_index )) !Set the timing data. Assumes no single loops with the time based on the input date and array length defined by the length of the EMEP input data format_temp = 'yyyymmddHH' call datestr_to_date ( config_date_str , format_temp , a_start ) !Assumes it starts at hour 1 !a_start(4)=1 !Do not assume it starts at hour 1 any more a_start ( 5 : 6 ) = 0 a_start_emission = a_start date_num_start = date_to_number ( a_start , ref_year_EMEP ) !Move the starting time according to the index value given (index is the number of hours) date_num_start_emission = date_num_start + dble ( save_emissions_start_index - 1 ) / 2 4. !Set the emission_date_str to be used to name the output file as this may not be the same as the input file call number_to_date ( date_num_start , a_start , ref_year_EMEP ) call number_to_date ( date_num_start_emission , a_start_emission , ref_year_EMEP ) call date_to_datestr ( a_start_emission , format_temp , emission_date_str ) !Do not do this now emission_date_str = config_date_str !write(*,*) config_date_str,emission_date_str !long_name = \"time at middle of period\"; unit_dim_nc ( time_dim_nc_index ) = \"days since 1900-1-1 0:0:0\" ; do t = 1 , subgrid_dim ( t_dim_index ) date_num_temp = date_num_start + dble ( t - 1 ) / 2 4. + dble ( 0.0001 ) / dble ( 2 4. ) / dble ( 360 0. ) !Add 0.0001 of a second to avoid any rounding off errors call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) write ( * , '(6i6)' ) date_array ( 1 : 6 ) val_dim_nc ( t , time_dim_nc_index ) = date_num_temp enddo unit_dim_nc ( x_dim_nc_index ) = 'm' unit_dim_nc ( y_dim_nc_index ) = 'm' !Define emission grids do i_source = 1 , n_source_index if ( save_emissions_for_EMEP ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) x_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( x_dim_index , i_source ) + emission_subgrid_delta ( x_dim_index , i_source ) * ( i - 0.5 ) y_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( y_dim_index , i_source ) + emission_subgrid_delta ( y_dim_index , i_source ) * ( j - 0.5 ) if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call lambert2lb2_uEMEP ( x_emission_subgrid ( i , j , i_source ), y_emission_subgrid ( i , j , i_source ) & , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) elseif ( trim ( save_emissions_for_EMEP_projection ). eq . 'latlon' ) then lon_emission_subgrid ( i , j , i_source ) = x_emission_subgrid ( i , j , i_source ) lat_emission_subgrid ( i , j , i_source ) = y_emission_subgrid ( i , j , i_source ) else write ( unit_logfile , '(A)' ) 'ERROR: Emission projection ' // trim ( save_emissions_for_EMEP_projection ) // ' not currently defined' stop endif !write(*,*) x_emission_subgrid(i,j,i_source),y_emission_subgrid(i,j,i_source),lon_emission_subgrid(i,j,i_source),lat_emission_subgrid(i,j,i_source) enddo enddo if ( i_source . eq . industry_index ) then !Read in industry data call uEMEP_read_industry_data call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif if ( i_source . eq . agriculture_index ) then !Read agriculture data call uEMEP_read_agriculture_rivm_data call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif if ( i_source . eq . traffic_index ) then g_loop = 1 !Read inthe road data call uEMEP_read_roadlink_data_ascii if ( use_NORTRIP_emission_data ) then call uEMEP_read_roadlink_emission_data endif !Redefine the road link positions to correspond to the EMEP coordinates !Grid the data. Road link coordinates will be redefined within this routine call uEMEP_grid_roads !call uEMEP_read_time_profiles !call uEMEP_set_emission_factors !call uEMEP_convert_proxy_to_emissions !Adjust traffic emissions of NOx based on temperature if ( use_traffic_nox_emission_temperature_dependency ) then use_alternative_meteorology_flag = . true . !Set the maximum dimension to that which is necessary. Minimum is not changed as it is selected in uEMEP_save_emission_netcdf end_time_meteo_nc_index = start_time_meteo_nc_index + ( save_emissions_end_index - 1 ) call uEMEP_read_meteo_nc !call uEMEP_subgrid_meteo_EMEP !call uEMEP_crossreference_grids call uEMEP_nox_emission_temperature endif endif if ( i_source . eq . heating_index ) then !meteo_var3d_nc(i_nc,j_nc,:,t2m_nc_index) !Read the heating data. Emission grid coordinates will be redefined within this routine !Must set g_loop=1 for it to read g_loop = 1 call uEMEP_read_RWC_heating_data !Read in the temperature fields from the alternative meteorology always, since EMEP data should not exist yet use_alternative_meteorology_flag = . true . !Set the maximum dimension to that which is necessary. Minimum is not changed as it is selected in uEMEP_save_emission_netcdf !start_time_meteo_nc_index=start_time_meteo_nc_index+(save_emissions_start_index-1) end_time_meteo_nc_index = start_time_meteo_nc_index + ( save_emissions_end_index - 1 ) call uEMEP_read_meteo_nc !Need to make a cross reference here or simply skip the two based on an if statement call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif if ( i_source . eq . shipping_index ) then !meteo_var3d_nc(i_nc,j_nc,:,t2m_nc_index) !Read the heating data. Emission grid coordinates will be redefined within this routine !Must set g_loop=1 for it to read g_loop = 1 if ( read_weekly_shipping_data_flag ) then call uEMEP_read_weekly_shipping_asi_data elseif ( read_monthly_and_daily_shipping_data_flag ) then call uEMEP_read_monthly_and_daily_shipping_asi_data else call uEMEP_read_shipping_asi_data endif !Read in the temperature fields from the alternative meteorology always, since EMEP data should not exist yet !use_alternative_meteorology_flag=.true. !call uEMEP_read_meteo_nc !Need to make a cross reference here or simply skip the two based on an if statement call uEMEP_read_time_profiles call uEMEP_set_emission_factors call uEMEP_convert_proxy_to_emissions endif endif enddo call uEMEP_save_emission_netcdf write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(a)' ) 'Finished saving emission data for EMEP.' write ( unit_logfile , '(A)' ) '================================================================' stop end subroutine uEMEP_calculate_emissions_for_EMEP subroutine uEMEP_save_emission_netcdf use uEMEP_definitions implicit none character ( 256 ) temp_date_str , temp_compound_str , variable_type , unit_str , temp_name , var_name_temp , title_str logical create_file real scale_factor , valid_min integer i_file , i_pollutant , i_source real , allocatable :: temp_subgrid (:,:,:) logical :: exists integer temp_time_dim integer i , j temp_time_dim = save_emissions_end_index - save_emissions_start_index + 1 write ( unit_logfile , '(A,3i6)' ) 'Time dimensions to be saved: ' , save_emissions_start_index , save_emissions_end_index , temp_time_dim if (. not . allocated ( temp_subgrid )) allocate ( temp_subgrid ( emission_subgrid_dim ( x_dim_index , allsource_index ), emission_subgrid_dim ( y_dim_index , allsource_index ), temp_time_dim )) valid_min = 0. unit_str = \"ug/m3\" !variable_type='byte' !variable_type='double' variable_type = 'float' scale_factor = 1. !Save the data !i_file=subgrid_total_file_index(allsource_index) !temp_name=trim(pathname_grid(i_file))//trim(filename_grid(i_file))//'_'//trim(file_tag)//'.nc' if ( len ( emission_date_str ). gt . 0 ) then temp_date_str = '_' // trim ( emission_date_str ) else temp_date_str = '' endif !Do not use the actual emission start date for the file name but use the format specified by filename_date_output_grid if ( len ( filename_date_output_grid ). gt . 0 ) then temp_date_str = '_' // trim ( filename_date_output_grid ) else temp_date_str = '' endif !Do not write 'all' in file name if all compounds are selected if ( pollutant_index . eq . all_nc_index ) then temp_compound_str = '' else temp_compound_str = '_' // trim ( var_name_nc ( conc_nc_index , compound_index , allsource_index )) endif title_str = 'uEMEP_emission_' // trim ( file_tag ) // temp_date_str i_file = subgrid_total_file_index ( allsource_index ) write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving emission netcdf data (uEMEP_save_emission_netcdf)' write ( unit_logfile , '(A)' ) '================================================================' inquire ( file = trim ( pathname_emissions_for_EMEP ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A)' ) 'ERROR: Path to EMEP emission output ' // trim ( pathname_emissions_for_EMEP ) // ' does not exist.' stop endif !Save the emissions interpolated to the target grid variable_type = 'float' unit_str = \"mg/m2\" do i_source = 1 , n_source_index if ( save_emissions_for_EMEP ( i_source ). and . i_source . ne . allsource_index ) then !Create a new file for each source create_file = . true . !temp_name=trim(pathname_emissions_for_EMEP)//'uEMEP_emission_for_EMEP_'//trim(file_tag)//'_'//trim(source_file_str(i_source))//trim(temp_compound_str)//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' temp_name = trim ( pathname_emissions_for_EMEP ) // 'uEMEP_emission_for_EMEP_' // trim ( file_tag ) // '_' // trim ( source_file_str ( i_source )) // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.nc' write ( unit_logfile , '(a,a)' ) 'Saving netcdf file: ' , trim ( temp_name ) do i_pollutant = 1 , n_pollutant_loop !if (pollutant_loop_index(i_pollutant).ne.pmex_nc_index.and.pollutant_loop_index(i_pollutant).ne.pm10_sand_nc_index.and.pollutant_loop_index(i_pollutant).ne.pm10_salt_nc_index & !    .and.pollutant_loop_index(i_pollutant).ne.pm25_sand_nc_index.and.pollutant_loop_index(i_pollutant).ne.pm25_salt_nc_index) then if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . nh3_nc_index & . or .( pollutant_loop_index ( i_pollutant ). eq . pmex_nc_index . and . i_source . eq . traffic_index )) then i_file = emission_file_index ( i_source ) var_name_temp = trim ( var_name_nc ( emis_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) !//'_'//trim(filename_grid(i_file)) !Calculate the emissions in the target grid temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , i_pollutant ) if ( save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag . and . i_source . eq . traffic_index . and . pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pm25_nc_index , allsource_index )) // '_' // 'nonexhaust' temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm25_nc_index )) - emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pmex_nc_index )) endif if ( save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag . and . i_source . eq . traffic_index . and . pollutant_loop_index ( i_pollutant ). eq . pmex_nc_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pm25_nc_index , allsource_index )) // '_' // 'exhaust' temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pmex_nc_index )) endif !Convert the PM10 to PMco, special case if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pmco_nc_index , allsource_index )) !//'_'//trim(filename_grid(i_file)) temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm10_nc_index )) - emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm25_nc_index )) if ( save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag . and . i_source . eq . traffic_index ) then var_name_temp = trim ( var_name_nc ( emis_nc_index , pmco_nc_index , allsource_index )) // '_' // 'nonexhaust' temp_subgrid (:,:,:) = emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm10_nc_index )) & - emission_subgrid (:,:, save_emissions_start_index : save_emissions_end_index , i_source , pollutant_loop_back_index ( pm25_nc_index )) endif endif !Subgrid emissions are in units ug/sec/subgrid. Convert to mg/m2/hour. Acount for the difference in subgrid sizes here if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then temp_subgrid (:,:,:) = 1.0e-3 * 360 0. * temp_subgrid (:,:,:) / ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) else !Temporary estimate of area of lat lon. Needs to be fixed do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) temp_subgrid ( i , j ,:) = 1.0e-3 * 360 0. * temp_subgrid ( i , j ,:) / ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source ) & * 11057 0. * 11057 0. * cos ( 3.14159 / 18 0. * y_emission_subgrid ( i , j , i_source ))) enddo enddo endif !write(*,'(4i,a)') i_pollutant,i_file,i_source,pollutant_loop_index(i_pollutant),trim(var_name_temp) if ( save_netcdf_file_flag . or . save_netcdf_receptor_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_for_EMEP_netcdf_file ( temp_name , emission_subgrid_dim ( x_dim_index , i_source ), emission_subgrid_dim ( y_dim_index , i_source ), temp_time_dim & , temp_subgrid (:,:,:), x_emission_subgrid (:,:, i_source ), y_emission_subgrid (:,:, i_source ), lon_emission_subgrid (:,:, i_source ), lat_emission_subgrid (:,:, i_source ), var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif !Do not create file after first loop create_file = . false . endif enddo endif enddo end subroutine uEMEP_save_emission_netcdf subroutine uEMEP_save_for_EMEP_netcdf_file ( filename_netcdf , nx , ny , nt , val_array , x_array , y_array , lon_array , lat_array , name_array , unit_array , title_str , create_file , valid_min , variable_type , scale_factor ) use uEMEP_definitions use netcdf implicit none character ( 256 ) filename_netcdf , name_array , unit_array , title_str , temp_name integer nx , ny , nt real val_array ( nx , ny , nt ) !,val_array_temp(nx,ny,nt) real x_array ( nx , ny ) real y_array ( nx , ny ) real lon_array ( nx , ny ) real lat_array ( nx , ny ) !,lat_array_temp(nx,ny) !real time_array(nt) real x_vector ( nx ) real y_vector ( ny ) logical create_file real valid_min character ( 256 ) variable_type real scale_factor integer ncid integer y_dimid , x_dimid , time_dimid integer y_varid , x_varid , lat_varid , lon_varid , val_varid , time_varid , proj_varid integer dimids3 ( 3 ), dimids2 ( 2 ), chunks3 ( 3 ) integer n_dims ( 3 ) integer status integer nf90_type if ( trim ( variable_type ). eq . 'byte' ) nf90_type = NF90_BYTE if ( trim ( variable_type ). eq . 'short' ) nf90_type = NF90_SHORT if ( trim ( variable_type ). eq . 'float' ) nf90_type = NF90_FLOAT if ( trim ( variable_type ). eq . 'double' ) nf90_type = NF90_DOUBLE !Assumes x and y are the dimensions x_vector = x_array (:, 1 ) y_vector = y_array ( 1 ,:) !write(*,*) x_vector !write(*,*) y_vector if ( create_file ) then !Create a netcdf file !call check(  nf90_create(filename_netcdf, nf90_clobber, ncid) ) !call check(  nf90_create(filename_netcdf, NF90_HDF5, ncid) ) call check ( nf90_create ( filename_netcdf , IOR ( NF90_HDF5 , NF90_CLASSIC_MODEL ), ncid ) ) !New !Specify global attributes call check ( nf90_put_att ( ncid , nf90_global , \"Conventions\" , \"CF-1.4\" ) ) call check ( nf90_put_att ( ncid , nf90_global , \"title\" , trim ( title_str )) ) call check ( nf90_put_att ( ncid , nf90_global , \"Model\" , \"uEMEP emissions for EMEP\" ) ) !Projection data if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call check ( nf90_def_var ( ncid , \"projection_lambert\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"standard_parallel\" , EMEP_projection_attributes ( 1 : 2 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , EMEP_projection_attributes ( 3 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"lambert_conformal_conic\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , EMEP_projection_attributes ( 4 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"earth_radius\" , EMEP_projection_attributes ( 5 ) ) ) endif !Define the dimensions call check ( nf90_def_dim ( ncid , \"time\" , NF90_UNLIMITED , time_dimid ) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_def_dim ( ncid , \"y\" , ny , y_dimid ) ) call check ( nf90_def_dim ( ncid , \"x\" , nx , x_dimid ) ) !else !call check(  nf90_def_dim(ncid, \"lat\", ny, y_dimid) ) !call check(  nf90_def_dim(ncid, \"lon\", nx, x_dimid) ) !endif !Define the dimension variables call check ( nf90_def_var ( ncid , \"time\" , NF90_DOUBLE , time_dimid , time_varid ) ) !call check(  nf90_def_var(ncid, \"time\", NF90_INT, time_dimid, time_varid) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_def_var ( ncid , \"y\" , NF90_REAL , y_dimid , y_varid ) ) call check ( nf90_def_var ( ncid , \"x\" , NF90_REAL , x_dimid , x_varid ) ) !else !call check(  nf90_def_var(ncid, \"lat\", NF90_REAL, y_dimid, y_varid) ) !call check(  nf90_def_var(ncid, \"lon\", NF90_REAL, x_dimid, x_varid) ) !endif !Define the values dimids3 = ( / x_dimid , y_dimid , time_dimid / ) dimids2 = ( / x_dimid , y_dimid / ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_def_var ( ncid , \"lat\" , NF90_REAL , dimids2 , lat_varid ) ) call check ( nf90_def_var ( ncid , \"lon\" , NF90_REAL , dimids2 , lon_varid ) ) !endif !Specify the units call check ( nf90_put_att ( ncid , lat_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , lon_varid , \"units\" , \"degrees_east\" ) ) if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"m\" ) ) else call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"degrees_east\" ) ) endif call check ( nf90_put_att ( ncid , time_varid , \"units\" , trim ( unit_dim_nc ( time_dim_nc_index ))) ) !Specify other dimension attributes !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_put_att ( ncid , y_varid , \"standard_name\" , \"projection_y_coordinate\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"standard_name\" , \"projection_x_coordinate\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"axis\" , \"Y\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"axis\" , \"X\" ) ) !else !call check(  nf90_put_att(ncid, y_varid, \"standard_name\", \"latitude\") ) !call check(  nf90_put_att(ncid, x_varid, \"standard_name\", \"longitude\") ) !endif !Close the definitions call check ( nf90_enddef ( ncid ) ) !write(*,*) 'here6',shape(val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index)) !write(*,*) val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index) call check ( nf90_put_var ( ncid , time_varid , val_dim_nc ( save_emissions_start_index : save_emissions_end_index , time_dim_nc_index )) ) !call check( nf90_put_var(ncid, time_varid, time_seconds_output(1:dim_length_nc(time_dim_nc_index))) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_put_var ( ncid , y_varid , y_vector ) ) call check ( nf90_put_var ( ncid , x_varid , x_vector ) ) call check ( nf90_put_var ( ncid , lat_varid , lat_array ) ) call check ( nf90_put_var ( ncid , lon_varid , lon_array ) ) !else !call check( nf90_put_var(ncid, y_varid, y_vector) ) !call check( nf90_put_var(ncid, x_varid, x_vector) ) !endif call check ( nf90_close ( ncid ) ) endif !Add to the existing file call check ( nf90_open ( filename_netcdf , NF90_WRITE , ncid ) ) !Get the dimensions id from the existing file call check ( nf90_inq_dimid ( ncid , \"time\" , time_dimid ) ) !if (trim(save_emissions_for_EMEP_projection).eq.'lambert') then call check ( nf90_inq_dimid ( ncid , \"y\" , y_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"x\" , x_dimid ) ) !else !call check( nf90_inq_dimid(ncid, \"lat\", y_dimid) ) !call check( nf90_inq_dimid(ncid, \"lon\", x_dimid) ) !endif dimids3 = ( / x_dimid , y_dimid , time_dimid / ) chunks3 = ( / nx , ny , 1 / ) !New call check ( nf90_inquire_dimension ( ncid , dimids3 ( 1 ), temp_name , n_dims ( 1 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 2 ), temp_name , n_dims ( 2 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 3 ), temp_name , n_dims ( 3 )) ) !write(*,*) 'here7' status = nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) if ( status . ne . nf90_NoErr ) then call check ( nf90_redef ( ncid ) ) !if the variable does not exist then create a new one !write(*,*) 'Creating new: ',trim(name_array) call check ( nf90_def_var ( ncid , trim ( name_array ), nf90_type , dimids3 , val_varid ) ) ! gzip level 3 compression and shuffling ! optional _FillValue for values which never have been written, unpacked value call check ( nf90_def_var_chunking ( ncid , val_varid , NF90_CHUNKED , chunks3 ) ) !New call check ( nf90_def_var_deflate ( ncid , val_varid , 1 , 1 , 3 ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"units\" , trim ( unit_array )) ) !Specify other variable attributes if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 1 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 2 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 2 )) ) else call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , NODATA_value ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , valid_min ) ) endif !write(*,*) 'here8' if ( trim ( save_emissions_for_EMEP_projection ). eq . 'lambert' ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_lambert\" ) ) else call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"latitude_longitude\" ) ) endif !write(*,*) 'here9' call check ( nf90_put_att ( ncid , val_varid , \"coordinates\" , \"lon lat\" ) ) if ( scale_factor . ne . 1. ) call check ( nf90_put_att ( ncid , val_varid , \"scale_factor\" , scale_factor ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) !write(*,*) 'here10' endif if ( use_single_time_loop_flag ) then write ( unit_logfile , '(A)' ) 'ERROR: Saving emissions for EMEP will not work when use_single_time_loop_flag=.true. Set to false' stop !Add time to the time dimension call check ( nf90_inq_varid ( ncid , \"time\" , time_varid ) ) !write(*,*) 'here11a' !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 n_dims ( 3 ) = t_loop !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) call check ( nf90_put_var ( ncid , time_varid , val_dim_nc ( 1 , time_dim_nc_index ), start = ( / n_dims ( 3 ) / ) ) ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !write(*,*) 'here11b' !Add dimension and array to existing call check ( nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) ) if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 1 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 2 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) else call check ( nf90_put_var ( ncid , val_varid , val_array , start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) endif !write(*,*) 'here11' else !Write the variable to file. Default is float if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array , kind = 2 )) ) else !write(*,*) ncid, val_varid, shape(val_array) call check ( nf90_put_var ( ncid , val_varid , val_array ) ) endif endif call check ( nf90_close ( ncid ) ) end subroutine uEMEP_save_for_EMEP_netcdf_file end module save_emission_netcdf","tags":"","loc":"sourcefile/uemep_save_emission_netcdf.f90.html"},{"title":"uEMEP_save_netcdf_file.f90 – uEMEP","text":"Source Code module save_netcdf_file use uemep_configuration use chemistry_no2 , only : uEMEP_source_fraction_chemistry use mod_read_esri_ascii_file , only : write_esri_ascii_file use mod_area_interpolation , only : area_weighted_interpolation_function implicit none private public :: uEMEP_save_netcdf_control , mean_mask , check contains !Saves data in netcdf format subroutine uEMEP_save_netcdf_control use uEMEP_definitions implicit none integer i , j , k , t , l integer i_comp , i_file , i_meteo character ( 256 ) temp_name , unit_str , title_str , title_str_rec , var_name_temp , temp_date_str , station_name_str , temp_name_rec , temp_compound_str logical create_file , create_file_rec integer i_source real :: valid_min = 0. real , allocatable :: temp_subgrid (:,:,:) real , allocatable :: temp_integral_subgrid (:,:,:) real , allocatable :: aqi_subgrid (:,:,:,:) integer , allocatable :: aqi_responsible_pollutant_index (:,:,:) real , allocatable :: temp_subgrid_ascii (:,:) integer ii , jj , tt real aqi_limits_temp ( n_compound_index , 1 : 5 ) real max_aqi integer n_aqi_pollutant_index parameter ( n_aqi_pollutant_index = 4 ) integer aqi_pollutant_index ( n_aqi_pollutant_index ) integer i_pollutant , i_loop character ( 256 ) variable_type logical :: receptor_available = . true . real scale_factor integer n_save_aqi_pollutant_index real temp_sum_comp integer count character ( 256 ) filename_ascii integer i_sp , ii_sp integer source_domain_loop integer no2_o3_loop , comp_index , comp_nc_index character ( 256 ) filename_append if ( include_o3_in_aqi_index ) then n_save_aqi_pollutant_index = n_aqi_pollutant_index else n_save_aqi_pollutant_index = n_aqi_pollutant_index - 1 endif if (. not . allocated ( temp_subgrid )) allocate ( temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ))) if (. not . allocated ( temp_integral_subgrid )) allocate ( temp_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ))) if (. not . allocated ( aqi_subgrid ). and . save_aqi ) allocate ( aqi_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) if (. not . allocated ( aqi_responsible_pollutant_index ). and . save_aqi ) allocate ( aqi_responsible_pollutant_index ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ))) if (. not . allocated ( temp_subgrid_ascii ). and . save_compounds_as_ascii ) allocate ( temp_subgrid_ascii ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) !Save subgrid calculations valid_min = 0. unit_str = \"ug/m3\" variable_type = 'byte' !variable_type='double' variable_type = 'float' scale_factor = 1. !Save the data i_file = subgrid_total_file_index ( allsource_index ) !temp_name=trim(pathname_grid(i_file))//trim(filename_grid(i_file))//'_'//trim(file_tag)//'.nc' !if (len(config_date_str).gt.0) then !    temp_date_str='_'//trim(config_date_str) !else !    temp_date_str='' !endif if ( len ( filename_date_output_grid ). gt . 0 ) then temp_date_str = '_' // filename_date_output_grid else temp_date_str = '' endif if ( use_multiple_receptor_grids_flag ) then station_name_str = trim ( name_receptor_in ( g_loop , 1 )) // '_' ; else station_name_str = '' endif !Do not write 'all' in file name if all compounds are selected if ( pollutant_index . eq . all_nc_index ) then temp_compound_str = '' else temp_compound_str = '_' // trim ( var_name_nc ( conc_nc_index , compound_index , allsource_index )) endif !Do not write anything about the compounds temp_compound_str = '' !temp_name=trim(pathname_grid(i_file))//trim(station_name_str)//'uEMEP_'//trim(file_tag)//trim(temp_compound_str)//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !temp_name_rec=trim(pathname_grid(i_file))//'uEMEP_'//trim(file_tag)//'_station'//trim(temp_compound_str)//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !if (save_netcdf_average_flag) then !temp_name=trim(pathname_grid(i_file))//trim(station_name_str)//'uEMEP_'//trim(file_tag)//trim(temp_compound_str)//'_mean'//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !temp_name_rec=trim(pathname_grid(i_file))//'uEMEP_'//trim(file_tag)//'_station'//trim(temp_compound_str)//'_mean'//trim(temp_date_str)//'_'//trim(forecast_hour_str)//'.nc' !endif temp_name = trim ( pathname_grid ( i_file )) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.nc' temp_name_rec = trim ( pathname_grid ( i_file )) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.nc' if ( save_netcdf_average_flag ) then temp_name = trim ( pathname_grid ( i_file )) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.nc' temp_name_rec = trim ( pathname_grid ( i_file )) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.nc' endif finished_file = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.' // trim ( finished_filename ) finished_file_rec = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // trim ( temp_date_str ) // '.' // trim ( finished_filename ) if ( save_netcdf_average_flag ) then finished_file = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // trim ( station_name_str ) // 'uEMEP_' // trim ( file_tag ) // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.' // trim ( finished_filename ) finished_file_rec = trim ( pathname_grid ( i_file )) // trim ( finished_subpath ) // 'uEMEP_' // trim ( file_tag ) // '_station' // trim ( temp_compound_str ) // '_mean' // trim ( temp_date_str ) // '.' // trim ( finished_filename ) endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Saving netcdf data (uEMEP_save_netcdf_control)' write ( unit_logfile , '(A)' ) '================================================================' i_comp = 1 if ( save_netcdf_receptor_flag . and . n_valid_receptor . eq . 0 ) then if ( i_comp . eq . 1. and . t_loop . eq . start_time_loop_index ) then write ( unit_logfile , '(a)' ) 'No receptor positions available. Will not save receptor data.' receptor_available = . false . endif endif if ( save_netcdf_average_flag ) then if (. not . allocated ( val_array_av )) then allocate ( val_array_av ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_var_av )) val_array_av = 0. endif if (. not . allocated ( time_seconds_output_av )) then allocate ( time_seconds_output_av ( n_var_av )) time_seconds_output_av = 0 endif !Reset average file counter for every time step saving occurs counter_av = 0 write ( unit_logfile , * ) 'Saving as mean data' endif !Save the final result of the subgrid calculation in ascii format !This should only be used for annual mean calculations since it cannot have a time dimmension !Intended for FAIRMODE output !Makes a new file for each compound and averages over time, if there is a time dimension if ( save_compounds_as_ascii ) then variable_type = 'float' unit_str = \"ug/m3\" do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) !write(*,*) i_comp var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) title_str = trim ( var_name_temp ) // '_' // trim ( file_tag ) // trim ( temp_date_str ) write ( unit_logfile , '(a)' ) 'Writing ascii data to: ' // trim ( title_str ) filename_ascii = trim ( pathname_output_grid ) // trim ( title_str ) // '.asc' temp_subgrid_ascii (:,:) = sum ( comp_subgrid (:,:,:, i_comp ), 3 ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(a,f12.3)' ) 'Writing ascii array variable: ' // trim ( var_name_temp ), sum ( comp_subgrid (:,:,:, i_comp )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) call write_esri_ascii_file ( filename_ascii , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_delta ( x_dim_index ), temp_subgrid_ascii , x_subgrid , y_subgrid ) enddo endif enddo endif !Save the final result of the subgrid calculation if ( save_compounds ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving all total compounds' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' unit_str = \"ug/m3\" do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) !write(*,*) i_comp if ( i_pollutant . eq . 1. and . i_loop . eq . 1. and . t_loop . eq . start_time_loop_index . and . save_netcdf_file_flag ) then create_file = . true . title_str = 'uEMEP_concentration_' // trim ( file_tag ) // temp_date_str write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name ) else create_file = . false . endif if ( i_pollutant . eq . 1. and . i_loop . eq . 1. and . t_loop . eq . start_time_loop_index . and . first_g_loop . and . save_netcdf_receptor_flag ) then create_file_rec = . true . title_str_rec = 'uEMEP_receptor_' // trim ( file_tag ) // temp_date_str if ( receptor_available ) write ( unit_logfile , '(a)' ) 'Writing to: ' // trim ( temp_name_rec ) else create_file_rec = . false . endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_concentration' if ( save_netcdf_file_flag ) then temp_sum_comp = 0. count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then temp_sum_comp = temp_sum_comp + sum ( comp_subgrid ( i , j ,:, i_comp )) / subgrid_dim ( t_dim_index ) count = count + 1 endif enddo enddo if ( count . gt . 0 ) then temp_sum_comp = temp_sum_comp / count else temp_sum_comp = 0 endif !write(unit_logfile,'(a,f12.3)')'Writing netcdf array variable:    '//trim(var_name_temp),temp_sum_comp write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( comp_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( comp_subgrid (:,:,:, i_comp ), 1 ), size ( comp_subgrid (:,:,:, i_comp ), 2 ), size ( comp_subgrid (:,:,:, i_comp ), 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , comp_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( comp_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( comp_subgrid (:,:,:, i_comp ), 1 ), size ( comp_subgrid (:,:,:, i_comp ), 2 ), size ( comp_subgrid (:,:,:, i_comp ), 3 )) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(comp_subgrid(:,:,:,i_comp))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , comp_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo endif enddo endif create_file = . false . create_file_rec = . false . ! Save downscaled source contributions for pollutants (not no2 or o3) ! 1 = local ! 2 = local, cut down to from_in_region ! 3-4: not used here, but kept to make numbering consistent with the other loops over source_domain_loop ! 5 = total: contribution from big domain, but using downscaled within moving window: 1 + (additional_emep_local(3) - emep_local(1) ! 6 = total from in region = 2 + semilocal emep contribution (4)) do source_domain_loop = 1 , 6 ! Skip this round in the loop if this type of source contributions are not to be saved if ( source_domain_loop == 1 ) then if (. not . save_source_contributions ) cycle filename_append = '' else if ( source_domain_loop == 2 ) then if (. not . ( trace_emissions_from_in_region . and . save_local_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 5 ) then if (. not . ( save_total_source_contributions . and . EMEP_additional_grid_interpolation_size . gt . 0 )) cycle filename_append = '' else if ( source_domain_loop == 6 ) then if (. not . ( trace_emissions_from_in_region . and . save_total_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else ! skip rounds 3-4 cycle end if write ( unit_logfile , '(a)' ) '--------------------------' if ( source_domain_loop == 1 ) write ( unit_logfile , '(a)' ) 'Saving downscaled contributions' if ( source_domain_loop == 2 ) write ( unit_logfile , '(a)' ) 'Saving downscaled contributions from-in-region' if ( source_domain_loop == 5 ) write ( unit_logfile , '(a)' ) 'Saving total contributions' if ( source_domain_loop == 6 ) write ( unit_logfile , '(a)' ) 'Saving total contributions from-in-region' write ( unit_logfile , '(a)' ) '--------------------------' if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" else variable_type = 'byte' unit_str = \"%\" endif do i_pollutant = 1 , n_pollutant_loop do i_source = 1 , n_source_index if ( source_domain_loop == 5 ) then i_file = subgrid_sourcetotal_file_index ( i_source ) else if ( source_domain_loop == 6 ) then i_file = subgrid_sourcetotal_inregion_file_index ( i_source ) else ! 1 or 2 i_file = subgrid_local_file_index ( i_source ) end if !if (calculate_source(i_source).or.i_source.eq.allsource_index) then !Don't save any exhaust, sand or salt pollutant sources. Dealt with later !(calculate_source(i_source).or.calculate_emep_source(i_source)) if ( calculate_source ( i_source ). and . i_source . ne . allsource_index . and . pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then !Only save nonexhaust pm and all the other sources if (( pollutant_loop_index ( i_pollutant ). eq . nox_index . and . i_source . eq . traffic_index )) then !if ((pollutant_loop_index(i_pollutant).ne.nox_index.or.i_source.ne.traffic_index)) then else if ( i_source . eq . traffic_index . and .( pollutant_loop_index ( i_pollutant ). eq . pm10_index . or . pollutant_loop_index ( i_pollutant ). eq . pm25_index )) then ! Special case for traffic pm: In some setups we need to subtract exhaust to get non-exhaust if ( pollutant_index . eq . all_totals_nc_index . or . pollutant_index . eq . aaqd_totals_nc_index . or . pollutant_index . eq . gp_totals_nc_index . or . pollutant_index . eq . op_totals_nc_index ) then ! Traffic exhaust is not a separate pollutant, so just save total traffic var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else ! source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) endif else ! Calculate non-exhaust as difference between total traffic and exhaust for downscaled contributions ! For EMEP contributions, non-exhaust can be directly accessed with traffic_nonexhaust_nc_index var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // '_nonexhaust' // trim ( filename_append ) if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) - subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) - subgrid (:,:,:, emep_local_subgrid_index , traffic_nonexhaust_nc_index , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , traffic_nonexhaust_nc_index , i_pollutant ) else !source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) - subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) + subgrid_EMEP_semilocal_from_in_region (:,:,:, traffic_nonexhaust_nc_index , i_pollutant ) end if endif else var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else ! source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) endif endif ! Convert to fractions if (. not . save_netcdf_fraction_as_contribution_flag ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. end if !In case of any 0 concentrations when using the fractional contributions where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp), mean_nodata(temp_subgrid,size(temp_subgrid,1),size(temp_subgrid,2),size(temp_subgrid,3),NODATA_value) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) ! write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif !Special case for exhaust as this must be given as a fraction for both PM2.5 and PM10. !if ((pollutant_loop_index(i_pollutant).eq.pm10_index.or.pollutant_loop_index(i_pollutant).eq.pm25_index).and.i_source.eq.traffic_index) then !Write all exhaust pollutants except the pmex if ( i_source . eq . traffic_index . and .(. not . pollutant_index . eq . all_totals_nc_index . and .. not . pollutant_index . eq . aaqd_totals_nc_index . and .. not . pollutant_index . eq . gp_totals_nc_index . and .. not . pollutant_index . eq . op_totals_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . nox_index )) then !If PM then exhaust output is exhaust if ( pollutant_loop_index ( i_pollutant ). eq . pm10_index . or . pollutant_loop_index ( i_pollutant ). eq . pm25_index ) then if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , pollutant_loop_back_index ( pmex_index )) - subgrid (:,:,:, emep_local_subgrid_index , traffic_exhaust_nc_index , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , traffic_exhaust_nc_index , i_pollutant ) else !source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , pollutant_loop_back_index ( pmex_index )) + subgrid_EMEP_semilocal_from_in_region (:,:,:, traffic_exhaust_nc_index , i_pollutant ) end if else if ( source_domain_loop == 1 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) - subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) + subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else !source_domain_loop == 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) end if endif var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // '_exhaust' // trim ( filename_append ) if (. not . save_netcdf_fraction_as_contribution_flag ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. end if where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif !Special case for salt and sand if ( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_sand_index & . or . pollutant_loop_index ( i_pollutant ). eq . pm25_salt_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_salt_index ) then !Save the nonexhaust sand and salt ! NB: sand and salt do not have EMEP contributions, so total is the same as local if ( i_source . eq . traffic_index ) then var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) if ( source_domain_loop == 1 . or . source_domain_loop == 5 ) then temp_subgrid = subgrid (:,:,:, local_subgrid_index , i_source , i_pollutant ) else ! 2 or 6 temp_subgrid = subgrid_local_from_in_region (:,:,:, i_source , i_pollutant ) end if if (. not . save_netcdf_fraction_as_contribution_flag ) then !temp_subgrid=subgrid(:,:,:,local_subgrid_index,i_source,i_pollutant) if ( pollutant_loop_index ( i_pollutant ). eq . pm10_sand_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_salt_index ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_index )) * 10 0. else temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_index )) * 10 0. endif endif where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif end do ! i_source end do ! i_pollutant end do ! source_domain_loop ! Save the total nonlocal contributions from EMEP (not saving it for in-region domains!) ! 1 = nonlocal to the moving window ! 2 = not used, but kept for consistency with other source_domain_loop loops ! 3 = nonlocal to the additional domain do source_domain_loop = 1 , 3 if ( source_domain_loop == 2 ) cycle write ( unit_logfile , '(A)' ) '-------------------------------' if ( source_domain_loop == 1 ) write ( unit_logfile , '(A)' ) 'Saving nonlocal contributions' if ( source_domain_loop == 3 ) write ( unit_logfile , '(A)' ) 'Saving additional nonlocal contributions' write ( unit_logfile , '(A)' ) '-------------------------------' do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_sand_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_sand_index & . and . pollutant_loop_index ( i_pollutant ). ne . pm25_salt_index . and . pollutant_loop_index ( i_pollutant ). ne . pm10_salt_index ) then if ( source_domain_loop == 1 ) then if (. not . ( save_source_contributions . or . save_emep_source_contributions . or . save_total_source_contributions )) cycle i_file = emep_subgrid_nonlocal_file_index ( allsource_index ) temp_subgrid = subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) else ! source_domain_loop == 3 if (. not . ( EMEP_additional_grid_interpolation_size . gt . 0 . and . ( save_emep_additional_source_contributions . or . save_total_source_contributions ))) cycle i_file = emep_additional_subgrid_nonlocal_file_index ( allsource_index ) temp_subgrid = subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ) end if var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) if (. not . ( save_netcdf_fraction_as_contribution_flag )) then temp_subgrid = temp_subgrid / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. end if where ( subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ). eq . 0 ) temp_subgrid = 0 if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif end if enddo ! i_pollutant end do ! source_domain_loop ! Calculate and save NO2 and O3 source contributions if ( save_no2_source_contributions . or . save_o3_source_contributions ) then ! Calculate NO2 and O3 source contributions if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then calculate_EMEP_additional_grid_flag = . true . call uEMEP_source_fraction_chemistry endif calculate_EMEP_additional_grid_flag = . false . call uEMEP_source_fraction_chemistry ! Save the contributions to file ! 1 = normal source contributions from within moving window ! 2 = source contributions cut down to region ! 3 = additional nonlocal ! 4 = semilocal contribution from in region, based on background ! 5 = not used, but kept to be consistent with other loops over \"source_domain_loop\" ! 6 = total contribution from in region = 2+4 do source_domain_loop = 1 , 6 ! Skip this round in the loop if this type of source contributions are not to be saved ! or set appropriate variable name extension if ( source_domain_loop == 1 ) then if (. not . save_source_contributions ) cycle filename_append = '' else if ( source_domain_loop == 2 ) then if (. not . ( trace_emissions_from_in_region . and . save_local_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 3 ) then if (. not . ( EMEP_additional_grid_interpolation_size . gt . 0 . and . ( save_emep_additional_source_contributions . or . save_total_source_contributions ))) cycle filename_append = '' else if ( source_domain_loop == 4 ) then if (. not . ( trace_emissions_from_in_region . and . save_semilocal_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 5 ) then cycle else ! source_domain_loop == 6 if (. not . ( trace_emissions_from_in_region . and . save_total_source_contributions_from_in_region )) cycle filename_append = '_from_in_region' end if write ( unit_logfile , '(A)' ) '-------------------------------' if ( source_domain_loop == 1 ) write ( unit_logfile , '(A)' ) 'Saving local NO2 and O3 contributions' if ( source_domain_loop == 2 ) write ( unit_logfile , '(A)' ) 'Saving local NO2 and O3 contributions from-in-region' if ( source_domain_loop == 3 ) write ( unit_logfile , '(A)' ) 'Saving additional nonlocal NO2 and O3 contributions' if ( source_domain_loop == 4 ) write ( unit_logfile , '(A)' ) 'Saving semilocal NO2 and O3 contributions from-in-region' if ( source_domain_loop == 6 ) write ( unit_logfile , '(A)' ) 'Saving total NO2 and O3 contributions from-in-region' write ( unit_logfile , '(A)' ) '-------------------------------' ! Save NO2 in round 1 and O3 in round 2 do no2_o3_loop = 1 , 2 if ( no2_o3_loop == 1 ) then ! no2 comp_index = no2_index comp_nc_index = no2_nc_index if (. not . save_no2_source_contributions ) cycle valid_min = 0. if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" else variable_type = 'byte' unit_str = \"%\" endif else ! o3 comp_index = o3_index comp_nc_index = o3_nc_index if (. not . save_o3_source_contributions ) cycle if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" valid_min =- 100 0. else variable_type = 'short' unit_str = \"%\" valid_min =- 10 0. endif end if do i_source = 1 , n_source_index if ( i_source . eq . allsource_index . or . calculate_source ( i_source ) . or . calculate_emep_source ( i_source )) then !Do not save nonexhaust for exhaust gas emissions if ( i_source . eq . traffic_nonexhaust_index ) then cycle end if if ( i_source == allsource_index ) then ! Non-local contributions if ( source_domain_loop == 1 ) then ! nonlocal to the normal domain i_file = emep_subgrid_nonlocal_file_index ( i_source ) temp_subgrid = comp_source_EMEP_subgrid (:,:,:, comp_index , i_source ) else if ( source_domain_loop == 3 ) then ! nonlocal to the additional domain i_file = emep_additional_subgrid_nonlocal_file_index ( i_source ) temp_subgrid = comp_source_EMEP_additional_subgrid (:,:,:, comp_index , i_source ) else ! do not save nonlocal for the in-region versions cycle end if else ! Sector source contributions if ( source_domain_loop == 1 ) then ! normal local domain if ( calculate_source ( i_source )) then i_file = subgrid_local_file_index ( i_source ) else ! calculate_emep_source(i_source) i_file = emep_subgrid_local_file_index ( i_source ) endif temp_subgrid = comp_source_subgrid (:,:,:, comp_index , i_source ) else if ( source_domain_loop == 2 ) then ! in-region contributions within the normal local domain if ( calculate_source ( i_source )) then i_file = subgrid_local_file_index ( i_source ) else ! calculate_emep_source(i_source) i_file = emep_subgrid_local_file_index ( i_source ) endif temp_subgrid = comp_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) else if ( source_domain_loop == 3 ) then ! additional domain: save only non-local for additional domain cycle else if ( source_domain_loop == 4 ) then ! semilocal inregion contributions i_file = emep_subgrid_semilocal_file_index ( i_source ) temp_subgrid = comp_semilocal_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) else ! source_domain_loop == 6 ! sum of local inregion and semilocal inregion i_file = subgrid_sourcetotal_inregion_file_index ( i_source ) temp_subgrid = comp_semilocal_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) + comp_source_subgrid_from_in_region (:,:,:, comp_index , i_source ) end if end if ! Variable name if ( i_source . eq . traffic_index . and . comp_index . eq . no2_index ) then ! special case for no2 traffic: add exhaust to variable name var_name_temp = trim ( var_name_nc ( conc_nc_index , comp_nc_index , allsource_nc_index )) // '_' // trim ( filename_grid ( i_file )) // '_exhaust' // trim ( filename_append ) else var_name_temp = trim ( var_name_nc ( conc_nc_index , comp_nc_index , allsource_nc_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) endif if (. not . save_netcdf_fraction_as_contribution_flag ) then ! Transform to fraction if ( comp_index == o3_index ) then ! For O3, only include nonlocal when saving as fractions, and normalize with EMEP concentration to always get 100% if ( i_source == allsource_index ) then temp_subgrid = temp_subgrid / comp_EMEP_subgrid (:,:,:, comp_index ) temp_subgrid = min ( temp_subgrid , 100 0. ) temp_subgrid = max ( temp_subgrid , - 10 0. ) else cycle end if else ! for NO2, normalize with EMEP concentration for additional, and with uEMEP concentration in all other cases if ( source_domain_loop == 3 ) then temp_subgrid = temp_subgrid / comp_EMEP_subgrid (:,:,:, comp_index ) * 10 0. else temp_subgrid = temp_subgrid / comp_subgrid (:,:,:, comp_index ) * 10 0. end if end if endif ! Save to file if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo !i_source end do !no2_o3_loop end do !source_domain_loop valid_min = 0. end if !(save_no2_source_contributions .or. save_o3_source_contributions) !Save the emissions interpolated to the target grid if ( save_emissions ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving emissions' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' unit_str = \"g/s\" do i_pollutant = 1 , n_pollutant_loop do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then !Do not save emissions if the source is not traffic and the pollutant is road sand and salt or exhaust as these do not exist if ( i_source . ne . traffic_index . and .( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_sand_index & . or . pollutant_loop_index ( i_pollutant ). eq . pm25_salt_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_salt_index & . or . pollutant_loop_index ( i_pollutant ). eq . pmex_index )) then !Do nothing because these pollutants only exist for traffic else i_file = emission_file_index ( i_source ) var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) !Calculate the emissions in the target grid temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) jj = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) temp_subgrid ( i , j ,:) = emission_subgrid ( ii , jj ,:, i_source , i_pollutant ) !Subgrid emissions, if relevant, are in units ug/sec/subgrid. Convert to g/s. Acount for the difference in subgrid sizes here temp_subgrid ( i , j ,:) = 1.0e-6 * temp_subgrid ( i , j ,:) * ( subgrid_delta ( y_dim_index ) * subgrid_delta ( x_dim_index )) & / ( emission_subgrid_delta ( y_dim_index , i_source ) * emission_subgrid_delta ( x_dim_index , i_source )) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif enddo enddo endif !Save population interpolated to the target grid if ( save_population ) then write ( unit_logfile , '(A)' ) '-------------------------------' write ( unit_logfile , '(A)' ) 'Saving population data' write ( unit_logfile , '(A)' ) '-------------------------------' variable_type = 'float' unit_str = \"inhabitants/grid\" i_file = population_file_index ( population_index ) var_name_temp = trim ( filename_grid ( i_file )) !Calculate the population in the target grid temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_population_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_population_subgrid ( i , j , y_dim_index ) temp_subgrid ( i , j ,:) = population_subgrid ( ii , jj , population_index ) !Acount for the difference in subgrid sizes here temp_subgrid ( i , j ,:) = temp_subgrid ( i , j ,:) * ( subgrid_delta ( y_dim_index ) * subgrid_delta ( x_dim_index )) & / ( population_subgrid_delta ( y_dim_index ) * population_subgrid_delta ( x_dim_index )) enddo enddo unit_str = 'inhabitants/grid' if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif ! Save region mask at target subgrid if ( trace_emissions_from_in_region ) then !! .or. use_region_select_and_mask_flag ?? write ( unit_logfile , '(A)' ) '-------------------------------' write ( unit_logfile , '(A)' ) 'Saving region mask' write ( unit_logfile , '(A)' ) '-------------------------------' variable_type = 'short' var_name_temp = 'region_index' unit_str = '1' !!!!!!! what to write here??? temp_subgrid = 0. do tt = 1 , subgrid_dim ( t_dim_index ) ! add 0.1 to all values to avoid them being rounded down to 1 less than original value temp_subgrid (:,:, tt ) = subgrid_region_index + 0.1 end do if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ) ! NB: hard-coding scale_factor=1 since it does not make sense to have scale_factor for an ID variable! call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , 1. ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then ! check if region is the same for the whole grid. If not, set to zero to avoid getting wrong ID when interpolating if (. not . ( minval ( subgrid_region_index ) == maxval ( subgrid_region_index ))) then write ( unit_logfile , '(A)' ) 'Warning: Not the same region_index for the whole receptor grid. Setting to 0.' temp_subgrid = 0. end if write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , 1. ) endif end if ! Save EMEP allsources ! NB: For now, this is always saved write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving EMEP allsources' write ( unit_logfile , '(a)' ) '--------------------------' do i_pollutant = 1 , n_emep_pollutant_loop !EMEP does not have all pollutants so only save to n_emep_pollutant_loop !Only save the allsource value here 'EMEP_allsources' variable_type = 'float' i_file = emep_subgrid_file_index ( allsource_index ) var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) unit_str = 'ug/m3' if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif end do !Save the EMEP data interpolated to the subgrid. These are based on the gridded concentrations ! Loop over 5 different verions ! 1 = emep local contributions from the moving-window (downscaling domain) ! 2 = As 1, but only the part of the moving window that is within the receptor region ! 3 = emep additional local contributions, extending further using larger LF grid ! 4 = Semilocal contribution, i.e. outside moving-window but inside the receptor region ! 5 = total contribution: Same as 3 (but saved as a different name and under different flag) ! 6 = total contribution from_in_region = 2+4, only for sources not downscaled do source_domain_loop = 1 , 6 ! check if this version of source contributions should be saved if ( source_domain_loop == 1 ) then if (. not . save_emep_source_contributions ) cycle filename_append = '' else if ( source_domain_loop == 2 ) then if (. not . ( save_local_source_contributions_from_in_region . and . trace_emissions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 3 ) then if (. not . ( save_emep_additional_source_contributions . and . EMEP_additional_grid_interpolation_size . gt . 0 )) cycle filename_append = '' else if ( source_domain_loop == 4 ) then if (. not . ( save_semilocal_source_contributions_from_in_region . and . trace_emissions_from_in_region )) cycle filename_append = '_from_in_region' else if ( source_domain_loop == 5 ) then if (. not . ( save_total_source_contributions . and . EMEP_additional_grid_interpolation_size . gt . 0 )) cycle filename_append = '' else !source_domain_loop == 6 if (. not . ( save_total_source_contributions_from_in_region . and . trace_emissions_from_in_region )) cycle filename_append = '_from_in_region' end if write ( unit_logfile , '(a)' ) '--------------------------' if ( source_domain_loop . eq . 1 ) write ( unit_logfile , '(a)' ) 'Saving EMEP contributions' if ( source_domain_loop . eq . 2 ) write ( unit_logfile , '(a)' ) 'Saving EMEP contributions from in region' if ( source_domain_loop . eq . 3 ) write ( unit_logfile , '(a)' ) 'Saving EMEP additional contributions' if ( source_domain_loop . eq . 4 ) write ( unit_logfile , '(a)' ) 'Saving EMEP semilocal contributions from in region' if ( source_domain_loop . eq . 5 ) write ( unit_logfile , '(a)' ) 'Saving total contributions' if ( source_domain_loop . eq . 6 ) write ( unit_logfile , '(a)' ) 'Saving total contributions from in region' write ( unit_logfile , '(a)' ) '--------------------------' if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' unit_str = \"ug/m3\" else variable_type = 'byte' unit_str = \"%\" endif do i_pollutant = 1 , n_emep_pollutant_loop !EMEP does not have all pollutants so only save to n_emep_pollutant_loop do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . save_EMEP_source ( i_source ). or . i_source . eq . allsource_index ) then !Do not save for the additional GNFR sources if ( i_source . eq . traffic_gasoline_nc_index . or . i_source . eq . traffic_diesel_nc_index . or . i_source . eq . traffic_gas_nc_index . or . i_source . eq . publicpower_point_nc_index . or . i_source . eq . publicpower_area_nc_index ) then cycle end if !Do not save nonexhaust for exhaust gas emissions if ( i_source . eq . traffic_nonexhaust_nc_index . and .( pollutant_loop_index ( i_pollutant ). eq . no2_index . or . pollutant_loop_index ( i_pollutant ). eq . nox_index . or . pollutant_loop_index ( i_pollutant ). eq . o3_index )) then cycle end if if ( source_domain_loop == 1 ) then ! local EMEP contribution i_file = emep_subgrid_local_file_index ( i_source ) temp_subgrid = subgrid (:,:,:, emep_local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 2 ) then ! local EMEP contribution cut down to in-region i_file = emep_subgrid_local_file_index ( i_source ) temp_subgrid = subgrid_EMEP_local_from_in_region (:,:,:, i_source , i_pollutant ) else if ( source_domain_loop == 3 ) then ! additional local EMEP contribution i_file = emep_additional_subgrid_local_file_index ( i_source ) temp_subgrid = subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else if ( source_domain_loop == 4 ) then ! semilocal EMEP contribution i_file = emep_subgrid_semilocal_file_index ( i_source ) temp_subgrid = subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) else ! source_domain_loop is 5 or 6 ! Only save total for non-downscaled sources, since downscaled sources were saved earlier if ( i_source == allsource_index . or . calculate_source ( i_source )) then cycle else if (( i_source == traffic_exhaust_nc_index . or . i_source == traffic_nonexhaust_nc_index ) . and . calculate_source ( traffic_index )) then ! if traffic is downscaled, then total contributions to traffic exhaust and nonexhaust are saved earlier in the subroutine using downscaled local contributions cycle end if if ( source_domain_loop == 5 ) then ! EMEP contribution from additional domain i_file = subgrid_sourcetotal_file_index ( i_source ) temp_subgrid = subgrid (:,:,:, emep_additional_local_subgrid_index , i_source , i_pollutant ) else !source_domain_loop == 6 ! sum of EMEP local and EMEP semilocal contribution i_file = subgrid_sourcetotal_inregion_file_index ( i_source ) temp_subgrid = subgrid_EMEP_local_from_in_region (:,:,:, i_source , i_pollutant ) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source , i_pollutant ) end if end if var_name_temp = trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // '_' // trim ( filename_grid ( i_file )) // trim ( filename_append ) !if (i_source.eq.traffic_exhaust_nc_index) var_name_temp=var_name_temp//'_exhaust' !if (i_source.eq.traffic_nonexhaust_nc_index) var_name_temp=var_name_temp//'_nonexhaust' ! Transform to fraction if (. not . save_netcdf_fraction_as_contribution_flag ) then temp_subgrid = temp_subgrid / subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ) * 10 0. temp_subgrid = min ( temp_subgrid , 100 0. ) temp_subgrid = max ( temp_subgrid , - 100 0. ) endif if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo ! i_source enddo ! i_pollutant enddo !source_domain_loop !Save the other interpolated EMEP compounds used for nox chemistry as well. These are based on the surface comp values if ( save_for_chemistry ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving for offline chemistry' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_pollutant = 1 , n_emep_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . nox_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) !Somo35 may be included here. Do not include it if it is. if ( i_comp . ne . somo35_nc_index ) then i_file = emep_subgrid_file_index ( allsource_index ) var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_forchemistry' // '_' // trim ( filename_grid ( i_file )) temp_subgrid = comp_EMEP_subgrid (:,:,:, i_comp ) unit_str = \"ug/m3\" if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( comp_EMEP_subgrid (:,:,:, i_comp )) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo endif enddo endif !Save weighted travel time if ( save_for_chemistry ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving weighted travel time' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' var_name_temp = 'Weighted_travel_time' unit_str = 'seconds' i_pollutant = pollutant_loop_back_index ( nox_nc_index ) !Only save the travel time for nox. Though this may be expanded for other compounds if necessary, like ammonia temp_subgrid = traveltime_subgrid (:,:,:, 3 , i_pollutant ) if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a)')'Writing netcdf variable: '//trim(var_name_temp) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(traveltime_subgrid(:,:,:,1,i_pollutant))/size(subgrid,1)/size(subgrid,2)/size(subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif if ( save_for_chemistry ) then variable_type = 'float' i_file = subgrid_J_file_index i_meteo = J_subgrid_index unit_str = \"1/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a)')'Writing netcdf variable: '//trim(var_name_temp) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- !Save temperature if not also saving the meteo data. if (. not . save_other_meteo ) then variable_type = 'float' i_file = subgrid_t2m_file_index i_meteo = t2m_subgrid_index unit_str = \"Celcius\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) - 27 3.13 enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a)')'Writing netcdf variable: '//trim(var_name_temp) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) !write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(temp_subgrid)/size(temp_subgrid,1)/size(temp_subgrid,2)/size(temp_subgrid,3) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif endif if ( save_emep_species ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving EMEP species' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) if ( i_sp . ne . sp_pm_index ) then !Do not include the total do i_loop = 1 , n_pmxx_sp_index if ( i_loop . eq . pm25_sp_index . or . i_loop . eq . pm10_sp_index ) then if ( i_loop . eq . pm25_sp_index ) i_pollutant = pollutant_loop_back_index ( pm25_index ) if ( i_loop . eq . pm10_sp_index ) i_pollutant = pollutant_loop_back_index ( pm10_index ) if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' var_name_temp = trim ( species_name_nc ( i_loop , ii_sp )) // '_nonlocal_contribution' unit_str = \"ug/m3\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) else variable_type = 'byte' var_name_temp = trim ( species_name_nc ( i_loop , i_sp )) // '_nonlocal_fraction' unit_str = \"%\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. endif if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo endif enddo endif !Only save sea salt in this way when emep species are not saved in the general way if ( save_seasalt . and .. not . save_emep_species ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving EMEP sea salt' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' i_sp = n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index if ( i_loop . eq . pm25_sp_index . or . i_loop . eq . pm10_sp_index ) then if ( i_loop . eq . pm25_sp_index ) i_pollutant = pollutant_loop_back_index ( pm25_index ) if ( i_loop . eq . pm10_sp_index ) i_pollutant = pollutant_loop_back_index ( pm10_index ) if ( save_netcdf_fraction_as_contribution_flag ) then variable_type = 'float' var_name_temp = trim ( species_name_nc ( i_loop , ii_sp )) // '_nonlocal_contribution' unit_str = \"ug/m3\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) else variable_type = 'byte' var_name_temp = trim ( species_name_nc ( i_loop , ii_sp )) // '_nonlocal_fraction' unit_str = \"%\" temp_subgrid = species_EMEP_subgrid (:,:,:, i_loop , i_sp ) / subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) * 10 0. endif if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid (:,:,:)) / size ( subgrid , 1 ) / size ( subgrid , 2 ) / size ( subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo endif !Save the original EMEP compounds if ( save_emep_original ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving original EMEP' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_pollutant = 1 , n_emep_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). ne . pmex_index ) then do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) i_comp = pollutant_compound_loop_index ( i_pollutant , i_loop ) i_file = emep_subgrid_file_index ( allsource_index ) var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_original_EMEP_concentration' unit_str = \"ug/m3\" if ( i_comp . eq . somo35_index ) unit_str = \"ppb�d\" if ( save_netcdf_file_flag ) then !write(unit_logfile,'(a,f12.3)')'Writing netcdf variable: '//trim(var_name_temp),sum(orig_EMEP_subgrid(:,:,:,i_comp))/size(subgrid,1)/size(subgrid,2)/size(subgrid,3) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( orig_EMEP_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , orig_EMEP_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then ! write(unit_logfile,'(a,f12.3)')'Writing netcdf receptor variable: '//trim(var_name_temp),sum(orig_EMEP_subgrid(:,:,:,i_comp))/size(subgrid,1)/size(subgrid,2)/size(subgrid,3) write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( orig_EMEP_subgrid (:,:,:, i_comp ), use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , orig_EMEP_subgrid (:,:,:, i_comp ), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo endif enddo endif !Save AQI if ( save_aqi ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving AQI' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'byte' scale_factor = 0.1 !Hard coded AQI limits aqi_pollutant_index ( 1 ) = no2_index ; aqi_pollutant_index ( 2 ) = pm10_index ; aqi_pollutant_index ( 3 ) = pm25_index ; aqi_pollutant_index ( 4 ) = o3_index aqi_limits_temp (:, 2 : 4 ) = aqi_hourly_limits (:, 1 : 3 ) aqi_limits_temp (:, 1 ) = 0. aqi_limits_temp (:, 5 ) = 2. * aqi_hourly_limits (:, 3 ) aqi_subgrid = 0. do t = 1 , subgrid_dim ( t_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) max_aqi = 0. do l = 1 , n_save_aqi_pollutant_index !pollutant (no2,pm10,pm2.5,o3) do k = 1 , 4 !level if ( comp_subgrid ( i , j , t , aqi_pollutant_index ( l )). ge . aqi_limits_temp ( aqi_pollutant_index ( l ), k ). and . comp_subgrid ( i , j , t , aqi_pollutant_index ( l )). lt . aqi_limits_temp ( aqi_pollutant_index ( l ), k + 1 )) then aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )) = k + ( comp_subgrid ( i , j , t , aqi_pollutant_index ( l )) - aqi_limits_temp ( aqi_pollutant_index ( l ), k )) / ( aqi_limits_temp ( aqi_pollutant_index ( l ), k + 1 ) - aqi_limits_temp ( aqi_pollutant_index ( l ), k )) endif enddo aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )) = min ( aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )), 4.99 ) if ( aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )). gt . max_aqi ) then max_aqi = aqi_subgrid ( i , j , t , aqi_pollutant_index ( l )) aqi_responsible_pollutant_index ( i , j , t ) = l endif !write(*,*)  i,j,t,aqi_responsible_pollutant_index(i,j,t),aqi_subgrid(i,j,t,aqi_pollutant_index(l)),max_aqi enddo enddo enddo enddo do l = 1 , n_save_aqi_pollutant_index !write(unit_logfile,*)  'MAX AQI in time and space from '//trim(pollutant_file_str(aqi_pollutant_index(l)))//' = ',maxval(aqi_subgrid(:,:,:,aqi_pollutant_index(l))) enddo var_name_temp = 'AQI' unit_str = '1' !Take the maximum of the pollutants temp_subgrid = maxval ( aqi_subgrid (:,:,:, aqi_pollutant_index ( 1 : n_save_aqi_pollutant_index )), 4 ) / scale_factor if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid * scale_factor ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif do l = 1 , n_save_aqi_pollutant_index i_comp = aqi_pollutant_index ( l ) var_name_temp = 'AQI_' // trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) unit_str = '1' !Take the maximum of the pollutants temp_subgrid = aqi_subgrid (:,:,:, i_comp ) / scale_factor if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid * scale_factor ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo !Reset scale_factor scale_factor = 1. endif !Save deposition if ( save_deposition . and . calculate_deposition_flag ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving deposition' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' do i_pollutant = 1 , n_pollutant_loop do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i_comp = pollutant_loop_index ( i_pollutant ) var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_local_dry_deposition_' // source_file_str ( i_source ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, drydepo_local_subgrid_index , i_source , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_local_wet_deposition_' // source_file_str ( i_source ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, wetdepo_local_subgrid_index , i_source , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif enddo var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_nonlocal_dry_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_total_dry_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = ( subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) + subgrid (:,:,:, drydepo_local_subgrid_index , allsource_index , i_pollutant )) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_nonlocal_wet_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_total_wet_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = ( subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) + subgrid (:,:,:, wetdepo_local_subgrid_index , allsource_index , i_pollutant )) / 100 0. * 360 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !Deposition velocity temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) temp_subgrid ( i , j ,:) = deposition_subgrid ( ii , jj ,:, vd_index , i_pollutant ) enddo enddo var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_deposition_velocity_' // source_file_str ( allsource_index ) unit_str = \"cm/s\" !Save in cm/s, conversition from ug/m2/s temp_subgrid = temp_subgrid * 10 0. if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !Landuse category if ( read_landuse_flag ) then temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) temp_subgrid ( i , j ,:) = landuse_subgrid ( ii , jj , grid_index ) enddo enddo var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_EMEP_landuse_category' unit_str = \"1\" variable_type = 'byte' if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif endif variable_type = 'float' !Save the original emep wet and dry deposition var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_original_EMEP_wet_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = orig_emep_deposition_subgrid (:,:,:, wetdepo_index , i_pollutant ) if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif var_name_temp = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_index )) // '_original_EMEP_dry_deposition_' // source_file_str ( allsource_index ) unit_str = \"mg/m2/hr\" !Save in mg per hour, conversition from ug/m2/s temp_subgrid = orig_emep_deposition_subgrid (:,:,:, drydepo_index , i_pollutant ) if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,es12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid , x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp & , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif enddo endif !Save the meteo interpolated to the target grid valid_min =- 1.e24 if ( save_wind_vectors ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving wind vectors' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' if ( wind_vectors_10m_available ) then i_file = subgrid_u10_file_index i_meteo = u10_subgrid_index else i_file = subgrid_ugrid_file_index i_meteo = ugrid_subgrid_index endif unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( wind_vectors_10m_available ) then i_file = subgrid_v10_file_index i_meteo = v10_subgrid_index else i_file = subgrid_vgrid_file_index i_meteo = vgrid_subgrid_index endif unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- endif if ( save_other_meteo ) then write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Saving other meteo data' write ( unit_logfile , '(a)' ) '--------------------------' variable_type = 'float' i_file = subgrid_hmix_file_index i_meteo = hmix_subgrid_index unit_str = \"m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- variable_type = 'float' i_file = subgrid_t2m_file_index i_meteo = t2m_subgrid_index unit_str = \"Celcius\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) - 27 3.13 enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.2)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.2)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- variable_type = 'float' i_file = subgrid_hmix_file_index i_meteo = precip_subgrid_index unit_str = \"mm/hr\" !The same for all-------------------- var_name_temp = 'precipitation' !trim(filename_grid(i_file)) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_kz_file_index i_meteo = kz_subgrid_index unit_str = \"m2/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( hourly_calculations ) then if ( wind_vectors_10m_available ) then i_file = subgrid_FF10_file_index i_meteo = FF10_subgrid_index else i_file = subgrid_FFgrid_file_index i_meteo = FFgrid_subgrid_index endif unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( wind_vectors_10m_available ) then i_file = subgrid_DD10_file_index else i_file = subgrid_DDgrid_file_index endif !i_meteo=DDgrid_subgrid_index !i_meteo not used in this conversion to wind direction unit_str = \"degrees\" do tt = 1 , subgrid_dim ( t_dim_index ) do jj = 1 , integral_subgrid_dim ( y_dim_index ) do ii = 1 , integral_subgrid_dim ( x_dim_index ) if ( wind_vectors_10m_available ) then temp_integral_subgrid ( ii , jj , tt ) = DIRECTION ( meteo_subgrid ( ii , jj , tt , u10_subgrid_index ), meteo_subgrid ( ii , jj , tt , v10_subgrid_index )) else temp_integral_subgrid ( ii , jj , tt ) = DIRECTION ( meteo_subgrid ( ii , jj , tt , ugrid_subgrid_index ), meteo_subgrid ( ii , jj , tt , vgrid_subgrid_index )) endif enddo enddo enddo !This is not converted to real degrees, but subgrid degrees, so is wrong but close !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); !In this case this is not the same for all temp_subgrid ( i , j ,:) = temp_integral_subgrid ( ii , jj ,:) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- endif i_file = subgrid_invL_file_index i_meteo = invL_subgrid_index unit_str = \"1/m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.4)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.4)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_logz0_file_index i_meteo = logz0_subgrid_index unit_str = \"log(m)\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_ustar_file_index i_meteo = ustar_subgrid_index unit_str = \"m/s\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- if ( annual_calculations ) then i_file = subgrid_invFFgrid_file_index i_meteo = inv_FFgrid_subgrid_index unit_str = \"s/m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- i_file = subgrid_invFF10_file_index i_meteo = inv_FF10_subgrid_index unit_str = \"s/m\" !The same for all-------------------- var_name_temp = trim ( filename_grid ( i_file )) temp_subgrid = 0. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ); jj = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ); temp_subgrid ( i , j ,:) = meteo_subgrid ( ii , jj ,:, i_meteo ) enddo enddo if ( save_netcdf_file_flag ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf variable: ' // trim ( var_name_temp ), mean_mask ( temp_subgrid , use_subgrid (:,:, allsource_index ), size ( temp_subgrid , 1 ), size ( temp_subgrid , 2 ), size ( temp_subgrid , 3 )) call uEMEP_save_netcdf_file ( unit_logfile , temp_name , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str , create_file , valid_min , variable_type , scale_factor ) endif if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( unit_logfile , '(a,f12.3)' ) 'Writing netcdf receptor variable: ' // trim ( var_name_temp ), sum ( temp_subgrid ) / size ( temp_subgrid , 1 ) / size ( temp_subgrid , 2 ) / size ( temp_subgrid , 3 ) call uEMEP_save_netcdf_receptor_file ( unit_logfile , temp_name_rec , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ) & , temp_subgrid (:,:,:), x_subgrid , y_subgrid , lon_subgrid , lat_subgrid , var_name_temp , unit_str , title_str_rec , create_file_rec , valid_min & , x_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), y_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , lon_receptor ( valid_receptor_index ( 1 : n_valid_receptor )), lat_receptor ( valid_receptor_index ( 1 : n_valid_receptor )) & , z_rec ( allsource_index , 1 ) & , name_receptor ( valid_receptor_index ( 1 : n_valid_receptor ), 1 ), n_valid_receptor , variable_type , scale_factor ) endif !The same for all-------------------- endif endif !Deallocate the averaging arrays with each receptor grid if ( use_multiple_receptor_grids_flag . and .. not . use_single_time_loop_flag . and . save_netcdf_average_flag ) then if ( allocated ( val_array_av )) deallocate ( val_array_av ) if ( allocated ( time_seconds_output_av )) deallocate ( time_seconds_output_av ) counter_av = 0 endif end subroutine uEMEP_save_netcdf_control subroutine uEMEP_save_netcdf_file ( unit_logfile_in , filename_netcdf , nx , ny , nt_in , val_array_in , x_array , y_array , lon_array , lat_array , name_array , unit_array , title_str , create_file , valid_min , variable_type , scale_factor ) use uEMEP_definitions use netcdf implicit none character ( 256 ) filename_netcdf , name_array , unit_array , title_str , temp_name integer unit_logfile_in integer nx , ny , nt_in real val_array ( nx , ny , nt_in ), val_array_in ( nx , ny , nt_in ) !,val_array_temp(nx,ny,nt) real x_array ( nx , ny ) real y_array ( nx , ny ) real lon_array ( nx , ny ) real lat_array ( nx , ny ) !,lat_array_temp(nx,ny) !real time_array(nt) real x_vector ( nx ) real y_vector ( ny ) logical create_file real valid_min character ( 256 ) variable_type real scale_factor integer ncid integer y_dimid , x_dimid , time_dimid integer y_varid , x_varid , lat_varid , lon_varid , val_varid , time_varid , proj_varid integer dimids3 ( 3 ), dimids2 ( 2 ), chunks3 ( 3 ) integer n_dims ( 3 ) integer status integer nf90_type integer t integer n_time_total integer nt integer ( 8 ) time_seconds_output_nc ( nt_in ) !Need integer 8 for the averaging integer i_source character ( 2 ) temp_str integer i character ( 256 ) temp_str2 if ( trim ( variable_type ). eq . 'byte' ) nf90_type = NF90_BYTE if ( trim ( variable_type ). eq . 'short' ) nf90_type = NF90_SHORT if ( trim ( variable_type ). eq . 'float' ) nf90_type = NF90_FLOAT if ( trim ( variable_type ). eq . 'double' ) nf90_type = NF90_DOUBLE !Assumes x and y are the dimensions x_vector = x_array (:, 1 ) y_vector = y_array ( 1 ,:) n_time_total = end_time_nc_index - start_time_nc_index + 1 nt = nt_in val_array = val_array_in time_seconds_output_nc = time_seconds_output !Save averages only if ( save_netcdf_average_flag ) then counter_av = counter_av + 1 if ( counter_av . gt . n_var_av ) then write ( unit_logfile_in , * ) 'ERROR: Array size for saving averages (n_var_av) not large enough. Stopping' stop endif if ( use_single_time_loop_flag ) then val_array_av (:,:, counter_av ) = val_array_av (:,:, counter_av ) + val_array (:,:, nt ) !nt=1 in this case time_seconds_output_av ( counter_av ) = time_seconds_output_av ( counter_av ) + time_seconds_output_nc ( nt ) if ( t_loop . eq . end_time_loop_index ) then val_array (:,:, nt ) = val_array_av (:,:, counter_av ) / n_time_total time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) / n_time_total endif !write(unit_logfile_in,'(a,3i)') 'Saving as average single time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(nt) else val_array_av (:,:, counter_av ) = sum ( val_array , 3 ) / size ( val_array , 3 ) time_seconds_output_av ( counter_av ) = sum ( time_seconds_output_nc ) / size ( time_seconds_output_nc , 1 ) nt = 1 val_array (:,:, nt ) = val_array_av (:,:, counter_av ) time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) !write(unit_logfile_in,'(a,3i)') 'Saving as average multiple time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(nt) endif endif !Mask the regions if required if ( use_region_select_and_mask_flag ) then do t = 1 , nt ! NB: Array subgrid_val is no longer allocated or used !where (use_subgrid_val(:,:,allsource_index).eq.outside_region_index) val_array(:,:,t)=NODATA_value where (. not . use_subgrid (:,:, allsource_index )) val_array (:,:, t ) = NODATA_value enddo endif if ( create_file ) then !Create a netcdf file !call check(  nf90_create(filename_netcdf, nf90_clobber, ncid) ) !call check(  nf90_create(filename_netcdf, NF90_HDF5, ncid) ) call check ( nf90_create ( filename_netcdf , IOR ( NF90_HDF5 , NF90_CLASSIC_MODEL ), ncid ) ) !New !Specify global attributes call check ( nf90_put_att ( ncid , nf90_global , \"Conventions\" , \"CF-1.6\" ) ) call check ( nf90_put_att ( ncid , nf90_global , \"title\" , trim ( title_str )) ) call check ( nf90_put_att ( ncid , nf90_global , \"Model\" , trim ( model_version_str ) ) ) !Save some model flags for later reference call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_flag\" , EMEP_grid_interpolation_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_chemistry_scheme_flag\" , no2_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_size\" , EMEP_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_additional_grid_interpolation_size\" , EMEP_additional_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_background_chemistry_scheme_flag\" , no2_background_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_subgrid_method_flag\" , local_subgrid_method_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_emission_grid_interpolation_flag\" , EMEP_emission_grid_interpolation_flag ) ) if ( limit_emep_grid_interpolation_region_to_calculation_region ) then call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"true\" ) ) else call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"false\" ) ) endif call check ( nf90_put_att ( ncid , nf90_global , \"n_local_fraction_grids\" , n_local_fraction_grids ) ) do i = 1 , n_local_fraction_grids write ( temp_str , '(i0)' ) i temp_str2 = \"local_fraction_grid_size(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), local_fraction_grid_size ( i )) ) enddo call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_grid_interpolation\" , local_fraction_grid_for_EMEP_grid_interpolation ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_additional_grid_interpolation\" , local_fraction_grid_for_EMEP_additional_grid_interpolation ) ) if (. not . use_GNFR_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR_emissions_from_EMEP_flag\" , \"false\" ) ) endif if ( use_GNFR_emissions_from_EMEP_flag . and .. not . use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR13_emissions_from_EMEP_flag\" , \"true\" ) ) endif if ( use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR19_emissions_from_EMEP_flag\" , \"true\" ) ) endif !Write out sources i = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"uEMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_uEMEP_sources\" , i )) i = 0 do i_source = 1 , n_source_index if ( calculate_EMEP_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"EMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_EMEP_sources\" , i )) !Projection data if ( projection_type . eq . UTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_utm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) if ( utm_zone . ge . 0 ) then call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) else call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 1000000 0. ) ) endif call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) endif if ( projection_type . eq . LTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_tm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) if ( utm_zone . ge . 0 ) then call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) else call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 1000000 0. ) ) endif call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , ltm_lon0 ) ) endif if ( projection_type . eq . RDM_projection_index ) then !Not properly assigned, same as UTM call check ( nf90_def_var ( ncid , \"projection_RDM\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) endif if ( projection_type . eq . LAEA_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_ETRS89_LAEA\" , NF90_int , proj_varid ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378137.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"inverse_flattening\", 298.257222101 ) ) !https://github.com/mdsumner/rasterwise/blob/master/README.md !EPSG:3035 !int ETRS89-LAEA ; !    ETRS89-LAEA:missing_value = -1. ; !   ETRS89-LAEA:grid_mapping_name = \"lambert_azimuthal_equal_area\" ; !   ETRS89-LAEA:longitude_of_projection_origin = 10. ; !   ETRS89-LAEA:latitude_of_projection_origin = 52. ; !   ETRS89-LAEA:false_easting = 4321000. ; !   ETRS89-LAEA:false_northing = 3210000. ; !   ETRS89-LAEA:inverse_flattening = 298.257222101 ; !   ETRS89-LAEA:semi_major_axis = 6378137. ; !call check(  nf90_put_att(ncid, proj_varid, \"grid_mapping_name\", \"lambert_azimuthal_equal_area\" ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378137.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"inverse_flattening\", 298.257222101 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"scale_factor_at_central_meridian\", 0.9996 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"latitude_of_projection_origin\",  52. ) ) !call check(  nf90_put_att(ncid, proj_varid, \"false_easting\", 4321000. ) ) !call check(  nf90_put_att(ncid, proj_varid, \"false_northing\", 3210000. ) ) !call check(  nf90_put_att(ncid, proj_varid, \"longitude_of_projection_origin\", 10.) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"lambert_azimuthal_equal_area\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , projection_attributes ( 5 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , projection_attributes ( 6 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , projection_attributes ( 2 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , projection_attributes ( 3 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , projection_attributes ( 4 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_projection_origin\" , projection_attributes ( 1 )) ) endif !Define the dimensions call check ( nf90_def_dim ( ncid , \"time\" , NF90_UNLIMITED , time_dimid ) ) call check ( nf90_def_dim ( ncid , \"y\" , ny , y_dimid ) ) call check ( nf90_def_dim ( ncid , \"x\" , nx , x_dimid ) ) !Define the dimension variables !call check(  nf90_def_var(ncid, \"time\", NF90_DOUBLE, time_dimid, time_varid) ) call check ( nf90_def_var ( ncid , \"time\" , NF90_INT , time_dimid , time_varid ) ) call check ( nf90_def_var ( ncid , \"y\" , NF90_REAL , y_dimid , y_varid ) ) call check ( nf90_def_var ( ncid , \"x\" , NF90_REAL , x_dimid , x_varid ) ) !Define the values dimids3 = ( / x_dimid , y_dimid , time_dimid / ) dimids2 = ( / x_dimid , y_dimid / ) call check ( nf90_def_var ( ncid , \"lat\" , NF90_REAL , dimids2 , lat_varid ) ) call check ( nf90_def_var ( ncid , \"lon\" , NF90_REAL , dimids2 , lon_varid ) ) !Specify the units call check ( nf90_put_att ( ncid , lat_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , lon_varid , \"units\" , \"degrees_east\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , time_varid , \"units\" , trim ( unit_dim_nc ( time_dim_nc_index ))) ) !Specify other dimension attributes call check ( nf90_put_att ( ncid , y_varid , \"standard_name\" , \"projection_y_coordinate\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"standard_name\" , \"projection_x_coordinate\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"axis\" , \"Y\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"axis\" , \"X\" ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index)) ) !call check( nf90_put_var(ncid, time_varid, time_seconds_output(1:dim_length_nc(time_dim_nc_index))) ) call check ( nf90_put_var ( ncid , time_varid , time_seconds_output_nc ( 1 : nt )) ) call check ( nf90_put_var ( ncid , y_varid , y_vector ) ) call check ( nf90_put_var ( ncid , x_varid , x_vector ) ) call check ( nf90_put_var ( ncid , lat_varid , lat_array ) ) call check ( nf90_put_var ( ncid , lon_varid , lon_array ) ) call check ( nf90_close ( ncid ) ) endif !Do not save any average data for single time loops until the last time step where it will save the average if ( save_netcdf_average_flag . and . use_single_time_loop_flag . and . t_loop . ne . end_time_loop_index ) then !call check( nf90_close(ncid) ) return endif !Add to the existing file call check ( nf90_open ( filename_netcdf , NF90_WRITE , ncid ) ) !Get the dimensions id from the existing file call check ( nf90_inq_dimid ( ncid , \"time\" , time_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"y\" , y_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"x\" , x_dimid ) ) dimids3 = ( / x_dimid , y_dimid , time_dimid / ) chunks3 = ( / nx , ny , 1 / ) !New call check ( nf90_inquire_dimension ( ncid , dimids3 ( 1 ), temp_name , n_dims ( 1 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 2 ), temp_name , n_dims ( 2 )) ) call check ( nf90_inquire_dimension ( ncid , dimids3 ( 3 ), temp_name , n_dims ( 3 )) ) status = nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) if ( status . ne . nf90_NoErr ) then call check ( nf90_redef ( ncid ) ) !if the variable does not exist then create a new one !write(*,*) 'Creating new: ',trim(name_array) call check ( nf90_def_var ( ncid , trim ( name_array ), nf90_type , dimids3 , val_varid ) ) ! gzip level 3 compression and shuffling ! optional _FillValue for values which never have been written, unpacked value call check ( nf90_def_var_chunking ( ncid , val_varid , NF90_CHUNKED , chunks3 ) ) !New call check ( nf90_def_var_deflate ( ncid , val_varid , 1 , 1 , 3 ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"units\" , trim ( unit_array )) ) !Specify other variable attributes if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 1 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 2 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 2 )) ) else call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , NODATA_value ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , valid_min ) ) endif if ( projection_type . eq . UTM_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_utm\" ) ) elseif ( projection_type . eq . LTM_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_tm\" ) ) elseif ( projection_type . eq . LAEA_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_ETRS89_LAEA\" ) ) elseif ( projection_type . eq . RDM_projection_index ) then call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_RDM\" ) ) endif call check ( nf90_put_att ( ncid , val_varid , \"coordinates\" , \"lon lat\" ) ) if ( scale_factor . ne . 1. ) call check ( nf90_put_att ( ncid , val_varid , \"scale_factor\" , scale_factor ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) endif if ( use_single_time_loop_flag ) then !Add time to the time dimension call check ( nf90_inq_varid ( ncid , \"time\" , time_varid ) ) !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 if ( save_netcdf_average_flag ) then n_dims ( 3 ) = nt else n_dims ( 3 ) = t_loop endif call check ( nf90_put_var ( ncid , time_varid , time_seconds_output_nc ( 1 ), start = ( / n_dims ( 3 ) / ) ) ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !Add dimension and array to existing call check ( nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) ) if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 1 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 2 ), start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) else call check ( nf90_put_var ( ncid , val_varid , val_array , start = ( / 1 , 1 , n_dims ( 3 ) / ), count = ( / n_dims ( 1 ), n_dims ( 2 ), 1 / )) ) endif else !Write the whole variable to file. Default is float if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_array (:,:, 1 : nt ), kind = 2 )) ) else call check ( nf90_put_var ( ncid , val_varid , val_array (:,:, 1 : nt )) ) endif endif call check ( nf90_close ( ncid ) ) end subroutine uEMEP_save_netcdf_file subroutine check ( status ) use netcdf implicit none integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( * , * ) 'Stopping due to netcdf error: ' // trim ( nf90_strerror ( status )) error stop end if end subroutine check ! ###################################################################### FUNCTION DIRECTION ( UD , VD ) !\tCALCULATES THE WIND DIRECTION !Taken from NBLM1 IMPLICIT NONE REAL DIRECTION , UD , VD , PI PI = 18 0. / 3.14159 DIRECTION = 0. IF ( UD . GT . 0. AND . VD . GE . 0 ) DIRECTION = 27 0. - ATAN ( ABS ( VD / UD )) * PI IF ( UD . LE . 0. AND . VD . GT . 0 ) DIRECTION = 18 0. - ATAN ( ABS ( UD / VD )) * PI IF ( UD . LT . 0. AND . VD . LE . 0 ) DIRECTION = 9 0. - ATAN ( ABS ( VD / UD )) * PI IF ( UD . GE . 0. AND . VD . LT . 0 ) DIRECTION = 36 0. - ATAN ( ABS ( UD / VD )) * PI END FUNCTION DIRECTION ! ###################################################################### function mean_nodata ( array , n1 , n2 , n3 , nodata_num ) !use uEMEP_definitions implicit none real :: array ( n1 , n2 , n3 ) real :: nodata_num integer :: n1 , n2 , n3 real :: mean_nodata integer i , j , t real :: count = 0 real :: sum_array = 0 do t = 1 , n3 do j = 1 , n2 do i = 1 , n1 if ( array ( i , j , t ). ne . nodata_num ) then sum_array = sum_array + array ( i , j , t ) count = count + 1. endif enddo enddo enddo if ( count . gt . 0 ) then mean_nodata = sum_array / count else mean_nodata = 0 endif end function mean_nodata function mean_mask ( array , mask , n1 , n2 , n3 ) !use uEMEP_definitions implicit none real , intent ( in ) :: array ( n1 , n2 , n3 ) logical , intent ( in ) :: mask ( n1 , n2 ) integer , intent ( in ) :: n1 , n2 , n3 real :: mean_mask integer i , j , t real :: count = 0 real :: sum_array = 0 sum_array = 0 count = 0 do t = 1 , n3 do j = 1 , n2 do i = 1 , n1 if ( mask ( i , j )) then sum_array = sum_array + array ( i , j , t ) count = count + 1. endif enddo enddo enddo if ( count . gt . 0 ) then mean_mask = sum_array / count else mean_mask = 0 endif end function mean_mask !Saves receptor data in netcdf format subroutine uEMEP_save_netcdf_receptor_file ( unit_logfile_in , filename_netcdf , nx , ny , nt_in , val_array_in , x_array , y_array , lon_array , lat_array , name_array , unit_array , title_str , create_file , valid_min & , x_rec , y_rec , lon_rec , lat_rec , height_rec , name_rec_in , nr , variable_type , scale_factor ) use uEMEP_definitions use netcdf implicit none character ( 256 ) filename_netcdf , name_array , unit_array , title_str , temp_name integer unit_logfile_in integer nx , ny , nt_in , nr real val_array ( nx , ny , nt_in ), val_array_in ( nx , ny , nt_in ) !,val_array_temp(nx,ny,nt_in) real x_array ( nx , ny ) real y_array ( nx , ny ) real lon_array ( nx , ny ) real lat_array ( nx , ny ) !,lat_array_temp(nx,ny) !real time_array(nt_in) !real x_vector(nx) !real y_vector(ny) logical create_file real valid_min character ( 256 ) variable_type real scale_factor integer ncid integer station_dimid , time_dimid , charlen_dimid integer station_varid , station_name_varid , lat_varid , lon_varid , val_varid , time_varid , proj_varid , x_varid , y_varid , height_varid integer dimids2 ( 2 ) integer n_dims_length ( 3 ), n_dims_start ( 3 ) integer status integer tr , rr real x_rec ( nr ), y_rec ( nr ), height_rec ( nr ) real lon_rec ( nr ), lat_rec ( nr ) character ( 256 ) name_rec_in ( nr ) character ( 256 ) temp_char integer n_char !parameter (n_char=7) parameter ( n_char = 64 ) character ( 1 ) name_rec ( n_char , nr ) integer n_time_total real val_rec ( nr , nt_in ) real delta ( 2 ) integer id_rec ( nr ) integer nf90_type integer nt integer ( 8 ) time_seconds_output_nc ( nt_in ) integer tr_0 integer i_source character ( 2 ) temp_str integer i character ( 256 ) temp_str2 !Do not save if no receptor position data is available if ( nr . eq . 0 ) then return endif if ( trim ( variable_type ). eq . 'byte' ) nf90_type = NF90_BYTE if ( trim ( variable_type ). eq . 'short' ) nf90_type = NF90_SHORT if ( trim ( variable_type ). eq . 'float' ) nf90_type = NF90_FLOAT if ( trim ( variable_type ). eq . 'double' ) nf90_type = NF90_DOUBLE nt = nt_in val_array = val_array_in time_seconds_output_nc = time_seconds_output !Save averages only if ( save_netcdf_average_flag ) then counter_av = counter_av + 1 if ( counter_av . gt . n_var_av ) then write ( unit_logfile_in , * ) 'ERROR: Array size for saving averages (n_var_av) not large enough. Stopping' stop endif if ( use_single_time_loop_flag ) then val_array_av (:,:, counter_av ) = val_array_av (:,:, counter_av ) + val_array (:,:, nt ) !nt=1 in this case time_seconds_output_av ( counter_av ) = time_seconds_output_av ( counter_av ) + time_seconds_output_nc ( nt ) if ( t_loop . eq . end_time_loop_index ) then val_array (:,:, nt ) = val_array_av (:,:, counter_av ) / end_time_loop_index time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) / end_time_loop_index endif !write(unit_logfile_in,*) 'Saving as average single time loop (nt,counter_av):',nt,counter_av else !write(unit_logfile_in,*) 'Saving as average multiple time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(1),time_seconds_output_nc(nt) !write(*,*) time_seconds_output_nc(1:nt) val_array_av (:,:, counter_av ) = sum ( val_array (:,:, 1 : nt ), 3 ) / nt time_seconds_output_av ( counter_av ) = sum ( time_seconds_output_nc ( 1 : nt ), 1 ) / nt !write(*,*) sum(time_seconds_output_nc(1:nt),1) nt = 1 val_array (:,:, nt ) = val_array_av (:,:, counter_av ) time_seconds_output_nc ( nt ) = time_seconds_output_av ( counter_av ) !write(unit_logfile_in,*) 'Saving as average multiple time loop (nt,counter_av):',nt,counter_av,time_seconds_output_nc(nt),time_seconds_output_av(counter_av) endif endif !Interpolate to receptor position given the input array !write(unit_logfile,'(a)')' Interpolating to receptor point ' !Assumes 2 elements to an array delta ( 1 ) = ( x_array ( 2 , 1 ) - x_array ( 1 , 1 )) delta ( 2 ) = ( y_array ( 1 , 2 ) - y_array ( 1 , 1 )) do rr = 1 , nr do tr = 1 , nt val_rec ( rr , tr ) = area_weighted_interpolation_function ( x_array , y_array , val_array (:,:, tr ), nx , ny , delta , x_rec ( rr ), y_rec ( rr )) enddo enddo !Make the receptor name to fit to netcdf requirements do rr = 1 , nr id_rec ( rr ) = rr temp_char = name_rec_in ( rr ) tr_0 = len_trim ( temp_char ) do tr = 1 , tr_0 name_rec ( tr , rr ) = temp_char ( tr : tr ) !write(*,*) trim(name_rec_in(rr)),trim(name_rec(rr)) enddo do tr = tr_0 + 1 , n_char name_rec ( tr , rr ) = char ( 0 ) enddo enddo if ( save_netcdf_average_flag ) then n_time_total = 1 else n_time_total = end_time_nc_index - start_time_nc_index + 1 endif if ( create_file ) then !Create a netcdf file !call check(  nf90_create(filename_netcdf, nf90_clobber, ncid) ) !call check(  nf90_create(filename_netcdf, NF90_HDF5, ncid) ) call check ( nf90_create ( filename_netcdf , IOR ( NF90_HDF5 , NF90_CLASSIC_MODEL ), ncid ) ) !New !Specify global attributes call check ( nf90_put_att ( ncid , nf90_global , \"Conventions\" , \"CF-1.6\" ) ) call check ( nf90_put_att ( ncid , nf90_global , \"title\" , trim ( title_str )) ) call check ( nf90_put_att ( ncid , nf90_global , \"Model\" , trim ( model_version_str ) ) ) call check ( nf90_put_att ( ncid , nf90_global , \"featureType\" , \"timeSeries\" ) ) !Save some model flags for later reference call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_flag\" , EMEP_grid_interpolation_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_chemistry_scheme_flag\" , no2_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_grid_interpolation_size\" , EMEP_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_additional_grid_interpolation_size\" , EMEP_additional_grid_interpolation_size ) ) call check ( nf90_put_att ( ncid , nf90_global , \"no2_background_chemistry_scheme_flag\" , no2_background_chemistry_scheme_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_subgrid_method_flag\" , local_subgrid_method_flag ) ) call check ( nf90_put_att ( ncid , nf90_global , \"EMEP_emission_grid_interpolation_flag\" , EMEP_emission_grid_interpolation_flag ) ) if ( limit_emep_grid_interpolation_region_to_calculation_region ) then call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"true\" ) ) else call check ( nf90_put_att ( ncid , nf90_global , \"limit_emep_grid_interpolation_region_to_calculation_region\" , \"false\" ) ) endif call check ( nf90_put_att ( ncid , nf90_global , \"n_local_fraction_grids\" , n_local_fraction_grids ) ) do i = 1 , n_local_fraction_grids write ( temp_str , '(i0)' ) i temp_str2 = \"local_fraction_grid_size(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), local_fraction_grid_size ( i )) ) enddo call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_grid_interpolation\" , local_fraction_grid_for_EMEP_grid_interpolation ) ) call check ( nf90_put_att ( ncid , nf90_global , \"local_fraction_grid_for_EMEP_additional_grid_interpolation\" , local_fraction_grid_for_EMEP_additional_grid_interpolation ) ) if (. not . use_GNFR_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR_emissions_from_EMEP_flag\" , \"false\" ) ) endif if ( use_GNFR_emissions_from_EMEP_flag . and .. not . use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR13_emissions_from_EMEP_flag\" , \"true\" ) ) endif if ( use_GNFR19_emissions_from_EMEP_flag ) then call check ( nf90_put_att ( ncid , nf90_global , \"use_GNFR19_emissions_from_EMEP_flag\" , \"true\" ) ) endif !Write out sources i = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"uEMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_uEMEP_sources\" , i )) i = 0 do i_source = 1 , n_source_index if ( calculate_EMEP_source ( i_source )) then i = i + 1 write ( temp_str , '(i0)' ) i temp_str2 = \"EMEP_source(\" // trim ( temp_str ) // \")\" call check ( nf90_put_att ( ncid , nf90_global , trim ( temp_str2 ), trim ( source_file_str ( i_source )) ) ) endif enddo call check ( nf90_put_att ( ncid , nf90_global , \"n_EMEP_sources\" , i )) !Projection data if ( projection_type . eq . UTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_utm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378140.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_minor_axis\", 6356750.0 ) ) endif if ( projection_type . eq . LTM_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_tm\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , ltm_lon0 ) ) endif if ( projection_type . eq . RDM_projection_index ) then !Not properly assigned, same as UTM call check ( nf90_def_var ( ncid , \"projection_RDM\" , NF90_int , proj_varid ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , 637813 7.0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , 29 8.257222101 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"transverse_mercator\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"scale_factor_at_central_meridian\" , 0.9996 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , 0 ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , 50000 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , 0. ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_central_meridian\" , utm_lon0 ) ) endif if ( projection_type . eq . LAEA_projection_index ) then call check ( nf90_def_var ( ncid , \"projection_ETRS89_LAEA\" , NF90_int , proj_varid ) ) !call check(  nf90_put_att(ncid, proj_varid, \"semi_major_axis\", 6378137.0 ) ) !call check(  nf90_put_att(ncid, proj_varid, \"inverse_flattening\", 298.257222101 ) ) !https://github.com/mdsumner/rasterwise/blob/master/README.md !EPSG:3035 call check ( nf90_put_att ( ncid , proj_varid , \"grid_mapping_name\" , \"lambert_azimuthal_equal_area\" ) ) call check ( nf90_put_att ( ncid , proj_varid , \"semi_major_axis\" , projection_attributes ( 5 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"inverse_flattening\" , projection_attributes ( 6 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"latitude_of_projection_origin\" , projection_attributes ( 2 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_easting\" , projection_attributes ( 3 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"false_northing\" , projection_attributes ( 4 ) ) ) call check ( nf90_put_att ( ncid , proj_varid , \"longitude_of_projection_origin\" , projection_attributes ( 1 )) ) endif !Define the dimensions for the entire dataset !write(*,*) 'n_valid_receptor_in',n_valid_receptor_in !write(*,*) 'n_valid_receptor',n_valid_receptor call check ( nf90_def_dim ( ncid , \"station_id\" , n_valid_receptor_in , station_dimid ) ) call check ( nf90_def_dim ( ncid , \"charlen\" , n_char , charlen_dimid ) ) !call check(  nf90_def_dim(ncid,\"time\",n_time_total, time_dimid) ) !To have time as unlimittec (Heiko) call check ( nf90_def_dim ( ncid , \"time\" , NF90_UNLIMITED , time_dimid ) ) !Define the dimension variables call check ( nf90_def_var ( ncid , \"station_id\" , NF90_INT , station_dimid , station_varid ) ) !call check(  nf90_def_var(ncid, \"time\", NF90_DOUBLE, time_dimid, time_varid) ) call check ( nf90_def_var ( ncid , \"time\" , NF90_INT , time_dimid , time_varid ) ) !Define the values dimids2 = ( / station_dimid , time_dimid / ) !dimids1 = (/ station_dimid /) call check ( nf90_def_var ( ncid , \"lat\" , NF90_REAL , station_dimid , lat_varid ) ) call check ( nf90_def_var ( ncid , \"lon\" , NF90_REAL , station_dimid , lon_varid ) ) call check ( nf90_def_var ( ncid , \"y\" , NF90_REAL , station_dimid , y_varid ) ) call check ( nf90_def_var ( ncid , \"x\" , NF90_REAL , station_dimid , x_varid ) ) call check ( nf90_def_var ( ncid , \"station_name\" , NF90_CHAR , ( / charlen_dimid , station_dimid / ), station_name_varid ) ) call check ( nf90_def_var ( ncid , \"station_height\" , NF90_REAL , station_dimid , height_varid ) ) !call check(  nf90_def_var(ncid, \"station_name\", NF90_CHAR, (/station_dimid/), station_name_varid) ) !call check(  nf90_def_var(ncid, \"station_name\", NF90_CHAR, (/charlen_dimid,station_dimid/), station_name_varid) ) !Specify the units call check ( nf90_put_att ( ncid , lat_varid , \"units\" , \"degrees_north\" ) ) call check ( nf90_put_att ( ncid , lon_varid , \"units\" , \"degrees_east\" ) ) call check ( nf90_put_att ( ncid , y_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , x_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , height_varid , \"units\" , \"m\" ) ) call check ( nf90_put_att ( ncid , time_varid , \"units\" , trim ( unit_dim_nc ( time_dim_nc_index ))) ) call check ( nf90_put_att ( ncid , station_varid , \"long_name\" , \"station index\" ) ) call check ( nf90_put_att ( ncid , station_name_varid , \"long_name\" , \"station name\" ) ) call check ( nf90_put_att ( ncid , station_name_varid , \"cf_role\" , \"timeseries_id\" ) ) !Specify other dimension attributes !call check(  nf90_put_att(ncid, y_varid, \"standard_name\", \"projection_y_coordinate\") ) !call check(  nf90_put_att(ncid, x_varid, \"standard_name\", \"projection_x_coordinate\") ) !call check(  nf90_put_att(ncid, y_varid, \"axis\", \"Y\") ) !call check(  nf90_put_att(ncid, x_varid, \"axis\", \"X\") ) !Close the definitions call check ( nf90_enddef ( ncid ) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index)) ) !call check( nf90_put_var(ncid, station_varid, name_rec(:,1:n_char) ) !call check( nf90_put_var(ncid, lat_varid, lat_array) ) !call check( nf90_put_var(ncid, lon_varid, lon_array) ) !Put this in to fix unlimitted problem? If works on annual need to check it works other places as well! !call check( nf90_put_var(ncid, time_varid, time_seconds_output_nc(1:nt), start=(/1/), count=(/nt/)) ) !call check( nf90_put_var(ncid, time_varid, time_seconds_output_nc(1:nt)) ) call check ( nf90_close ( ncid ) ) endif !Add to the existing file call check ( nf90_open ( filename_netcdf , NF90_WRITE , ncid ) ) !Get the dimensions id from the existing file call check ( nf90_inq_dimid ( ncid , \"time\" , time_dimid ) ) call check ( nf90_inq_dimid ( ncid , \"station_id\" , station_dimid ) ) ! write(*,*) 'station_dimid ',station_dimid ! write(*,*) 'time_dimid ',time_dimid dimids2 = ( / station_dimid , time_dimid / ) !Get the size of the dimensions call check ( nf90_inquire_dimension ( ncid , dimids2 ( 1 ), temp_name , n_dims_length ( 1 )) ) call check ( nf90_inquire_dimension ( ncid , dimids2 ( 2 ), temp_name , n_dims_length ( 2 )) ) !Set the starting point to 1 n_dims_start ( 1 : 2 ) = 1 !Set time to full length in unlimitted case (Heiko) n_dims_length ( 2 ) = n_time_total ! write(*,*) 'n_dims_length(1) ',n_dims_length(1) ! write(*,*) 'n_dims_length(2) ',n_dims_length(2) status = nf90_inq_varid ( ncid , trim ( name_array ), val_varid ) if ( status . ne . nf90_NoErr ) then !if the variable does not exist then create a new one !write(*,*) 'Creating new: ',trim(name_array) call check ( nf90_redef ( ncid ) ) call check ( nf90_def_var ( ncid , trim ( name_array ), nf90_type , dimids2 , val_varid ) ) call check ( nf90_put_att ( ncid , val_varid , \"units\" , trim ( unit_array )) ) !Specify other variable attributes if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 1 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 1 )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , int ( NODATA_value , kind = 2 ) ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , int ( valid_min , kind = 2 )) ) else call check ( nf90_put_att ( ncid , val_varid , \"missing_value\" , NODATA_value ) ) !New call check ( nf90_put_att ( ncid , val_varid , \"valid_min\" , valid_min ) ) endif call check ( nf90_put_att ( ncid , val_varid , \"grid_mapping\" , \"projection_utm\" ) ) call check ( nf90_put_att ( ncid , val_varid , \"coordinates\" , \"station_name lat lon\" ) ) if ( scale_factor . ne . 1. ) call check ( nf90_put_att ( ncid , val_varid , \"scale_factor\" , scale_factor ) ) !Close the definitions call check ( nf90_enddef ( ncid ) ) endif !Should not be used but can be if ( use_single_time_loop_flag ) then !Add time to the time dimension !call check( nf90_inq_varid(ncid, \"time\", time_varid) ) !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 if ( save_netcdf_average_flag ) then n_dims_start ( 2 ) = 1 n_dims_length ( 2 ) = 1 else n_dims_start ( 2 ) = t_loop n_dims_length ( 2 ) = 1 endif !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1,time_dim_nc_index), start = (/n_dims(2)/) ) ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !Add dimension and array to existing !call check( nf90_inq_varid(ncid, trim(name_array), val_varid) ) !call check( nf90_put_var(ncid, val_varid, val_rec, start=(/1,n_dims(2)/), count=(/n_dims(1),1/)) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index), start=(/n_dims(2)/), count=(/1/)) ) !call check( nf90_put_var(ncid, station_varid, name_rec(1,:), start=(/1,1/), count=(/n_dims(1),n_char/)) ) elseif ( use_multiple_receptor_grids_flag ) then !Add time to the time dimension !call check( nf90_inq_varid(ncid, \"station\", station_varid) ) !call check( nf90_inquire_dimension(ncid, time_dimid, temp_name, n_dims(3)) ) !n_dims(3)=n_dims(3)+1 n_dims_start ( 1 ) = valid_receptor_inverse_index ( g_loop ) n_dims_length ( 1 ) = 1 id_rec ( 1 ) = valid_receptor_inverse_index ( g_loop ) !write(*,*) n_dims(3),val_dim_nc(1,time_dim_nc_index) !write(*,*) n_dims !Add dimension and array to existing !call check( nf90_inq_varid(ncid, trim(name_array), val_varid) ) !call check( nf90_put_var(ncid, val_varid, val_rec, start=(/n_dims(1),1/), count=(/1,n_dims(2)/)) ) !call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index) , start=(/1/), count=(/n_dims(2)/)) ) !call check( nf90_put_var(ncid, station_varid, name_rec(1,:), start = (/n_dims(1),1/), count=(/1,n_char/)) ) endif !write(*,*) 'n_dims_start',n_dims_start !write(*,*) 'n_dims_length',n_dims_length !Fill in the complete dimension variables for time and receptor names call check ( nf90_inq_varid ( ncid , \"station_id\" , station_varid ) ) call check ( nf90_inq_varid ( ncid , \"time\" , time_varid ) ) call check ( nf90_inq_varid ( ncid , \"station_name\" , station_name_varid ) ) call check ( nf90_inq_varid ( ncid , \"x\" , x_varid ) ) call check ( nf90_inq_varid ( ncid , \"y\" , y_varid ) ) call check ( nf90_inq_varid ( ncid , \"lon\" , lon_varid ) ) call check ( nf90_inq_varid ( ncid , \"lat\" , lat_varid ) ) call check ( nf90_inq_varid ( ncid , \"station_height\" , height_varid ) ) !Write time to the file !!call check( nf90_put_var(ncid, time_varid, val_dim_nc(1:dim_length_nc(time_dim_nc_index),time_dim_nc_index), start=(/n_dims_start(2)/), count=(/n_dims_length(2)/)) ) call check ( nf90_put_var ( ncid , time_varid , time_seconds_output_nc ( 1 : nt ), start = ( / n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 2 ) / )) ) !!call check( nf90_put_var(ncid, station_varid, name_rec(:), start = (/1,1/), count=(/n_dims(1),n_char/)) ) !Write station index and name call check ( nf90_put_var ( ncid , station_varid , id_rec , start = ( / n_dims_start ( 1 ), 1 / ), count = ( / n_dims_length ( 1 ), n_char / )) ) call check ( nf90_put_var ( ncid , station_name_varid , name_rec , start = ( / 1 , n_dims_start ( 1 ) / ), count = ( / n_char , n_dims_length ( 1 ) / )) ) !!call check( nf90_put_var(ncid, station_name_varid, name_rec, start = (/1,1/), count=(/n_char,n_dims(1)/)) ) !!call check( nf90_put_var(ncid, station_name_varid, name_rec, start = (/1/), count=(/n_dims(1)/)) ) !Write the variable to file if ( nf90_type . eq . NF90_byte ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_rec (:, 1 : nt ), kind = 1 ), start = ( / n_dims_start ( 1 ), n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 1 ), n_dims_length ( 2 ) / )) ) elseif ( nf90_type . eq . NF90_short ) then call check ( nf90_put_var ( ncid , val_varid , int ( val_rec (:, 1 : nt ), kind = 2 ), start = ( / n_dims_start ( 1 ), n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 1 ), n_dims_length ( 2 ) / )) ) else call check ( nf90_put_var ( ncid , val_varid , val_rec (:, 1 : nt ), start = ( / n_dims_start ( 1 ), n_dims_start ( 2 ) / ), count = ( / n_dims_length ( 1 ), n_dims_length ( 2 ) / )) ) endif !Write position data to the file call check ( nf90_put_var ( ncid , x_varid , x_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , y_varid , y_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , lon_varid , lon_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , lat_varid , lat_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_put_var ( ncid , height_varid , height_rec , start = ( / n_dims_start ( 1 ) / ), count = ( / n_dims_length ( 1 ) / )) ) call check ( nf90_close ( ncid ) ) end subroutine uEMEP_save_netcdf_receptor_file end module save_netcdf_file","tags":"","loc":"sourcefile/uemep_save_netcdf_file.f90.html"},{"title":"uEMEP_control_v2.f90 – uEMEP","text":"Source Code program uEMEP_v6 !! **************************************************************************** !!   uEMEP control v2 !! !!   Bruce rolstad Denby (brucerd@met.no) !!   MET Norway !! **************************************************************************** !! Reminder note for compilation on Intel !! To add this library to your linker input in the IDE, open the context menu for the project node, choose Properties, then in the Project Properties dialog box, choose Linker !! , and edit the Linker Input to add legacy_stdio_definitions.lib to the semi-colon-separated list !! Tools/options/intel compilers and tools/visual fortran/compilers and add bin, include and lib, e.g. C:\\Program Files (x86)\\netcdf 4.3.3.1\\bin; !!   Control programme for running the downscaling routine uEMEP !! **************************************************************************** !! !! **************************************************************************** !! To link to netcdf in visual studio !! Tools - options - Intel compilers - VisusalFortran - Compilers - Libraries/includes/executables !! C:\\Program Files (x86)\\netcdf 4.3.3.1\\include !! C:\\Program Files (x86)\\netcdf 4.3.3.1\\bin !! C:\\Program Files (x86)\\netcdf 4.3.3.1\\lib use uemep_configuration use uEMEP_definitions use read_command_line , only : uEMEP_read_command_line , check_command_line use set_constants , only : uEMEP_set_constants , uEMEP_set_pollutant_loop , & uEMEP_reset_constants , uEMEP_set_species_loop use read_config , only : uEMEP_read_config use read_emep , only : uEMEP_read_EMEP use read_meteo_nc , only : uEMEP_read_meteo_nc use read_rwc_heating_data , only : uEMEP_read_RWC_heating_data use save_emission_netcdf , only : uEMEP_calculate_emissions_for_EMEP use set_subgrids , only : uEMEP_set_subgrids , uEMEP_set_subgrid_select_latlon_centre use read_landuse_rivm_data , only : uEMEP_read_landuse_rivm_data , & uEMEP_set_landuse_classes , uEMEP_read_netcdf_landuse_latlon use read_roadlink_data_ascii , only : read_country_bounding_box_data , & uEMEP_read_roadlink_data_ascii , uEMEP_change_road_data , uEMEP_read_roadlink_emission_data use set_filenames , only : uEMEP_set_filenames use read_receptor_data , only : uEMEP_read_receptor_data , uEMEP_set_loop_receptor_grid , & uEMEP_grid_receptor_data use read_ssb_data , only : uEMEP_read_netcdf_population , uEMEP_read_SSB_data , & uEMEP_read_netcdf_population_latlon use read_agriculture_asi_data , only : uEMEP_read_agriculture_rivm_data , & uEMEP_read_emission_rivm_data use read_industry_data , only : uEMEP_read_industry_data use read_shipping_asi_data , only : uEMEP_preaggregate_shipping_asi_data , & uEMEP_read_netcdf_shipping_latlon , uEMEP_read_weekly_shipping_asi_data , & uEMEP_read_monthly_and_daily_shipping_asi_data , uEMEP_read_shipping_asi_data use read_time_profiles , only : uEMEP_read_time_profiles use redistribute_data , only : uEMEP_redistribute_local_source , uEMEP_disperse_local_source , & uEMEP_combine_local_source use save_netcdf_file , only : uEMEP_save_netcdf_control use subgrid_deposition , only : uEMEP_subgrid_deposition use subgrid_dispersion , only : uEMEP_subgrid_dispersion use set_emission_factors , only : uEMEP_set_emission_factors , uEMEP_convert_proxy_to_emissions , & uEMEP_nox_emission_temperature use subgrid_emep , only : uEMEP_subgrid_EMEP , uEMEP_subgrid_EMEP_from_in_region use subgrid_deposition_emep , only : uEMEP_set_deposition_velocities , & uEMEP_subgrid_deposition_EMEP , uEMEP_calculate_deposition use subgrid_emission_emep , only : uEMEP_subgrid_emission_EMEP use subgrid_meteo_emep , only : uEMEP_subgrid_meteo_EMEP use tiling_routines , only : uEMEP_set_tile_grids , uEMEP_set_region_tile_grids use chemistry_no2 , only : uEMEP_chemistry , correct_annual_mean_chemistry use crossreference_grids , only : uEMEP_crossreference_grids use grid_roads , only : uEMEP_grid_roads use define_subgrid , only : uEMEP_define_subgrid_extent , uEMEP_define_subgrid use calculate_exposure , only : uEMEP_calculate_exposure use auto_subgrid , only : uEMEP_region_mask_new use uemep_logger implicit none integer :: source_index real :: start_time_cpu , end_time_cpu logical :: have_read_emep = . false . character ( len = 64 ) :: logfile_name = \"logfile.txt\" , program_name ! Start timer call cpu_Time ( start_time_cpu ) ! Check command line arguments and handle special cases that have to be printed to stdout call check_command_line () ! Set model version model_version_str = 'uEMEP_v6.3' write ( * , * ) '' write ( * , * ) '------------------------------------------------------------------------' write ( * , * ) 'Starting program ' // trim ( model_version_str ) write ( * , * ) '------------------------------------------------------------------------' ! Read the command line, assigning the configuration file names and the substitution date_str call uEMEP_read_command_line () ! Set constants and variable names to be read from EMEP and meteo files call uEMEP_set_constants () ! Read the configuration files. Hard coded to be up to 5 files. Log file opened in this routine call uEMEP_read_config () ! If selected then specify subgrid using the lat and lon coordinates if ( select_latlon_centre_domain_position_flag ) then call uEMEP_set_subgrid_select_latlon_centre () end if ! Set the landuse if required if ( use_landuse_as_proxy . or . read_landuse_flag ) then call uEMEP_set_landuse_classes () end if ! Set the pollutant and compound loop definitions call uEMEP_set_pollutant_loop () !Reset any constants needed based on the configuration input call uEMEP_reset_constants () ! Autoselect files and countries if required. Place here because it changes config data if ( auto_select_OSM_country_flag . or . trim ( select_country_by_name ) . ne . '' ) then call read_country_bounding_box_data () end if ! Set the EMEP species definitions if they are to be read call uEMEP_set_species_loop () ! Set the names of files to be written to when saving intermediate files call uEMEP_set_filenames () ! Read positions of receptor points (usually observations) for specifying multiple receptor grids or calculation points within a single grid call uEMEP_read_receptor_data () ! Enter the routine for saving emissions used in uEMEP for EMEP in netcdf files defined for the Norwegian domain in Lambert coordinates. Will stop after this if ( save_emissions_for_EMEP ( allsource_index )) then call uEMEP_calculate_emissions_for_EMEP () end if ! We set up an initial emission grid parameter set that can be used to first select the outester region ! This has been done to enable reading of multiple road link files but only keeping those in the initial defined emission area call uEMEP_set_subgrids () init_emission_subgrid_min = emission_subgrid_min init_emission_subgrid_max = emission_subgrid_max init_emission_subgrid_dim = emission_subgrid_dim init_emission_subgrid_delta = emission_subgrid_delta ! Set the grid loop (g_loop) extent based on use_multiple_receptor_grids_flag or not if ( use_multiple_receptor_grids_flag ) then start_grid_loop_index = 1 end_grid_loop_index = n_receptor_in n_receptor = 1 n_valid_receptor = 1 valid_receptor_index ( 1 ) = 1 else start_grid_loop_index = 1 end_grid_loop_index = 1 n_receptor = n_receptor_in use_receptor ( start_grid_loop_index ) = . true . end if first_g_loop = . true . ! If the use_single_time_loop_flag is true (Reads and calculates one time step at a time to save memory) then set these parameters if ( use_single_time_loop_flag ) then start_time_loop_index = 1 end_time_loop_index = end_time_nc_index - start_time_nc_index + 1 subgrid_dim ( t_dim_index ) = 1 dim_length_nc ( time_dim_nc_index ) = 1 else start_time_loop_index = 1 end_time_loop_index = 1 subgrid_dim ( t_dim_index ) = end_time_nc_index - start_time_nc_index + 1 dim_length_nc ( time_dim_nc_index ) = subgrid_dim ( t_dim_index ) end if ! Start internal grid receptor loop using only those receptor grids specified in uEMEP_read_receptor_data do g_loop = start_grid_loop_index , end_grid_loop_index if ( use_receptor ( g_loop )) then ! Set the grid definitions according to the receptor/observation positions call uEMEP_set_loop_receptor_grid () ! Create the subgrid call uEMEP_set_subgrids () ! Set emission factors for the current subgrid call uEMEP_set_emission_factors () ! Start the internal time loop do t_loop = start_time_loop_index , end_time_loop_index ! Write progress in time and receptor grid loop to screen write ( * , * ) 'REC LOOP= ' , g_loop , ' OF ' , end_grid_loop_index if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) 'REC LOOP= ' , g_loop , ' OF ' , end_grid_loop_index end if write ( * , * ) 'TIME LOOP=' , t_loop , ' OF ' , end_time_loop_index if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) 'TIME LOOP=' , t_loop , ' OF ' , end_time_loop_index end if ! For the first time loop set the initial subgrid range values used in reading EMEP and meteo data if ( t_loop . ge . start_time_loop_index ) then init_subgrid_min = subgrid_min init_subgrid_max = subgrid_max end if ! Read EMEP data from netcdf files. Time stamps based on this if ( . not . have_read_emep ) then call uEMEP_read_EMEP () end if ! If read EMEP only once flag is on then turn off the EMEP reading ! This is intended for use with multiple receptor files and requires alot of memory so is permanently turned off if ( read_EMEP_only_once_flag ) have_read_emep = . true . ! Read meteo grid from netcdf files if required if ( use_alternative_meteorology_flag . or . use_alternative_z0_flag ) then call uEMEP_read_meteo_nc () end if ! Set the following for the first internal time step only if ( t_loop . eq . start_time_loop_index ) then ! Define subgrid positions and buffer zones. Must be done after reading EMEP data as is based on EMEP grid sizes call uEMEP_define_subgrid_extent () call uEMEP_define_subgrid () ! Define and allocate cross reference subgrids used to transfer data between different subgrids call uEMEP_crossreference_grids () ! Read all road link data from ascii files if ( calculate_source ( traffic_index ) . and . . not . read_subgrid_emission_data ) then ! Do this only for the first receptor grid loop if ( first_g_loop ) then call uEMEP_read_roadlink_data_ascii () call uEMEP_change_road_data () ! Read in the NORTRIP emission data for traffic in the first g_loop if required if ( use_NORTRIP_emission_data ) then call uEMEP_read_roadlink_emission_data () end if end if end if ! Read in and grid industry data if ( calculate_source ( industry_index ) . and . . not . read_subgrid_emission_data ) then call uEMEP_read_industry_data () end if ! Read and subgrid shipping data if ( calculate_source ( shipping_index ) . and . . not . read_subgrid_emission_data ) then ! If necessary aggregate shipping data first call uEMEP_preaggregate_shipping_asi_data () ! Read in shipping data if ( read_shipping_from_netcdf_flag ) then call uEMEP_read_netcdf_shipping_latlon () else if ( read_weekly_shipping_data_flag ) then call uEMEP_read_weekly_shipping_asi_data () else if ( read_monthly_and_daily_shipping_data_flag ) then call uEMEP_read_monthly_and_daily_shipping_asi_data () else call uEMEP_read_shipping_asi_data () end if end if end if ! Read in proxy data for home heating. Currently dwelling density if ( calculate_source ( heating_index ) . and . . not . read_subgrid_emission_data ) then ! If calculating tiles then read only the dwelling data if ( calculate_tiling_flag . or . calculate_region_tiling_flag ) then use_RWC_emission_data = . false . end if ! Read the Residential Wood Combustion data from MetVed if ( use_RWC_emission_data ) then call uEMEP_read_RWC_heating_data () else ! Read and subgrid SSB dwelling data SSB_data_type = dwelling_index if ( read_population_from_netcdf_flag ) then call uEMEP_read_netcdf_population_latlon () else if ( read_population_from_netcdf_local_flag ) then call uEMEP_read_netcdf_population () else call uEMEP_read_SSB_data () end if end if end if ! Read and subgrid agriculture data if ( calculate_source ( agriculture_index ) . and . use_rivm_agricuture_emission_data . and . . not . read_subgrid_emission_data ) then ! Currently only data from RIVM here call uEMEP_read_agriculture_rivm_data () end if if ( read_rivm_landuse_flag ) then call uEMEP_read_landuse_rivm_data () end if if ( read_subgrid_emission_data ) then ! Special routine for reading in RIVM point source emission data if ( use_rivm_subgrid_emission_format ) then call uEMEP_read_emission_rivm_data () else ! Nothing else available yet end if end if ! Read in population data if ( calculate_population_exposure_flag . or . use_population_positions_for_auto_subgrid_flag . or . save_population ) then ! Read and subgrid SSB population data SSB_data_type = population_data_type if ( read_population_from_netcdf_flag ) then call uEMEP_read_netcdf_population_latlon () else if ( read_population_from_netcdf_local_flag ) then call uEMEP_read_netcdf_population () else call uEMEP_read_SSB_data () end if end if if ( use_landuse_as_proxy . or . read_landuse_flag ) then call uEMEP_read_netcdf_landuse_latlon () end if ! Autogrid setting for selecting which subgrids to calculate if ( use_emission_positions_for_auto_subgrid_flag ( allsource_index )) then call uEMEP_grid_roads () write ( unit_logfile , * ) \"'uEMEP_auto_subgrid' has been disabled, because array 'use_subgrid_val' is disabled\" stop !call uEMEP_auto_subgrid() end if ! No longer call uEMEP_region_mask, as use_subgrid_val is deactivated and use_subgrid is set elsewhere !if (use_region_select_and_mask_flag) then !    call uEMEP_region_mask() !end if ! New subroutine for reading region mask and region fraction if ( trace_emissions_from_in_region . or . use_region_select_and_mask_flag ) then call uEMEP_region_mask_new () endif ! Specify the subgrids sizes to be calculated using use_receptor_region call uEMEP_grid_receptor_data ! Carry out tiling. Programme will stop here if ( calculate_tiling_flag ) then call uEMEP_grid_roads () call uEMEP_set_tile_grids () end if ! Carry out regional tiling. Programme will stop here if ( calculate_region_tiling_flag ) then call uEMEP_set_region_tile_grids () end if end if ! Read time profiles for emissions call uEMEP_read_time_profiles () ! Call grid_roads again to include the time variation from NORTRIP if ( . not . read_subgrid_emission_data ) then call uEMEP_grid_roads () end if ! Interpolate meteo data to subgrid. Placed on the integral subgrid call uEMEP_subgrid_meteo_EMEP () ! Replaces proxy emissions with distributed EMEP emissions call uEMEP_subgrid_emission_EMEP () ! Convert proxies to emissions including time profiles call uEMEP_convert_proxy_to_emissions () ! Adjust traffic emissions of NOx based on temperature if ( use_traffic_nox_emission_temperature_dependency ) then call uEMEP_nox_emission_temperature () end if ! Places EMEP deposition velocities into the deposition_subgrid if ( calculate_deposition_flag ) then call uEMEP_set_deposition_velocities () end if ! Set travel_time values to 0 outside of the source loop as these are aggregated over all sources traveltime_subgrid = 0.0 ! Subgrid dispersion calculation do source_index = 1 , n_source_index if ( calculate_source ( source_index ) . and . . not . use_plume_dispersion_deposition_flag ) then call uEMEP_subgrid_dispersion ( source_index ) end if end do do source_index = 1 , n_source_index if ( calculate_source ( source_index ) . and . use_plume_dispersion_deposition_flag ) then call uEMEP_subgrid_deposition ( source_index ) end if end do ! Interpolate local_subgrid if necessary if ( interpolate_subgrids_flag ) then write ( unit_logfile , * ) \"'uEMEP_interpolate_auto_subgrid' has been disabled, because array 'use_subgrid_val' is disabled\" stop !call uEMEP_interpolate_auto_subgrid() end if ! Old diagnostic for comparing EMEP and proxy data emissions. Working only on lat lon EMEP grids. Do not use if ( make_EMEP_grid_emission_data ( allsource_index )) then !call uEMEP_aggregate_proxy_emission_in_EMEP_grid end if ! Put EMEP data into the additional subgrids for all sources. ! Must be run first if ( EMEP_additional_grid_interpolation_size . gt . 0.0 ) then calculate_EMEP_additional_grid_flag = . true . call uEMEP_subgrid_EMEP () calculate_EMEP_additional_grid_flag = . false . end if ! Put EMEP data into subgrids for all sources call uEMEP_subgrid_EMEP () ! Call the new subroutine for calculating more precise estimates of the contributions from outside moving window but within region if ( trace_emissions_from_in_region ) then if ( EMEP_grid_interpolation_flag == 0 . or . EMEP_grid_interpolation_flag == 6 ) then call uEMEP_subgrid_EMEP_from_in_region () end if ! NB: Only implemented to be consistent with interpolation flag 0 and 6 end if if ( calculate_deposition_flag ) then call uEMEP_subgrid_deposition_EMEP () end if ! Interpolate EMEP to sub-grid do source_index = 1 , n_source_index if ( calculate_source ( source_index )) then ! Redistributes proxy subgrid data into the EMEP grid concentrations only when local_subgrid_method_flag=1 (based on EMEP concentration redistribution scaling factor) call uEMEP_redistribute_local_source ( source_index ) ! Places the proxy_subgrid data into the local_subgrid when local_subgrid_method_flag<>1 call uEMEP_disperse_local_source ( source_index ) end if end do ! Combine and save sources in local and total values call uEMEP_combine_local_source () ! Calculate the nonlocal depositions if ( calculate_deposition_flag ) then call uEMEP_calculate_deposition () end if ! Calculate chemistry for NO2 and O3 call uEMEP_chemistry () ! Correct annual mean chemistry for pdf if ( use_annual_mean_pdf_chemistry_correction ) then call correct_annual_mean_chemistry () end if ! Calculate exposure if ( calculate_population_exposure_flag ) then call uEMEP_calculate_exposure () end if ! Save results to netcdf if ( save_netcdf_file_flag . or . save_netcdf_receptor_flag ) then call uEMEP_save_netcdf_control () end if end do ! t_loop ! Update first_g_loop flag if ( first_g_loop ) first_g_loop = . false . end if ! use_receptor end do ! g_loop call cpu_time ( end_time_cpu ) if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) '' write ( unit_logfile , * ) '------------------------------------------------------------------------' write ( unit_logfile , * ) 'Ending program ' // trim ( model_version_str ) write ( unit_logfile , '(a,i5,a,i2)' ) ' CPU time taken (MM:SS): ' , floor (( end_time_cpu - start_time_cpu ) / 6 0.0 ), ':' , floor ( mod ( end_time_cpu - start_time_cpu , 6 0.0 )) write ( unit_logfile , * ) '------------------------------------------------------------------------' end if if ( unit_logfile . gt . 0 ) then close ( unit_logfile , status = 'keep' ) end if ! Save finished file if ( trim ( finished_filename ) . ne . '' ) then if ( save_netcdf_receptor_flag . and . n_valid_receptor . ne . 0 ) then write ( * , '(2A)' ) 'Writing finished file for uEMEP output: ' , trim ( finished_file_rec ) open ( unit_finishedfile , file = finished_file_rec , status = 'replace' ) close ( unit_finishedfile ) end if if ( save_netcdf_file_flag ) then write ( * , '(2A)' ) 'Writing finished file for uEMEP output: ' , trim ( finished_file ) open ( unit_finishedfile , file = finished_file , status = 'replace' ) close ( unit_finishedfile ) end if end if write ( * , * ) '' write ( * , * ) '------------------------------------------------------------------------' write ( * , * ) 'Ending program ' // trim ( model_version_str ) write ( * , '(a,i5,a,i2)' ) ' CPU time taken (MM:SS): ' , floor (( end_time_cpu - start_time_cpu ) / 6 0.0 ), ':' , floor ( mod ( end_time_cpu - start_time_cpu , 6 0.0 )) write ( * , * ) '------------------------------------------------------------------------' end program uEMEP_v6","tags":"","loc":"sourcefile/uemep_control_v2.f90.html"},{"title":"uEMEP_read_config.f90 – uEMEP","text":"Source Code module read_config use uemep_configuration use uEMEP_definitions use read_namefile_routines , only : read_name_char , read_name_real , & read_name_logical , read_name_integer , read_name_double use time_functions , only : date_to_datestr_bracket , date_to_number , & number_to_date , date_to_datestr_squarebracket , date_to_datestr , & datestr_to_date implicit none private public :: uEMEP_read_config , replace_string_char contains !   Set up of uEMEP before starting calculations subroutine uEMEP_read_config implicit none integer i character ( 256 ) pathfilename_log_file logical :: exists integer a ( 6 ) character ( 256 ) format_temp integer :: unit_in = 30 integer i_config , i_source , i_landuse double precision datenum_temp character ( 256 ) yesterday_date_str character ( 256 ) a_str , b_str character ( 256 ) temp_str !========================================================================== !   uEMEP model setup !========================================================================== write ( * , '(A)' ) '' write ( * , '(A)' ) '================================================================' write ( * , '(A)' ) 'Reading model run configuration (uEMEP_read_config)' write ( * , '(A)' ) '================================================================' do i_config = 1 , n_config_files !Temporary hardcoding of config file name. Will be read in as command line string if ( len ( name_config_file ( i_config )). eq . 0 ) then !name_config_file='C:\\uEMEP\\Fortran\\application\\config\\uEMEP_config_test.txt' write ( * , '(a)' ) 'ERROR: No configuration file available. Stopping.' stop endif write ( * , '(a)' ) 'Reading configuration file: ' // trim ( name_config_file ( i_config )) !Check existence of file inquire ( file = trim ( name_config_file ( i_config )), exist = exists ) if (. not . exists ) then write ( * , '(A)' ) 'ERROR: Configuration file ' // trim ( name_config_file ( i_config )) // ' does not exist.' stop endif !Open the config file for reading open ( unit_in , file = name_config_file ( i_config ), access = 'sequential' , status = 'old' , readonly ) !First read log file name and open it filename_log_file = read_name_char ( 'filename_log_file' , filename_log_file , unit_in , unit_logfile ) pathname_log_file = read_name_char ( 'pathname_log_file' , pathname_log_file , unit_in , unit_logfile ) !Open log file when reading the first configuration file if ( i_config . eq . 1 ) then if ( len ( trim ( filename_log_file )). gt . 0 ) then unit_logfile = 10 !Check existence of path inquire ( file = trim ( pathname_log_file ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A)' ) 'ERROR: Log file directory path ' // trim ( pathname_log_file ) // ' does not exist.' stop endif !Write to screen if writing to log file pathfilename_log_file = trim ( pathname_log_file ) // trim ( filename_log_file ) write ( * , '(A,A)' ) 'Writing to log file: ' , trim ( pathfilename_log_file ) write ( * , '(A)' ) '================================================================' open ( unit_logfile , file = trim ( pathfilename_log_file ), access = 'sequential' , form = 'formatted' , status = 'unknown' ) if ( unit_logfile . ne . 0 ) then write ( unit_logfile , * ) '------------------------------------------------------------------------' write ( unit_logfile , * ) 'Starting programm ' , trim ( model_version_str ) write ( unit_logfile , * ) '------------------------------------------------------------------------' endif else unit_logfile = 0 endif endif file_tag = read_name_char ( 'file_tag' , file_tag , unit_in , unit_logfile ) replacement_date_str = read_name_char ( 'replacement_date_str' , replacement_date_str , unit_in , unit_logfile ) replacement_yesterday_date_str = read_name_char ( 'replacement_yesterday_date_str' , replacement_yesterday_date_str , unit_in , unit_logfile ) replacement_hour_str = read_name_char ( 'replacement_hour_str' , replacement_hour_str , unit_in , unit_logfile ) NORTRIP_replacement_hour_str = read_name_char ( 'NORTRIP_replacement_hour_str' , NORTRIP_replacement_hour_str , unit_in , unit_logfile ) input_comp_name = read_name_char ( 'input_comp_name' , input_comp_name , unit_in , unit_logfile ) hourly_calculations = read_name_logical ( 'hourly_calculations' , hourly_calculations , unit_in , unit_logfile ) annual_calculations = read_name_logical ( 'annual_calculations' , annual_calculations , unit_in , unit_logfile ) !Not implemented !start_month_in_annual_calculations=read_name_integer('start_month_in_annual_calculations',start_month_in_annual_calculations,unit_in,unit_logfile) !end_month_in_annual_calculations=read_name_integer('end_month_in_annual_calculations',end_month_in_annual_calculations,unit_in,unit_logfile) start_time_nc_index = read_name_integer ( 'start_time_nc_index' , start_time_nc_index , unit_in , unit_logfile ) end_time_nc_index = read_name_integer ( 'end_time_nc_index' , end_time_nc_index , unit_in , unit_logfile ) start_time_meteo_nc_index = read_name_integer ( 'start_time_meteo_nc_index' , start_time_meteo_nc_index , unit_in , unit_logfile ) end_time_meteo_nc_index = read_name_integer ( 'end_time_meteo_nc_index' , end_time_meteo_nc_index , unit_in , unit_logfile ) use_single_time_loop_flag = read_name_logical ( 'use_single_time_loop_flag' , use_single_time_loop_flag , unit_in , unit_logfile ) reduce_EMEP_region_flag = read_name_logical ( 'reduce_EMEP_region_flag' , reduce_EMEP_region_flag , unit_in , unit_logfile ) use_multiple_receptor_grids_flag = read_name_logical ( 'use_multiple_receptor_grids_flag' , use_multiple_receptor_grids_flag , unit_in , unit_logfile ) use_receptor_region = read_name_integer ( 'use_receptor_region' , use_receptor_region , unit_in , unit_logfile ) reduce_roadlink_region_flag = read_name_logical ( 'reduce_roadlink_region_flag' , reduce_roadlink_region_flag , unit_in , unit_logfile ) !Choose which sources to calculate !calculate_source(:)=read_name_logical('calculate_source(:)',calculate_source(allsource_index),unit_in,unit_logfile) calculate_source ( traffic_index ) = read_name_logical ( 'calculate_source(traffic_index)' , calculate_source ( traffic_index ), unit_in , unit_logfile ) calculate_source ( shipping_index ) = read_name_logical ( 'calculate_source(shipping_index)' , calculate_source ( shipping_index ), unit_in , unit_logfile ) calculate_source ( heating_index ) = read_name_logical ( 'calculate_source(heating_index)' , calculate_source ( heating_index ), unit_in , unit_logfile ) calculate_source ( agriculture_index ) = read_name_logical ( 'calculate_source(agriculture_index)' , calculate_source ( agriculture_index ), unit_in , unit_logfile ) calculate_source ( industry_index ) = read_name_logical ( 'calculate_source(industry_index)' , calculate_source ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources calculate_source ( publicpower_index ) = read_name_logical ( 'calculate_source(publicpower_index)' , calculate_source ( publicpower_index ), unit_in , unit_logfile ) calculate_source ( fugitive_index ) = read_name_logical ( 'calculate_source(fugitive_index)' , calculate_source ( fugitive_index ), unit_in , unit_logfile ) calculate_source ( solvents_index ) = read_name_logical ( 'calculate_source(solvents_index)' , calculate_source ( solvents_index ), unit_in , unit_logfile ) calculate_source ( aviation_index ) = read_name_logical ( 'calculate_source(aviation_index)' , calculate_source ( aviation_index ), unit_in , unit_logfile ) calculate_source ( offroad_index ) = read_name_logical ( 'calculate_source(offroad_index)' , calculate_source ( offroad_index ), unit_in , unit_logfile ) calculate_source ( waste_index ) = read_name_logical ( 'calculate_source(waste_index)' , calculate_source ( waste_index ), unit_in , unit_logfile ) calculate_source ( livestock_index ) = read_name_logical ( 'calculate_source(livestock_index)' , calculate_source ( livestock_index ), unit_in , unit_logfile ) calculate_source ( other_index ) = read_name_logical ( 'calculate_source(other_index)' , calculate_source ( other_index ), unit_in , unit_logfile ) !Choose which EMEP sources to include/calculate. Will not be downscaled but will included as gridded source contributions !calculate_source(:)=read_name_logical('calculate_source(:)',calculate_source(allsource_index),unit_in,unit_logfile) calculate_EMEP_source ( traffic_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_index)' , calculate_EMEP_source ( traffic_index ), unit_in , unit_logfile ) calculate_EMEP_source ( shipping_index ) = read_name_logical ( 'calculate_EMEP_source(shipping_index)' , calculate_EMEP_source ( shipping_index ), unit_in , unit_logfile ) calculate_EMEP_source ( heating_index ) = read_name_logical ( 'calculate_EMEP_source(heating_index)' , calculate_EMEP_source ( heating_index ), unit_in , unit_logfile ) calculate_EMEP_source ( agriculture_index ) = read_name_logical ( 'calculate_EMEP_source(agriculture_index)' , calculate_EMEP_source ( agriculture_index ), unit_in , unit_logfile ) calculate_EMEP_source ( industry_index ) = read_name_logical ( 'calculate_EMEP_source(industry_index)' , calculate_EMEP_source ( industry_index ), unit_in , unit_logfile ) !Additional GNFR13 sources calculate_EMEP_source ( publicpower_index ) = read_name_logical ( 'calculate_EMEP_source(publicpower_index)' , calculate_EMEP_source ( publicpower_index ), unit_in , unit_logfile ) calculate_EMEP_source ( fugitive_index ) = read_name_logical ( 'calculate_EMEP_source(fugitive_index)' , calculate_EMEP_source ( fugitive_index ), unit_in , unit_logfile ) calculate_EMEP_source ( solvents_index ) = read_name_logical ( 'calculate_EMEP_source(solvents_index)' , calculate_EMEP_source ( solvents_index ), unit_in , unit_logfile ) calculate_EMEP_source ( aviation_index ) = read_name_logical ( 'calculate_EMEP_source(aviation_index)' , calculate_EMEP_source ( aviation_index ), unit_in , unit_logfile ) calculate_EMEP_source ( offroad_index ) = read_name_logical ( 'calculate_EMEP_source(offroad_index)' , calculate_EMEP_source ( offroad_index ), unit_in , unit_logfile ) calculate_EMEP_source ( waste_index ) = read_name_logical ( 'calculate_EMEP_source(waste_index)' , calculate_EMEP_source ( waste_index ), unit_in , unit_logfile ) calculate_EMEP_source ( livestock_index ) = read_name_logical ( 'calculate_EMEP_source(livestock_index)' , calculate_EMEP_source ( livestock_index ), unit_in , unit_logfile ) calculate_EMEP_source ( other_index ) = read_name_logical ( 'calculate_EMEP_source(other_index)' , calculate_EMEP_source ( other_index ), unit_in , unit_logfile ) !GNFR19 sources. Note nc_index not in the input calculate_EMEP_source ( traffic_gasoline_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_gasoline_index)' , calculate_EMEP_source ( traffic_gasoline_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( traffic_diesel_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_diesel_index)' , calculate_EMEP_source ( traffic_diesel_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( traffic_gas_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_gas_index)' , calculate_EMEP_source ( traffic_gas_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( traffic_nonexhaust_nc_index ) = read_name_logical ( 'calculate_EMEP_source(traffic_nonexhaust_index)' , calculate_EMEP_source ( traffic_nonexhaust_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( publicpower_point_nc_index ) = read_name_logical ( 'calculate_EMEP_source(publicpower_point_index)' , calculate_EMEP_source ( publicpower_point_nc_index ), unit_in , unit_logfile ) calculate_EMEP_source ( publicpower_area_nc_index ) = read_name_logical ( 'calculate_EMEP_source(publicpower_area_index)' , calculate_EMEP_source ( publicpower_area_nc_index ), unit_in , unit_logfile ) !do i_source=1,n_source_index !    if (calculate_source(i_source)) calculate_source(allsource_index)=.true. !enddo !For aggregating proxy emission data to EMEP grids in ascii test routines that no longer exist. Default is false make_EMEP_grid_emission_data ( traffic_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(traffic_index)' , make_EMEP_grid_emission_data ( traffic_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( shipping_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(shipping_index)' , make_EMEP_grid_emission_data ( shipping_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( heating_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(heating_index)' , make_EMEP_grid_emission_data ( heating_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( agriculture_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(agriculture_index)' , make_EMEP_grid_emission_data ( agriculture_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( industry_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(industry_index)' , make_EMEP_grid_emission_data ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources make_EMEP_grid_emission_data ( publicpower_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(publicpower_index)' , make_EMEP_grid_emission_data ( publicpower_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( fugitive_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(fugitive_index)' , make_EMEP_grid_emission_data ( fugitive_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( solvents_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(solvents_index)' , make_EMEP_grid_emission_data ( solvents_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( aviation_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(aviation_index)' , make_EMEP_grid_emission_data ( aviation_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( offroad_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(offroad_index)' , make_EMEP_grid_emission_data ( offroad_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( waste_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(waste_index)' , make_EMEP_grid_emission_data ( waste_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( livestock_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(livestock_index)' , make_EMEP_grid_emission_data ( livestock_index ), unit_in , unit_logfile ) make_EMEP_grid_emission_data ( other_index ) = read_name_logical ( 'make_EMEP_grid_emission_data(other_index)' , make_EMEP_grid_emission_data ( other_index ), unit_in , unit_logfile ) do i_source = 1 , n_source_index if ( make_EMEP_grid_emission_data ( i_source )) make_EMEP_grid_emission_data ( allsource_index ) = . true . enddo !For scaling EMEP concentrations with EMEP/local emission ratio. for testing purposes only. Default is false replace_EMEP_local_with_subgrid_local ( traffic_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(traffic_index)' , replace_EMEP_local_with_subgrid_local ( traffic_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( shipping_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(shipping_index)' , replace_EMEP_local_with_subgrid_local ( shipping_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( heating_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(heating_index)' , replace_EMEP_local_with_subgrid_local ( heating_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( agriculture_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(agriculture_index)' , replace_EMEP_local_with_subgrid_local ( agriculture_index ), unit_in , unit_logfile ) replace_EMEP_local_with_subgrid_local ( industry_index ) = read_name_logical ( 'replace_EMEP_local_with_subgrid_local(industry_index)' , replace_EMEP_local_with_subgrid_local ( industry_index ), unit_in , unit_logfile ) projection_type = read_name_integer ( 'projection_type' , projection_type , unit_in , unit_logfile ) EMEP_projection_type = read_name_integer ( 'EMEP_projection_type' , EMEP_projection_type , unit_in , unit_logfile ) utm_zone = read_name_integer ( 'utm_zone' , utm_zone , unit_in , unit_logfile ) !Present UTM central lon position if not overridden by input utm_lon0 = abs ( utm_zone ) * 6 - 180 - 3 utm_lon0 = read_name_real ( 'utm_lon0' , utm_lon0 , unit_in , unit_logfile ) ltm_lon0 = read_name_real ( 'ltm_lon0' , ltm_lon0 , unit_in , unit_logfile ) !Read the projection attributes for uEMEP if they are available projection_attributes ( 1 ) = read_name_double ( 'projection_attributes(1)' , projection_attributes ( 1 ), unit_in , unit_logfile ) projection_attributes ( 2 ) = read_name_double ( 'projection_attributes(2)' , projection_attributes ( 2 ), unit_in , unit_logfile ) projection_attributes ( 3 ) = read_name_double ( 'projection_attributes(3)' , projection_attributes ( 3 ), unit_in , unit_logfile ) projection_attributes ( 4 ) = read_name_double ( 'projection_attributes(4)' , projection_attributes ( 4 ), unit_in , unit_logfile ) projection_attributes ( 5 ) = read_name_double ( 'projection_attributes(5)' , projection_attributes ( 5 ), unit_in , unit_logfile ) projection_attributes ( 6 ) = read_name_double ( 'projection_attributes(6)' , projection_attributes ( 6 ), unit_in , unit_logfile ) projection_attributes ( 7 ) = read_name_double ( 'projection_attributes(7)' , projection_attributes ( 7 ), unit_in , unit_logfile ) !Read the projection attributes for EMEP if they are available !THese will be reset if EMEP data is read in EMEP_projection_attributes ( 1 ) = read_name_double ( 'EMEP_projection_attributes(1)' , EMEP_projection_attributes ( 1 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 2 ) = read_name_double ( 'EMEP_projection_attributes(2)' , EMEP_projection_attributes ( 2 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 3 ) = read_name_double ( 'EMEP_projection_attributes(3)' , EMEP_projection_attributes ( 3 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 4 ) = read_name_double ( 'EMEP_projection_attributes(4)' , EMEP_projection_attributes ( 4 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 5 ) = read_name_double ( 'EMEP_projection_attributes(5)' , EMEP_projection_attributes ( 5 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 6 ) = read_name_double ( 'EMEP_projection_attributes(6)' , EMEP_projection_attributes ( 6 ), unit_in , unit_logfile ) EMEP_projection_attributes ( 7 ) = read_name_double ( 'EMEP_projection_attributes(7)' , EMEP_projection_attributes ( 7 ), unit_in , unit_logfile ) EMEP_grid_interpolation_flag = read_name_integer ( 'EMEP_grid_interpolation_flag' , EMEP_grid_interpolation_flag , unit_in , unit_logfile ) EMEP_meteo_grid_interpolation_flag = read_name_integer ( 'EMEP_meteo_grid_interpolation_flag' , EMEP_meteo_grid_interpolation_flag , unit_in , unit_logfile ) EMEP_emission_grid_interpolation_flag = read_name_integer ( 'EMEP_emission_grid_interpolation_flag' , EMEP_emission_grid_interpolation_flag , unit_in , unit_logfile ) subgrid_emission_distribution_flag = read_name_logical ( 'subgrid_emission_distribution_flag' , subgrid_emission_distribution_flag , unit_in , unit_logfile ) !Not used EMEP_grid_interpolation_simple_flag = read_name_logical ( 'EMEP_grid_interpolation_simple_flag' , EMEP_grid_interpolation_simple_flag , unit_in , unit_logfile ) EMEP_grid_interpolation_size = read_name_real ( 'EMEP_grid_interpolation_size' , EMEP_grid_interpolation_size , unit_in , unit_logfile ) EMEP_additional_grid_interpolation_size = read_name_real ( 'EMEP_additional_grid_interpolation_size' , EMEP_additional_grid_interpolation_size , unit_in , unit_logfile ) use_downwind_position_flag = read_name_logical ( 'use_downwind_position_flag' , use_downwind_position_flag , unit_in , unit_logfile ) local_subgrid_method_flag = read_name_integer ( 'local_subgrid_method_flag' , local_subgrid_method_flag , unit_in , unit_logfile ) stability_scheme_flag = read_name_integer ( 'stability_scheme_flag' , stability_scheme_flag , unit_in , unit_logfile ) average_zc_h_in_Kz_flag = read_name_logical ( 'average_zc_h_in_Kz_flag' , average_zc_h_in_Kz_flag , unit_in , unit_logfile ) wind_level_flag = read_name_integer ( 'wind_level_flag' , wind_level_flag , unit_in , unit_logfile ) wind_level_integral_flag = read_name_integer ( 'wind_level_integral_flag' , wind_level_flag , unit_in , unit_logfile ) !Default is wind_level_flag no2_chemistry_scheme_flag = read_name_integer ( 'no2_chemistry_scheme_flag' , no2_chemistry_scheme_flag , unit_in , unit_logfile ) no2_background_chemistry_scheme_flag = read_name_integer ( 'no2_background_chemistry_scheme_flag' , no2_background_chemistry_scheme_flag , unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( traffic_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(traffic_index)' , use_emission_positions_for_auto_subgrid_flag ( traffic_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( shipping_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(shipping_index)' , use_emission_positions_for_auto_subgrid_flag ( shipping_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( heating_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(heating_index)' , use_emission_positions_for_auto_subgrid_flag ( heating_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( agriculture_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(agriculture_index)' , use_emission_positions_for_auto_subgrid_flag ( agriculture_index ), unit_in , unit_logfile ) use_emission_positions_for_auto_subgrid_flag ( industry_index ) = read_name_logical ( 'use_emission_positions_for_auto_subgrid_flag(industry_index)' , use_emission_positions_for_auto_subgrid_flag ( industry_index ), unit_in , unit_logfile ) !Set all source index to true if any of the sources are to be auto gridded. allsource_index defines if the routine is called or not do i_source = 1 , n_source_index if ( use_emission_positions_for_auto_subgrid_flag ( i_source ). and . i_source . ne . allsource_index ) use_emission_positions_for_auto_subgrid_flag ( allsource_index ) = . true . enddo !do i_source=1,n_source_index !write(*,*) 'Using auto subgrid for source ',trim(source_file_str(i_source)),use_emission_positions_for_auto_subgrid_flag(i_source) !enddo use_receptor_positions_for_auto_subgrid_flag = read_name_logical ( 'use_receptor_positions_for_auto_subgrid_flag' , use_receptor_positions_for_auto_subgrid_flag , unit_in , unit_logfile ) use_population_positions_for_auto_subgrid_flag = read_name_logical ( 'use_population_positions_for_auto_subgrid_flag' , use_population_positions_for_auto_subgrid_flag , unit_in , unit_logfile ) interpolate_subgrids_flag = read_name_logical ( 'interpolate_subgrids_flag' , interpolate_subgrids_flag , unit_in , unit_logfile ) !use_trajectory_flag(:)=read_name_logical('use_trajectory_flag',use_trajectory_flag(allsource_index),unit_in,unit_logfile) use_trajectory_flag ( shipping_index ) = read_name_logical ( 'use_trajectory_flag(shipping_index)' , use_trajectory_flag ( shipping_index ), unit_in , unit_logfile ) use_trajectory_flag ( traffic_index ) = read_name_logical ( 'use_trajectory_flag(traffic_index)' , use_trajectory_flag ( traffic_index ), unit_in , unit_logfile ) use_trajectory_flag ( heating_index ) = read_name_logical ( 'use_trajectory_flag(heating_index)' , use_trajectory_flag ( heating_index ), unit_in , unit_logfile ) use_trajectory_flag ( agriculture_index ) = read_name_logical ( 'use_trajectory_flag(agriculture_index)' , use_trajectory_flag ( agriculture_index ), unit_in , unit_logfile ) use_trajectory_flag ( industry_index ) = read_name_logical ( 'use_trajectory_flag(industry_index)' , use_trajectory_flag ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources use_trajectory_flag ( publicpower_index ) = read_name_logical ( 'use_trajectory_flag(publicpower_index)' , use_trajectory_flag ( publicpower_index ), unit_in , unit_logfile ) use_trajectory_flag ( fugitive_index ) = read_name_logical ( 'use_trajectory_flag(fugitive_index)' , use_trajectory_flag ( fugitive_index ), unit_in , unit_logfile ) use_trajectory_flag ( solvents_index ) = read_name_logical ( 'use_trajectory_flag(solvents_index)' , use_trajectory_flag ( solvents_index ), unit_in , unit_logfile ) use_trajectory_flag ( aviation_index ) = read_name_logical ( 'use_trajectory_flag(aviation_index)' , use_trajectory_flag ( aviation_index ), unit_in , unit_logfile ) use_trajectory_flag ( offroad_index ) = read_name_logical ( 'use_trajectory_flag(offroad_index)' , use_trajectory_flag ( offroad_index ), unit_in , unit_logfile ) use_trajectory_flag ( waste_index ) = read_name_logical ( 'use_trajectory_flag(waste_index)' , use_trajectory_flag ( waste_index ), unit_in , unit_logfile ) use_trajectory_flag ( livestock_index ) = read_name_logical ( 'use_trajectory_flag(livestock_index)' , use_trajectory_flag ( livestock_index ), unit_in , unit_logfile ) use_trajectory_flag ( other_index ) = read_name_logical ( 'use_trajectory_flag(other_index)' , use_trajectory_flag ( other_index ), unit_in , unit_logfile ) traj_step_scale = read_name_real ( 'traj_step_scale' , traj_step_scale , unit_in , unit_logfile ) calculate_aggregated_shipping_emissions_flag = read_name_logical ( 'calculate_aggregated_shipping_emissions_flag' , calculate_aggregated_shipping_emissions_flag , unit_in , unit_logfile ) use_aggregated_shipping_emissions_flag = read_name_logical ( 'use_aggregated_shipping_emissions_flag' , use_aggregated_shipping_emissions_flag , unit_in , unit_logfile ) calculate_population_exposure_flag = read_name_logical ( 'calculate_population_exposure_flag' , calculate_population_exposure_flag , unit_in , unit_logfile ) !Grid specific parameters integral_subgrid_step = read_name_integer ( 'integral_subgrid_step' , integral_subgrid_step , unit_in , unit_logfile ) !Specify the site grid information subgrid_delta ( x_dim_index ) = read_name_real ( 'subgrid_delta(x_dim_index)' , subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) subgrid_delta ( y_dim_index ) = read_name_real ( 'subgrid_delta(y_dim_index)' , subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) subgrid_min ( x_dim_index ) = read_name_real ( 'subgrid_min(x_dim_index)' , subgrid_min ( x_dim_index ), unit_in , unit_logfile ) subgrid_min ( y_dim_index ) = read_name_real ( 'subgrid_min(y_dim_index)' , subgrid_min ( y_dim_index ), unit_in , unit_logfile ) subgrid_max ( x_dim_index ) = read_name_real ( 'subgrid_max(x_dim_index)' , subgrid_max ( x_dim_index ), unit_in , unit_logfile ) subgrid_max ( y_dim_index ) = read_name_real ( 'subgrid_max(y_dim_index)' , subgrid_max ( y_dim_index ), unit_in , unit_logfile ) !Save the read in grid data. This will be used to select EMEP region and receptor points init_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) init_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) init_subgrid_min ( x_dim_index ) = subgrid_min ( x_dim_index ) init_subgrid_min ( y_dim_index ) = subgrid_min ( y_dim_index ) init_subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) init_subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) !These will probably be set by the input data deposition_subgrid_delta ( x_dim_index ) = read_name_real ( 'deposition_subgrid_delta(x_dim_index)' , deposition_subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) deposition_subgrid_delta ( y_dim_index ) = read_name_real ( 'deposition_subgrid_delta(y_dim_index)' , deposition_subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) landuse_subgrid_delta ( x_dim_index ) = read_name_real ( 'landuse_subgrid_delta(x_dim_index)' , landuse_subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) landuse_subgrid_delta ( y_dim_index ) = read_name_real ( 'landuse_subgrid_delta(y_dim_index)' , landuse_subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) !Specifies the number of subsources for each source. Not used as default is 1 n_subsource ( traffic_index ) = read_name_integer ( 'n_subsource(traffic_index)' , n_subsource ( traffic_index ), unit_in , unit_logfile ) n_subsource ( shipping_index ) = read_name_integer ( 'n_subsource(shipping_index)' , n_subsource ( shipping_index ), unit_in , unit_logfile ) n_subsource ( heating_index ) = read_name_integer ( 'n_subsource(heating_index)' , n_subsource ( heating_index ), unit_in , unit_logfile ) n_subsource ( agriculture_index ) = read_name_integer ( 'n_subsource(agriculture_index)' , n_subsource ( agriculture_index ), unit_in , unit_logfile ) n_subsource ( industry_index ) = read_name_integer ( 'n_subsource(industry_index)' , n_subsource ( industry_index ), unit_in , unit_logfile ) h_emis ( traffic_index , 1 ) = read_name_real ( 'h_emis(traffic_index,1)' , h_emis ( traffic_index , 1 ), unit_in , unit_logfile ) h_emis ( shipping_index , 1 ) = read_name_real ( 'h_emis(shipping_index,1)' , h_emis ( shipping_index , 1 ), unit_in , unit_logfile ) h_emis ( heating_index , 1 ) = read_name_real ( 'h_emis(heating_index,1)' , h_emis ( heating_index , 1 ), unit_in , unit_logfile ) h_emis ( agriculture_index , 1 ) = read_name_real ( 'h_emis(agriculture_index,1)' , h_emis ( agriculture_index , 1 ), unit_in , unit_logfile ) h_emis ( industry_index , 1 ) = read_name_real ( 'h_emis(industry_index,1)' , h_emis ( industry_index , 1 ), unit_in , unit_logfile ) !Additional GNFR sources h_emis ( publicpower_index , 1 ) = read_name_real ( 'h_emis(publicpower_index,1)' , h_emis ( publicpower_index , 1 ), unit_in , unit_logfile ) h_emis ( fugitive_index , 1 ) = read_name_real ( 'h_emis(fugitive_index,1)' , h_emis ( fugitive_index , 1 ), unit_in , unit_logfile ) h_emis ( solvents_index , 1 ) = read_name_real ( 'h_emis(solvents_index,1)' , h_emis ( solvents_index , 1 ), unit_in , unit_logfile ) h_emis ( aviation_index , 1 ) = read_name_real ( 'h_emis(aviation_index,1)' , h_emis ( aviation_index , 1 ), unit_in , unit_logfile ) h_emis ( offroad_index , 1 ) = read_name_real ( 'h_emis(offroad_index,1)' , h_emis ( offroad_index , 1 ), unit_in , unit_logfile ) h_emis ( waste_index , 1 ) = read_name_real ( 'h_emis(waste_index,1)' , h_emis ( waste_index , 1 ), unit_in , unit_logfile ) h_emis ( livestock_index , 1 ) = read_name_real ( 'h_emis(livestock_index,1)' , h_emis ( livestock_index , 1 ), unit_in , unit_logfile ) h_emis ( other_index , 1 ) = read_name_real ( 'h_emis(other_index,1)' , h_emis ( other_index , 1 ), unit_in , unit_logfile ) !These second subsources do not exist but still possible to implement h_emis ( traffic_index , 2 ) = read_name_real ( 'h_emis(traffic_index,2)' , h_emis ( traffic_index , 2 ), unit_in , unit_logfile ) h_emis ( shipping_index , 2 ) = read_name_real ( 'h_emis(shipping_index,2)' , h_emis ( shipping_index , 2 ), unit_in , unit_logfile ) h_emis ( heating_index , 2 ) = read_name_real ( 'h_emis(heating_index,2)' , h_emis ( heating_index , 2 ), unit_in , unit_logfile ) h_emis ( agriculture_index , 2 ) = read_name_real ( 'h_emis(agriculture_index,2)' , h_emis ( agriculture_index , 2 ), unit_in , unit_logfile ) h_emis ( industry_index , 2 ) = read_name_real ( 'h_emis(industry_index,2)' , h_emis ( industry_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( traffic_index , 1 ) = read_name_real ( 'sig_y_00(traffic_index,1)' , sig_y_00 ( traffic_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( shipping_index , 1 ) = read_name_real ( 'sig_y_00(shipping_index,1)' , sig_y_00 ( shipping_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( heating_index , 1 ) = read_name_real ( 'sig_y_00(heating_index,1)' , sig_y_00 ( heating_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( agriculture_index , 1 ) = read_name_real ( 'sig_y_00(agriculture_index,1)' , sig_y_00 ( agriculture_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( industry_index , 1 ) = read_name_real ( 'sig_y_00(industry_index,1)' , sig_y_00 ( industry_index , 1 ), unit_in , unit_logfile ) !Additional GNFR sources sig_y_00 ( publicpower_index , 1 ) = read_name_real ( 'sig_y_00(publicpower_index,1)' , sig_y_00 ( publicpower_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( fugitive_index , 1 ) = read_name_real ( 'sig_y_00(fugitive_index,1)' , sig_y_00 ( fugitive_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( solvents_index , 1 ) = read_name_real ( 'sig_y_00(solvents_index,1)' , sig_y_00 ( solvents_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( aviation_index , 1 ) = read_name_real ( 'sig_y_00(aviation_index,1)' , sig_y_00 ( aviation_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( offroad_index , 1 ) = read_name_real ( 'sig_y_00(offroad_index,1)' , sig_y_00 ( offroad_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( waste_index , 1 ) = read_name_real ( 'sig_y_00(waste_index,1)' , sig_y_00 ( waste_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( livestock_index , 1 ) = read_name_real ( 'sig_y_00(livestock_index,1)' , sig_y_00 ( livestock_index , 1 ), unit_in , unit_logfile ) sig_y_00 ( other_index , 1 ) = read_name_real ( 'sig_y_00(other_index,1)' , sig_y_00 ( other_index , 1 ), unit_in , unit_logfile ) !These second subsources do not exist but still possible to implement sig_y_00 ( traffic_index , 2 ) = read_name_real ( 'sig_y_00(traffic_index,2)' , sig_y_00 ( traffic_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( shipping_index , 2 ) = read_name_real ( 'sig_y_00(shipping_index,2)' , sig_y_00 ( shipping_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( heating_index , 2 ) = read_name_real ( 'sig_y_00(heating_index,2)' , sig_y_00 ( heating_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( agriculture_index , 2 ) = read_name_real ( 'sig_y_00(agriculture_index,2)' , sig_y_00 ( agriculture_index , 2 ), unit_in , unit_logfile ) sig_y_00 ( industry_index , 2 ) = read_name_real ( 'sig_y_00(industry_index,2)' , sig_y_00 ( industry_index , 2 ), unit_in , unit_logfile ) !This scales the subgrid size to give to give sig_y_0. Optimal value is 0.8 so sig_y_0=0.8/2*delta_y sigy_0_subgid_width_scale = read_name_real ( 'sigy_0_subgid_width_scale' , sigy_0_subgid_width_scale , unit_in , unit_logfile ) sig_z_00 ( traffic_index , 1 ) = read_name_real ( 'sig_z_00(traffic_index,1)' , sig_z_00 ( traffic_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( shipping_index , 1 ) = read_name_real ( 'sig_z_00(shipping_index,1)' , sig_z_00 ( shipping_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( heating_index , 1 ) = read_name_real ( 'sig_z_00(heating_index,1)' , sig_z_00 ( heating_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( agriculture_index , 1 ) = read_name_real ( 'sig_z_00(agriculture_index,1)' , sig_z_00 ( agriculture_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( industry_index , 1 ) = read_name_real ( 'sig_z_00(industry_index,1)' , sig_z_00 ( industry_index , 1 ), unit_in , unit_logfile ) !Additional GNFR sources sig_z_00 ( publicpower_index , 1 ) = read_name_real ( 'sig_z_00(publicpower_index,1)' , sig_z_00 ( publicpower_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( fugitive_index , 1 ) = read_name_real ( 'sig_z_00(fugitive_index,1)' , sig_z_00 ( fugitive_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( solvents_index , 1 ) = read_name_real ( 'sig_z_00(solvents_index,1)' , sig_z_00 ( solvents_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( aviation_index , 1 ) = read_name_real ( 'sig_z_00(aviation_index,1)' , sig_z_00 ( aviation_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( offroad_index , 1 ) = read_name_real ( 'sig_z_00(offroad_index,1)' , sig_z_00 ( offroad_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( waste_index , 1 ) = read_name_real ( 'sig_z_00(waste_index,1)' , sig_z_00 ( waste_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( livestock_index , 1 ) = read_name_real ( 'sig_z_00(livestock_index,1)' , sig_z_00 ( livestock_index , 1 ), unit_in , unit_logfile ) sig_z_00 ( other_index , 1 ) = read_name_real ( 'sig_z_00(other_index,1)' , sig_z_00 ( other_index , 1 ), unit_in , unit_logfile ) !These second subsources do not exist but still possible to implement sig_z_00 ( traffic_index , 2 ) = read_name_real ( 'sig_z_00(traffic_index,2)' , sig_z_00 ( traffic_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( shipping_index , 2 ) = read_name_real ( 'sig_z_00(shipping_index,2)' , sig_z_00 ( shipping_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( heating_index , 2 ) = read_name_real ( 'sig_z_00(heating_index,2)' , sig_z_00 ( heating_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( agriculture_index , 2 ) = read_name_real ( 'sig_z_00(agriculture_index,2)' , sig_z_00 ( agriculture_index , 2 ), unit_in , unit_logfile ) sig_z_00 ( industry_index , 2 ) = read_name_real ( 'sig_z_00(industry_index,2)' , sig_z_00 ( industry_index , 2 ), unit_in , unit_logfile ) !Read output grid path for all data pathname_output_grid = read_name_char ( 'pathname_output_grid' , pathname_output_grid , unit_in , unit_logfile ) filename_date_output_grid = read_name_char ( 'filename_date_output_grid' , filename_date_output_grid , unit_in , unit_logfile ) !Read in file names. Only 2 choices for most file types pathname_rl ( 1 ) = read_name_char ( 'pathname_rl(1)' , pathname_rl ( 1 ), unit_in , unit_logfile ) pathname_rl ( 2 ) = read_name_char ( 'pathname_rl(2)' , pathname_rl ( 2 ), unit_in , unit_logfile ) filename_rl ( 1 ) = read_name_char ( 'filename_rl(1)' , filename_rl ( 1 ), unit_in , unit_logfile ) filename_rl ( 2 ) = read_name_char ( 'filename_rl(2)' , filename_rl ( 2 ), unit_in , unit_logfile ) pathname_mrl ( 1 ) = read_name_char ( 'pathname_mrl(1)' , pathname_mrl ( 1 ), unit_in , unit_logfile ) pathname_mrl ( 2 ) = read_name_char ( 'pathname_mrl(2)' , pathname_mrl ( 2 ), unit_in , unit_logfile ) pathname_mrl ( 3 ) = read_name_char ( 'pathname_mrl(3)' , pathname_mrl ( 3 ), unit_in , unit_logfile ) pathname_mrl ( 4 ) = read_name_char ( 'pathname_mrl(4)' , pathname_mrl ( 4 ), unit_in , unit_logfile ) pathname_mrl ( 5 ) = read_name_char ( 'pathname_mrl(5)' , pathname_mrl ( 5 ), unit_in , unit_logfile ) pathname_mrl ( 6 ) = read_name_char ( 'pathname_mrl(6)' , pathname_mrl ( 6 ), unit_in , unit_logfile ) pathname_mrl ( 7 ) = read_name_char ( 'pathname_mrl(7)' , pathname_mrl ( 7 ), unit_in , unit_logfile ) pathname_mrl ( 8 ) = read_name_char ( 'pathname_mrl(8)' , pathname_mrl ( 8 ), unit_in , unit_logfile ) pathname_mrl ( 9 ) = read_name_char ( 'pathname_mrl(9)' , pathname_mrl ( 9 ), unit_in , unit_logfile ) pathname_mrl ( 10 ) = read_name_char ( 'pathname_mrl(10)' , pathname_mrl ( 10 ), unit_in , unit_logfile ) filename_mrl ( 1 ) = read_name_char ( 'filename_mrl(1)' , filename_mrl ( 1 ), unit_in , unit_logfile ) filename_mrl ( 2 ) = read_name_char ( 'filename_mrl(2)' , filename_mrl ( 2 ), unit_in , unit_logfile ) filename_mrl ( 3 ) = read_name_char ( 'filename_mrl(3)' , filename_mrl ( 3 ), unit_in , unit_logfile ) filename_mrl ( 4 ) = read_name_char ( 'filename_mrl(4)' , filename_mrl ( 4 ), unit_in , unit_logfile ) filename_mrl ( 5 ) = read_name_char ( 'filename_mrl(5)' , filename_mrl ( 5 ), unit_in , unit_logfile ) filename_mrl ( 6 ) = read_name_char ( 'filename_mrl(6)' , filename_mrl ( 6 ), unit_in , unit_logfile ) filename_mrl ( 7 ) = read_name_char ( 'filename_mrl(7)' , filename_mrl ( 7 ), unit_in , unit_logfile ) filename_mrl ( 8 ) = read_name_char ( 'filename_mrl(8)' , filename_mrl ( 8 ), unit_in , unit_logfile ) filename_mrl ( 9 ) = read_name_char ( 'filename_mrl(9)' , filename_mrl ( 9 ), unit_in , unit_logfile ) filename_mrl ( 10 ) = read_name_char ( 'filename_mrl(10)' , filename_mrl ( 10 ), unit_in , unit_logfile ) num_multiple_roadlink_files = read_name_integer ( 'num_multiple_roadlink_files' , num_multiple_roadlink_files , unit_in , unit_logfile ) pathname_EMEP ( 1 ) = read_name_char ( 'pathname_EMEP(1)' , pathname_EMEP ( 1 ), unit_in , unit_logfile ) pathname_EMEP ( 2 ) = read_name_char ( 'pathname_EMEP(2)' , pathname_EMEP ( 2 ), unit_in , unit_logfile ) pathname_EMEP ( 3 ) = read_name_char ( 'pathname_EMEP(3)' , pathname_EMEP ( 3 ), unit_in , unit_logfile ) pathname_EMEP ( 4 ) = read_name_char ( 'pathname_EMEP(4)' , pathname_EMEP ( 4 ), unit_in , unit_logfile ) filename_EMEP ( 1 ) = read_name_char ( 'filename_EMEP(1)' , filename_EMEP ( 1 ), unit_in , unit_logfile ) filename_EMEP ( 2 ) = read_name_char ( 'filename_EMEP(2)' , filename_EMEP ( 2 ), unit_in , unit_logfile ) filename_EMEP ( 3 ) = read_name_char ( 'filename_EMEP(3)' , filename_EMEP ( 3 ), unit_in , unit_logfile ) filename_EMEP ( 4 ) = read_name_char ( 'filename_EMEP(4)' , filename_EMEP ( 4 ), unit_in , unit_logfile ) original_pathname_EMEP = pathname_EMEP original_filename_EMEP = filename_EMEP pathname_ship ( 1 ) = read_name_char ( 'pathname_ship(1)' , pathname_ship ( 1 ), unit_in , unit_logfile ) pathname_ship ( 2 ) = read_name_char ( 'pathname_ship(2)' , pathname_ship ( 2 ), unit_in , unit_logfile ) filename_ship ( 1 ) = read_name_char ( 'filename_ship(1)' , filename_ship ( 1 ), unit_in , unit_logfile ) filename_ship ( 2 ) = read_name_char ( 'filename_ship(2)' , filename_ship ( 2 ), unit_in , unit_logfile ) pathname_agriculture ( 1 ) = read_name_char ( 'pathname_agriculture(1)' , pathname_agriculture ( 1 ), unit_in , unit_logfile ) pathname_agriculture ( 2 ) = read_name_char ( 'pathname_agriculture(2)' , pathname_agriculture ( 2 ), unit_in , unit_logfile ) filename_agriculture ( 1 ) = read_name_char ( 'filename_agriculture(1)' , filename_agriculture ( 1 ), unit_in , unit_logfile ) filename_agriculture ( 2 ) = read_name_char ( 'filename_agriculture(2)' , filename_agriculture ( 2 ), unit_in , unit_logfile ) pathname_emission_rivm ( 1 ) = read_name_char ( 'pathname_emission_rivm(1)' , pathname_emission_rivm ( 1 ), unit_in , unit_logfile ) pathname_emission_rivm ( 2 ) = read_name_char ( 'pathname_emission_rivm(2)' , pathname_emission_rivm ( 2 ), unit_in , unit_logfile ) filename_emission_rivm ( 1 ) = read_name_char ( 'filename_emission_rivm(1)' , filename_emission_rivm ( 1 ), unit_in , unit_logfile ) filename_emission_rivm ( 2 ) = read_name_char ( 'filename_emission_rivm(2)' , filename_emission_rivm ( 2 ), unit_in , unit_logfile ) pathname_industry ( 1 ) = read_name_char ( 'pathname_industry(1)' , pathname_industry ( 1 ), unit_in , unit_logfile ) pathname_industry ( 2 ) = read_name_char ( 'pathname_industry(2)' , pathname_industry ( 2 ), unit_in , unit_logfile ) filename_industry ( 1 ) = read_name_char ( 'filename_industry(1)' , filename_industry ( 1 ), unit_in , unit_logfile ) filename_industry ( 2 ) = read_name_char ( 'filename_industry(2)' , filename_industry ( 2 ), unit_in , unit_logfile ) pathname_heating ( dwelling_index ) = read_name_char ( 'pathname_heating(dwelling_index)' , pathname_heating ( dwelling_index ), unit_in , unit_logfile ) pathname_heating ( population_index ) = read_name_char ( 'pathname_heating(population_index)' , pathname_heating ( population_index ), unit_in , unit_logfile ) filename_heating ( dwelling_index ) = read_name_char ( 'filename_heating(dwelling_index)' , filename_heating ( dwelling_index ), unit_in , unit_logfile ) filename_heating ( population_index ) = read_name_char ( 'filename_heating(population_index)' , filename_heating ( population_index ), unit_in , unit_logfile ) pathname_heating ( RWC_heating_index ) = read_name_char ( 'pathname_heating(RWC_heating_index)' , pathname_heating ( RWC_heating_index ), unit_in , unit_logfile ) filename_heating ( RWC_heating_index ) = read_name_char ( 'filename_heating(RWC_heating_index)' , filename_heating ( RWC_heating_index ), unit_in , unit_logfile ) pathname_population ( dwelling_index ) = read_name_char ( 'pathname_population(dwelling_index)' , pathname_population ( dwelling_index ), unit_in , unit_logfile ) pathname_population ( population_index ) = read_name_char ( 'pathname_population(population_index)' , pathname_population ( population_index ), unit_in , unit_logfile ) pathname_population ( establishment_index ) = read_name_char ( 'pathname_population(establishment_index)' , pathname_population ( establishment_index ), unit_in , unit_logfile ) pathname_population ( school_index ) = read_name_char ( 'pathname_population(school_index)' , pathname_population ( school_index ), unit_in , unit_logfile ) pathname_population ( kindergaten_index ) = read_name_char ( 'pathname_population(kindergaten_index)' , pathname_population ( kindergaten_index ), unit_in , unit_logfile ) pathname_population ( home_index ) = read_name_char ( 'pathname_population(home_index)' , pathname_population ( home_index ), unit_in , unit_logfile ) pathname_population ( municipality_index ) = read_name_char ( 'pathname_population(municipality_index)' , pathname_population ( municipality_index ), unit_in , unit_logfile ) filename_population ( dwelling_index ) = read_name_char ( 'filename_population(dwelling_index)' , filename_population ( dwelling_index ), unit_in , unit_logfile ) filename_population ( population_index ) = read_name_char ( 'filename_population(population_index)' , filename_population ( population_index ), unit_in , unit_logfile ) filename_population ( establishment_index ) = read_name_char ( 'filename_population(establishment_index)' , filename_population ( establishment_index ), unit_in , unit_logfile ) filename_population ( school_index ) = read_name_char ( 'filename_population(school_index)' , filename_population ( school_index ), unit_in , unit_logfile ) filename_population ( kindergaten_index ) = read_name_char ( 'filename_population(kindergaten_index)' , filename_population ( kindergaten_index ), unit_in , unit_logfile ) filename_population ( home_index ) = read_name_char ( 'filename_population(home_index)' , filename_population ( home_index ), unit_in , unit_logfile ) filename_population ( municipality_index ) = read_name_char ( 'filename_population(municipality_index)' , filename_population ( municipality_index ), unit_in , unit_logfile ) pathname_receptor = read_name_char ( 'pathname_receptor' , pathname_receptor , unit_in , unit_logfile ) filename_receptor = read_name_char ( 'filename_receptor' , filename_receptor , unit_in , unit_logfile ) pathname_timeprofile = read_name_char ( 'pathname_timeprofile' , pathname_timeprofile , unit_in , unit_logfile ) filename_timeprofile = read_name_char ( 'filename_timeprofile' , filename_timeprofile , unit_in , unit_logfile ) population_data_type = read_name_integer ( 'population_data_type' , population_data_type , unit_in , unit_logfile ) FF_min_dispersion = read_name_real ( 'FF_min_dispersion' , FF_min_dispersion , unit_in , unit_logfile ) emission_timeprofile_hour_shift = read_name_integer ( 'emission_timeprofile_hour_shift' , emission_timeprofile_hour_shift , unit_in , unit_logfile ) use_last_meteo_in_dispersion = read_name_logical ( 'use_last_meteo_in_dispersion' , use_last_meteo_in_dispersion , unit_in , unit_logfile ) use_meandering_in_dispersion = read_name_logical ( 'use_meandering_in_dispersion' , use_meandering_in_dispersion , unit_in , unit_logfile ) use_traffic_for_sigma0_flag = read_name_logical ( 'use_traffic_for_sigma0_flag' , use_traffic_for_sigma0_flag , unit_in , unit_logfile ) !use_traffic_for_minFF_flag=read_name_logical('use_traffic_for_minFF_flag',use_traffic_for_minFF_flag,unit_in,unit_logfile) use_alternative_meteorology_flag = read_name_logical ( 'use_alternative_meteorology_flag' , use_alternative_meteorology_flag , unit_in , unit_logfile ) ustar_min = read_name_real ( 'ustar_min' , ustar_min , unit_in , unit_logfile ) hmix_min = read_name_real ( 'hmix_min' , hmix_min , unit_in , unit_logfile ) hmix_max = read_name_real ( 'hmix_max' , hmix_max , unit_in , unit_logfile ) use_alternative_z0_flag = read_name_logical ( 'use_alternative_z0_flag' , use_alternative_z0_flag , unit_in , unit_logfile ) alternative_meteorology_type = read_name_char ( 'alternative_meteorology_type' , alternative_meteorology_type , unit_in , unit_logfile ) !Read emission factors for traffic emission_factor ( nox_index , traffic_index ,:) = read_name_real ( 'emission_factor(nox_index,traffic_index,:)' , emission_factor ( nox_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( nox_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(nox_index,traffic_index,1)' , emission_factor ( nox_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( nox_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(nox_index,traffic_index,2)' , emission_factor ( nox_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( no2_index , traffic_index ,:) = read_name_real ( 'emission_factor(no2_index,traffic_index,:)' , emission_factor ( no2_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( no2_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(no2_index,traffic_index,1)' , emission_factor ( no2_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( no2_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(no2_index,traffic_index,2)' , emission_factor ( no2_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( pm25_index , traffic_index ,:) = read_name_real ( 'emission_factor(pm25_index,traffic_index,:)' , emission_factor ( pm25_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm25_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(pm25_index,traffic_index,1)' , emission_factor ( pm25_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm25_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(pm25_index,traffic_index,2)' , emission_factor ( pm25_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( pm10_index , traffic_index ,:) = read_name_real ( 'emission_factor(pm10_index,traffic_index,:)' , emission_factor ( pm10_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm10_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(pm10_index,traffic_index,1)' , emission_factor ( pm10_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pm10_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(pm10_index,traffic_index,2)' , emission_factor ( pm10_index , traffic_index , 2 ), unit_in , unit_logfile ) emission_factor ( pmex_index , traffic_index ,:) = read_name_real ( 'emission_factor(pmex_index,traffic_index,:)' , emission_factor ( pmex_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pmex_index , traffic_index , 1 ) = read_name_real ( 'emission_factor(pmex_index,traffic_index,1)' , emission_factor ( pmex_index , traffic_index , 1 ), unit_in , unit_logfile ) emission_factor ( pmex_index , traffic_index , 2 ) = read_name_real ( 'emission_factor(pmex_index,traffic_index,2)' , emission_factor ( pmex_index , traffic_index , 2 ), unit_in , unit_logfile ) ratio_truck_car_emission ( nox_index ) = read_name_real ( 'ratio_truck_car_emission(nox_index)' , ratio_truck_car_emission ( nox_index ), unit_in , unit_logfile ) ratio_truck_car_emission ( pm25_index ) = read_name_real ( 'ratio_truck_car_emission(pm25_index)' , ratio_truck_car_emission ( pm25_index ), unit_in , unit_logfile ) ratio_truck_car_emission ( pm10_index ) = read_name_real ( 'ratio_truck_car_emission(pm10_index)' , ratio_truck_car_emission ( pm10_index ), unit_in , unit_logfile ) !NO2 ratio does not do anything but is included for possible future changes ratio_truck_car_emission ( no2_index ) = read_name_real ( 'ratio_truck_car_emission(no2_index)' , ratio_truck_car_emission ( no2_index ), unit_in , unit_logfile ) z_rec = read_name_real ( 'z_rec' , z_rec ( allsource_index , 1 ), unit_in , unit_logfile ) replace_z0 = read_name_real ( 'replace_z0' , replace_z0 , unit_in , unit_logfile ) replace_invL = read_name_real ( 'replace_invL' , replace_invL , unit_in , unit_logfile ) replace_hmix = read_name_real ( 'replace_hmix' , replace_hmix , unit_in , unit_logfile ) FF_scale = read_name_real ( 'FF_scale' , FF_scale , unit_in , unit_logfile ) FF10_offset = read_name_real ( 'FF10_offset' , FF10_offset , unit_in , unit_logfile ) DD_offset = read_name_real ( 'DD_offset' , DD_offset , unit_in , unit_logfile ) J_scale = read_name_real ( 'J_scale' , J_scale , unit_in , unit_logfile ) save_netcdf_file_flag = read_name_logical ( 'save_netcdf_file_flag' , save_netcdf_file_flag , unit_in , unit_logfile ) save_netcdf_receptor_flag = read_name_logical ( 'save_netcdf_receptor_flag' , save_netcdf_receptor_flag , unit_in , unit_logfile ) save_netcdf_fraction_as_contribution_flag = read_name_logical ( 'save_netcdf_fraction_as_contribution_flag' , save_netcdf_fraction_as_contribution_flag , unit_in , unit_logfile ) calculate_tiling_flag = read_name_logical ( 'calculate_tiling_flag' , calculate_tiling_flag , unit_in , unit_logfile ) calculate_region_tiling_flag = read_name_logical ( 'calculate_region_tiling_flag' , calculate_region_tiling_flag , unit_in , unit_logfile ) pathname_region_id = read_name_char ( 'pathname_region_id' , pathname_region_id , unit_in , unit_logfile ) filename_region_id = read_name_char ( 'filename_region_id' , filename_region_id , unit_in , unit_logfile ) region_name = read_name_char ( 'region_name' , region_name , unit_in , unit_logfile ) region_id = read_name_integer ( 'region_id' , region_id , unit_in , unit_logfile ) region_index = read_name_integer ( 'region_index' , region_index , unit_in , unit_logfile ) region_subgrid_delta = read_name_real ( 'region_subgrid_delta' , region_subgrid_delta , unit_in , unit_logfile ) use_region_select_and_mask_flag = read_name_logical ( 'use_region_select_and_mask_flag' , use_region_select_and_mask_flag , unit_in , unit_logfile ) max_interpolation_subgrid_size = read_name_real ( 'max_interpolation_subgrid_size' , max_interpolation_subgrid_size , unit_in , unit_logfile ) pathname_tiles = read_name_char ( 'pathname_tiles' , pathname_tiles , unit_in , unit_logfile ) filename_tiles = read_name_char ( 'filename_tiles' , filename_tiles , unit_in , unit_logfile ) tile_tag = read_name_char ( 'tile_tag' , tile_tag , unit_in , unit_logfile ) save_tile_tag = read_name_char ( 'save_tile_tag' , save_tile_tag , unit_in , unit_logfile ) use_NORTRIP_emission_data = read_name_logical ( 'use_NORTRIP_emission_data' , use_NORTRIP_emission_data , unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( nox_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(nox_index)' , use_NORTRIP_emission_pollutant ( nox_index ), unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( pm10_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(pm10_index)' , use_NORTRIP_emission_pollutant ( pm10_index ), unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( pm25_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(pm25_index)' , use_NORTRIP_emission_pollutant ( pm25_index ), unit_in , unit_logfile ) use_NORTRIP_emission_pollutant ( pmex_index ) = read_name_logical ( 'use_NORTRIP_emission_pollutant(pmex_index)' , use_NORTRIP_emission_pollutant ( pmex_index ), unit_in , unit_logfile ) use_RWC_emission_data = read_name_logical ( 'use_RWC_emission_data' , use_RWC_emission_data , unit_in , unit_logfile ) HDD_threshold_value = read_name_integer ( 'HDD_threshold_value' , HDD_threshold_value , unit_in , unit_logfile ) DMT_min_value = read_name_real ( 'DMT_min_value' , DMT_min_value , unit_in , unit_logfile ) inpath_region_heating_scaling = read_name_char ( 'inpath_region_heating_scaling' , inpath_region_heating_scaling , unit_in , unit_logfile ) infile_region_heating_scaling = read_name_char ( 'infile_region_heating_scaling' , infile_region_heating_scaling , unit_in , unit_logfile ) integral_subgrid_delta_ref = read_name_real ( 'integral_subgrid_delta_ref' , integral_subgrid_delta_ref , unit_in , unit_logfile ) pathname_rl_change = read_name_char ( 'pathname_rl_change' , pathname_rl_change , unit_in , unit_logfile ) filename_rl_change = read_name_char ( 'filename_rl_change' , filename_rl_change , unit_in , unit_logfile ) forecast_hour_str = read_name_char ( 'forecast_hour_str' , forecast_hour_str , unit_in , unit_logfile ) NORTRIP_hour_str = read_name_char ( 'NORTRIP_hour_str' , NORTRIP_hour_str , unit_in , unit_logfile ) include_o3_in_aqi_index = read_name_logical ( 'include_o3_in_aqi_index' , include_o3_in_aqi_index , unit_in , unit_logfile ) n_kz_iterations = read_name_integer ( 'n_kz_iterations' , n_kz_iterations , unit_in , unit_logfile ) read_weekly_shipping_data_flag = read_name_logical ( 'read_weekly_shipping_data_flag' , read_weekly_shipping_data_flag , unit_in , unit_logfile ) read_monthly_and_daily_shipping_data_flag = read_name_logical ( 'read_monthly_and_daily_shipping_data_flag' , read_monthly_and_daily_shipping_data_flag , unit_in , unit_logfile ) use_tunnel_emissions_flag = read_name_logical ( 'use_tunnel_emissions_flag' , use_tunnel_emissions_flag , unit_in , unit_logfile ) use_tunnel_deposition_flag = read_name_logical ( 'use_tunnel_deposition_flag' , use_tunnel_deposition_flag , unit_in , unit_logfile ) ventilation_factor = read_name_real ( 'ventilation_factor' , ventilation_factor , unit_in , unit_logfile ) min_ADT_ventilation_factor = read_name_real ( 'min_ADT_ventilation_factor' , min_ADT_ventilation_factor , unit_in , unit_logfile ) min_length_ventilation_factor = read_name_real ( 'min_length_ventilation_factor' , min_length_ventilation_factor , unit_in , unit_logfile ) windspeed_tunnel = read_name_real ( 'windspeed_tunnel' , windspeed_tunnel , unit_in , unit_logfile ) save_emissions_for_EMEP ( traffic_index ) = read_name_logical ( 'save_emissions_for_EMEP(traffic_index)' , save_emissions_for_EMEP ( traffic_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( shipping_index ) = read_name_logical ( 'save_emissions_for_EMEP(shipping_index)' , save_emissions_for_EMEP ( shipping_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( industry_index ) = read_name_logical ( 'save_emissions_for_EMEP(industry_index)' , save_emissions_for_EMEP ( industry_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( heating_index ) = read_name_logical ( 'save_emissions_for_EMEP(heating_index)' , save_emissions_for_EMEP ( heating_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( agriculture_index ) = read_name_logical ( 'save_emissions_for_EMEP(agriculture_index)' , save_emissions_for_EMEP ( agriculture_index ), unit_in , unit_logfile ) !Additional GNFR sources save_emissions_for_EMEP ( publicpower_index ) = read_name_logical ( 'save_emissions_for_EMEP(publicpower_index)' , save_emissions_for_EMEP ( publicpower_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( fugitive_index ) = read_name_logical ( 'save_emissions_for_EMEP(fugitive_index)' , save_emissions_for_EMEP ( fugitive_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( solvents_index ) = read_name_logical ( 'save_emissions_for_EMEP(solvents_index)' , save_emissions_for_EMEP ( solvents_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( aviation_index ) = read_name_logical ( 'save_emissions_for_EMEP(aviation_index)' , save_emissions_for_EMEP ( aviation_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( offroad_index ) = read_name_logical ( 'save_emissions_for_EMEP(offroad_index)' , save_emissions_for_EMEP ( offroad_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( waste_index ) = read_name_logical ( 'save_emissions_for_EMEP(waste_index)' , save_emissions_for_EMEP ( waste_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( livestock_index ) = read_name_logical ( 'save_emissions_for_EMEP(livestock_index)' , save_emissions_for_EMEP ( livestock_index ), unit_in , unit_logfile ) save_emissions_for_EMEP ( other_index ) = read_name_logical ( 'save_emissions_for_EMEP(other_index)' , save_emissions_for_EMEP ( other_index ), unit_in , unit_logfile ) !Set all source index to true if any of the sources are to be saved. allsource_index defines if the routine is called or not do i_source = 1 , n_source_index if ( save_emissions_for_EMEP ( i_source )) save_emissions_for_EMEP ( allsource_index ) = . true . enddo pathname_emissions_for_EMEP = read_name_char ( 'pathname_emissions_for_EMEP' , pathname_emissions_for_EMEP , unit_in , unit_logfile ) save_emissions_start_index = read_name_integer ( 'save_emissions_start_index' , save_emissions_start_index , unit_in , unit_logfile ) save_emissions_end_index = read_name_integer ( 'save_emissions_end_index' , save_emissions_end_index , unit_in , unit_logfile ) save_emissions_for_EMEP_projection = read_name_char ( 'save_emissions_for_EMEP_projection' , save_emissions_for_EMEP_projection , unit_in , unit_logfile ) save_emissions_for_EMEP_region = read_name_char ( 'save_emissions_for_EMEP_region' , save_emissions_for_EMEP_region , unit_in , unit_logfile ) save_compounds = read_name_logical ( 'save_compounds' , save_compounds , unit_in , unit_logfile ) save_source_contributions = read_name_logical ( 'save_source_contributions' , save_source_contributions , unit_in , unit_logfile ) save_emep_source_contributions = read_name_logical ( 'save_emep_source_contributions' , save_emep_source_contributions , unit_in , unit_logfile ) save_emep_additional_source_contributions = read_name_logical ( 'save_emep_additional_source_contributions' , save_emep_additional_source_contributions , unit_in , unit_logfile ) save_total_source_contributions = read_name_logical ( 'save_total_source_contributions' , save_total_source_contributions , unit_in , unit_logfile ) save_local_source_contributions_from_in_region = read_name_logical ( 'save_local_source_contributions_from_in_region' , save_local_source_contributions_from_in_region , unit_in , unit_logfile ) save_semilocal_source_contributions_from_in_region = read_name_logical ( 'save_semilocal_source_contributions_from_in_region' , save_semilocal_source_contributions_from_in_region , unit_in , unit_logfile ) save_total_source_contributions_from_in_region = read_name_logical ( 'save_total_source_contributions_from_in_region' , save_total_source_contributions_from_in_region , unit_in , unit_logfile ) save_no2_source_contributions = read_name_logical ( 'save_no2_source_contributions' , save_no2_source_contributions , unit_in , unit_logfile ) save_o3_source_contributions = read_name_logical ( 'save_o3_source_contributions' , save_o3_source_contributions , unit_in , unit_logfile ) save_wind_vectors = read_name_logical ( 'save_wind_vectors' , save_wind_vectors , unit_in , unit_logfile ) save_other_meteo = read_name_logical ( 'save_other_meteo' , save_other_meteo , unit_in , unit_logfile ) save_emep_original = read_name_logical ( 'save_emep_original' , save_emep_original , unit_in , unit_logfile ) save_emissions = read_name_logical ( 'save_emissions' , save_emissions , unit_in , unit_logfile ) save_for_chemistry = read_name_logical ( 'save_for_chemistry' , save_for_chemistry , unit_in , unit_logfile ) save_population = read_name_logical ( 'save_population' , save_population , unit_in , unit_logfile ) save_aqi = read_name_logical ( 'save_aqi' , save_aqi , unit_in , unit_logfile ) save_emep_species = read_name_logical ( 'save_emep_species' , save_emep_species , unit_in , unit_logfile ) save_deposition = read_name_logical ( 'save_deposition' , save_deposition , unit_in , unit_logfile ) save_seasalt = read_name_logical ( 'save_seasalt' , save_seasalt , unit_in , unit_logfile ) lowest_stable_L = read_name_real ( 'lowest_stable_L' , lowest_stable_L , unit_in , unit_logfile ) lowest_unstable_L = read_name_real ( 'lowest_unstable_L' , lowest_unstable_L , unit_in , unit_logfile ) tunnel_sig_z_00 = read_name_real ( 'tunnel_sig_z_00' , tunnel_sig_z_00 , unit_in , unit_logfile ) bridge_h_emis = read_name_real ( 'bridge_h_emis' , bridge_h_emis , unit_in , unit_logfile ) !Input variable names for meteo data read from EMEP var_name_nc ( hmix_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(hmix_nc_index)' , var_name_nc ( hmix_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( u10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(u10_nc_index)' , var_name_nc ( u10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( v10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(v10_nc_index)' , var_name_nc ( v10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( FF10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(FF10_nc_index)' , var_name_nc ( FF10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( ugrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(ugrid_nc_index)' , var_name_nc ( ugrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( vgrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(vgrid_nc_index)' , var_name_nc ( vgrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( FFgrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(FFgrid_nc_index)' , var_name_nc ( FFgrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( inv_FFgrid_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(inv_FFgrid_nc_index)' , var_name_nc ( inv_FFgrid_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( inv_FF10_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(inv_FF10_nc_index)' , var_name_nc ( inv_FF10_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( kz_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(kz_nc_index)' , var_name_nc ( kz_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( ustar_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(ustar_nc_index)' , var_name_nc ( ustar_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( logz0_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(logz0_nc_index)' , var_name_nc ( logz0_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( invL_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(invL_nc_index)' , var_name_nc ( invL_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( ZTOP_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(ZTOP_nc_index)' , var_name_nc ( ZTOP_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(t2m_nc_index)' , var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( precip_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(precip_nc_index)' , var_name_nc ( precip_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( J_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(J_nc_index)' , var_name_nc ( J_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) var_name_nc ( phi_nc_index , all_nc_index , allsource_nc_index ) = read_name_char ( 'var_name_nc(phi_nc_index)' , var_name_nc ( phi_nc_index , all_nc_index , allsource_nc_index ), unit_in , unit_logfile ) save_netcdf_average_flag = read_name_logical ( 'save_netcdf_average_flag' , save_netcdf_average_flag , unit_in , unit_logfile ) use_traffic_nox_emission_temperature_dependency = read_name_logical ( 'use_traffic_nox_emission_temperature_dependency' , use_traffic_nox_emission_temperature_dependency , unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_temperature ( 1 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_temperature(1)' , traffic_nox_emission_temperature_ref_temperature ( 1 ), unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_temperature ( 2 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_temperature(2)' , traffic_nox_emission_temperature_ref_temperature ( 2 ), unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_scaling ( 1 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_scaling(1)' , traffic_nox_emission_temperature_ref_scaling ( 1 ), unit_in , unit_logfile ) traffic_nox_emission_temperature_ref_scaling ( 2 ) = read_name_real ( 'traffic_nox_emission_temperature_ref_scaling(2)' , traffic_nox_emission_temperature_ref_scaling ( 2 ), unit_in , unit_logfile ) calculate_deposition_flag = read_name_logical ( 'calculate_deposition_flag' , calculate_deposition_flag , unit_in , unit_logfile ) calculate_source_depletion_flag = read_name_logical ( 'calculate_source_depletion_flag' , calculate_source_depletion_flag , unit_in , unit_logfile ) read_landuse_flag = read_name_logical ( 'read_landuse_flag' , read_landuse_flag , unit_in , unit_logfile ) use_plume_dispersion_deposition_flag = read_name_logical ( 'use_plume_dispersion_deposition_flag' , use_plume_dispersion_deposition_flag , unit_in , unit_logfile ) pathname_landuse = read_name_char ( 'pathname_landuse' , pathname_landuse , unit_in , unit_logfile ) filename_landuse = read_name_char ( 'filename_landuse' , filename_landuse , unit_in , unit_logfile ) adjust_wetdepo_integral_to_lowest_layer_flag = read_name_logical ( 'adjust_wetdepo_integral_to_lowest_layer_flag' , adjust_wetdepo_integral_to_lowest_layer_flag , unit_in , unit_logfile ) auto_adjustment_for_summertime = read_name_logical ( 'auto_adjustment_for_summertime' , auto_adjustment_for_summertime , unit_in , unit_logfile ) use_EMEP_surface_ozone_flag = read_name_logical ( 'use_EMEP_surface_ozone_flag' , use_EMEP_surface_ozone_flag , unit_in , unit_logfile ) use_EMEP_surface_compounds_flag = read_name_logical ( 'use_EMEP_surface_compounds_flag' , use_EMEP_surface_compounds_flag , unit_in , unit_logfile ) use_water_in_EMEP_surface_pm_flag = read_name_logical ( 'use_water_in_EMEP_surface_pm_flag' , use_water_in_EMEP_surface_pm_flag , unit_in , unit_logfile ) save_compounds_as_ascii = read_name_logical ( 'save_compounds_as_ascii' , save_compounds_as_ascii , unit_in , unit_logfile ) use_GNFR_emissions_from_EMEP_flag = read_name_logical ( 'use_GNFR_emissions_from_EMEP_flag' , use_GNFR_emissions_from_EMEP_flag , unit_in , unit_logfile ) use_GNFR19_emissions_from_EMEP_flag = read_name_logical ( 'use_GNFR19_emissions_from_EMEP_flag' , use_GNFR19_emissions_from_EMEP_flag , unit_in , unit_logfile ) use_alphabetic_GNFR_emissions_from_EMEP_flag = read_name_logical ( 'use_alphabetic_GNFR_emissions_from_EMEP_flag' , use_alphabetic_GNFR_emissions_from_EMEP_flag , unit_in , unit_logfile ) use_emission_naming_template_flag = read_name_logical ( 'use_emission_naming_template_flag' , use_emission_naming_template_flag , unit_in , unit_logfile ) emission_naming_template_str = read_name_char ( 'emission_naming_template_str' , emission_naming_template_str , unit_in , unit_logfile ) read_OSM_roadlink_data_flag = read_name_logical ( 'read_OSM_roadlink_data_flag' , read_OSM_roadlink_data_flag , unit_in , unit_logfile ) no_header_roadlink_data_flag = read_name_logical ( 'no_header_roadlink_data_flag' , no_header_roadlink_data_flag , unit_in , unit_logfile ) EMEP_surface_level_nc = read_name_integer ( 'EMEP_surface_level_nc' , EMEP_surface_level_nc , unit_in , unit_logfile ) EMEP_surface_level_nc_2 = read_name_integer ( 'EMEP_surface_level_nc_2' , EMEP_surface_level_nc_2 , unit_in , unit_logfile ) limit_industry_delta = read_name_real ( 'limit_industry_delta' , limit_industry_delta , unit_in , unit_logfile ) limit_shipping_delta = read_name_real ( 'limit_shipping_delta' , limit_shipping_delta , unit_in , unit_logfile ) limit_heating_delta = read_name_real ( 'limit_heating_delta' , limit_heating_delta , unit_in , unit_logfile ) limit_population_delta = read_name_real ( 'limit_population_delta' , limit_population_delta , unit_in , unit_logfile ) use_user_specified_sectors_flag = read_name_logical ( 'use_user_specified_sectors_flag' , use_user_specified_sectors_flag , unit_in , unit_logfile ) if ( use_user_specified_sectors_flag ) then uEMEP_to_EMEP_replace_sector ( traffic_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(traffic_index)' , uEMEP_to_EMEP_replace_sector ( traffic_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( shipping_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(shipping_index)' , uEMEP_to_EMEP_replace_sector ( shipping_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( agriculture_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(agriculture_index)' , uEMEP_to_EMEP_replace_sector ( agriculture_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( heating_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(heating_index)' , uEMEP_to_EMEP_replace_sector ( heating_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( industry_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(industry_index)' , uEMEP_to_EMEP_replace_sector ( industry_index ), unit_in , unit_logfile ) !Additional GNFR sources uEMEP_to_EMEP_replace_sector ( publicpower_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(publicpower_index)' , uEMEP_to_EMEP_replace_sector ( publicpower_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( fugitive_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(fugitive_index)' , uEMEP_to_EMEP_replace_sector ( fugitive_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( solvents_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(solvents_index)' , uEMEP_to_EMEP_replace_sector ( solvents_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( aviation_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(aviation_index)' , uEMEP_to_EMEP_replace_sector ( aviation_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( offroad_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(offroad_index)' , uEMEP_to_EMEP_replace_sector ( offroad_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( waste_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(waste_index)' , uEMEP_to_EMEP_replace_sector ( waste_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( livestock_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(livestock_index)' , uEMEP_to_EMEP_replace_sector ( livestock_index ), unit_in , unit_logfile ) uEMEP_to_EMEP_replace_sector ( other_index ) = read_name_integer ( 'uEMEP_to_EMEP_replace_sector(other_index)' , uEMEP_to_EMEP_replace_sector ( other_index ), unit_in , unit_logfile ) endif EMEP_emission_aggregation_period = read_name_real ( 'EMEP_emission_aggregation_period' , EMEP_emission_aggregation_period , unit_in , unit_logfile ) read_population_from_netcdf_flag = read_name_logical ( 'read_population_from_netcdf_flag' , read_population_from_netcdf_flag , unit_in , unit_logfile ) read_population_from_netcdf_local_flag = read_name_logical ( 'read_population_from_netcdf_local_flag' , read_population_from_netcdf_flag , unit_in , unit_logfile ) auto_select_OSM_country_flag = read_name_logical ( 'auto_select_OSM_country_flag' , auto_select_OSM_country_flag , unit_in , unit_logfile ) pathname_boundingbox = read_name_char ( 'pathname_boundingbox' , pathname_boundingbox , unit_in , unit_logfile ) filename_boundingbox = read_name_char ( 'filename_boundingbox' , filename_boundingbox , unit_in , unit_logfile ) select_country_by_name = read_name_char ( 'select_country_by_name' , select_country_by_name , unit_in , unit_logfile ) select_latlon_centre_domain_position_flag = read_name_logical ( 'select_latlon_centre_domain_position_flag' , select_latlon_centre_domain_position_flag , unit_in , unit_logfile ) select_lat_centre_position = read_name_real ( 'select_lat_centre_position' , select_lat_centre_position , unit_in , unit_logfile ) select_lon_centre_position = read_name_real ( 'select_lon_centre_position' , select_lon_centre_position , unit_in , unit_logfile ) select_domain_width_EW_km = read_name_real ( 'select_domain_width_EW_km' , select_domain_width_EW_km , unit_in , unit_logfile ) select_domain_height_NS_km = read_name_real ( 'select_domain_height_NS_km' , select_domain_height_NS_km , unit_in , unit_logfile ) osm_adt_power_scale = read_name_real ( 'osm_adt_power_scale' , osm_adt_power_scale , unit_in , unit_logfile ) romberg_parameters ( 1 ) = read_name_real ( 'romberg_parameters(1)' , romberg_parameters ( 1 ), unit_in , unit_logfile ) romberg_parameters ( 2 ) = read_name_real ( 'romberg_parameters(2)' , romberg_parameters ( 2 ), unit_in , unit_logfile ) romberg_parameters ( 3 ) = read_name_real ( 'romberg_parameters(3)' , romberg_parameters ( 3 ), unit_in , unit_logfile ) SRM_parameters ( 1 ) = read_name_real ( 'SRM_parameters(1)' , SRM_parameters ( 1 ), unit_in , unit_logfile ) !beta SRM_parameters ( 2 ) = read_name_real ( 'SRM_parameters(2)' , SRM_parameters ( 2 ), unit_in , unit_logfile ) !K SRM_parameters ( 3 ) = read_name_real ( 'SRM_parameters(3)' , SRM_parameters ( 3 ), unit_in , unit_logfile ) !F sig_y_scaling_factor = read_name_real ( 'sig_y_scaling_factor' , sig_y_scaling_factor , unit_in , unit_logfile ) read_shipping_from_netcdf_flag = read_name_logical ( 'read_shipping_from_netcdf_flag' , read_shipping_from_netcdf_flag , unit_in , unit_logfile ) min_proxy_emission_shipping_value = read_name_real ( 'min_proxy_emission_shipping_value' , min_proxy_emission_shipping_value , unit_in , unit_logfile ) population_power_scale = read_name_real ( 'population_power_scale' , population_power_scale , unit_in , unit_logfile ) H_emep = read_name_real ( 'H_emep' , H_emep , unit_in , unit_logfile ) !Allow the user to change the EMEP PM used for nonlocal contribution. !Will be overridden by use_EMEP_surface_compounds_flag and use_water_in_EMEP_surface_pm_flag if they are set to true comp_name_nc ( pm10_nc_index ) = read_name_char ( 'comp_name_nc(pm10_nc_index)' , comp_name_nc ( pm10_nc_index ), unit_in , unit_logfile ) comp_name_nc ( pm25_nc_index ) = read_name_char ( 'comp_name_nc(pm25_nc_index)' , comp_name_nc ( pm25_nc_index ), unit_in , unit_logfile ) comp_name_nc ( o3_nc_index ) = read_name_char ( 'comp_name_nc(o3_nc_index)' , comp_name_nc ( o3_nc_index ), unit_in , unit_logfile ) comp_name_nc ( no2_nc_index ) = read_name_char ( 'comp_name_nc(no2_nc_index)' , comp_name_nc ( no2_nc_index ), unit_in , unit_logfile ) comp_name_nc ( nox_nc_index ) = read_name_char ( 'comp_name_nc(nox_nc_index)' , comp_name_nc ( nox_nc_index ), unit_in , unit_logfile ) comp_name_nc ( nh3_nc_index ) = read_name_char ( 'comp_name_nc(nh3_nc_index)' , comp_name_nc ( nh3_nc_index ), unit_in , unit_logfile ) comp_name_nc ( nh4_nc_index ) = read_name_char ( 'comp_name_nc(nh4_nc_index)' , comp_name_nc ( nh4_nc_index ), unit_in , unit_logfile ) comp_name_nc ( pmex_nc_index ) = read_name_char ( 'comp_name_nc(pmex_nc_index)' , comp_name_nc ( pmex_nc_index ), unit_in , unit_logfile ) comp_name_nc ( co_nc_index ) = read_name_char ( 'comp_name_nc(co_nc_index)' , comp_name_nc ( co_nc_index ), unit_in , unit_logfile ) comp_name_nc ( bap_nc_index ) = read_name_char ( 'comp_name_nc(bap_nc_index)' , comp_name_nc ( bap_nc_index ), unit_in , unit_logfile ) comp_name_nc ( c6h6_nc_index ) = read_name_char ( 'comp_name_nc(c6h6_nc_index)' , comp_name_nc ( c6h6_nc_index ), unit_in , unit_logfile ) comp_name_nc ( so2_nc_index ) = read_name_char ( 'comp_name_nc(so2_nc_index)' , comp_name_nc ( so2_nc_index ), unit_in , unit_logfile ) comp_name_nc ( somo35_nc_index ) = read_name_char ( 'comp_name_nc(somo35_nc_index)' , comp_name_nc ( somo35_nc_index ), unit_in , unit_logfile ) comp_name_nc ( comax_nc_index ) = read_name_char ( 'comp_name_nc(comax_nc_index)' , comp_name_nc ( comax_nc_index ), unit_in , unit_logfile ) comp_name_nc ( o3max_nc_index ) = read_name_char ( 'comp_name_nc(o3max_nc_index)' , comp_name_nc ( o3max_nc_index ), unit_in , unit_logfile ) comp_name_nc ( o3_26th_nc_index ) = read_name_char ( 'comp_name_nc(o3_26th_nc_index)' , comp_name_nc ( o3_26th_nc_index ), unit_in , unit_logfile ) read_RWC_file_with_extra_HDD = read_name_logical ( 'read_RWC_file_with_extra_HDD' , read_RWC_file_with_extra_HDD , unit_in , unit_logfile ) read_RWC_file_with_extra_HDD_and_height = read_name_logical ( 'read_RWC_file_with_extra_HDD_and_height' , read_RWC_file_with_extra_HDD_and_height , unit_in , unit_logfile ) !Allows a scaling of EMEP input ozone. For testing. comp_scale_nc ( o3_nc_index ) = read_name_real ( 'comp_scale_nc(o3_nc_index)' , comp_scale_nc ( o3_nc_index ), unit_in , unit_logfile ) comp_scale_nc ( nox_nc_index ) = read_name_real ( 'comp_scale_nc(nox_nc_index)' , comp_scale_nc ( nox_nc_index ), unit_in , unit_logfile ) comp_scale_nc ( no2_nc_index ) = read_name_real ( 'comp_scale_nc(no2_nc_index)' , comp_scale_nc ( no2_nc_index ), unit_in , unit_logfile ) use_alternative_traveltime_weighting = read_name_logical ( 'use_alternative_traveltime_weighting' , use_alternative_traveltime_weighting , unit_in , unit_logfile ) traveltime_power = read_name_real ( 'traveltime_power' , traveltime_power , unit_in , unit_logfile ) traveltime_scaling = read_name_real ( 'traveltime_scaling' , traveltime_scaling , unit_in , unit_logfile ) use_straightline_traveltime_distance = read_name_logical ( 'use_straightline_traveltime_distance' , use_straightline_traveltime_distance , unit_in , unit_logfile ) !Name of the netcdf variable read for population or dwelling proxy var_name_population_nc ( population_nc_index ) = read_name_char ( 'var_name_population_nc(population_nc_index)' , var_name_population_nc ( population_nc_index ), unit_in , unit_logfile ) var_name_population_nc ( dwelling_nc_index ) = read_name_char ( 'var_name_population_nc(dwelling_nc_index)' , var_name_population_nc ( dwelling_nc_index ), unit_in , unit_logfile ) f_no2_emep = read_name_real ( 'f_no2_emep' , f_no2_emep , unit_in , unit_logfile ) limit_emep_grid_interpolation_region_to_calculation_region = read_name_logical ( 'limit_emep_grid_interpolation_region_to_calculation_region' , limit_emep_grid_interpolation_region_to_calculation_region , unit_in , unit_logfile ) use_local_fraction_naming_template_flag = read_name_logical ( 'use_local_fraction_naming_template_flag' , use_local_fraction_naming_template_flag , unit_in , unit_logfile ) use_local_fraction_grid_size_in_template_flag = read_name_logical ( 'use_local_fraction_grid_size_in_template_flag' , use_local_fraction_grid_size_in_template_flag , unit_in , unit_logfile ) local_fraction_grid_size ( 1 ) = read_name_integer ( 'local_fraction_grid_size(1)' , local_fraction_grid_size ( 1 ), unit_in , unit_logfile ) local_fraction_grid_size ( 2 ) = read_name_integer ( 'local_fraction_grid_size(2)' , local_fraction_grid_size ( 2 ), unit_in , unit_logfile ) local_fraction_grid_size ( 3 ) = read_name_integer ( 'local_fraction_grid_size(3)' , local_fraction_grid_size ( 3 ), unit_in , unit_logfile ) n_local_fraction_grids = read_name_integer ( 'n_local_fraction_grids' , n_local_fraction_grids , unit_in , unit_logfile ) local_fraction_naming_template_str = read_name_char ( 'local_fraction_naming_template_str' , local_fraction_naming_template_str , unit_in , unit_logfile ) local_fraction_grid_for_EMEP_grid_interpolation = read_name_integer ( 'local_fraction_grid_for_EMEP_grid_interpolation' , local_fraction_grid_for_EMEP_grid_interpolation , unit_in , unit_logfile ) local_fraction_grid_for_EMEP_additional_grid_interpolation = read_name_integer ( 'local_fraction_grid_for_EMEP_additional_grid_interpolation' , local_fraction_grid_for_EMEP_additional_grid_interpolation , unit_in , unit_logfile ) save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag = read_name_logical ( 'save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag' , save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag , unit_in , unit_logfile ) n_var_av = read_name_integer ( 'n_var_av' , n_var_av , unit_in , unit_logfile ) finished_filename = read_name_char ( 'finished_filename' , finished_filename , unit_in , unit_logfile ) finished_subpath = read_name_char ( 'finished_subpath' , finished_subpath , unit_in , unit_logfile ) use_annual_mean_pdf_chemistry_correction = read_name_logical ( 'use_annual_mean_pdf_chemistry_correction' , use_annual_mean_pdf_chemistry_correction , unit_in , unit_logfile ) quick_annual_mean_pdf_chemistry_correction = read_name_logical ( 'quick_annual_mean_pdf_chemistry_correction' , quick_annual_mean_pdf_chemistry_correction , unit_in , unit_logfile ) ox_sigma_ratio_pdf = read_name_real ( 'ox_sigma_ratio_pdf' , ox_sigma_ratio_pdf , unit_in , unit_logfile ) nox_sigma_ratio_pdf = read_name_real ( 'nox_sigma_ratio_pdf' , nox_sigma_ratio_pdf , unit_in , unit_logfile ) min_bin_pdf = read_name_real ( 'min_bin_pdf' , min_bin_pdf , unit_in , unit_logfile ) max_bin_pdf = read_name_real ( 'max_bin_pdf' , max_bin_pdf , unit_in , unit_logfile ) log10_step_bin_pdf = read_name_real ( 'log10_step_bin_pdf' , log10_step_bin_pdf , unit_in , unit_logfile ) use_landuse_as_proxy = read_name_logical ( 'use_landuse_as_proxy' , use_landuse_as_proxy , unit_in , unit_logfile ) read_rivm_landuse_flag = read_name_logical ( 'read_rivm_landuse_flag' , read_rivm_landuse_flag , unit_in , unit_logfile ) var_name_landuse_nc ( num_var_landuse_nc ) = read_name_char ( 'var_name_landuse_nc' , var_name_landuse_nc ( num_var_landuse_nc ), unit_in , unit_logfile ) use_rivm_agricuture_emission_data = read_name_logical ( 'use_rivm_agricuture_emission_data' , use_rivm_agricuture_emission_data , unit_in , unit_logfile ) read_subgrid_emission_data = read_name_logical ( 'read_subgrid_emission_data' , read_subgrid_emission_data , unit_in , unit_logfile ) use_rivm_subgrid_emission_format = read_name_logical ( 'use_rivm_subgrid_emission_format' , use_rivm_subgrid_emission_format , unit_in , unit_logfile ) !Read landuse weighting this may take some time !Source input is numbered as GNFR13 in input but is placed in the uEMEP source sectors do i_source = 1 , n_source_index do i_landuse = 1 , n_clc_landuse_index write ( UNIT = a_str , FMT =* ) convert_uEMEP_to_GNFR_sector_index ( i_source ) write ( UNIT = b_str , FMT =* ) i_landuse temp_str = 'landuse_proxy_weighting(' // trim ( adjustl ( a_str )) // ',' // trim ( adjustl ( b_str )) // ')' !write(*,*) i_source,trim(temp_str) landuse_proxy_weighting ( i_source , i_landuse ) = read_name_real ( trim ( temp_str ), landuse_proxy_weighting ( i_source , i_landuse ), unit_in , unit_logfile ) enddo enddo !Scale EMEP emission by sector !Source input is numbered as GNFR13 in input but is placed in the uEMEP source sectors do i_source = 1 , n_source_index write ( UNIT = a_str , FMT =* ) convert_uEMEP_to_GNFR_sector_index ( i_source ) temp_str = 'scale_GNFR_emission_source(' // trim ( adjustl ( a_str )) // ')' !write(*,*) i_source,trim(temp_str) scale_GNFR_emission_source ( i_source ) = read_name_real ( trim ( temp_str ), scale_GNFR_emission_source ( i_source ), unit_in , unit_logfile ) enddo !Save original EMEP values for save_EMEP_somo35 = read_name_logical ( 'save_EMEP_somo35' , save_EMEP_somo35 , unit_in , unit_logfile ) save_EMEP_comax = read_name_logical ( 'save_EMEP_comax' , save_EMEP_comax , unit_in , unit_logfile ) save_EMEP_o3max = read_name_logical ( 'save_EMEP_o3max' , save_EMEP_o3max , unit_in , unit_logfile ) save_EMEP_o3_26th = read_name_logical ( 'save_EMEP_o3_26th' , save_EMEP_o3_26th , unit_in , unit_logfile ) save_EMEP_so2 = read_name_logical ( 'save_EMEP_so2' , save_EMEP_so2 , unit_in , unit_logfile ) !Read subgrid receptor offset. This is for testing purposes only and applies only to the receptor subgrids subgrid_receptor_offset ( x_dim_index ) = read_name_real ( 'subgrid_receptor_offset(x_dim_index)' , subgrid_receptor_offset ( x_dim_index ), unit_in , unit_logfile ) subgrid_receptor_offset ( y_dim_index ) = read_name_real ( 'subgrid_receptor_offset(y_dim_index)' , subgrid_receptor_offset ( y_dim_index ), unit_in , unit_logfile ) derive_SOA_from_other_species = read_name_logical ( 'derive_SOA_from_other_species' , derive_SOA_from_other_species , unit_in , unit_logfile ) Kz_scheme = read_name_integer ( 'Kz_scheme' , Kz_scheme , unit_in , unit_logfile ) use_phi_for_invL = read_name_logical ( 'use_phi_for_invL' , use_phi_for_invL , unit_in , unit_logfile ) z_invL = read_name_real ( 'z_invL' , z_invL , unit_in , unit_logfile ) save_emission_subgrid_min ( x_dim_index ) = read_name_real ( 'save_emission_subgrid_min(x_dim_index)' , save_emission_subgrid_min ( x_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_min ( y_dim_index ) = read_name_real ( 'save_emission_subgrid_min(y_dim_index)' , save_emission_subgrid_min ( y_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_delta ( x_dim_index ) = read_name_real ( 'save_emission_subgrid_delta(x_dim_index)' , save_emission_subgrid_delta ( x_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_delta ( y_dim_index ) = read_name_real ( 'save_emission_subgrid_delta(y_dim_index)' , save_emission_subgrid_delta ( y_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_dim ( x_dim_index ) = read_name_integer ( 'save_emission_subgrid_dim(x_dim_index)' , save_emission_subgrid_dim ( x_dim_index ), unit_in , unit_logfile ) save_emission_subgrid_dim ( y_dim_index ) = read_name_integer ( 'save_emission_subgrid_dim(y_dim_index)' , save_emission_subgrid_dim ( y_dim_index ), unit_in , unit_logfile ) trace_emissions_from_in_region = read_name_logical ( 'trace_emissions_from_in_region' , trace_emissions_from_in_region , unit_in , unit_logfile ) calc_grid_vertical_average_concentration_annual_flag = read_name_logical ( 'calc_grid_vertical_average_concentration_annual_flag' , calc_grid_vertical_average_concentration_annual_flag , unit_in , unit_logfile ) wind_level_zc_flag = read_name_logical ( 'wind_level_zc_flag' , wind_level_zc_flag , unit_in , unit_logfile ) use_alternative_ppm_variable_for_lf = read_name_logical ( 'use_alternative_ppm_variable_for_lf' , use_alternative_ppm_variable_for_lf , unit_in , unit_logfile ) alternative_ppm_variable_for_lf_dim = read_name_integer ( 'alternative_ppm_variable_for_lf_dim' , alternative_ppm_variable_for_lf_dim , unit_in , unit_logfile ) var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index ) = read_name_char ( 'var_name_nc(conc_nc_index,pm25_nc_index,extrasource_nc_index)' , var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index ), unit_in , unit_logfile ) var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index ) = read_name_char ( 'var_name_nc(conc_nc_index,pmco_nc_index,extrasource_nc_index)' , var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index ), unit_in , unit_logfile ) save_emep_OP_species = read_name_logical ( 'save_emep_OP_species' , save_emep_OP_species , unit_in , unit_logfile ) ! Read configs added for the nonlocal from-in-region method pathname_region_mask = read_name_char ( 'pathname_region_mask' , pathname_region_mask , unit_in , unit_logfile ) filename_region_mask = read_name_char ( 'filename_region_mask' , filename_region_mask , unit_in , unit_logfile ) varname_region_mask = read_name_char ( 'varname_region_mask' , varname_region_mask , unit_in , unit_logfile ) close ( unit_in ) enddo !End configuration file number loop !The rest below was inside the file loop before. Have moved to outside now. Hope that works! !Call some error traps if ( len ( trim ( pathname_output_grid )). eq . 0 ) then write ( unit_logfile , '(A)' ) 'WARNING: No output path given in configuration file. Stopping' stop endif if ( local_subgrid_method_flag == 1 . and . trace_emissions_from_in_region ) then write ( unit_logfile , '(A)' ) 'trace_emissions_from_in_region must be false when local_subgrid_method_flag is 1, since it is not possible to trace emission origin when EMEP concentrations are directly redistributed. Stopping' stop end if !Find the correct compound index based on the compound string do i = 1 , n_pollutant_nc_index if ( trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )). eq . trim ( input_comp_name )) then compound_index = i pollutant_index = i write ( unit_logfile , * ) 'Selected pollutant: ' , trim ( input_comp_name ), i endif enddo !Replace some of the strings with the date_str. Do this twice in case there are two occurences of it in a string do i = 1 , 2 pathname_EMEP ( 1 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 1 )) pathname_EMEP ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 2 )) pathname_EMEP ( 3 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 3 )) pathname_EMEP ( 4 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_EMEP ( 4 )) filename_EMEP ( 1 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 1 )) filename_EMEP ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 2 )) filename_EMEP ( 3 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 3 )) filename_EMEP ( 4 ) = replace_string_char ( config_date_str , replacement_date_str , filename_EMEP ( 4 )) pathname_output_grid = replace_string_char ( config_date_str , replacement_date_str , pathname_output_grid ) filename_date_output_grid = replace_string_char ( config_date_str , replacement_date_str , filename_date_output_grid ) !NORTRIP file and path name pathname_rl ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , pathname_rl ( 2 )) filename_rl ( 2 ) = replace_string_char ( config_date_str , replacement_date_str , filename_rl ( 2 )) pathname_EMEP ( 1 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 1 )) pathname_EMEP ( 2 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 2 )) pathname_EMEP ( 3 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 3 )) pathname_EMEP ( 4 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_EMEP ( 4 )) filename_EMEP ( 1 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 1 )) filename_EMEP ( 2 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 2 )) filename_EMEP ( 3 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 3 )) filename_EMEP ( 4 ) = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_EMEP ( 4 )) pathname_output_grid = replace_string_char ( forecast_hour_str , replacement_hour_str , pathname_output_grid ) filename_date_output_grid = replace_string_char ( forecast_hour_str , replacement_hour_str , filename_date_output_grid ) !NORTRIP file and path name pathname_rl ( 2 ) = replace_string_char ( NORTRIP_hour_str , NORTRIP_replacement_hour_str , pathname_rl ( 2 )) filename_rl ( 2 ) = replace_string_char ( NORTRIP_hour_str , NORTRIP_replacement_hour_str , filename_rl ( 2 )) enddo !Replace date in the output file if required, 3 times for yyyy mm dd format_temp = 'yyyymmdd' call datestr_to_date ( config_date_str , format_temp , a ) !write (unit_logfile,'(2A)') ' Updating output path from: ',trim(pathname_output_grid) do i = 1 , 3 call date_to_datestr_bracket ( a , pathname_output_grid , pathname_output_grid ) call date_to_datestr_bracket ( a , filename_date_output_grid , filename_date_output_grid ) call date_to_datestr_bracket ( a , pathname_EMEP ( 1 ), pathname_EMEP ( 1 )) call date_to_datestr_bracket ( a , pathname_EMEP ( 2 ), pathname_EMEP ( 2 )) call date_to_datestr_bracket ( a , pathname_EMEP ( 3 ), pathname_EMEP ( 3 )) call date_to_datestr_bracket ( a , pathname_EMEP ( 4 ), pathname_EMEP ( 4 )) call date_to_datestr_bracket ( a , pathname_rl ( 1 ), pathname_rl ( 1 )) call date_to_datestr_bracket ( a , pathname_rl ( 2 ), pathname_rl ( 2 )) call date_to_datestr_bracket ( a , filename_EMEP ( 1 ), filename_EMEP ( 1 )) call date_to_datestr_bracket ( a , filename_EMEP ( 2 ), filename_EMEP ( 2 )) call date_to_datestr_bracket ( a , filename_EMEP ( 3 ), filename_EMEP ( 3 )) call date_to_datestr_bracket ( a , filename_EMEP ( 4 ), filename_EMEP ( 4 )) call date_to_datestr_bracket ( a , filename_rl ( 1 ), filename_rl ( 1 )) call date_to_datestr_bracket ( a , filename_rl ( 2 ), filename_rl ( 2 )) call date_to_datestr_bracket ( a , pathname_emissions_for_EMEP , pathname_emissions_for_EMEP ) enddo !write (unit_logfile,'(2A)') ' Updating output path to:   ',trim(pathname_output_grid) !write (unit_logfile,'(2A)') ' Updating output file to:   ',trim(pathname_EMEP(1)) !Specify the yesterday date string and replace it if found. Identified wiht a square bracket !call datestr_to_date(config_date_str,format_temp,a) datenum_temp = date_to_number ( a , ref_year_EMEP ) datenum_temp = datenum_temp - 1. call number_to_date ( datenum_temp , a , ref_year_EMEP ) call date_to_datestr ( a , format_temp , yesterday_date_str ) write ( unit_logfile , '(2a)' ) 'Todays date string: ' , trim ( config_date_str ) write ( unit_logfile , '(2a)' ) 'Yesterdays date string: ' , trim ( yesterday_date_str ) do i = 1 , 3 call date_to_datestr_squarebracket ( a , pathname_output_grid , pathname_output_grid ) call date_to_datestr_squarebracket ( a , filename_date_output_grid , filename_date_output_grid ) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 1 ), pathname_EMEP ( 1 )) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 2 ), pathname_EMEP ( 2 )) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 3 ), pathname_EMEP ( 3 )) call date_to_datestr_squarebracket ( a , pathname_EMEP ( 4 ), pathname_EMEP ( 4 )) call date_to_datestr_squarebracket ( a , pathname_rl ( 1 ), pathname_rl ( 1 )) call date_to_datestr_squarebracket ( a , pathname_rl ( 2 ), pathname_rl ( 2 )) enddo do i = 1 , 2 pathname_EMEP ( 1 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 1 )) pathname_EMEP ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 2 )) pathname_EMEP ( 3 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 3 )) pathname_EMEP ( 4 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_EMEP ( 4 )) filename_EMEP ( 1 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 1 )) filename_EMEP ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 2 )) filename_EMEP ( 3 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 3 )) filename_EMEP ( 4 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_EMEP ( 4 )) pathname_output_grid = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_output_grid ) filename_date_output_grid = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_date_output_grid ) !NORTRIP file and path name pathname_rl ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , pathname_rl ( 2 )) filename_rl ( 2 ) = replace_string_char ( yesterday_date_str , replacement_yesterday_date_str , filename_rl ( 2 )) enddo !write(*,*) trim(filename_EMEP(3)) !write(*,*) trim(pathname_EMEP(3)) !Place tile_tag in front of file_tag if it has been read if ( tile_tag . ne . '' ) then file_tag = trim ( file_tag ) // '_' // trim ( tile_tag ) endif end subroutine uEMEP_read_config !---------------------------------------------------------------------- function replace_string_char ( replace_str , match_str , read_str ) !Finds a match_str in read_str and replaces it with replace_str to give a new version of read_str implicit none character ( 256 ) replace_string_char character ( * ) match_str , replace_str , read_str character ( 256 ) temp_str1 , temp_str2 integer index_start , index_stop replace_string_char = read_str index_start = index ( read_str , trim ( match_str )) if ( index_start . ne . 0 ) then index_stop = index_start + len ( trim ( match_str )) temp_str1 = read_str ( 1 : index_start - 1 ) temp_str2 = read_str ( index_stop : len ( read_str )) replace_string_char = trim ( temp_str1 ) // trim ( replace_str ) // trim ( temp_str2 ) endif !write(*,'(A)') trim(replace_string_char) end function replace_string_char !---------------------------------------------------------------------- end module read_config","tags":"","loc":"sourcefile/uemep_read_config.f90.html"},{"title":"uEMEP_set_subgrids.f90 – uEMEP","text":"Source Code module set_subgrids use uemep_configuration use uEMEP_definitions use utility_functions , only : ll2utm , ll2ltm use mod_lambert_projection , only : LL2LAEA implicit none private public :: uEMEP_set_subgrids , uEMEP_set_subgrid_select_latlon_centre contains subroutine uEMEP_set_subgrids () ! Local variables integer :: i real :: dim_check ( 2 ) ! In the case of interpolation and auto subgridding we need to extend the domain by dx and dy to get the different grids to fit ! Assume the maximum is 1 km if ( use_emission_positions_for_auto_subgrid_flag ( allsource_index )) then ! Check that it is divisable by the largest grid size dim_check ( x_dim_index ) = mod (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )), max_interpolation_subgrid_size ) dim_check ( y_dim_index ) = mod (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )), max_interpolation_subgrid_size ) if ( dim_check ( x_dim_index ) . eq . 0 ) then subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) + subgrid_delta ( x_dim_index ) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to x grid max: ' , subgrid_delta ( x_dim_index ) else subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) + ( max_interpolation_subgrid_size - dim_check ( x_dim_index ) + subgrid_delta ( x_dim_index )) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to x grid max: ' , ( max_interpolation_subgrid_size - dim_check ( x_dim_index ) + subgrid_delta ( x_dim_index )) end if if ( dim_check ( x_dim_index ) . eq . 0 ) then subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) + subgrid_delta ( y_dim_index ) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to y grid max: ' , subgrid_delta ( y_dim_index ) else subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) + ( max_interpolation_subgrid_size - dim_check ( y_dim_index ) + subgrid_delta ( y_dim_index )) write ( unit_logfile , '(A,f12.2)' ) 'Setting subgrids for auto emission gridding. Adding to y grid max: ' , ( max_interpolation_subgrid_size - dim_check ( y_dim_index ) + subgrid_delta ( y_dim_index )) end if end if ! Reset min and max with the buffer and calculate dimensions subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) ! Set all integral subgrids relative to the target subgrid if ( integral_subgrid_delta_ref . eq . 0. ) then integral_subgrid_delta = subgrid_delta * integral_subgrid_step else integral_subgrid_delta ( x_dim_index ) = max ( integral_subgrid_delta_ref , subgrid_delta ( x_dim_index )) integral_subgrid_delta ( y_dim_index ) = max ( integral_subgrid_delta_ref , subgrid_delta ( y_dim_index )) integral_subgrid_step = floor ( integral_subgrid_delta_ref / subgrid_delta ( x_dim_index ) + 0.5 ) end if integral_subgrid_min = subgrid_min integral_subgrid_max = subgrid_max integral_subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) integral_subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) integral_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) ! Set the integral subgrid dimensions so they cannot be larger than the target subgrid integral_subgrid_dim ( x_dim_index ) = min ( integral_subgrid_dim ( x_dim_index ), subgrid_dim ( x_dim_index )) integral_subgrid_dim ( y_dim_index ) = min ( integral_subgrid_dim ( y_dim_index ), subgrid_dim ( y_dim_index )) ! Set all population subgrids relative to the target subgrid if ( population_data_type . eq . population_index . and . . not . use_region_select_and_mask_flag ) then ! When not using regional mask then 250 m population data is used then set this as a limit population_subgrid_delta ( x_dim_index ) = max ( subgrid_delta ( x_dim_index ), limit_population_delta ) population_subgrid_delta ( y_dim_index ) = max ( subgrid_delta ( y_dim_index ), limit_population_delta ) else ! Allow the population data to have the same grid as the target grid population_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) population_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) end if population_subgrid_min = subgrid_min population_subgrid_max = subgrid_max population_subgrid_dim ( x_dim_index ) = floor (( population_subgrid_max ( x_dim_index ) - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) population_subgrid_dim ( y_dim_index ) = floor (( population_subgrid_max ( y_dim_index ) - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) ! Set the population subgrid dimensions so they cannot be larger than the target subgrid. Not certain why I do this. population_subgrid_dim ( x_dim_index ) = min ( population_subgrid_dim ( x_dim_index ), subgrid_dim ( x_dim_index )) population_subgrid_dim ( y_dim_index ) = min ( population_subgrid_dim ( y_dim_index ), subgrid_dim ( y_dim_index )) ! Set population subgrid so it has a minimum of 1 dimensions, to avoid problems when running receptor calculations population_subgrid_dim ( x_dim_index ) = max ( population_subgrid_dim ( x_dim_index ), 1 ) population_subgrid_dim ( y_dim_index ) = max ( population_subgrid_dim ( y_dim_index ), 1 ) ! Set all emission subgrids to be the same as the target subgrid emission_max_subgrid_dim = subgrid_dim do i = 1 , n_source_index emission_subgrid_delta (:, i ) = subgrid_delta emission_subgrid_min (:, i ) = subgrid_min emission_subgrid_max (:, i ) = subgrid_max emission_subgrid_dim (:, i ) = subgrid_dim end do ! Set shipping data to a minimum value for all sources (Cannot be smaller than the target subgrid) emission_subgrid_delta ( x_dim_index , shipping_index ) = max ( subgrid_delta ( x_dim_index ), limit_shipping_delta ) emission_subgrid_delta ( y_dim_index , shipping_index ) = max ( subgrid_delta ( y_dim_index ), limit_shipping_delta ) emission_subgrid_delta ( x_dim_index , heating_index ) = max ( subgrid_delta ( x_dim_index ), limit_heating_delta ) emission_subgrid_delta ( y_dim_index , heating_index ) = max ( subgrid_delta ( y_dim_index ), limit_heating_delta ) emission_subgrid_delta ( x_dim_index , industry_index ) = max ( subgrid_delta ( x_dim_index ), limit_industry_delta ) emission_subgrid_delta ( y_dim_index , industry_index ) = max ( subgrid_delta ( y_dim_index ), limit_industry_delta ) ! Set all the emission subgrid dimensions after changes do i = 1 , n_source_index emission_subgrid_dim ( x_dim_index , i ) = floor (( emission_subgrid_max ( x_dim_index , i ) - emission_subgrid_min ( x_dim_index , i )) / emission_subgrid_delta ( x_dim_index , i )) emission_subgrid_dim ( y_dim_index , i ) = floor (( emission_subgrid_max ( y_dim_index , i ) - emission_subgrid_min ( y_dim_index , i )) / emission_subgrid_delta ( y_dim_index , i )) write ( unit_logfile , '(A,I6,A5,2I6)' ) 'Emission grid dimensions for source ' , i , ': ' , emission_subgrid_dim ( 1 : 2 , i ) end do ! Set the landuse and deposition grids to have the same extent as the target grid if ( calculate_deposition_flag ) then if ( deposition_subgrid_delta ( x_dim_index ) . eq . 0 ) deposition_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) if ( deposition_subgrid_delta ( y_dim_index ) . eq . 0 ) deposition_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) deposition_subgrid_min (:) = subgrid_min deposition_subgrid_max (:) = subgrid_max deposition_subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / deposition_subgrid_delta ( x_dim_index )) deposition_subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / deposition_subgrid_delta ( y_dim_index )) deposition_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) end if if ( read_landuse_flag ) then if ( landuse_subgrid_delta ( x_dim_index ) . eq . 0 ) landuse_subgrid_delta ( x_dim_index ) = subgrid_delta ( x_dim_index ) if ( landuse_subgrid_delta ( y_dim_index ) . eq . 0 ) landuse_subgrid_delta ( y_dim_index ) = subgrid_delta ( y_dim_index ) landuse_subgrid_min (:) = subgrid_min landuse_subgrid_max (:) = subgrid_max landuse_subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / landuse_subgrid_delta ( x_dim_index )) landuse_subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / landuse_subgrid_delta ( y_dim_index )) landuse_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) end if write ( unit_logfile , '(A,2I6)' ) 'Concentration grid dimensions: ' , subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Integral grid dimensions: ' , integral_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2f10.1)' ) 'Concentration subgrid grid sizes: ' , subgrid_delta write ( unit_logfile , '(A,I6,2f10.1)' ) 'Integral subgrid step and grid sizes: ' , integral_subgrid_step , integral_subgrid_delta if ( calculate_deposition_flag ) then write ( unit_logfile , '(A,2I6)' ) 'Deposition grid dimensions: ' , deposition_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2f10.1)' ) 'Deposition subgrid grid sizes: ' , deposition_subgrid_delta end if if ( read_landuse_flag ) then write ( unit_logfile , '(A,2I6)' ) 'Landuse grid dimensions: ' , landuse_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2f10.1)' ) 'Landuse subgrid grid sizes: ' , landuse_subgrid_delta end if end subroutine uEMEP_set_subgrids subroutine uEMEP_set_subgrid_select_latlon_centre () ! If specified using select_latlon_centre_domain_position_flag then this routines specifies ! the grid according to the lat lon position and the width and height ! This is intended to make life easier for users and to implement uEMEP in a more global context ! Local variables real :: x_out , y_out ! Find centre position in specified coordinates if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , select_lat_centre_position , select_lon_centre_position , y_out , x_out ) else if ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , select_lat_centre_position , select_lon_centre_position , y_out , x_out ) else if ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_out , y_out , select_lon_centre_position , select_lat_centre_position , projection_attributes ) end if ! Snap to nearest 1 km x_out = floor ( x_out / 100 0.0 + 0.5 ) * 100 0.0 y_out = floor ( y_out / 100 0.0 + 0.5 ) * 100 0.0 ! Set max and min values subgrid_min ( x_dim_index ) = x_out - select_domain_width_EW_km * 100 0.0 / 2.0 subgrid_min ( y_dim_index ) = y_out - select_domain_height_NS_km * 100 0.0 / 2.0 subgrid_max ( x_dim_index ) = x_out + select_domain_width_EW_km * 100 0.0 / 2.0 subgrid_max ( y_dim_index ) = y_out + select_domain_height_NS_km * 100 0.0 / 2.0 write ( unit_logfile , '(A,2f12.1)' ) 'Setting domain centre (lon,lat) to: ' , select_lon_centre_position , select_lat_centre_position write ( unit_logfile , '(A,2f12.1)' ) 'Setting min domain (x,y) to: ' , subgrid_min ( 1 : 2 ) write ( unit_logfile , '(A,2f12.1)' ) 'Setting max domain (x,y) to: ' , subgrid_max ( 1 : 2 ) ! Reset the initial subgrid as well, needed for EMEP and receptor selection init_subgrid_min ( x_dim_index ) = subgrid_min ( x_dim_index ) init_subgrid_min ( y_dim_index ) = subgrid_min ( y_dim_index ) init_subgrid_max ( x_dim_index ) = subgrid_max ( x_dim_index ) init_subgrid_max ( y_dim_index ) = subgrid_max ( y_dim_index ) end subroutine uEMEP_set_subgrid_select_latlon_centre end module set_subgrids","tags":"","loc":"sourcefile/uemep_set_subgrids.f90.html"},{"title":"uEMEP_read_industry_data.f90 – uEMEP","text":"Source Code module read_industry_data use uemep_configuration use mod_lambert_projection , only : LL2LAEA , lb2lambert2_uEMEP , LL2PS_spherical use utility_functions , only : ll2utm , ll2ltm implicit none private public :: uEMEP_read_industry_data contains !uEMEP_read_industry_data.f90 !Reads in and places in subgrid industry emissions !These emissions come from norgeutslipp.no but are reformatted for use in uEMEP subroutine uEMEP_read_industry_data use uEMEP_definitions implicit none integer i , j integer unit_in character ( 256 ) temp_str integer count integer n_industries logical exists integer subsource_index integer , allocatable :: industry_ref (:) character ( 256 ), allocatable :: industry_num (:) real , allocatable :: industry_lb_pos (:,:) real , allocatable :: industry_xy_pos (:,:) real , allocatable :: industry_height (:) real , allocatable :: industry_emission (:,:) character ( 256 ), allocatable :: industry_code (:) integer industry_emission_year character ( 256 ) industry_emission_num , industry_emission_comp_str , industry_emission_unit real industry_emission_comp_val integer industry_number integer i_industry_index , j_industry_index , source_index , i_pollutant real ratio_industry_pm25_to_pm10 real x_industry , y_industry integer , allocatable :: count_subgrid (:,:,:) real , allocatable :: emission_height_subgrid (:,:,:) integer pollutant_count integer :: io subsource_index = 1 source_index = industry_index !Set default pm25/pm10 ratio for when pm10 is given but not pm25. Value of 1 appropriate for exhaust but not for fugitive dust emissions ratio_industry_pm25_to_pm10 = 1.0 write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading industry data  (uEMEP_read_industry_data)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_industry ( 1 ) = trim ( pathname_industry ( 1 )) // trim ( filename_industry ( 1 )) !Metadata pathfilename_industry ( 2 ) = trim ( pathname_industry ( 2 )) // trim ( filename_industry ( 2 )) !Emission data !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_industry ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Industry metadata file does not exist: ' , trim ( pathfilename_industry ( 1 )) stop endif inquire ( file = trim ( pathfilename_industry ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Industry emission file does not exist: ' , trim ( pathfilename_industry ( 2 )) stop endif !Open the metadata file for reading unit_in = 20 open ( unit_in , file = pathfilename_industry ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening industry metadata file ' // trim ( pathfilename_industry ( 1 )) rewind ( unit_in ) !Read header: AnleggIdRef\tAnleggNummer\tGeografiskLatitude\tGeografiskLongitude\tUtm33Nord\tUtm33Ost\tHeight\tNACEKode read ( unit_in , '(A)' ) temp_str !write(*,*) trim(temp_str) !Count how many lines for allocation of arrays count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit count = count + 1 enddo !Allocate arrays n_industries = count allocate ( industry_ref ( n_industries )) allocate ( industry_num ( n_industries )) allocate ( industry_lb_pos ( n_industries , 2 )) allocate ( industry_xy_pos ( n_industries , 2 )) allocate ( industry_height ( n_industries )) allocate ( industry_code ( n_industries )) allocate ( industry_emission ( n_industries , n_compound_index )) rewind ( unit_in ) !Read header again read ( unit_in , '(A)' ) temp_str do i = 1 , n_industries read ( unit_in , * ) industry_ref ( i ), industry_num ( i ), industry_lb_pos ( i , 2 ), industry_lb_pos ( i , 1 ), industry_xy_pos ( i , 2 ), industry_xy_pos ( i , 1 ), industry_height ( i ), industry_code ( i ) !write(unit_logfile,'(i12,a16,2f12.4,3f12.1,a16)' ) industry_ref(i),trim(industry_num(i)),industry_lb_pos(i,2),industry_lb_pos(i,1),industry_xy_pos(i,2),industry_xy_pos(i,1),industry_height(i),trim(industry_code(i)) enddo close ( unit_in ) write ( unit_logfile , '(a,i)' ) ' Number of industries: ' , n_industries !Read in emission file and write emisions to industry array allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) allocate ( emission_height_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 emission_height_subgrid = 0. !Open the emission file for reading industry_emission = 0. unit_in = 20 open ( unit_in , file = pathfilename_industry ( 2 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening industry emission file ' // trim ( pathfilename_industry ( 2 )) rewind ( unit_in ) !Read header: �r\tAnleggNummer\tKomponent\tSamlet_mengde\tEnhet read ( unit_in , '(A)' ) temp_str do read ( unit_in , * , iostat = io ) industry_emission_year , industry_emission_num , industry_emission_comp_str , industry_emission_comp_val , industry_emission_unit if ( io /= 0 ) exit !write(unit_logfile,'(i12,2a16,f12.2,a16)' ) industry_emission_year,trim(industry_emission_num),trim(industry_emission_comp_str),industry_emission_comp_val,trim(industry_emission_unit) !Find index for the industry industry_number = 0 do i = 1 , n_industries if ( trim ( industry_emission_num ). eq . trim ( industry_num ( i ))) then industry_number = i exit endif enddo if ( industry_number . eq . 0 ) then write ( unit_logfile , * ) 'No matching industry ID for the emissions: ' // trim ( industry_emission_num ) else !write(unit_logfile,*) 'Matching industry ID found: '//trim(industry_emission_num) endif !If an industry is found then put the emissions in the industry_emission array if ( industry_number . gt . 0 ) then if ( trim ( industry_emission_comp_str ). eq . 'nox' ) then industry_emission ( industry_number , nox_index ) = industry_emission ( industry_number , nox_index ) + industry_emission_comp_val endif if ( trim ( industry_emission_comp_str ). eq . 'pm10' ) then industry_emission ( industry_number , pm10_index ) = industry_emission ( industry_number , pm10_index ) + industry_emission_comp_val endif if ( trim ( industry_emission_comp_str ). eq . 'pm25' ) then industry_emission ( industry_number , pm25_index ) = industry_emission ( industry_number , pm25_index ) + industry_emission_comp_val endif endif enddo close ( unit_in ) !Adjust pm10 and pm25 dependent on if they exist or not do i = 1 , n_industries !Set pm10 to pm25 in the case when it is less than pm25. if ( industry_emission ( i , pm10_index ). lt . industry_emission ( i , pm25_index )) then industry_emission ( i , pm10_index ) = industry_emission ( i , pm25_index ) endif !Set pm25 to pm10*ratio in cases where pm10 exists but pm25 does not if ( industry_emission ( i , pm25_index ). eq . 0. and . industry_emission ( i , pm10_index ). gt . 0 ) then industry_emission ( i , pm25_index ) = industry_emission ( i , pm10_index ) * ratio_industry_pm25_to_pm10 endif enddo !Initialise the industry emission arrays proxy_emission_subgrid (:,:, source_index ,:) = 0. emission_properties_subgrid (:,:, emission_h_index , source_index ) = 0. !Count the number of industry emission grid placements count = 0 do industry_number = 1 , n_industries !Convert lat lon to utm coords if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , industry_lb_pos ( industry_number , 2 ), industry_lb_pos ( industry_number , 1 ), y_industry , x_industry ) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , industry_lb_pos ( industry_number , 2 ), industry_lb_pos ( industry_number , 1 ), y_industry , x_industry ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_industry , y_industry , industry_lb_pos ( industry_number , 1 ), industry_lb_pos ( industry_number , 2 ), projection_attributes ) endif !Special case when saving emissions, convert to either latlon or lambert if ( save_emissions_for_EMEP ( industry_index )) then if ( EMEP_projection_type . eq . LL_projection_index ) then x_industry = industry_lb_pos ( industry_number , 1 ) y_industry = industry_lb_pos ( industry_number , 2 ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_industry , y_industry , industry_lb_pos ( industry_number , 1 ), industry_lb_pos ( industry_number , 2 ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_industry , y_industry , industry_lb_pos ( industry_number , 1 ), industry_lb_pos ( industry_number , 2 ), EMEP_projection_attributes ) endif endif !Find the grid index it belongs to i_industry_index = 1 + floor (( x_industry - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_industry_index = 1 + floor (( y_industry - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if it is within the subgrid range if ( i_industry_index . ge . 1. and . i_industry_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_industry_index . ge . 1. and . j_industry_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index . and . industry_emission ( industry_number , nox_index ). gt . 0 ) then proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) & + industry_emission ( industry_number , nox_index ) emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + industry_height ( industry_number ) * industry_emission ( industry_number , nox_index ) count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + 1 count = count + 1 !write(*,'(a,3i,f12.2)') 'Industry height nox: ',industry_number,i_industry_index,j_industry_index,industry_height(industry_number) endif if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index . and . industry_emission ( industry_number , pm10_index ). gt . 0 ) then proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) & + industry_emission ( industry_number , pm10_index ) emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + industry_height ( industry_number ) * industry_emission ( industry_number , pm10_index ) count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + 1 count = count + 1 !write(*,'(a,3i,f12.2)') 'Industry height pm10: ',industry_number,i_industry_index,j_industry_index,industry_height(industry_number) endif if ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . and . industry_emission ( industry_number , pm25_index ). gt . 0 ) then proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_industry_index , j_industry_index , source_index , i_pollutant ) & + industry_emission ( industry_number , pm25_index ) emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = emission_height_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + industry_height ( industry_number ) * industry_emission ( industry_number , pm25_index ) count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) = count_subgrid ( i_industry_index , j_industry_index , i_pollutant ) + 1 count = count + 1 !write(*,'(a,3i,f12.2)') 'Industry height pm25: ',industry_number,i_industry_index,j_industry_index,industry_height(industry_number) endif enddo endif enddo !Loop through the emission subgrid and take the average emission height !This is not weighted as it is averaged over all pollutants as well. Could do this but will not. !Probably need a pollutant dependent emission property do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) pollutant_count = 0 do i_pollutant = 1 , n_pollutant_loop if ( proxy_emission_subgrid ( i , j , source_index , i_pollutant ). gt . 0 ) then emission_height_subgrid ( i , j , i_pollutant ) = emission_height_subgrid ( i , j , i_pollutant ) / proxy_emission_subgrid ( i , j , source_index , i_pollutant ) !write(unit_logfile,'(2a,2i6,f12.2)') 'Emission height: ',trim(pollutant_file_str(pollutant_loop_index(i_pollutant))),i,j,emission_height_subgrid(i,j,i_pollutant) !Take the average of the pollutants emission_properties_subgrid ( i , j , emission_h_index , source_index ) = emission_properties_subgrid ( i , j , emission_h_index , source_index ) + emission_height_subgrid ( i , j , i_pollutant ) pollutant_count = pollutant_count + 1 endif enddo if ( pollutant_count . gt . 0 ) then emission_properties_subgrid ( i , j , emission_h_index , source_index ) = emission_properties_subgrid ( i , j , emission_h_index , source_index ) / pollutant_count !write(unit_logfile,'(2a,2i6,f12.2)') 'Final emission height: ',trim('mean'),i,j,emission_properties_subgrid(i,j,emission_h_index,source_index) endif !Set the industry emission heights to that given in the config file if it is > 0 if ( h_emis ( industry_index , 1 ). ge . 0 ) then emission_properties_subgrid ( i , j , emission_h_index , source_index ) = h_emis ( industry_index , 1 ) endif enddo enddo write ( unit_logfile , '(A,I)' ) 'Industry counts = ' , count do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo write ( unit_logfile , '(A,f12.2)' ) 'Average industry emission height for all industries = ' , sum ( industry_height ( 1 : n_industries )) / n_industries close ( unit_in ) deallocate ( industry_ref ) deallocate ( industry_num ) deallocate ( industry_lb_pos ) deallocate ( industry_xy_pos ) deallocate ( industry_height ) deallocate ( industry_code ) deallocate ( count_subgrid ) deallocate ( industry_emission ) end subroutine uEMEP_read_industry_data end module read_industry_data","tags":"","loc":"sourcefile/uemep_read_industry_data.f90.html"},{"title":"uEMEP_read_meteo_nc.f90 – uEMEP","text":"Source Code module read_meteo_nc use uemep_configuration use uEMEP_definitions use read_config , only : replace_string_char use time_functions , only : date_to_number , number_to_date , & date_to_datestr_bracket , datestr_to_date use mod_lambert_projection , only : PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical use netcdf implicit none private public :: uEMEP_read_meteo_nc contains !uEMEP_read_meteo_nc !Reads in AROME data in 2 files, 3 for meteo and 4 for z0 !These two files must have the same x,y dimensions as they are placed in the same grid subroutine uEMEP_read_meteo_nc implicit none integer i , j , t integer ii , jj logical exists integer status_nc !Error message integer id_nc integer dim_id_nc ( num_dims_meteo_nc ) character ( 256 ) dimname_temp , var_name_nc_temp , unit_name_nc_temp integer var_id_nc integer i_file , i_dim integer temp_num_dims integer temp_start_time_meteo_nc_index , temp_end_time_meteo_nc_index integer valid_dim_length_meteo_nc ( num_dims_meteo_nc ) !dimensions of file 3 real temp_lat ( 4 ), temp_lon ( 4 ) real temp_y ( 4 ), temp_x ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max double precision temp_var1d_nc_dp ( 2 , 2 ) real temp_delta ( 2 ) real scale_grid_interpolation_size ( 2 ) real EMEP_temp_delta ( 2 ) real temp_lat_mean integer n_file , n_file_start double precision date_num_temp integer date_array ( 6 ) double precision scale_factor_nc logical found_file integer :: search_hour_step = 6 integer new_start_date_input ( 6 ) character ( 256 ) format_temp real EMEP_grid_interpolation_size_temp !Temporary reading rvariables double precision , allocatable :: var1d_nc_dp (:) double precision , allocatable :: var2d_nc_dp (:,:) !Temporary files for roatating wind field real , allocatable :: temp_meteo_var3d_nc (:,:,:,:) !Daily mean temperature variables integer DMT_start_time_nc_index , DMT_end_time_nc_index , DMT_dim_length_nc write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading additional meteo data (uEMEP_read_meteo_nc)' write ( unit_logfile , '(A)' ) '================================================================' !This if statement is already specified in uEMEP_define_subgrid and is not necessary here if ( hourly_calculations ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index temp_end_time_meteo_nc_index = end_time_meteo_nc_index else temp_start_time_meteo_nc_index = 1 temp_end_time_meteo_nc_index = 1 endif if ( use_single_time_loop_flag ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index + t_loop - 1 temp_end_time_meteo_nc_index = temp_start_time_meteo_nc_index endif !Presettng the surface level to 1. Valid when there is no inverting of layers surface_level_nc = 1 write ( unit_logfile , '(A,I)' ) ' Surface level base set to: ' , surface_level_nc if ( allocated ( val_dim_meteo_nc )) deallocate ( val_dim_meteo_nc ) if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( meteo_var1d_nc )) deallocate ( meteo_var1d_nc ) if ( allocated ( meteo_var2d_nc )) deallocate ( meteo_var2d_nc ) if ( allocated ( meteo_var3d_nc )) deallocate ( meteo_var3d_nc ) if ( allocated ( meteo_var4d_nc )) deallocate ( meteo_var4d_nc ) !Loop through the meteorological files containing the data if ( use_alternative_meteorology_flag ) then n_file_start = 3 n_file = 3 endif if ( use_alternative_z0_flag ) then n_file_start = 4 n_file = 4 endif if ( use_alternative_meteorology_flag . and . use_alternative_z0_flag ) then n_file_start = 3 n_file = 4 endif do i_file = n_file_start , n_file !Set the filename pathfilename_EMEP ( i_file ) = trim ( pathname_EMEP ( i_file )) // trim ( filename_EMEP ( i_file )) !Test existence of the filename 4. If does not exist then stop if ( i_file . eq . 4 ) then inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif endif !Test existence of the filename. If does not exist then try 6 hours before if ( i_file . eq . 3 ) then inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' WARNING: Meteo netcdf file does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) ' Will try 6 hours before 4 times' !Start search back 6 hours found_file = . false . do i = 1 , 4 if ( hourly_calculations ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index + search_hour_step * ( i ) temp_end_time_meteo_nc_index = end_time_meteo_nc_index + search_hour_step * ( i ) endif if ( use_single_time_loop_flag ) then temp_start_time_meteo_nc_index = start_time_meteo_nc_index + t_loop - 1 + search_hour_step * ( i ) temp_end_time_meteo_nc_index = temp_start_time_meteo_nc_index + search_hour_step * ( i ) endif !Create new date_str format_temp = 'yyyymmddHH' call datestr_to_date ( config_date_str , format_temp , new_start_date_input ) date_num_temp = date_to_number ( new_start_date_input , ref_year_meteo ) call number_to_date ( date_num_temp - dble ( search_hour_step * i + 0.5 ) / dble ( 2 4. ), new_start_date_input , ref_year_meteo ) !Replace replacement_date_str with <yyyyhhmm> so the new_start_date_input can be inserted format_temp = '<yyyymmdd>' filename_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_date_str , original_filename_EMEP ( i_file )) pathname_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_date_str , original_pathname_EMEP ( i_file )) !write(*,*) trim(filename_EMEP(i_file)),'  ',trim(replacement_date_str) !Replace replacement_hour_str with <HH> so the forecast hour can be inserted format_temp = '<HH>' filename_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_hour_str , filename_EMEP ( i_file )) pathname_EMEP ( i_file ) = replace_string_char ( format_temp , replacement_hour_str , pathname_EMEP ( i_file )) !write(*,*) trim(filename_EMEP(i_file)),'  ',trim(forecast_hour_str) !Replace datestr twice for both forecast_hour and config_date call date_to_datestr_bracket ( new_start_date_input , filename_EMEP ( i_file ), filename_EMEP ( i_file )) call date_to_datestr_bracket ( new_start_date_input , pathname_EMEP ( i_file ), pathname_EMEP ( i_file )) call date_to_datestr_bracket ( new_start_date_input , filename_EMEP ( i_file ), filename_EMEP ( i_file )) call date_to_datestr_bracket ( new_start_date_input , pathname_EMEP ( i_file ), pathname_EMEP ( i_file )) pathfilename_EMEP ( i_file ) = trim ( pathname_EMEP ( i_file )) // trim ( filename_EMEP ( i_file )) write ( unit_logfile , '(A,A)' ) ' Trying: ' , trim ( pathfilename_EMEP ( i_file )) inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if ( exists ) then found_file = . true . exit else found_file = . false . endif enddo if (. not . found_file ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Meteo netcdf file still does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) ' STOPPING' stop else write ( unit_logfile , '(A,A)' ) ' Found earlier meteo netcdf file: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A,2i6)' ) ' New start and end index: ' , temp_start_time_meteo_nc_index , temp_end_time_meteo_nc_index endif endif endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_EMEP ( i_file )) status_nc = NF90_OPEN ( pathfilename_EMEP ( i_file ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif meteo_nc_projection_type = LL_projection_index !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'projection_lambert' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) status_nc = nf90_get_att ( id_nc , var_id_nc , 'standard_parallel' , meteo_nc_projection_attributes ( 1 : 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_central_meridian' , meteo_nc_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , meteo_nc_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , meteo_nc_projection_attributes ( 5 )) meteo_nc_projection_type = LCC_projection_index write ( unit_logfile , '(A,5f12.2)' ) 'Reading lambert_conformal_conic projection. ' , meteo_nc_projection_attributes ( 1 : 5 ) if ( meteo_nc_projection_attributes ( 1 ). ne . meteo_nc_projection_attributes ( 4 ). or . meteo_nc_projection_attributes ( 2 ). ne . meteo_nc_projection_attributes ( 4 )) then use_alternative_LCC_projection_flag = . true . write ( unit_logfile , '(A,l)' ) 'Using alternative lambert_conformal_conic projection: ' , use_alternative_LCC_projection_flag else use_alternative_LCC_projection_flag = . false . endif !Always set to true. i.e. not use anymore use_alternative_LCC_projection_flag = . true . endif !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'Polar_Stereographic' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then EMEP_projection_attributes = 0. EMEP_projection_attributes ( 5 ) = 6.370e6 status_nc = nf90_get_att ( id_nc , var_id_nc , 'straight_vertical_longitude_from_pole' , meteo_nc_projection_attributes ( 1 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , meteo_nc_projection_attributes ( 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_easting' , meteo_nc_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_northing' , meteo_nc_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , meteo_nc_projection_attributes ( 5 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'scale_factor_at_projection_origin' , meteo_nc_projection_attributes ( 6 )) meteo_nc_projection_type = PS_projection_index write ( unit_logfile , '(A,5f12.2)' ) 'Reading Polar_Stereographic projection. ' , meteo_nc_projection_attributes ( 1 : 5 ) endif !Find the (x,y,z,time) dimensions of the file do i_dim = 1 , num_dims_meteo_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_meteo_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_meteo_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_meteo_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_meteo_nc ( i_dim ) = 1 endif enddo if ( i_file . eq . 3 ) then valid_dim_length_meteo_nc = dim_length_meteo_nc endif if ( i_file . eq . 3 ) then if ( subgrid_dim ( t_dim_index ). gt . dim_length_meteo_nc ( time_dim_nc_index )) then write ( unit_logfile , '(A,2I)' ) 'ERROR: Specified time dimensions are greater than meteo netcdf dimensions. Stopping ' , subgrid_dim ( t_dim_index ), dim_length_meteo_nc ( time_dim_nc_index ) stop endif if ( temp_end_time_meteo_nc_index . gt . dim_length_meteo_nc ( time_dim_nc_index )) then write ( unit_logfile , '(A,2I)' ) 'ERROR: Required meteo time dimension larger than available meteo time dimension. Stopping ' , temp_end_time_meteo_nc_index , dim_length_meteo_nc ( time_dim_nc_index ) stop endif endif write ( unit_logfile , '(A,6I)' ) ' Size of meteo dimensions (x,y,z,t): ' , dim_length_meteo_nc if ( i_file . eq . 3 ) then dim_start_meteo_nc ( time_dim_nc_index ) = temp_start_time_meteo_nc_index dim_length_meteo_nc ( time_dim_nc_index ) = min ( dim_length_meteo_nc ( time_dim_nc_index ), subgrid_dim ( t_dim_index )) elseif ( i_file . eq . 4 ) then dim_start_meteo_nc ( time_dim_nc_index ) = 1 dim_length_meteo_nc ( time_dim_nc_index ) = 1 endif write ( unit_logfile , '(A,6I)' ) ' New size of meteo dimensions (x,y,z,t): ' , dim_length_meteo_nc !Calculate the necessary extent of the meteo_nc grid region and only read these grids if ( reduce_EMEP_region_flag ) then !Determine the LL cordinates of the target grid !EMEP_grid_interpolation_size_temp=max(EMEP_grid_interpolation_size*local_fraction_grid_size_scaling,EMEP_additional_grid_interpolation_size_original*local_fraction_grid_size_scaling) EMEP_grid_interpolation_size_temp = EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Retrieve the four corners of the target grid in lat and lon call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(1),temp_lon(1)) !call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(2),temp_lon(2)) !call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(3),temp_lon(3)) !call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(4),temp_lon(4)) !Find the average for use later temp_lat_mean = sum ( temp_lat ) / 4. temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 if ( meteo_nc_projection_type . eq . LCC_projection_index ) then !Convert lat lon corners to lambert do i = 1 , 4 call lb2lambert2_uEMEP ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), meteo_nc_projection_attributes ) enddo elseif ( meteo_nc_projection_type . eq . PS_projection_index ) then !Convert lat lon corners to lambert do i = 1 , 4 call LL2PS_spherical ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), meteo_nc_projection_attributes ) enddo elseif ( meteo_nc_projection_type . eq . LL_projection_index ) then !Set lat lon corners if EMEP is in lat lon temp_x = temp_lon ; temp_y = temp_lat else !Otherwise assume the same coordinate system temp_x ( 1 ) = init_subgrid_min ( x_dim_index ); temp_y ( 1 ) = init_subgrid_min ( y_dim_index ) temp_x ( 2 ) = init_subgrid_max ( x_dim_index ); temp_y ( 2 ) = init_subgrid_min ( y_dim_index ) temp_x ( 3 ) = init_subgrid_min ( x_dim_index ); temp_y ( 3 ) = init_subgrid_max ( y_dim_index ) temp_x ( 4 ) = init_subgrid_max ( x_dim_index ); temp_y ( 4 ) = init_subgrid_max ( y_dim_index ) endif do i = 1 , 4 if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo !Read in the first 2 x and y position values from the nc file to get min values and delta values !write(*,*) temp_x_min,temp_x_max,temp_y_min,temp_y_max status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_meteo_nc ( x_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 1 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_meteo_nc ( y_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 2 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_name_nc_temp ) if ( trim ( unit_name_nc_temp ). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' temp_var1d_nc_dp = temp_var1d_nc_dp * 100 0. endif !HERE FIX. The EMEP_grid_interpolation_size is too small when using EMEP is a different grid to the meteo grid. Need to rescale this somehow !By using meteo_dgrid_nc(lon_nc_index), not defined yet, and dgrid_nc(lon_nc_index) !For example  dx_temp=111000.*dgrid_nc(lon_nc_index)*cos(lat_temp*pi/180.) and dy_temp=111000.*dgrid_nc(lat_nc_index) !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = temp_var1d_nc_dp ( 1 , 2 ) - temp_var1d_nc_dp ( 1 , 1 ) temp_delta ( 2 ) = temp_var1d_nc_dp ( 2 , 2 ) - temp_var1d_nc_dp ( 2 , 1 ) !write(*,*) temp_delta if (( meteo_nc_projection_type . eq . LCC_projection_index . and . EMEP_projection_type . eq . LCC_projection_index ) & . or .( meteo_nc_projection_type . eq . LL_projection_index . and . EMEP_projection_type . eq . LL_projection_index ) & . or .( meteo_nc_projection_type . eq . PS_projection_index . and . EMEP_projection_type . eq . PS_projection_index )) then !If both EMEP and meteo are in the same coordinates then set the EMEP size to be the same as the meteo siz EMEP_temp_delta ( 1 ) = dgrid_nc ( lon_nc_index ) EMEP_temp_delta ( 2 ) = dgrid_nc ( lat_nc_index ) elseif (( meteo_nc_projection_type . eq . LCC_projection_index . and . EMEP_projection_type . eq . LL_projection_index ) & . or .( meteo_nc_projection_type . eq . PS_projection_index . and . EMEP_projection_type . eq . LL_projection_index )) then !EMEP is in latlon, convert to local coordinates EMEP_temp_delta ( 1 ) = dgrid_nc ( lon_nc_index ) * 11100 0. * cos ( temp_lat_mean * 3.14159 / 18 0. ) EMEP_temp_delta ( 2 ) = dgrid_nc ( lat_nc_index ) * 11100 0. elseif (( meteo_nc_projection_type . eq . LL_projection_index . and . EMEP_projection_type . eq . LCC_projection_index )& . or .( meteo_nc_projection_type . eq . LL_projection_index . and . EMEP_projection_type . eq . PS_projection_index )) then !This conversion not available write ( unit_logfile , '(A,3I)' ) 'Use of lat lon projection in meteo data, together with Lambert or PS in EMEP not available. Stopping' stop else write ( unit_logfile , '(A,3I)' ) 'Use of current projections in meteo and EMEP data not available. Stopping' stop endif scale_grid_interpolation_size = EMEP_temp_delta / temp_delta !write(*,*) dgrid_nc(lon_nc_index),dgrid_nc(lat_nc_index) !write(*,*) EMEP_temp_delta !write(*,*) scale_grid_interpolation_size !stop !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max i_temp_min = max ( 1 , i_temp_min - 1 - ceiling ( scale_grid_interpolation_size ( 1 ) * EMEP_grid_interpolation_size_temp )) i_temp_max = min ( dim_length_meteo_nc ( x_dim_nc_index ), i_temp_max + 1 + ceiling ( scale_grid_interpolation_size ( 1 ) * EMEP_grid_interpolation_size_temp )) j_temp_min = max ( 1 , j_temp_min - 1 - ceiling ( scale_grid_interpolation_size ( 2 ) * EMEP_grid_interpolation_size_temp )) j_temp_max = min ( dim_length_meteo_nc ( y_dim_nc_index ), j_temp_max + 1 + ceiling ( scale_grid_interpolation_size ( 2 ) * EMEP_grid_interpolation_size_temp )) dim_length_meteo_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_meteo_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_meteo_nc ( x_dim_nc_index ) = i_temp_min dim_start_meteo_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading meteo x grids: ' , i_temp_min , i_temp_max , dim_length_meteo_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading meteo y grids: ' , j_temp_min , j_temp_max , dim_length_meteo_nc ( y_dim_nc_index ) !Set the new valid meteo dimensions if ( i_file . ge . 3 ) then valid_dim_length_meteo_nc ( x_dim_nc_index ) = dim_length_meteo_nc ( x_dim_nc_index ) valid_dim_length_meteo_nc ( y_dim_nc_index ) = dim_length_meteo_nc ( y_dim_nc_index ) endif endif !Allocate the nc arrays for reading if (. not . allocated ( val_dim_meteo_nc )) allocate ( val_dim_meteo_nc ( maxval ( dim_length_meteo_nc ), num_dims_meteo_nc )) !x, y, z and time dimension values if (. not . allocated ( unit_dim_meteo_nc )) allocate ( unit_dim_meteo_nc ( num_dims_meteo_nc )) !x, y, z and time dimension values if (. not . allocated ( var1d_nc_dp )) allocate ( var1d_nc_dp ( maxval ( dim_length_meteo_nc ))) if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ))) !Lat and lon !Allocate array for the alternative meteo files if ( i_file . ge . 3 ) then if (. not . allocated ( meteo_var1d_nc )) allocate ( meteo_var1d_nc ( maxval ( dim_length_meteo_nc ), num_dims_meteo_nc )) !x, y, z and time maximum dimensions if (. not . allocated ( meteo_var2d_nc )) allocate ( meteo_var2d_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 2 )) !Lat and lon if (. not . allocated ( meteo_var3d_nc )) allocate ( meteo_var3d_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 0 : dim_length_meteo_nc ( time_dim_nc_index ), num_var_meteo_nc )) if (. not . allocated ( meteo_var4d_nc )) allocate ( meteo_var4d_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( z_dim_nc_index ), 0 : dim_length_meteo_nc ( time_dim_nc_index ), num_var_meteo_nc )) endif !Read in the dimensions and check values of the dimensions. do i = 1 , num_dims_meteo_nc status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_meteo_nc ( i )), var_id_nc ) !write(*,*) id_nc, trim(dim_name_nc(i)), var_id_nc(i),dim_length_nc(i) var1d_nc_dp = 0. !write(*,*) 'HERE',i,dim_start_nc(i),dim_length_nc(i) unit_dim_meteo_nc ( i ) = '' if ( status_nc . EQ . NF90_NOERR ) then status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_dim_meteo_nc ( i )) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var1d_nc_dp ( 1 : dim_length_meteo_nc ( i )), start = ( / dim_start_meteo_nc ( i ) / ), count = ( / dim_length_meteo_nc ( i ) / )); meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_meteo_nc ( i ))) !Use the first file to give valid time stamps if ( i_file . eq . 3. and . i . eq . time_dim_nc_index ) then val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_meteo_nc ( i ))) valid_dim_length_meteo_nc ( i ) = dim_length_meteo_nc ( i ) endif !Use first file to get the valid height of the wind measurements (height3) if ( i_file . eq . 3. and . i . eq . z_dim_nc_index ) then val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_meteo_nc ( i ))) valid_dim_length_meteo_nc ( i ) = dim_length_meteo_nc ( i ) endif !Convert from meters to km for AROME data if necessary if (( i . eq . x_dim_nc_index . or . i . eq . y_dim_nc_index ). and . trim ( unit_dim_meteo_nc ( i )). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) = val_dim_meteo_nc ( 1 : dim_length_meteo_nc ( i ), i ) * 100 0. meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i ) = meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i ) * 100 0. endif write ( unit_logfile , '(3A,2es12.4)' ) ' ' , trim ( dim_name_meteo_nc ( i )), ' (min, max): ' & , minval ( meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i )), maxval ( meteo_var1d_nc ( 1 : dim_length_meteo_nc ( i ), i )) else !meteo_var1d_nc(1:dim_length_meteo_nc(i),i)=0. !val_dim_meteo_nc(1:dim_length_meteo_nc(i),i)=0. endif enddo !i_conc=compound_index !Loop through the meteo_variables do i = 1 , num_var_meteo_nc !Identify the variable name and ID in the nc file var_name_nc_temp = var_name_meteo_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) !write(*,*) 'Status1: ',status_nc,var_id_nc,trim(var_name_nc_temp),i_source !If a variable name is found in the file then go further if ( status_nc . eq . NF90_NOERR ) then scale_factor_nc = 1. !Find the dimensions of the variable (temp_num_dims) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) !write(*,*) temp_num_dims,status_nc if ( temp_num_dims . eq . 2. and . i_file . eq . 3 ) then !Read latitude and longitude data into a 2d grid if available. Only lat lon is 2d? if ( i . eq . lat_nc_index . or . i . eq . lon_nc_index ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ); meteo_var2d_nc (:,:, i ) = real ( var2d_nc_dp ) write ( unit_logfile , '(A,i3,A,2A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var2d_nc (:,:, i )), maxval ( meteo_var2d_nc (:,:, i )) endif elseif ( temp_num_dims . eq . 3. and . i_file . eq . 4 ) then !Special case for z0 file as they are scaled integers and a single time file !write(*,'(6i)') dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(time_dim_nc_index),dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = nf90_get_att ( id_nc , var_id_nc , \"scale_factor\" , scale_factor_nc ) if ( status_nc . ne . NF90_NOERR ) scale_factor_nc = 1. !write(*,*) 'scale_factor=',scale_factor_nc status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var3d_nc (:,:, 1 , i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) / )) meteo_var3d_nc (:,:,:, i ) = real ( meteo_var3d_nc (:,:,:, i ) * scale_factor_nc ) !write(*,*) status_nc write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) elseif ( temp_num_dims . eq . 4. and . i_file . eq . 3 ) then !write(*,*) dim_start_nc(z_dim_nc_index),dim_start_nc(z_dim_nc_index)+dim_length_nc(z_dim_nc_index)-1 !write(*,*) dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),dim_start_nc(time_dim_nc_index) !write(*,*) dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 ,:, i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( z_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) - 1 / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( z_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) + 1 / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, meteo_var4d_nc(:,:,dim_start_meteo_nc(z_dim_nc_index):dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1,dim_start_meteo_nc(time_dim_nc_index)-1:dim_start_meteo_nc(time_dim_nc_index)+dim_length_meteo_nc(time_dim_nc_index)-1,i),start=(/dim_start_meteo_nc(x_dim_nc_index),dim_start_meteo_nc(y_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(time_dim_nc_index)-1/),count=(/dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index),dim_length_meteo_nc(z_dim_nc_index),dim_length_meteo_nc(time_dim_nc_index)+1/)) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, meteo_var4d_nc(:,:,1,dim_start_meteo_nc(time_dim_nc_index):dim_length_meteo_nc(time_dim_nc_index),i),start=(/dim_start_meteo_nc(x_dim_nc_index),dim_start_meteo_nc(y_dim_nc_index),1,dim_start_meteo_nc(time_dim_nc_index)/),count=(/dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index),1,dim_length_meteo_nc(time_dim_nc_index)/)) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) !var4d_nc(:,val_dim_nc:,:,:,i,i_source)=real(temp_var4d_nc(:,:,:,:)) write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var4d_nc ( 1 : dim_length_meteo_nc ( x_dim_nc_index ), 1 : dim_length_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) !write(*,*) dim_start_meteo_nc(time_dim_nc_index)-1,dim_length_meteo_nc(time_dim_nc_index)+1,dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1 elseif ( temp_num_dims . eq . 3. and . i_file . eq . 3 ) then !NBV meteo data status_nc = nf90_get_att ( id_nc , var_id_nc , \"scale_factor\" , scale_factor_nc ) if ( status_nc . ne . NF90_NOERR ) scale_factor_nc = 1. !write(*,*) dim_start_nc(z_dim_nc_index),dim_start_nc(z_dim_nc_index)+dim_length_nc(z_dim_nc_index)-1 !write(*,*) dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),dim_start_nc(time_dim_nc_index) !write(*,*) dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, meteo_var4d_nc(:,:,1,:,i),start=(/dim_start_meteo_nc(x_dim_nc_index),dim_start_meteo_nc(y_dim_nc_index),dim_start_meteo_nc(time_dim_nc_index)-1/),count=(/dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index),dim_length_meteo_nc(time_dim_nc_index)+1/)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var4d_nc (:,:, 1 , dim_start_meteo_nc ( time_dim_nc_index ): dim_length_meteo_nc ( time_dim_nc_index ), i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) meteo_var4d_nc (:,:,:,:, i ) = real ( meteo_var4d_nc (:,:,:,:, i ) * scale_factor_nc ) write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var4d_nc (:,:, 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var4d_nc ( 1 : dim_length_meteo_nc ( x_dim_nc_index ), 1 : dim_length_meteo_nc ( y_dim_nc_index ), 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) !write(*,*) dim_start_meteo_nc(time_dim_nc_index)-1,dim_length_meteo_nc(time_dim_nc_index)+1,dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1 elseif ( temp_num_dims . eq . 5. and . i_file . eq . 3 ) then !This is the case when there is an ensemble member in the format !write(*,*) dim_start_nc(z_dim_nc_index),dim_start_nc(z_dim_nc_index)+dim_length_nc(z_dim_nc_index)-1 !write(*,*) dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),dim_start_nc(time_dim_nc_index) !write(*,*) dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 ,:, i ), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), 1 , dim_start_meteo_nc ( z_dim_nc_index ), dim_start_meteo_nc ( time_dim_nc_index ) - 1 / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 1 , dim_length_meteo_nc ( z_dim_nc_index ), dim_length_meteo_nc ( time_dim_nc_index ) + 1 / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) !var4d_nc(:,val_dim_nc:,:,:,i,i_source)=real(temp_var4d_nc(:,:,:,:)) write ( unit_logfile , '(A,I,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( meteo_var4d_nc (:,:, dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )), maxval ( meteo_var4d_nc ( 1 : dim_length_meteo_nc ( x_dim_nc_index ), 1 : dim_length_meteo_nc ( y_dim_nc_index ), dim_start_meteo_nc ( z_dim_nc_index ): dim_start_meteo_nc ( z_dim_nc_index ) + dim_length_meteo_nc ( z_dim_nc_index ) - 1 , 1 : dim_length_meteo_nc ( time_dim_nc_index ), i )) !write(*,*) dim_start_meteo_nc(time_dim_nc_index)-1,dim_length_meteo_nc(time_dim_nc_index)+1,dim_start_meteo_nc(z_dim_nc_index),dim_start_meteo_nc(z_dim_nc_index)+dim_length_meteo_nc(z_dim_nc_index)-1 else write ( unit_logfile , '(8A,8A)' ) ' Cannot find a correct dimension for: ' , trim ( var_name_nc_temp ) endif else !write(unit_logfile,'(8A,8A)') ' Cannot read: ',trim(var_name_nc_temp) endif enddo !Read in 2m temperature completely to get the daily average for home heating !if (use_RWC_emission_data.and.save_emissions_for_EMEP(heating_index).and.i_file.eq.3) then if ( use_RWC_emission_data . and . i_file . eq . 3 ) then DMT_start_time_nc_index = start_time_meteo_nc_index DMT_end_time_nc_index = end_time_meteo_nc_index !DMT_start_time_nc_index=save_emissions_start_index !DMT_end_time_nc_index=save_emissions_end_index DMT_dim_length_nc = DMT_end_time_nc_index - DMT_start_time_nc_index + 1 if ( allocated ( DMT_EMEP_grid_nc )) deallocate ( DMT_EMEP_grid_nc ) if (. not . allocated ( DMT_EMEP_grid_nc )) allocate ( DMT_EMEP_grid_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), DMT_dim_length_nc )) !write(*,*) DMT_start_time_nc_index,DMT_end_time_nc_index,DMT_dim_length_nc if ( calculate_source ( heating_index ). and . i_file . eq . 3 ) then var_name_nc_temp = var_name_meteo_nc ( t2m_nc_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) if ( temp_num_dims . eq . 4 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc (:,:,:), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), 1 , DMT_start_time_nc_index / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 1 , DMT_dim_length_nc / )) elseif ( temp_num_dims . eq . 3 ) then !NBV meteo data status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc (:,:,:), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), DMT_start_time_nc_index / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), DMT_dim_length_nc / )) elseif ( temp_num_dims . eq . 5 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc (:,:,:), start = ( / dim_start_meteo_nc ( x_dim_nc_index ), dim_start_meteo_nc ( y_dim_nc_index ), 1 , 1 , DMT_start_time_nc_index / ), count = ( / dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ), 1 , 1 , DMT_dim_length_nc / )) else write ( unit_logfile , '(8A,8A)' ) ' Cannot find a correct dimension for: ' , trim ( var_name_nc_temp ) endif write ( unit_logfile , '(A,i,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc ), maxval ( DMT_EMEP_grid_nc ) DMT_EMEP_grid_nc (:,:, 1 ) = sum ( DMT_EMEP_grid_nc , 3 ) / DMT_dim_length_nc - 27 3.13 write ( unit_logfile , '(3A,2f16.4)' ) ' Calculating mean: ' , trim ( 'Daily mean temperature' ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc (:,:, 1 )), maxval ( DMT_EMEP_grid_nc (:,:, 1 )) endif endif status_nc = NF90_CLOSE ( id_nc ) enddo !End file loop !Set the correct time dimensions to the first file value dim_length_meteo_nc = valid_dim_length_meteo_nc !Set the grid spacing if ( meteo_nc_projection_type . eq . LL_projection_index ) then meteo_dgrid_nc ( lon_nc_index ) = meteo_var1d_nc ( 2 , x_dim_nc_index ) - meteo_var1d_nc ( 1 , x_dim_nc_index ) meteo_dgrid_nc ( lat_nc_index ) = meteo_var1d_nc ( 2 , y_dim_nc_index ) - meteo_var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing meteo (lon,lat): ' , meteo_dgrid_nc ( lon_nc_index ), meteo_dgrid_nc ( lat_nc_index ) else meteo_dgrid_nc ( lon_nc_index ) = meteo_var1d_nc ( 2 , x_dim_nc_index ) - meteo_var1d_nc ( 1 , x_dim_nc_index ) meteo_dgrid_nc ( lat_nc_index ) = meteo_var1d_nc ( 2 , y_dim_nc_index ) - meteo_var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing meteo (x,y) in meters: ' , meteo_dgrid_nc ( lon_nc_index ), meteo_dgrid_nc ( lat_nc_index ) endif !Do manipulations when the additional meteorology is read in !Put everything in 3d data since it is all surface values write ( unit_logfile , '(A)' ) ' Calculating alternative meteorological data' write ( unit_logfile , '(A,4i)' ) ' Dimensions: ' , dim_length_meteo_nc !logz0 is read in as z0 and must be converted to logz0 do t = 1 , dim_length_meteo_nc ( time_dim_nc_index ) meteo_var3d_nc (:,:, t , logz0_nc_index ) = meteo_var3d_nc (:,:, 1 , logz0_nc_index ) !write(*,*) t,sum(meteo_var3d_nc(:,:,t,logz0_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) enddo where ( meteo_var3d_nc (:,:,:, logz0_nc_index ). lt . 0.001 ) meteo_var3d_nc (:,:,:, logz0_nc_index ) = 0.001 meteo_var3d_nc (:,:,:, logz0_nc_index ) = log ( meteo_var3d_nc (:,:,:, logz0_nc_index )) meteo_var3d_nc (:,:,:, t2m_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, t2m_nc_index ) !Assumes that the first step is 0 and data is hourly. So that the start time step for meteo must correspond to the second hour of any calculation !t=1 !meteo_var3d_nc(:,:,t,Hflux_nc_index)=meteo_var4d_nc(:,:,surface_level_nc,t,Hflux_nc_index)/3600. !meteo_var3d_nc(:,:,t,uw_nc_index)=meteo_var4d_nc(:,:,surface_level_nc,t,uw_nc_index)/3600. !meteo_var3d_nc(:,:,t,vw_nc_index)=meteo_var4d_nc(:,:,surface_level_nc,t,vw_nc_index)/3600. if ( index ( alternative_meteorology_type , 'nbv' ). gt . 0 ) then !Flux is upward and not integrated. Stress is not integrated meteo_var3d_nc (:,:,:, Hflux_nc_index ) =- meteo_var4d_nc (:,:, surface_level_nc ,:, Hflux_nc_index ) meteo_var3d_nc (:,:,:, uw_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, uw_nc_index ) meteo_var3d_nc (:,:,:, vw_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, vw_nc_index ) meteo_var3d_nc (:,:,:, precip_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, precip_nc_index ) else do t = dim_length_meteo_nc ( time_dim_nc_index ), 1 , - 1 meteo_var3d_nc (:,:, t , Hflux_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , Hflux_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , Hflux_nc_index )) / 360 0. meteo_var3d_nc (:,:, t , uw_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , uw_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , uw_nc_index )) / 360 0. meteo_var3d_nc (:,:, t , vw_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , vw_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , vw_nc_index )) / 360 0. meteo_var3d_nc (:,:, t , precip_nc_index ) = ( meteo_var4d_nc (:,:, surface_level_nc , t , precip_nc_index ) - meteo_var4d_nc (:,:, surface_level_nc , t - 1 , precip_nc_index )) !write(*,*) t,sum(meteo_var3d_nc(:,:,t,Hflux_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) & !    ,sum(meteo_var4d_nc(:,:,surface_level_nc,t,hmix_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) enddo endif !Approximate density of air used (1.2 kg/m&#94;3 +/- 10%) meteo_var3d_nc (:,:,:, ustar_nc_index ) = sqrt ( sqrt ( meteo_var3d_nc (:,:,:, uw_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, vw_nc_index ) ** 2 ) / 1.2 ) where ( meteo_var3d_nc (:,:,:, ustar_nc_index ). lt . ustar_min ) meteo_var3d_nc (:,:,:, ustar_nc_index ) = ustar_min !do t=dim_length_meteo_nc(time_dim_nc_index),0,-1 !     write(*,*) t,sum(meteo_var3d_nc(:,:,t,ustar_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) & !        ,sum(meteo_var3d_nc(:,:,t,uw_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) & !        ,sum(meteo_var3d_nc(:,:,t,vw_nc_index))/dim_length_meteo_nc(x_dim_nc_index)/dim_length_meteo_nc(y_dim_nc_index) !enddo !Approximate temperature (273 +/- 10%) !Have inserted the correct temperature now meteo_var3d_nc (:,:,:, invL_nc_index ) = meteo_var3d_nc (:,:,:, Hflux_nc_index ) * 0.4 * 9.8 / 1.2 / 100 4. / meteo_var3d_nc (:,:,:, t2m_nc_index ) / meteo_var3d_nc (:,:,:, ustar_nc_index ) ** 3 !Limit stable L to lowest_stable_L and to lowest_unstable_L (negative number) for unstable. where ( meteo_var3d_nc (:,:,:, invL_nc_index ). lt . 1.0 / lowest_unstable_L ) meteo_var3d_nc (:,:,:, invL_nc_index ) = 1.0 / lowest_unstable_L where ( meteo_var3d_nc (:,:,:, invL_nc_index ). gt . 1.0 / lowest_stable_L ) meteo_var3d_nc (:,:,:, invL_nc_index ) = 1.0 / lowest_stable_L !Put the 10 m wind vectors as the lowest grid level !H_meteo=val_dim_meteo_nc(surface_level_nc,z_dim_nc_index) H_meteo = 1 0. write ( unit_logfile , '(A,f8.2)' ) ' Alternative meteo: setting lowest meteo grid height = ' , H_meteo meteo_var3d_nc (:,:,:, ugrid_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, u10_nc_index ) meteo_var3d_nc (:,:,:, vgrid_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, v10_nc_index ) meteo_var3d_nc (:,:,:, FF10_nc_index ) = meteo_var4d_nc (:,:, surface_level_nc ,:, FF10_nc_index ) if ( sum ( abs ( meteo_var3d_nc (:,:,:, FF10_nc_index ))). eq . 0 ) then !Calculate wind speed if it can't read it meteo_var3d_nc (:,:,:, FF10_nc_index ) = sqrt ( meteo_var3d_nc (:,:,:, ugrid_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, vgrid_nc_index ) ** 2 ) else meteo_var3d_nc (:,:,:, FF10_nc_index ) = sqrt ( meteo_var3d_nc (:,:,:, u10_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, v10_nc_index ) ** 2 ) endif !Smooth the boundary layer height (running mean) and set minimum meteo_var3d_nc (:,:,:, hmix_nc_index ) = 0. do j = 2 , dim_length_meteo_nc ( y_dim_nc_index ) - 1 do i = 2 , dim_length_meteo_nc ( x_dim_nc_index ) - 1 do jj =- 1 , 1 do ii =- 1 , 1 meteo_var3d_nc ( i , j ,:, hmix_nc_index ) = meteo_var3d_nc ( i , j ,:, hmix_nc_index ) + meteo_var4d_nc ( i + ii , j + jj , surface_level_nc ,:, hmix_nc_index ) / 9. !if (ii.ne.0.and.jj.ne.0) then !    var3d_nc(i,j,:,hmix_nc_index,allsource_index)=var3d_nc(i,j,:,hmix_nc_index,allsource_index)-var3d_nc(i+ii,j+jj,:,hmix_nc_index,traffic_index)/8. !endif enddo enddo enddo enddo where ( meteo_var3d_nc (:,:,:, hmix_nc_index ). lt . hmix_min ) meteo_var3d_nc (:,:,:, hmix_nc_index ) = hmix_min where ( meteo_var3d_nc (:,:,:, hmix_nc_index ). gt . hmix_max ) meteo_var3d_nc (:,:,:, hmix_nc_index ) = hmix_max where ( meteo_var3d_nc (:,:,:, ustar_nc_index ). lt . ustar_min ) meteo_var3d_nc (:,:,:, ustar_nc_index ) = ustar_min !do t=dim_length_nc(time_dim_nc_index),2,-1 !    write(*,*) t,sum(var3d_nc(:,:,t,hmix_nc_index,allsource_nc_index))/dim_length_nc(x_dim_nc_index)/dim_length_nc(y_dim_nc_index) !enddo write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( logz0_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), logz0_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), logz0_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( ustar_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ustar_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ustar_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( Hflux_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), Hflux_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), Hflux_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( invL_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), invL_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), invL_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( ugrid_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ugrid_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), ugrid_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( vgrid_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), vgrid_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), vgrid_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( FF10_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), FF10_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), FF10_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( hmix_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), hmix_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), hmix_nc_index )) write ( unit_logfile , '(3A,2f16.4)' ) ' Alternative meteo: ' , trim ( var_name_meteo_nc ( t2m_nc_index )), ' (min, max): ' , minval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), t2m_nc_index )), maxval ( meteo_var3d_nc (:,:, 1 : dim_length_meteo_nc ( time_dim_nc_index ), t2m_nc_index )) !If no logz0 available. Set to log(0.1) !For urban areas a value of 0.3 is used !where (var3d_nc(:,:,:,logz0_nc_index,:).eq.0.0) var3d_nc(:,:,:,logz0_nc_index,:)=log(0.3) if ( replace_z0 . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing z0 everywhere with: ' , replace_z0 meteo_var3d_nc (:,:,:, logz0_nc_index ) = log ( replace_z0 ) endif if ( replace_invL . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing inverse L everywhere with: ' , replace_invL meteo_var3d_nc (:,:,:, invL_nc_index ) = replace_invL endif if ( replace_hmix . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing HMIX everywhere with: ' , replace_hmix meteo_var3d_nc (:,:,:, hmix_nc_index ) = replace_hmix endif if ( FF_scale . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rescaling wind fields everywhere with factor: ' , FF_scale meteo_var3d_nc (:,:,:, ustar_nc_index ) = meteo_var3d_nc (:,:,:, ustar_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, FF10_nc_index ) = meteo_var3d_nc (:,:,:, FF10_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, inv_FF10_nc_index ) = meteo_var3d_nc (:,:,:, inv_FF10_nc_index ) / FF_scale meteo_var3d_nc (:,:,:, ugrid_nc_index ) = meteo_var3d_nc (:,:,:, ugrid_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, vgrid_nc_index ) = meteo_var3d_nc (:,:,:, vgrid_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, inv_FFgrid_nc_index ) = meteo_var3d_nc (:,:,:, inv_FFgrid_nc_index ) / FF_scale meteo_var3d_nc (:,:,:, ugrid_nc_index ) = meteo_var3d_nc (:,:,:, ugrid_nc_index ) * FF_scale meteo_var3d_nc (:,:,:, vgrid_nc_index ) = meteo_var3d_nc (:,:,:, vgrid_nc_index ) * FF_scale endif if ( FF10_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Offsetting 10 m wind fields everywhere with a value: ' , FF10_offset meteo_var3d_nc (:,:,:, FF10_nc_index ) = meteo_var3d_nc (:,:,:, FF10_nc_index ) + FF10_offset endif if ( DD_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rotating wind fields everywhere with a value: ' , DD_offset if (. not . allocated ( temp_meteo_var3d_nc )) allocate ( temp_meteo_var3d_nc ( valid_dim_length_meteo_nc ( x_dim_nc_index ), valid_dim_length_meteo_nc ( y_dim_nc_index ), valid_dim_length_meteo_nc ( time_dim_nc_index ), 2 )) temp_meteo_var3d_nc (:,:,:, 1 ) = meteo_var3d_nc (:,:,:, ugrid_nc_index ) * cos ( DD_offset / 18 0. * 3.14159 ) + meteo_var3d_nc (:,:,:, vgrid_nc_index ) * sin ( DD_offset / 18 0. * 3.14159 ) temp_meteo_var3d_nc (:,:,:, 2 ) =- meteo_var3d_nc (:,:,:, ugrid_nc_index ) * sin ( DD_offset / 18 0. * 3.14159 ) + meteo_var3d_nc (:,:,:, vgrid_nc_index ) * cos ( DD_offset / 18 0. * 3.14159 ) meteo_var3d_nc (:,:,:, ugrid_nc_index ) = temp_meteo_var3d_nc (:,:,:, 1 ) meteo_var3d_nc (:,:,:, vgrid_nc_index ) = temp_meteo_var3d_nc (:,:,:, 2 ) endif !Set the magnitude of the gridded wind fields. Should probably be done after subgridding? meteo_var3d_nc (:,:,:, FFgrid_nc_index ) = sqrt ( meteo_var3d_nc (:,:,:, ugrid_nc_index ) ** 2 + meteo_var3d_nc (:,:,:, vgrid_nc_index ) ** 2 ) !Check meteo time which comes in seconds since 1970. Converts to days. if ( use_alternative_meteorology_flag ) then date_num_temp = val_dim_meteo_nc ( 1 , time_dim_nc_index ) / 360 0. / 2 4. + 3 0. / 2 4. / 360 0. call number_to_date ( date_num_temp , date_array , ref_year_meteo ) write ( unit_logfile , '(a,i6)' ) ' Time dimension meteo: ' , dim_length_meteo_nc ( time_dim_nc_index ) write ( unit_logfile , '(a,6i6)' ) ' Date start meteo = ' , date_array !date_num_temp=dble(ceiling(val_dim_meteo_nc(dim_length_meteo_nc(time_dim_nc_index),time_dim_nc_index)/3600.))/24. date_num_temp = val_dim_meteo_nc ( dim_length_meteo_nc ( time_dim_nc_index ), time_dim_nc_index ) / 360 0. / 2 4. + 3 0. / 2 4. / 360 0. call number_to_date ( date_num_temp , date_array , ref_year_meteo ) write ( unit_logfile , '(a,6i6)' ) ' Date end meteo =   ' , date_array !write(*,*) start_time_meteo_nc_index,valid_dim_length_meteo_nc(time_dim_nc_index) endif !do t=1,dim_length_meteo_nc(time_dim_nc_index) !    date_num_temp=val_dim_meteo_nc(t,time_dim_nc_index)/3600./24.+0.1/24. !    call number_to_date(date_num_temp,date_array,ref_year_meteo) !    write(unit_logfile,'(a,i4,6i6,f12.4)') ' Date end meteo =   ',t,date_array,date_num_temp !enddo !stop if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_meteo_var3d_nc )) deallocate ( temp_meteo_var3d_nc ) if ( allocated ( meteo_var4d_nc )) deallocate ( meteo_var4d_nc ) end subroutine uEMEP_read_meteo_nc end module read_meteo_nc","tags":"","loc":"sourcefile/uemep_read_meteo_nc.f90.html"},{"title":"uEMEP_subgrid_EMEP.f90 – uEMEP","text":"Source Code module subgrid_emep use uEMEP_definitions use uemep_constants , only : pi use uemep_configuration use mod_lambert_projection , only : LL2PROJ , PROJ2LL implicit none private public :: uEMEP_subgrid_EMEP , uEMEP_subgrid_EMEP_from_in_region contains !========================================================================== !   uEMEP_subgrid_EMEP !   Bruce Rolstad Denby !   MET Norway ! !   This routine calculates the local and nonlocal contribution of the EMEP !   grid at each subgrid point using a moving window. The local contribution !   is then later removed and replaced by the local dispersion or is used !   to redistribute concentrations. The moving window must take into account !   edges of the EMEP grid. The nonlocal_correction deals with grid contributions !   outside the central EMEP grid ! !   The following options are available: !   EMEP_grid_interpolation_flag=0 is no interpolation, just uses the EMEP grid it is in !   EMEP_grid_interpolation_flag=1 is area weighted (same as bilinear interpolation, quickest) !   EMEP_grid_interpolation_flag=2 is emission subgrid weighted (slowest) !   EMEP_grid_interpolation_flag=3 is emission aggregated to integral weighted (recommended, faster) !   EMEP_grid_interpolation_flag=4 is proxy dispersion integral weighted (similar to 3 but needs integral dispersion calculation) ! !========================================================================== subroutine uEMEP_subgrid_EMEP integer i , j integer ii , jj , tt , iii , jjj real , allocatable :: weighting_nc (:,:,:,:), weighting_subgrid (:,:,:,:,:) real , allocatable :: total_weighting_nc (:,:,:,:,:), proxy_weighting_nc (:,:,:,:,:) real , allocatable :: area_weighting_nc (:,:,:,:,:,:) integer i_nc_start , i_nc_end , j_nc_start , j_nc_end integer i_start , i_end , j_start , j_end , t_start , t_end real xpos_min , xpos_max , ypos_min , ypos_max real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_min2 , xpos_max2 , ypos_min2 , ypos_max2 real xpos_min3 , xpos_max3 , ypos_min3 , ypos_max3 real xpos_area_min2 , xpos_area_max2 , ypos_area_min2 , ypos_area_max2 integer i_nc , j_nc integer emep_subsource real , allocatable :: nonlocal_correction (:,:,:) real , allocatable :: nonlocal_correction_average (:,:) integer i_source integer ii_nc , jj_nc , ii_w , jj_w integer :: n_weight = 3 , ii_w0 = 2 , jj_w0 = 2 integer weighting_subgrid_dim ( 2 , n_source_index ) integer i_cross , j_cross integer , allocatable :: crossreference_weighting_to_emep_subgrid (:,:,:,:) integer i_w_c , j_w_c integer i_nc_c , j_nc_c integer count integer ii_start , ii_end , jj_start , jj_end integer iii_start , iii_end , jjj_start , jjj_end real xpos_limit , ypos_limit real xpos_limit2 , ypos_limit2 real xpos_subgrid , ypos_subgrid real xpos_emission_subgrid , ypos_emission_subgrid real xpos_integral_subgrid , ypos_integral_subgrid real EMEP_grid_interpolation_size_sqr integer :: tt_dim = 1 integer ii_nc_w0 , jj_nc_w0 , iii_nc_w , jjj_nc_w integer ii_nc_w , jj_nc_w real weighting_val , weighting_val3 integer i_pollutant , i_loop integer i_sp , ii_sp real , allocatable :: EMEP_local_contribution (:,:,:,:) real , allocatable :: EMEP_local_contribution_from_in_region (:,:,:,:) integer n_weight_nc_x , n_weight_nc_y real dgrid_lf_offset_x , dgrid_lf_offset_y real amod_temp real EMEP_grid_interpolation_size_saved real local_fraction_grid_size_scaling_temp real weight_check real xpos_lf_area_min , xpos_lf_area_max , ypos_lf_area_min , ypos_lf_area_max logical :: first_interpolate_lf = . false . logical :: set_lf_offset_to_0 = . true . integer lf_size_index real , allocatable :: temp_subgrid (:,:,:,:) real , allocatable :: temp_comp_EMEP_subgrid (:,:) real , allocatable :: temp_species_EMEP_subgrid (:,:,:) real , allocatable :: temp_EMEP (:,:,:,:,:,:) real , allocatable :: temp_EMEP_from_in_region (:,:,:,:,:,:) real , allocatable :: temp_species_EMEP (:,:,:,:,:) real , allocatable :: temp_comp_EMEP (:,:,:,:) real distance_grid_x , distance_grid_y integer temp_count character ( len = :), allocatable :: fmt write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Distributing EMEP concentrations to subgrids  (uEMEP_subgrid_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !Initialise subgrids to be written to subgrid (:,:,:, emep_subgrid_index ,:,:) = 0 subgrid (:,:,:, emep_frac_subgrid_index ,:,:) = 0 subgrid (:,:,:, emep_local_subgrid_index ,:,:) = 0 subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) = 0 comp_EMEP_subgrid (:,:,:,:) = 0 orig_EMEP_subgrid (:,:,:,:) = 0 if ( save_emep_species . or . save_seasalt ) species_EMEP_subgrid (:,:,:,:,:) = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source )) then write ( unit_logfile , '(2A)' ) 'Calculating for EMEP source: ' , trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) endif if ( save_EMEP_source ( i_source )) then write ( unit_logfile , '(2A)' ) 'Saving for EMEP source: ' , trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) endif enddo !Check if the additional EMEP calculation is to be carried out and set parameters EMEP_grid_interpolation_size_saved = EMEP_grid_interpolation_size lc_local_nc_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_grid_interpolation ) local_fraction_grid_size_scaling_temp = local_fraction_grid_size_scaling lf_size_index = 1 if ( calculate_EMEP_additional_grid_flag ) then EMEP_grid_interpolation_size = EMEP_additional_grid_interpolation_size local_fraction_grid_size_scaling_temp = local_fraction_additional_grid_size_scaling lc_local_nc_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_additional_grid_interpolation ) lf_size_index = 2 write ( unit_logfile , '(A,i)' ) 'Calculating additional EMEP concentrations to subgrids, index:' , lc_local_nc_index else write ( unit_logfile , '(A,i)' ) 'Calculating EMEP concentrations to subgrids, index:' , lc_local_nc_index endif !Set value used later EMEP_grid_interpolation_size_sqr = EMEP_grid_interpolation_size * EMEP_grid_interpolation_size !Time dimension when external time loop is used tt_dim = 1 !Allocate nonlocal_correction if (. not . allocated ( nonlocal_correction )) allocate ( nonlocal_correction ( tt_dim , n_source_index , n_pollutant_loop )) if (. not . allocated ( nonlocal_correction_average )) allocate ( nonlocal_correction_average ( n_source_index , n_pollutant_loop )) !There are no subsources in EMEP emep_subsource = 1 !Initialise a diagnostic check variable for the weighting nonlocal_correction_average = 0. !Save the original EMEP directly to subgrid for comparison and visualisation purposes on the target subgrid write ( unit_logfile , '(A)' ) 'Calculating original EMEP subgrid using nearest neighbour interpolation' do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then ii = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !Nearest neighbour interpolate the EMEP compounds to subgrid if ( ii . ge . 1. and . ii . le . dim_length_nc ( x_dim_nc_index ). and . jj . ge . 1. and . jj . le . dim_length_nc ( y_dim_nc_index )) then do i_pollutant = 1 , n_emep_pollutant_loop do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) !write(*,*) trim(pollutant_file_str(pollutant_compound_loop_index(i_pollutant,i_loop))) orig_EMEP_subgrid ( i , j ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_var3d_nc ( ii , jj ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) enddo enddo endif endif enddo enddo !Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. if ( EMEP_grid_interpolation_flag . eq . 0. or . EMEP_grid_interpolation_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using nearest neighbour interpolation' jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !Window does not extend outside the grid, since it is centred on the EMEP grid if ( EMEP_grid_interpolation_size . le . 1 ) then jj_start = 0 ii_start = 0 jj_end = 0 ii_end = 0 endif write ( unit_logfile , '(A,4i)' ) 'LF loop (ii_start,ii_end,jj_start,jj_end): ' , ii_start , ii_end , jj_start , jj_end ii_nc_w0 = xdist_centre_nc jj_nc_w0 = ydist_centre_nc !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) n_weight_nc_x = xdist_centre_nc * 2 - 1 n_weight_nc_y = ydist_centre_nc * 2 - 1 !Set the size of the region surounding the target grid that is searched xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !Do the calculation everywhere when EMEP_grid_interpolation_flag=5 since it uses the subgrid values later if ( use_subgrid ( i , j , allsource_index ). or . EMEP_grid_interpolation_flag . eq . 5 ) then i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) if ( i_nc . ge . 1. and . i_nc . le . dim_length_nc ( x_dim_nc_index ). and . j_nc . ge . 1. and . j_nc . le . dim_length_nc ( y_dim_nc_index )) then !Read from the local fraction file subgrid ( i , j ,:, emep_subgrid_index ,:,:) = var3d_nc ( i_nc , j_nc ,:, conc_nc_index , 1 : n_source_index ,:) !subgrid(i,j,:,emep_local_subgrid_index,:,:)=var3d_nc(i_nc,j_nc,:,local_nc_index,:,:) !Centre of grid xpos_subgrid = var1d_nc ( i_nc , lon_nc_index ) ypos_subgrid = var1d_nc ( j_nc , lat_nc_index ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit !Set the offset to the centre of the local fraction grid when using larger local fraction grids !Requires knowledge of the total EMEP grid index so uses dim_start_nc amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !dgrid_lf_offset_x=0 !dgrid_lf_offset_y=0 !Calculate the local fraction contribution from within the moving window, limited on the edges. subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = 0 weight_check = 0 do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_nc_w = ii + ii_nc_w0 jj_nc_w = jj + jj_nc_w0 ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index ) & . and . ii_nc_w . ge . 1. and . ii_nc_w . le . n_weight_nc_x . and . jj_nc_w . ge . 1. and . jj_nc_w . le . n_weight_nc_y ) then xpos_lf_area_min = var1d_nc ( i_nc , lon_nc_index ) + ( ii - 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp xpos_lf_area_max = var1d_nc ( i_nc , lon_nc_index ) + ( ii + 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_min = var1d_nc ( j_nc , lat_nc_index ) + ( jj - 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_max = var1d_nc ( j_nc , lat_nc_index ) + ( jj + 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp !Set the edges to an EMEP grid surounding the EMEP grid being assessed !xpos_min=max(xpos_area_min,var1d_nc(ii_nc,lon_nc_index)-dgrid_nc(lon_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_x*dgrid_nc(lon_nc_index)*local_fraction_grid_size_scaling_temp) !xpos_max=min(xpos_area_max,var1d_nc(ii_nc,lon_nc_index)+dgrid_nc(lon_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_x*dgrid_nc(lon_nc_index)*local_fraction_grid_size_scaling_temp) !ypos_min=max(ypos_area_min,var1d_nc(jj_nc,lat_nc_index)-dgrid_nc(lat_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_y*dgrid_nc(lat_nc_index)*local_fraction_grid_size_scaling_temp) !ypos_max=min(ypos_area_max,var1d_nc(jj_nc,lat_nc_index)+dgrid_nc(lat_nc_index)/2.*local_fraction_grid_size_scaling_temp+dgrid_lf_offset_y*dgrid_nc(lat_nc_index)*local_fraction_grid_size_scaling_temp) xpos_min = max ( xpos_area_min , xpos_lf_area_min ) xpos_max = min ( xpos_area_max , xpos_lf_area_max ) ypos_min = max ( ypos_area_min , ypos_lf_area_min ) ypos_max = min ( ypos_area_max , ypos_lf_area_max ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_val = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val = 0. endif !weighting_val=1. weight_check = weight_check + weighting_val !write(*,'(2i,5f12.2,f12.4)') ii,jj,weighting_val,xpos_lf_area_min-xpos_subgrid,xpos_lf_area_max-xpos_subgrid & !    ,xpos_area_min-xpos_subgrid,xpos_area_max-xpos_subgrid,dgrid_lf_offset_x subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) & + lc_var3d_nc ( ii_nc_w , jj_nc_w , i_nc , j_nc ,:, lc_local_nc_index , 1 : n_source_index ,:) * weighting_val endif enddo enddo !write(*,*) 'Check: ',(subgrid(i,j,1,emep_local_subgrid_index,traffic_index,1)),(subgrid(i,j,1,emep_subgrid_index,allsource_index,1)) !Interpolate the other EMEP compounds as well to subgrid in the same way. Read from the normal EMEP file !comp_var3d_nc(ii,jj,:,pollutant_compound_loop_index(i_pollutant,i_loop)) do i_pollutant = 1 , n_emep_pollutant_loop do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) comp_EMEP_subgrid ( i , j ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_var3d_nc ( i_nc , j_nc ,:, pollutant_compound_loop_index ( i_pollutant , i_loop )) enddo enddo if ( save_emep_species . or . save_seasalt ) then do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index species_EMEP_subgrid ( i , j ,:, i_loop , i_sp ) = species_var3d_nc ( i_nc , j_nc ,:, i_loop , i_sp ) enddo enddo endif endif endif enddo enddo !Set the non-local for each source individually subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) = subgrid (:,:,:, emep_subgrid_index ,:,:) - subgrid (:,:,:, emep_local_subgrid_index ,:,:) if ( calculate_deposition_flag ) then subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) endif endif !Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. if ( EMEP_grid_interpolation_flag . eq . 6 ) then write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using method 6. First contribution to grid then area interpolation' if (. not . allocated ( temp_EMEP )) allocate ( temp_EMEP ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , n_pollutant_loop )) if (. not . allocated ( temp_comp_EMEP )) allocate ( temp_comp_EMEP ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_compound_index )) temp_EMEP = 0 temp_comp_EMEP = 0 if ( save_emep_species . or . save_seasalt ) then if (. not . allocated ( temp_species_EMEP )) allocate ( temp_species_EMEP ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_pmxx_sp_index , n_species_loop_index )) temp_species_EMEP = 0 endif !Set the extent of the LF grid to be assessed jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !Window does not extend outside the grid, since it is centred on the EMEP grid if ( EMEP_grid_interpolation_size . le . 1 ) then jj_start = 0 ii_start = 0 jj_end = 0 ii_end = 0 endif write ( unit_logfile , '(A,4i)' ) 'LF loop (ii_start,ii_end,jj_start,jj_end): ' , ii_start , ii_end , jj_start , jj_end ii_nc_w0 = xdist_centre_nc jj_nc_w0 = ydist_centre_nc !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) n_weight_nc_x = xdist_centre_nc * 2 - 1 n_weight_nc_y = ydist_centre_nc * 2 - 1 !Set the size of the region surounding the target grid that is searched xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp !Set the size of the region for the area interpoaltion xpos_limit2 = dgrid_nc ( lon_nc_index ) / 2. ypos_limit2 = dgrid_nc ( lat_nc_index ) / 2. !Limits for the area interpolation jjj_start =- 1 iii_start =- 1 jjj_end = 1 iii_end = 1 !Loop through the EMEP grids and create the local contribution in the EMEP grid do j_nc = 1 , dim_length_nc ( y_dim_nc_index ) do i_nc = 1 , dim_length_nc ( x_dim_nc_index ) !i_nc=crossreference_target_to_emep_subgrid(i,j,x_dim_index) !j_nc=crossreference_target_to_emep_subgrid(i,j,y_dim_index) !if (i_nc.ge.1.and.i_nc.le.dim_length_nc(x_dim_nc_index).and.j_nc.ge.1.and.j_nc.le.dim_length_nc(y_dim_nc_index)) then !Read from the local fraction file temp_EMEP ( i_nc , j_nc ,:, emep_subgrid_index , 1 : n_source_index ,:) = var3d_nc ( i_nc , j_nc ,:, conc_nc_index , 1 : n_source_index ,:) !Centre of EMEP grid in lat lon or local coordinates xpos_subgrid = var1d_nc ( i_nc , lon_nc_index ) ypos_subgrid = var1d_nc ( j_nc , lat_nc_index ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit !Set the offset to the centre of the local fraction grid when using larger local fraction grids !Requires knowledge of the total EMEP grid index so uses dim_start_nc amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !Calculate the local fraction contribution to the EMEP grid centre, limited on the edges. temp_EMEP ( i_nc , j_nc ,:, emep_local_subgrid_index ,:,:) = 0 weight_check = 0 do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_nc_w = ii + ii_nc_w0 jj_nc_w = jj + jj_nc_w0 ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index ) & . and . ii_nc_w . ge . 1. and . ii_nc_w . le . n_weight_nc_x . and . jj_nc_w . ge . 1. and . jj_nc_w . le . n_weight_nc_y ) then xpos_lf_area_min = var1d_nc ( i_nc , lon_nc_index ) + ( ii - 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp xpos_lf_area_max = var1d_nc ( i_nc , lon_nc_index ) + ( ii + 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_min = var1d_nc ( j_nc , lat_nc_index ) + ( jj - 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_max = var1d_nc ( j_nc , lat_nc_index ) + ( jj + 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min = max ( xpos_area_min , xpos_lf_area_min ) xpos_max = min ( xpos_area_max , xpos_lf_area_max ) ypos_min = max ( ypos_area_min , ypos_lf_area_min ) ypos_max = min ( ypos_area_max , ypos_lf_area_max ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_val = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val = 0. endif !weighting_val=1. weight_check = weight_check + weighting_val !write(*,'(2i,5f12.2,f12.4)') ii,jj,weighting_val,xpos_lf_area_min-xpos_subgrid,xpos_lf_area_max-xpos_subgrid & !    ,xpos_area_min-xpos_subgrid,xpos_area_max-xpos_subgrid,dgrid_lf_offset_x temp_EMEP ( i_nc , j_nc ,:, emep_local_subgrid_index , 1 : n_source_index ,:) = temp_EMEP ( i_nc , j_nc ,:, emep_local_subgrid_index , 1 : n_source_index ,:) & + lc_var3d_nc ( ii_nc_w , jj_nc_w , i_nc , j_nc ,:, lc_local_nc_index , 1 : n_source_index ,:) * weighting_val endif enddo enddo !write(*,*) 'Check: ',(temp_EMEP(i_nc,j_nc,1,emep_local_subgrid_index,traffic_index,1)),(temp_EMEP(i_nc,j_nc,1,emep_subgrid_index,allsource_index,1)) !Interpolate the other EMEP compounds as well to subgrid in the same way. Read directly from the normal EMEP file !do i_pollutant=1,n_emep_pollutant_loop !do i_loop=1,n_pollutant_compound_loop(i_pollutant) !    temp_comp_EMEP(i_nc,j_nc,:,pollutant_compound_loop_index(i_pollutant,i_loop))=comp_var3d_nc(i_nc,j_nc,:,pollutant_compound_loop_index(i_pollutant,i_loop)) !enddo !enddo temp_comp_EMEP ( i_nc , j_nc ,:,:) = comp_var3d_nc ( i_nc , j_nc ,:,:) if ( save_emep_species . or . save_seasalt ) then temp_species_EMEP ( i_nc , j_nc ,:,:,:) = species_var3d_nc ( i_nc , j_nc ,:,:,:) !do i_sp=1,n_species_loop_index !ii_sp=species_loop_index(i_sp) !do i_loop=1,n_pmxx_sp_index !    temp_species_EMEP(i_nc,j_nc,:,i_loop,i_sp)=species_var3d_nc(i_nc,j_nc,:,i_loop,i_sp) !enddo !enddo endif !endif !endif enddo enddo subgrid (:,:,:, emep_local_subgrid_index ,:,:) = 0 comp_EMEP_subgrid = 0 species_EMEP_subgrid = 0 !Loop through the subgrids and allocate the temp_EMEP grids using area weighting do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then !Assumes it is never on the edge of the EMEP grid as it is not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Are xpos_limit2 in the same coordinates? xpos_area_min2 = xpos_subgrid - xpos_limit2 xpos_area_max2 = xpos_subgrid + xpos_limit2 ypos_area_min2 = ypos_subgrid - ypos_limit2 ypos_area_max2 = ypos_subgrid + ypos_limit2 !Limit the region. This will still allow an EMEP contribution from half a grid away !Same limit is NOT applied on the emissions in the moving window so inconsistent !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max if ( limit_emep_grid_interpolation_region_to_calculation_region ) then xpos_area_min = max ( xpos_area_min , subgrid_proj_min ( x_dim_index ) - xpos_subgrid - xpos_limit2 ) xpos_area_max = min ( xpos_area_max , subgrid_proj_max ( x_dim_index ) - xpos_subgrid + xpos_limit2 ) ypos_area_min = max ( ypos_area_min , subgrid_proj_min ( y_dim_index ) - ypos_subgrid - ypos_limit2 ) ypos_area_max = min ( ypos_area_max , subgrid_proj_max ( y_dim_index ) - ypos_subgrid + ypos_limit2 ) endif !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max !Set the offset to the centre of the local fraction grid when using larger local fraction grids amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !Loop through the +1, -1 grids do jj = jjj_start , jjj_end do ii = iii_start , iii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min2 = max ( xpos_area_min2 , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max2 = min ( xpos_area_max2 , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min2 = max ( ypos_area_min2 , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max2 = min ( ypos_area_max2 , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Calculate area weighting if ( xpos_max2 . gt . xpos_min2 . and . ypos_max2 . gt . ypos_min2 ) then weighting_val = ( ypos_max2 - ypos_min2 ) * ( xpos_max2 - xpos_min2 ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_val = 0. endif !write(*,*) i,j,ii_nc,jj_nc,weighting_val,temp_EMEP(ii_nc,jj_nc,1,emep_local_subgrid_index,1,1) !Area weighting (interpolated) EMEP concentrations, independent of where it comes from subgrid ( i , j ,:, emep_subgrid_index , 1 : n_source_index ,:) = subgrid ( i , j ,:, emep_subgrid_index , 1 : n_source_index ,:) + temp_EMEP ( ii_nc , jj_nc ,:, emep_subgrid_index , 1 : n_source_index ,:) * weighting_val subgrid ( i , j ,:, emep_local_subgrid_index , 1 : n_source_index ,:) = subgrid ( i , j ,:, emep_local_subgrid_index , 1 : n_source_index ,:) + temp_EMEP ( ii_nc , jj_nc ,:, emep_local_subgrid_index , 1 : n_source_index ,:) * weighting_val !var3d_nc(ii_nc,jj_nc,tt,conc_nc_index,1:n_source_index,:)*weighting_val !do i_pollutant=1,n_emep_pollutant_loop !do i_loop=1,n_pollutant_compound_loop(i_pollutant) !    comp_EMEP_subgrid(i,j,:,pollutant_compound_loop_index(i_pollutant,i_loop))=comp_EMEP_subgrid(i,j,:,pollutant_compound_loop_index(i_pollutant,i_loop))+temp_comp_EMEP(ii_nc,jj_nc,:,pollutant_compound_loop_index(i_pollutant,i_loop))*weighting_val !               ! +comp_var3d_nc(ii_nc,jj_nc,tt,pollutant_compound_loop_index(i_pollutant,i_loop))*weighting_val !enddo !enddo comp_EMEP_subgrid ( i , j ,:,:) = comp_EMEP_subgrid ( i , j ,:,:) + temp_comp_EMEP ( ii_nc , jj_nc ,:,:) * weighting_val if ( save_emep_species . or . save_seasalt ) then species_EMEP_subgrid ( i , j ,:,:,:) = species_EMEP_subgrid ( i , j ,:,:,:) + temp_species_EMEP ( ii_nc , jj_nc ,:,:,:) * weighting_val !do i_sp=1,n_species_loop_index !ii_sp=species_loop_index(i_sp) !do i_loop=1,n_pmxx_sp_index !    species_EMEP_subgrid(i,j,:,i_loop,i_sp)=species_EMEP_subgrid(i,j,:,i_loop,i_sp)+temp_species_EMEP(ii_nc,jj_nc,:,i_loop,i_sp)*weighting_val !       ! +species_var3d_nc(ii_nc,jj_nc,tt,i_loop,i_sp)*weighting_val !enddo !enddo endif endif enddo enddo endif enddo enddo !Set the non-local for each source individually subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) = subgrid (:,:,:, emep_subgrid_index ,:,:) - subgrid (:,:,:, emep_local_subgrid_index ,:,:) if ( calculate_deposition_flag ) then subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) endif if ( allocated ( temp_EMEP )) deallocate ( temp_EMEP ) if ( allocated ( temp_comp_EMEP )) deallocate ( temp_comp_EMEP ) if ( allocated ( temp_species_EMEP )) deallocate ( temp_species_EMEP ) if ( allocated ( temp_EMEP_from_in_region )) deallocate ( temp_EMEP_from_in_region ) endif !Areal interpolation of the subgrid nearest neighbour calculations EMEP_grid_interpolation_flag=0 !Do not use, very slow if ( EMEP_grid_interpolation_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'Interpolating uEMEP local subgrid nearest neighbour contributions using area weighted interpolation' if (. not . allocated ( temp_subgrid )) allocate ( temp_subgrid ( subgrid_dim ( t_dim_index ), n_subgrid_index , n_source_index , n_pollutant_loop )) if (. not . allocated ( temp_comp_EMEP_subgrid )) allocate ( temp_comp_EMEP_subgrid ( subgrid_dim ( t_dim_index ), n_compound_index )) if (. not . allocated ( temp_species_EMEP_subgrid )) allocate ( temp_species_EMEP_subgrid ( subgrid_dim ( t_dim_index ), n_pmxx_sp_index , n_species_loop_index )) !Set the loop sizes for the local area interpolation jjj_start =- 1 iii_start =- 1 jjj_end = 1 iii_end = 1 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !Do this calculation everywhere !if (use_subgrid(i,j,allsource_index)) then if ( EMEP_projection_type . eq . LL_projection_index ) then distance_grid_x = 11100 0. * dgrid_nc ( lon_nc_index ) * cos ( lat_subgrid ( i , j ) * pi / 18 0. ) distance_grid_y = 11100 0. * dgrid_nc ( lat_nc_index ) else !Assumed LCC or PS distance_grid_x = dgrid_nc ( lon_nc_index ) distance_grid_y = dgrid_nc ( lat_nc_index ) endif xpos_limit = distance_grid_x / 2. ypos_limit = distance_grid_y / 2. jj_start =- int (( ypos_limit ) / subgrid_delta ( y_dim_index )) ii_start =- int (( xpos_limit ) / subgrid_delta ( x_dim_index )) jj_end =+ int (( ypos_limit ) / subgrid_delta ( y_dim_index )) ii_end =+ int (( xpos_limit ) / subgrid_delta ( x_dim_index )) !Initialise arrays temp_subgrid (:, emep_subgrid_index ,:,:) = 0 temp_subgrid (:, emep_frac_subgrid_index ,:,:) = 0 temp_subgrid (:, emep_local_subgrid_index ,:,:) = 0 temp_subgrid (:, emep_nonlocal_subgrid_index ,:,:) = 0 temp_comp_EMEP_subgrid (:,:) = 0 temp_species_EMEP_subgrid (:,:,:) = 0 temp_count = 0 !write(*,*) i,j,ii_end,jj_end jjj_start = max ( 1 , j + jj_start ) iii_start = max ( 1 , i + ii_start ) jjj_end = min ( subgrid_dim ( y_dim_index ), j + jj_end ) iii_end = min ( subgrid_dim ( x_dim_index ), i + ii_end ) temp_subgrid (:,:,:,:) = sum ( sum ( subgrid ( iii_start : iii_end , jjj_start : jjj_end ,:,:,:,:), 1 ), 1 ) temp_comp_EMEP_subgrid (:,:) = sum ( sum ( comp_EMEP_subgrid ( iii_start : iii_end , jjj_start : jjj_end ,:,:), 1 ), 1 ) temp_species_EMEP_subgrid (:,:,:) = sum ( sum ( species_EMEP_subgrid ( iii_start : iii_end , jjj_start : jjj_end ,:,:,:), 1 ), 1 ) temp_count = ( iii_end - iii_start + 1 ) * ( jjj_end - jjj_start + 1 ) if ( temp_count . gt . 0 ) then subgrid ( i , j ,:, emep_subgrid_index ,:,:) = temp_subgrid (:, emep_subgrid_index ,:,:) / temp_count subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = temp_subgrid (:, emep_local_subgrid_index ,:,:) / temp_count subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) = temp_subgrid (:, emep_nonlocal_subgrid_index ,:,:) / temp_count comp_EMEP_subgrid ( i , j ,:,:) = temp_comp_EMEP_subgrid (:,:) / temp_count species_EMEP_subgrid ( i , j ,:,:,:) = temp_species_EMEP_subgrid (:,:,:) / temp_count else subgrid ( i , j ,:, emep_subgrid_index ,:,:) = 0 subgrid ( i , j ,:, emep_local_subgrid_index ,:,:) = 0 subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) = 0 species_EMEP_subgrid ( i , j ,:,:,:) = 0 endif !endif enddo enddo if ( allocated ( temp_subgrid )) deallocate ( temp_subgrid ) if ( allocated ( temp_comp_EMEP_subgrid )) deallocate ( temp_comp_EMEP_subgrid ) if ( allocated ( temp_species_EMEP_subgrid )) deallocate ( temp_species_EMEP_subgrid ) endif !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) !Loop through the time and the subgrids do tt = t_start , t_end !Quick calculation of area weighting, no edge effects. Does not need to change with time !This is done also if there is moving window weighting later as it is used for the nonlocal contribution !This is the old version no longer in use if ( EMEP_grid_interpolation_flag . eq . - 1. or .( EMEP_grid_interpolation_flag . gt . 1. and . EMEP_grid_interpolation_flag . lt . 5 )) then if ( tt . eq . t_start ) write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using area weighted interpolation (obsolete version)' !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) if ( tt . eq . t_start ) write ( unit_logfile , * ) 'Weighting grid dimensions and centres: ' , n_weight , ii_w0 , jj_w0 if (. not . allocated ( weighting_nc )) allocate ( weighting_nc ( n_weight , n_weight , tt_dim , n_source_index )) !EMEP grid weighting for interpolation. Does not need a source index for area weighting if (. not . allocated ( area_weighting_nc )) allocate ( area_weighting_nc ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_weight , n_weight , tt_dim , n_source_index )) !EMEP grid weighting for area interpolation !Initialise arrays subgrid (:,:, tt , emep_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_frac_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_local_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_nonlocal_subgrid_index ,:,:) = 0 comp_EMEP_subgrid (:,:, tt ,:) = 0 species_EMEP_subgrid (:,:, tt ,:,:) = 0 !Cover the search area necessary for the surounding EMEP grids jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !jj_start=-1-ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !ii_start=-1-ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !jj_end=1+ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !ii_end=1+ceiling(0.5*(EMEP_grid_interpolation_size-1.)) !Set the size of the region surounding the target grid that is searched xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then !Assumes it is never on the edge of the EMEP grid as it is not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !These are the subgrid positions projected to the EMEP projection xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit weighting_nc (:,:, tt_dim ,:) = 0. do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min = max ( xpos_area_min , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max = min ( xpos_area_max , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min = max ( ypos_area_min , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max = min ( ypos_area_max , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii_w , jj_w , tt_dim ,:) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / EMEP_grid_interpolation_size_sqr else weighting_nc ( ii_w , jj_w , tt_dim ,:) = 0. endif do i_pollutant = 1 , n_emep_pollutant_loop subgrid ( i , j , tt , emep_local_subgrid_index ,:, i_pollutant ) = subgrid ( i , j , tt , emep_local_subgrid_index ,:, i_pollutant ) & + var3d_nc ( ii_nc , jj_nc , tt , local_nc_index , 1 : n_source_index , i_pollutant ) * weighting_nc ( ii_w , jj_w , tt_dim ,:) subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:, i_pollutant ) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:, i_pollutant ) & + ( var3d_nc ( ii_nc , jj_nc , tt , conc_nc_index , 1 : n_source_index , i_pollutant ) - var3d_nc ( ii_nc , jj_nc , tt , local_nc_index , 1 : n_source_index , i_pollutant )) * weighting_nc ( ii_w , jj_w , tt_dim ,:) enddo do i_pollutant = 1 , n_emep_pollutant_loop !write(*,*) var3d_nc(ii_nc,jj_nc,tt,local_nc_index,:,i_pollutant) !Interpolate the other EMEP compounds as well to subgrid do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) & + comp_var3d_nc ( ii_nc , jj_nc , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) * weighting_nc ( ii_w , jj_w , tt_dim , allsource_index ) enddo enddo if ( save_emep_species . or . save_seasalt ) then do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) = species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) & + species_var3d_nc ( ii_nc , jj_nc , tt , i_loop , i_sp ) * weighting_nc ( ii_w , jj_w , tt_dim , allsource_index ) enddo enddo endif endif enddo enddo !Calculate the nonlocal correction, weighting for grids beyond the central grid nonlocal_correction ( tt_dim ,:,:) = 0. do jj = jj_start , jj_end do ii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then if ( jj . ne . 0. or . ii . ne . 0 ) then !First weight is emission, the second is area do i_pollutant = 1 , n_emep_pollutant_loop nonlocal_correction ( tt_dim ,:, i_pollutant ) = nonlocal_correction ( tt_dim ,:, i_pollutant ) & - lc_var3d_nc ( ii_w0 , jj_w0 , ii_nc , jj_nc , tt , lc_local_nc_index , 1 : n_source_index , i_pollutant ) * weighting_nc ( ii_w , jj_w , tt_dim ,:) * weighting_nc ( ii_w0 , jj_w0 , tt_dim ,:) & - lc_var3d_nc ( ii_w , jj_w , i_nc , j_nc , tt , lc_local_nc_index , 1 : n_source_index , i_pollutant ) * weighting_nc ( ii_w0 , jj_w0 , tt_dim ,:) * weighting_nc ( ii_w , jj_w , tt_dim ,:) enddo endif endif enddo enddo !Place the EMEP values in the target subgrid subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) + nonlocal_correction ( tt_dim ,:,:) subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) - nonlocal_correction ( tt_dim ,:,:) subgrid ( i , j , tt , emep_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) + subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) !Take the already calculated nonlocal depositions to be the fraction of the nonlocal/total EMEP values if ( calculate_deposition_flag ) then subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) endif !Put the area weighting in the larger array for use later in the emission proxy weighting (if needed) area_weighting_nc ( i , j ,:,:, tt_dim ,:) = weighting_nc (:,:, tt_dim ,:) !For diagnostics only nonlocal_correction_average = nonlocal_correction_average + nonlocal_correction ( tt_dim ,:,:) !write(*,*) subgrid(i,j,tt,emep_nonlocal_subgrid_index,allsource_index,:) endif enddo !write(*,*) 'Subgrid EMEP area interpolation: ',j,' of ',subgrid_dim(2) enddo if ( tt . eq . t_end ) then nonlocal_correction_average = nonlocal_correction_average / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) do i_pollutant = 1 , n_emep_pollutant_loop write ( fmt , '(A,I0,A)' ), '(' , n_source_index , 'es12.4)' write ( unit_logfile , fmt ) 'Nonlocal correction for area weighting (' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ') = ' , nonlocal_correction_average (:, i_pollutant ) enddo endif endif !This does not work very well for the additional and reigon contributions. Use 6 instead if ( EMEP_grid_interpolation_flag . eq . 1 ) then if ( tt . eq . t_start ) write ( unit_logfile , '(A)' ) 'Calculating EMEP local subgrid contribution using area weighted interpolation v2' !Set weighting indexes n_weight = 3 + 2 * floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_w0 = 1 + floor ( n_weight * . 5 ) jj_w0 = 1 + floor ( n_weight * . 5 ) ii_nc_w0 = xdist_centre_nc jj_nc_w0 = ydist_centre_nc n_weight_nc_x = xdist_centre_nc * 2 - 1 n_weight_nc_y = ydist_centre_nc * 2 - 1 n_weight_nc_x = dim_length_nc ( xdist_dim_nc_index ) n_weight_nc_y = dim_length_nc ( ydist_dim_nc_index ) if ( tt . eq . t_start ) write ( unit_logfile , '(a,3i)' ) 'Weighting grid dimensions and centres: ' , n_weight , ii_w0 , jj_w0 if ( tt . eq . t_start ) write ( unit_logfile , '(a,4i)' ) 'EMEP local fraction grid dimensions and centres: ' , n_weight_nc_x , n_weight_nc_y , ii_nc_w0 , jj_nc_w0 !if (.not.allocated(EMEP_local_contribution)) allocate (EMEP_local_contribution(n_weight_nc_x,n_weight_nc_y,n_source_index,n_emep_pollutant_loop)) if (. not . allocated ( EMEP_local_contribution )) allocate ( EMEP_local_contribution ( n_weight_nc_x , n_weight_nc_y , n_source_index , n_pollutant_loop )) !Initialise arrays subgrid (:,:, tt , emep_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_frac_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_local_subgrid_index ,:,:) = 0 subgrid (:,:, tt , emep_nonlocal_subgrid_index ,:,:) = 0 comp_EMEP_subgrid (:,:, tt ,:) = 0 species_EMEP_subgrid (:,:, tt ,:,:) = 0 EMEP_local_contribution = 0 !Cover the search area necessary for the surounding EMEP grids jj_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_start =- 1 - floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) jj_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) ii_end = 1 + floor ( 0.5 * ( EMEP_grid_interpolation_size - 1. )) !Set the loop sizes for the local area interpolation jjj_start =- 1 iii_start =- 1 jjj_end = 1 iii_end = 1 !Set the size of the region surounding the target grid that is searched in the LF grid xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling_temp xpos_limit2 = dgrid_nc ( lon_nc_index ) / 2. ypos_limit2 = dgrid_nc ( lat_nc_index ) / 2. !Recheck this! if ( tt . eq . t_start ) write ( unit_logfile , '(a,4i)' ) 'Loop sizes: ' , jj_start , jj_end , ii_start , ii_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then !Assumes it is never on the edge of the EMEP grid as it is not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Set the edges of the search area surounding the target grid xpos_area_min =- xpos_limit xpos_area_max =+ xpos_limit ypos_area_min =- ypos_limit ypos_area_max =+ ypos_limit xpos_area_min2 = xpos_subgrid - xpos_limit2 xpos_area_max2 = xpos_subgrid + xpos_limit2 ypos_area_min2 = ypos_subgrid - ypos_limit2 ypos_area_max2 = ypos_subgrid + ypos_limit2 !Limit the region. This will still allow an EMEP contribution from half a grid away !Same limit is NOT applied on the emissions in the moving window so inconsistent !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max if ( limit_emep_grid_interpolation_region_to_calculation_region ) then xpos_area_min = max ( xpos_area_min , subgrid_proj_min ( x_dim_index ) - xpos_subgrid - xpos_limit2 ) xpos_area_max = min ( xpos_area_max , subgrid_proj_max ( x_dim_index ) - xpos_subgrid + xpos_limit2 ) ypos_area_min = max ( ypos_area_min , subgrid_proj_min ( y_dim_index ) - ypos_subgrid - ypos_limit2 ) ypos_area_max = min ( ypos_area_max , subgrid_proj_max ( y_dim_index ) - ypos_subgrid + ypos_limit2 ) endif !write(*,'(2i,4e12.2)') i,j,xpos_area_min,xpos_area_max,ypos_area_min,ypos_area_max !Set the offset to the centre of the local fraction grid when using larger local fraction grids amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp !First create an interpolated grid around the x,y position for the species and the compounds EMEP_local_contribution = 0 do jj = jjj_start , jjj_end do ii = iii_start , iii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 !Put in a limit if ( ii_nc . ge . 1. and . ii_nc . le . dim_length_nc ( x_dim_nc_index ). and . jj_nc . ge . 1. and . jj_nc . le . dim_length_nc ( y_dim_nc_index )) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min2 = max ( xpos_area_min2 , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max2 = min ( xpos_area_max2 , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min2 = max ( ypos_area_min2 , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max2 = min ( ypos_area_max2 , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Calculate area weighting if ( xpos_max2 . gt . xpos_min2 . and . ypos_max2 . gt . ypos_min2 ) then weighting_val = ( ypos_max2 - ypos_min2 ) * ( xpos_max2 - xpos_min2 ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_val = 0. endif !write(*,*) ii,jj,weighting_val,(ypos_max2-ypos_min2),(xpos_max2-xpos_min2) !Area weighting (interpolated) EMEP concentrations, independent of where it comes from subgrid ( i , j , tt , emep_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_subgrid_index , 1 : n_source_index ,:) + var3d_nc ( ii_nc , jj_nc , tt , conc_nc_index , 1 : n_source_index ,:) * weighting_val do i_pollutant = 1 , n_emep_pollutant_loop do i_loop = 1 , n_pollutant_compound_loop ( i_pollutant ) comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) = comp_EMEP_subgrid ( i , j , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) & + comp_var3d_nc ( ii_nc , jj_nc , tt , pollutant_compound_loop_index ( i_pollutant , i_loop )) * weighting_val enddo enddo if ( save_emep_species . or . save_seasalt ) then do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) do i_loop = 1 , n_pmxx_sp_index species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) = species_EMEP_subgrid ( i , j , tt , i_loop , i_sp ) & + species_var3d_nc ( ii_nc , jj_nc , tt , i_loop , i_sp ) * weighting_val enddo enddo endif if ( first_interpolate_lf ) then !Set the area surrounding the multi LF grid, centred on 0 xpos_lf_area_min = ( ii - 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp xpos_lf_area_max = ( ii + 1 / 2. + dgrid_lf_offset_x ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_min = ( jj - 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ypos_lf_area_max = ( jj + 1 / 2. + dgrid_lf_offset_y ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp xpos_min3 = max ( xpos_area_min , xpos_lf_area_min ) xpos_max3 = min ( xpos_area_max , xpos_lf_area_max ) ypos_min3 = max ( ypos_area_min , ypos_lf_area_min ) ypos_max3 = min ( ypos_area_max , ypos_lf_area_max ) !Calculate area weighting LF grid if ( xpos_max3 . gt . xpos_min3 . and . ypos_max3 . gt . ypos_min3 ) then weighting_val3 = ( ypos_max3 - ypos_min3 ) * ( xpos_max3 - xpos_min3 ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val3 = 0. endif else weighting_val3 = weighting_val endif !write(*,*) ii,jj,ii_nc,jj_nc,weighting_val3 EMEP_local_contribution (:,:,:,:) = EMEP_local_contribution (:,:,:,:) + lc_var3d_nc (:,:, ii_nc , jj_nc , tt , lc_local_nc_index , 1 : n_source_index ,:) * weighting_val3 endif enddo enddo !Set the offset to the centre of the local fraction grid when using larger local fraction grids !Requires knowledge of the total EMEP grid index so uses dim_start_nc amod_temp = amod ( real ( dim_start_nc ( x_dim_nc_index ) - 1 + i_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_x = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp amod_temp = amod ( real ( dim_start_nc ( y_dim_nc_index ) - 1 + j_nc ), local_fraction_grid_size_scaling_temp ) if ( amod_temp . eq . 0 ) amod_temp = local_fraction_grid_size_scaling_temp dgrid_lf_offset_y = 0.5 - ( amod_temp - 0.5 ) / local_fraction_grid_size_scaling_temp !write(*,*) dim_start_nc(x_dim_nc_index)-1+i_nc,dim_start_nc(y_dim_nc_index)-1+j_nc,amod_temp,dgrid_lf_offset_x,dgrid_lf_offset_y if ( first_interpolate_lf ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif if ( set_lf_offset_to_0 ) then dgrid_lf_offset_x = 0 dgrid_lf_offset_y = 0 endif !Still need to change the dispersion routines for distance calculated and the size of the domain read in by EMEP and the other emissions !Calculate the local contribution within the moving window area do jjj = jj_start , jj_end do iii = ii_start , ii_end ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 iii_nc_w = iii + ii_nc_w0 jjj_nc_w = jjj + jj_nc_w0 !Put in a limit if ( iii_nc_w . ge . 1. and . iii_nc_w . le . n_weight_nc_x . and . jjj_nc_w . ge . 1. and . jjj_nc_w . le . n_weight_nc_y ) then !Set the edges to an EMEP grid surounding the EMEP grid being assessed xpos_min = max ( xpos_area_min ,( iii + dgrid_lf_offset_x - 1 / 2. ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ) xpos_max = min ( xpos_area_max ,( iii + dgrid_lf_offset_x + 1 / 2. ) * dgrid_nc ( lon_nc_index ) * local_fraction_grid_size_scaling_temp ) ypos_min = max ( ypos_area_min ,( jjj + dgrid_lf_offset_y - 1 / 2. ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ) ypos_max = min ( ypos_area_max ,( jjj + dgrid_lf_offset_y + 1 / 2. ) * dgrid_nc ( lat_nc_index ) * local_fraction_grid_size_scaling_temp ) !Calculate area weighting if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_val = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size_scaling_temp / local_fraction_grid_size_scaling_temp else weighting_val = 0. endif !write(*,*) iii_nc_w,jjj_nc_w,weighting_val subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) + EMEP_local_contribution ( iii_nc_w , jjj_nc_w , 1 : n_source_index ,:) * weighting_val !write(*,*) iii,jjj,weighting_val,EMEP_local_contribution(iii_nc_w,jjj_nc_w,traffic_nc_index,allsource_index) endif enddo enddo !Place the EMEP values in the target subgrid !subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)=subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)+nonlocal_correction(tt_dim,:,:) subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , emep_subgrid_index ,:,:) - subgrid ( i , j , tt , emep_local_subgrid_index ,:,:) !subgrid(i,j,tt,emep_subgrid_index,:,:)=subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)+subgrid(i,j,tt,emep_local_subgrid_index,:,:) !write(*,*) i,j,sum(subgrid(i,j,tt,emep_nonlocal_subgrid_index,:,:)) !Take the already calculated nonlocal depositions to be the fraction of the nonlocal/total EMEP values if ( calculate_deposition_flag ) then subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , drydepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) = subgrid ( i , j , tt , wetdepo_nonlocal_subgrid_index ,:,:) & * subgrid ( i , j , tt , emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j , tt , emep_subgrid_index ,:,:) endif endif enddo enddo endif !Loop through subgrid and carry out a subgrid weighted moving window interpolation using emissions. Not used anymore if ( EMEP_grid_interpolation_flag . gt . 1. and . EMEP_grid_interpolation_flag . lt . 5 ) then nonlocal_correction_average = 0. !n_weight is already set in the previous call if ( tt . eq . t_start ) write ( unit_logfile , '(A,2i)' ) 'Calculating EMEP local subgrid contribution using moving window interpolation method ' , EMEP_grid_interpolation_flag if (. not . allocated ( total_weighting_nc )) allocate ( total_weighting_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), tt_dim , n_source_index , n_pollutant_loop )) !EMEP grid weighting for interpolation if (. not . allocated ( proxy_weighting_nc )) allocate ( proxy_weighting_nc ( n_weight , n_weight , tt_dim , n_source_index , n_pollutant_loop )) !EMEP grid weighting for interpolation !Set the index offset for the local contribution i_w_c = 1 + floor ( n_weight * . 5 ) j_w_c = 1 + floor ( n_weight * . 5 ) subgrid (:,:, tt , emep_local_subgrid_index ,:,:) = 0 !Emission moving window only works properly when the emission and subgrids are the same !Emission moving window adds all the subsource emissions since EMEP does not understand subsources !This means that combine_emission_subsources_during_dispersion must be set to true whenever using the redistribution of EMEP !Emission weighting if ( EMEP_grid_interpolation_flag . eq . 2 ) then if (. not . allocated ( weighting_subgrid )) allocate ( weighting_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), tt_dim , n_source_index , n_pollutant_loop )) if (. not . allocated ( crossreference_weighting_to_emep_subgrid )) allocate ( crossreference_weighting_to_emep_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) weighting_subgrid (:,:, tt_dim ,:,:) = emission_subgrid (:,:, tt ,:,:) weighting_subgrid_dim (:,:) = emission_subgrid_dim ( 1 : 2 ,:) crossreference_weighting_to_emep_subgrid = crossreference_emission_to_emep_subgrid endif if ( EMEP_grid_interpolation_flag . eq . 3 ) then !Aggregated emissions first on integral grid to increase speed if (. not . allocated ( weighting_subgrid )) allocate ( weighting_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), tt_dim , n_source_index , n_pollutant_loop )) if (. not . allocated ( crossreference_weighting_to_emep_subgrid )) allocate ( crossreference_weighting_to_emep_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 , n_source_index )) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then crossreference_weighting_to_emep_subgrid (:,:,:, i_source ) = crossreference_integral_to_emep_subgrid weighting_subgrid_dim (:, i_source ) = integral_subgrid_dim ( 1 : 2 ) endif enddo weighting_subgrid (:,:, tt_dim ,:,:) = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_cross = crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) j_cross = crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) weighting_subgrid ( i_cross , j_cross , tt_dim , i_source ,:) = weighting_subgrid ( i_cross , j_cross , tt_dim , i_source ,:) + emission_subgrid ( i , j , tt , i_source ,:) enddo enddo endif enddo endif !Integral proxy weighting if ( EMEP_grid_interpolation_flag . eq . 4 ) then !Aggregated proxy on integral grid to increase speed if (. not . allocated ( weighting_subgrid )) allocate ( weighting_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( crossreference_weighting_to_emep_subgrid )) allocate ( crossreference_weighting_to_emep_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 , n_source_index )) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then crossreference_weighting_to_emep_subgrid (:,:,:, i_source ) = crossreference_integral_to_emep_subgrid weighting_subgrid_dim (:, i_source ) = integral_subgrid_dim ( 1 : 2 ) endif enddo !Set the weighting subgrid to the sum of all subsource integral emissions weighting_subgrid (:,:, tt_dim ,:,:) = integral_subgrid (:,:, tt , hsurf_integral_subgrid_index ,:,:) endif !Calculate weighting sum for each EMEP grid. total_weighting_nc = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , weighting_subgrid_dim ( y_dim_index , i_source ) do i = 1 , weighting_subgrid_dim ( x_dim_index , i_source ) i_nc = crossreference_weighting_to_emep_subgrid ( i , j , x_dim_index , i_source ) j_nc = crossreference_weighting_to_emep_subgrid ( i , j , y_dim_index , i_source ) total_weighting_nc ( i_nc , j_nc , tt_dim , i_source ,:) = total_weighting_nc ( i_nc , j_nc , tt_dim , i_source ,:) + weighting_subgrid ( i , j , tt_dim , i_source ,:) !write(*,*) i_source,i,j,i_nc,j_nc,weighting_subgrid(i,j,:,i_source) enddo enddo endif enddo nonlocal_correction_average = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then !Calculate the proxy weighting in the nearest emep grids for each subgrid do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then proxy_weighting_nc = 0. xpos_subgrid = xproj_subgrid ( i , j ) ypos_subgrid = yproj_subgrid ( i , j ) !Set the edges of the search area surounding the target grid xpos_area_min = xpos_subgrid - xpos_limit xpos_area_max = xpos_subgrid + xpos_limit ypos_area_min = ypos_subgrid - ypos_limit ypos_area_max = ypos_subgrid + ypos_limit if ( EMEP_grid_interpolation_flag . eq . 2 ) then i_cross = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) j_cross = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) i_nc_c = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc_c = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !Limit the loop so that it doesn't go over more than necessary subgrids and does not go outside the domain i_start = max ( 1 , i_cross - emission_subgrid_loop_index ( x_dim_index , i_source )) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i_cross + emission_subgrid_loop_index ( x_dim_index , i_source )) j_start = max ( 1 , j_cross - emission_subgrid_loop_index ( y_dim_index , i_source )) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j_cross + emission_subgrid_loop_index ( y_dim_index , i_source )) do jj = j_start , j_end do ii = i_start , i_end xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , i_source ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , i_source ) if ( abs ( xpos_subgrid - xpos_emission_subgrid ). le . xpos_limit & . and . abs ( ypos_subgrid - ypos_emission_subgrid ). le . ypos_limit ) then i_nc = crossreference_emission_to_emep_subgrid ( ii , jj , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( ii , jj , y_dim_index , i_source ) proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) = proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) + weighting_subgrid ( ii , jj , tt_dim , i_source ,:) !write(*,*) tt, proxy_weighting_nc(i_nc-i_nc_c+i_w_c,j_nc-j_nc_c+j_w_c,tt_dim,i_source), weighting_subgrid(ii,jj,tt_dim,i_source) endif enddo enddo !endif elseif ( EMEP_grid_interpolation_flag . eq . 3. or . EMEP_grid_interpolation_flag . eq . 4 ) then !Find the cross reference to the integral grid from the target grid i_cross = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) i_nc_c = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc_c = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) i_start = max ( 1 , i_cross - integral_subgrid_loop_index ( x_dim_index )) i_end = min ( integral_subgrid_dim ( x_dim_index ), i_cross + integral_subgrid_loop_index ( x_dim_index )) j_start = max ( 1 , j_cross - integral_subgrid_loop_index ( y_dim_index )) j_end = min ( integral_subgrid_dim ( y_dim_index ), j_cross + integral_subgrid_loop_index ( y_dim_index )) do jj = j_start , j_end do ii = i_start , i_end xpos_integral_subgrid = xproj_integral_subgrid ( ii , jj ) ypos_integral_subgrid = yproj_integral_subgrid ( ii , jj ) if ( abs ( xpos_subgrid - xpos_integral_subgrid ). le . xpos_limit & . and . abs ( ypos_subgrid - ypos_integral_subgrid ). le . ypos_limit ) then i_nc = crossreference_integral_to_emep_subgrid ( ii , jj , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( ii , jj , y_dim_index ) proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) = proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c , tt_dim , i_source ,:) + weighting_subgrid ( ii , jj , tt_dim , i_source ,:) endif enddo enddo endif i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) i_nc_start = max ( 1 + i_nc - i_w_c , i_nc - 1 - floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) i_nc_end = min ( dim_length_nc ( x_dim_nc_index ) + i_nc - i_w_c , i_nc + 1 + floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_start = max ( 1 + j_nc - j_w_c , j_nc - 1 - floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_end = min ( dim_length_nc ( y_dim_nc_index ) + j_nc - j_w_c , j_nc + 1 + floor (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) i_nc_start = max ( 1 + i_nc - i_w_c , i_nc - 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) i_nc_end = min ( dim_length_nc ( x_dim_nc_index ) + i_nc - i_w_c , i_nc + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_start = max ( 1 + j_nc - j_w_c , j_nc - 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) j_nc_end = min ( dim_length_nc ( y_dim_nc_index ) + j_nc - j_w_c , j_nc + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 )) do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end do i_pollutant = 1 , n_emep_pollutant_loop if ( total_weighting_nc ( ii , jj , tt_dim , i_source , i_pollutant ). ne . 0. ) then proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) = proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) / total_weighting_nc ( ii , jj , tt_dim , i_source , i_pollutant ) / EMEP_grid_interpolation_size_sqr !write(*,*)  tt,proxy_weighting_nc(ii-i_nc+i_w_c,jj-j_nc+j_w_c,tt_dim,i_source) else proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) = 0. endif if ( proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ). gt . 1 ) write ( * , '(A,8i6,f12.2)' ) 'WEIGHTING>1: ' , i_pollutant , tt , i , j , ii , jj , ii - i_nc , jj - j_nc , proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source , i_pollutant ) enddo enddo enddo !Add up the contributing weights do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) & + var3d_nc ( ii , jj , tt , local_nc_index , i_source ,:) * proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , tt_dim , i_source ,:) enddo enddo !Subtract the additional local emissions from the nonlocal using the new scheme nonlocal_correction ( tt_dim , i_source ,:) = 0. !           do jj=-1-floor((EMEP_grid_interpolation_size-1.)*0.5),+1+floor((EMEP_grid_interpolation_size-1.)*0.5) !           do ii=-1-floor((EMEP_grid_interpolation_size-1.)*0.5),+1+floor((EMEP_grid_interpolation_size-1.)*0.5) do jj =- 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ), + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) do ii =- 1 - ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ), + 1 + ceiling (( EMEP_grid_interpolation_size - 1. ) * 0.5 ) ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + ii_w0 jj_w = jj + jj_w0 if ( jj . ne . 0. or . ii . ne . 0 ) then !First weight is emission, the second is area nonlocal_correction ( tt_dim , i_source ,:) = nonlocal_correction ( tt_dim , i_source ,:) & - lc_var3d_nc ( ii_w0 , jj_w0 , ii_nc , jj_nc , tt , lc_local_nc_index , i_source ,:) * proxy_weighting_nc ( ii + i_w_c , jj + j_w_c , tt_dim , i_source ,:) * area_weighting_nc ( i , j , ii_w0 , jj_w0 , tt_dim , i_source ) & - lc_var3d_nc ( ii_w , jj_w , i_nc , j_nc , tt , lc_local_nc_index , i_source ,:) * proxy_weighting_nc ( ii + i_w_c , jj + j_w_c , tt_dim , i_source ,:) * area_weighting_nc ( i , j , ii_w , jj_w , tt_dim , i_source ) endif enddo enddo subgrid ( i , j , tt , emep_nonlocal_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index , i_source ,:) + nonlocal_correction ( tt_dim , i_source ,:) subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) - nonlocal_correction ( tt_dim , i_source ,:) subgrid ( i , j , tt , emep_subgrid_index , i_source ,:) = subgrid ( i , j , tt , emep_nonlocal_subgrid_index , i_source ,:) + subgrid ( i , j , tt , emep_local_subgrid_index , i_source ,:) !Averaged over time for diagnostic purposes only nonlocal_correction_average ( i_source ,:) = nonlocal_correction_average ( i_source ,:) + nonlocal_correction ( tt_dim , i_source ,:) endif !use subgrid enddo enddo endif !End if calculate_source enddo !End source loop if ( tt . eq . t_end ) then nonlocal_correction_average = nonlocal_correction_average / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) do i_pollutant = 1 , n_emep_pollutant_loop write ( fmt , '(A,I0,A)' ) '(' , n_source_index , 'es12.4)' write ( unit_logfile , fmt ) 'Nonlocal correction for proxy weighting (' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ') = ' , nonlocal_correction_average (:, i_pollutant ) enddo endif endif if ( mod ( j , 1 ). eq . 0 ) write ( * , '(a,i5,a,i5)' ) 'Gridding EMEP for hour ' , tt , ' of ' , subgrid_dim ( t_dim_index ) enddo !End time loop !Create the all source version of the local and nonlocal contribution after calculating all the source contributions !The nonlocal contribution uses the difference between the local and total, here the total is based on the area interpolation. Is this correct? subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:) = 0. subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) = 0. subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index ,:) = 0. !-subgrid(:,:,:,emep_subgrid_index,allsource_index,:) count = 0 do i_source = 1 , n_source_index !do i_source=1,n_source_calculate_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). and . i_source . ne . allsource_index ) then !Check values for local and totals for each source !write(*,*) trim(source_file_str(i_source)) do i_pollutant = 1 , n_emep_pollutant_loop if ( minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , i_source , i_pollutant )). lt . 0.0 ) then write ( unit_logfile , '(A,A,f12.4,A)' ) 'WARNING: Min nonlocal source less than 0 for ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , i_source , emep_subsource )), ' Setting to 0 and adding to local' endif enddo !Set any negative nonlocal to 0 and add the value back into the local. Indicates a problem with the moving window method do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) where ( subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source ,:). lt . 0. ) subgrid ( i , j ,:, emep_local_subgrid_index , i_source ,:) = subgrid ( i , j ,:, emep_local_subgrid_index , i_source ,:) - subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source ,:) subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source ,:) = 0. endwhere enddo enddo !Add the local subgrid sources together to get an allsource local contribution subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:) = subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:) + subgrid (:,:,:, emep_local_subgrid_index , i_source ,:) subgrid (:,:,:, emep_subgrid_index , i_source ,:) = subgrid (:,:,:, emep_nonlocal_subgrid_index , i_source ,:) + subgrid (:,:,:, emep_local_subgrid_index , i_source ,:) do i_pollutant = 1 , n_pollutant_loop !write(*,'(a,2i,3f12.1)')'Sum  (subgrid_index,i_source,comp_EMEP,original): ',i_source,i_pollutant,sum(subgrid(:,:,:,emep_subgrid_index,i_source,i_pollutant)),sum(comp_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))),sum(orig_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))) enddo !Add up the total EMEP for all source (will be averaged with count) subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) = subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) + subgrid (:,:,:, emep_subgrid_index , i_source ,:) count = count + 1 do i_pollutant = 1 , n_pollutant_loop if ( minval ( subgrid (:,:,:, emep_subgrid_index , i_source , i_pollutant )). lt . 0.0 ) then write ( unit_logfile , '(A,A,f12.4)' ) 'ERROR: Min total source less than 0 for ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( pollutant_loop_index ( i_pollutant )))), minval ( subgrid (:,:,:, emep_subgrid_index , i_source , i_pollutant )) stop endif enddo endif enddo !Set the allsource nonlocal value to the average of the remainder. This can be negative if ( count . gt . 0 ) then subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index ,:) = ( subgrid (:,:,:, emep_subgrid_index , allsource_index ,:) / real ( count ) - subgrid (:,:,:, emep_local_subgrid_index , allsource_index ,:)) !write(*,*) calculate_EMEP_additional_grid_flag,sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,:)) !stop endif do i_pollutant = 1 , n_emep_pollutant_loop if ( minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant )). lt . 0.0 ) then write ( unit_logfile , '(A,f12.4,A)' ) 'WARNING: Min nonlocal allsource less than 0 with ' // trim ( source_file_str ( allsource_index )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), minval ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant )), ' Setting to 0' endif enddo !Remove any negative values. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) where ( subgrid ( i , j ,:, emep_nonlocal_subgrid_index , allsource_index ,:). lt . 0. ) subgrid ( i , j ,:, emep_nonlocal_subgrid_index , allsource_index ,:) = 0. endwhere enddo enddo !write(*,'(a,2f12.1)')'Sum (local,nonlocal): ',sum(subgrid(:,:,:,emep_local_subgrid_index,allsource_index,:)), sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,:)) !Add up the sources and calculate fractions do i_pollutant = 1 , n_emep_pollutant_loop !write(*,'(a,i,f12.1)')'Sum before  (emep_subgrid allsource): ',i_pollutant,sum(subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)) enddo subgrid (:,:,:, emep_subgrid_index ,:,:) = subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) + subgrid (:,:,:, emep_local_subgrid_index ,:,:) do i_pollutant = 1 , n_emep_pollutant_loop !write(*,'(a,i,f12.1)')'Sum after (emep_subgrid allsource): ',i_pollutant,sum(subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)) enddo subgrid (:,:,:, emep_frac_subgrid_index ,:,:) = subgrid (:,:,:, emep_local_subgrid_index ,:,:) / subgrid (:,:,:, emep_subgrid_index ,:,:) do i_pollutant = 1 , n_emep_pollutant_loop if ( minval ( subgrid (:,:,:, emep_subgrid_index , allsource_index ,:)). lt . 0.0 ) then write ( unit_logfile , '(A,f12.4)' ) 'ERROR: Minimum total allsource less than 0 with ' // trim ( source_file_str ( allsource_index )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), minval ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) stop endif enddo !Check if the additional EMEP calculation is to be carried out and set parameters EMEP_grid_interpolation_size = EMEP_grid_interpolation_size_saved if ( calculate_EMEP_additional_grid_flag ) then subgrid (:,:,:, emep_additional_local_subgrid_index ,:,:) = subgrid (:,:,:, emep_local_subgrid_index ,:,:) subgrid (:,:,:, emep_additional_nonlocal_subgrid_index ,:,:) = subgrid (:,:,:, emep_nonlocal_subgrid_index ,:,:) endif if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) if ( allocated ( area_weighting_nc )) deallocate ( area_weighting_nc ) if ( allocated ( total_weighting_nc )) deallocate ( total_weighting_nc ) if ( allocated ( proxy_weighting_nc )) deallocate ( proxy_weighting_nc ) if ( allocated ( weighting_subgrid )) deallocate ( weighting_subgrid ) if ( allocated ( crossreference_weighting_to_emep_subgrid )) deallocate ( crossreference_weighting_to_emep_subgrid ) if ( allocated ( nonlocal_correction )) deallocate ( nonlocal_correction ) if ( allocated ( nonlocal_correction_average )) deallocate ( nonlocal_correction_average ) if ( allocated ( EMEP_local_contribution )) deallocate ( EMEP_local_contribution ) if ( allocated ( EMEP_local_contribution_from_in_region )) deallocate ( EMEP_local_contribution_from_in_region ) end subroutine uEMEP_subgrid_EMEP subroutine uEMEP_subgrid_EMEP_from_in_region ! contribution to centre of each EMEP cell from in-region, within MW and outside MW, for each region real , allocatable :: EMEP_local_from_in_region (:, :, :, :, :, :) ! (x,y,region,t,source,pollutant) real , allocatable :: EMEP_semilocal_from_in_region (:, :, :, :, :, :) ! (x,y,region,t,source,pollutant) ! arrays for accumulating data for a single EMEP cell of the above arrays (is this actually faster than accumulating directly in the big arrays????) real , allocatable :: temp_EMEP_local_from_in_region (:, :, :, :) real , allocatable :: temp_EMEP_semilocal_from_in_region (:, :, :, :) ! additional increment for the centre of each EMEP cell, for each region real , allocatable :: EMEP_additional_increment_from_in_region (:, :, :, :, :, :) ! (x,y,region,t,source,pollutant) ! additional increment for a single EMEP cell, for each region, to be accumulated real , allocatable :: temp_EMEP_additional_increment_from_in_region (:, :, :, :) ! (region,t,source,pollutant) ! additional increment of a single big LF grid to a single receptor EMEP grid (before weighing by region) real , allocatable :: EMEP_additional_increment_current_lfgrid (:, :, :) ! (t,source,pollutant) ! weighting of the additional increment, for each region real , allocatable :: weights_EMEP_additional_increment_current_lfgrid (:) ! (region) ! weighting of an LF cell for local and semilocal contribution real weighting_value_local , weighting_value_semilocal ! indexers for looping integer i , j ! target subgrids integer ii , jj ! EMEP grids integer i_dist , j_dist ! LF dimensions integer iiii , jjjj ! small LF grids within a big LF grid integer i_sub , j_sub ! subsamples of an EMEP grid integer i_region ! region dimension integer i_source ! source dimension ! indexers for determining positioning of additional LF grids integer ii_start , jj_start ! additinoal indexers integer iii , jjj integer iii_nc , jjj_nc ! displacement distances in LF grids (whole grids) integer x_dist , y_dist integer xdist_big , ydist_big integer xdist_small , ydist_small integer xdist_small_first , ydist_small_first integer idist_small , jdist_small integer max_x_dist , max_y_dist ! indexers for the location of a 1x1 LF grid cell in the EMEP grid integer iiii_nc , jjjj_nc ! indexers for the location of a 1x1 LF grid cell in the extended EMEP grid integer iiii_extended , jjjj_extended ! indexers for finding local contributions in LF array integer lc_index , lc_additional_index ! counters integer counter , counter_local , counter_semilocal ! variables to hold a region index integer current_region_index ! fractional position of uEMEP subgrid within an EMEP grid real ii_frac_target , jj_frac_target ! location of subgrid in EMEP's coordinate system real x_temp , y_temp ! distance between target subgrid and an EMEP grid centre or EMEP subsample location real x_dist_target , y_dist_target ! half-size of the moving window real n_EMEP_grids_to_edge_of_moving_window ! fraction of an EMEP grid that is in the correct region real current_EMEP_region_fraction ! weighting for area interpolation real weighting_val , weight_check write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '=====================================================================================================' write ( unit_logfile , '(A)' ) 'Calculation local and semilocal from-in-region EMEP contributions to subgrids (uEMEP_subgrid_EMEP_from_in_region)' write ( unit_logfile , '(A)' ) '=====================================================================================================' write ( unit_logfile , '(A,8I8)' ) 'dims: (x_emep,y_emep,reg,time,source,pollutant,xdist,ydist) = ' , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop , dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ) ! ************************************************ ! PART 1: Calculate contributions to the EMEP grid ! ************************************************ ! Indices in lc_var3d_nc to find the normal and additional local contributions lc_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_grid_interpolation ) lc_additional_index = lc_local_nc_loop_index ( local_fraction_grid_for_EMEP_additional_grid_interpolation ) ! distance in x or y (EMEP grid) from receptor subgrid to edge of moving window, in units of EMEP grids ! (normally whole number, but not if EMEP_grid_interpolation_size is odd number) n_EMEP_grids_to_edge_of_moving_window = EMEP_grid_interpolation_size * 0.5 write ( unit_logfile , '(A,f8.1)' ) 'n_EMEP_grids_to_edge_of_moving_window=' , n_EMEP_grids_to_edge_of_moving_window ! Calculate local and semilocal contributions to centre of all EMEP grids write ( unit_logfile , '(A)' ) 'Allocating arrays for calculating in-region local and semilocal contribution to the EMEP grid' ! Allocate arrays allocate ( EMEP_local_from_in_region ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) EMEP_local_from_in_region = 0.0 allocate ( EMEP_semilocal_from_in_region ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) EMEP_semilocal_from_in_region = 0.0 allocate ( temp_EMEP_local_from_in_region ( n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( temp_EMEP_semilocal_from_in_region ( n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) ! Loop over all EMEP cells and calculate local and semilocal contributions when moving window is centered at the centre of the cell do ii = 1 , dim_length_nc ( x_dim_nc_index ) do jj = 1 , dim_length_nc ( y_dim_nc_index ) temp_EMEP_local_from_in_region = 0.0 temp_EMEP_semilocal_from_in_region = 0.0 ! Loop over all (small) LF contribution cells to this EMEP cell do i_dist = 1 , dim_length_nc ( xdist_dim_nc_index ) do j_dist = 1 , dim_length_nc ( ydist_dim_nc_index ) ! number of grids displaced relative to the receptor grid cell x_dist = i_dist - xdist_centre_nc y_dist = j_dist - ydist_centre_nc ! index in the netcdf file of this cell iiii_nc = ii + x_dist jjjj_nc = jj + y_dist ! index in the extended EMEP grid of this cell iiii_extended = iiii_nc + ngrid_extended_margin jjjj_extended = jjjj_nc + ngrid_extended_margin ! Check if this cell is covered by the extended grid. If not, assume it is completely outside all regions if (. not . ( iiii_extended >= 1 . and . iiii_extended <= nx_EMEP_extended . and . jjjj_extended >= 1 . and . jjjj_extended <= ny_EMEP_extended )) then cycle end if ! Loop over all regions do i_region = 1 , n_regions ! get fraction of the LF grid that is in the region current_region_index = regionindex_loop_index ( i_region ) current_EMEP_region_fraction = regionfraction_per_EMEP_extended_grid ( iiii_extended , jjjj_extended , i_region ) ! Determine the weights to use for this LF cell ! for local, the weight is the area fraction that is in the region and inside the moving window ! for semilocal, the weight is the area fraction that is in the region but outside the moving window if ( current_EMEP_region_fraction <= 0 ) then ! No part of this EMEP grid is within the region cycle else if ( abs ( x_dist ) <= n_EMEP_grids_to_edge_of_moving_window - 1 . and . abs ( y_dist ) <= n_EMEP_grids_to_edge_of_moving_window - 1 ) then ! this LF grid is sure to be completely within the moving window weighting_value_local = current_EMEP_region_fraction weighting_value_semilocal = 0.0 else if ( abs ( x_dist ) >= n_EMEP_grids_to_edge_of_moving_window + 1 . or . abs ( y_dist ) >= n_EMEP_grids_to_edge_of_moving_window + 1 ) then ! this LF grid is sure to be completely outside the moving window weighting_value_local = 0.0 weighting_value_semilocal = current_EMEP_region_fraction else ! this LF grid might be partly covered by the moving window ! -> we must go through all subsamples of that grid to find the overlap between region and moving window counter_local = 0 ! count the subsample grids inside-moving-window & in-region counter_semilocal = 0 ! count the subsample grids outside-moving-window & in-region do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid ! first check if this subsample is in the region if ( EMEP_extended_subsample_region_id ( i_sub , j_sub , iiii_extended , jjjj_extended ) == current_region_index ) then ! deduce x- and y-distance (in number of EMEP grids) from this subsample location to the midpoint of the receptor grid-cell x_dist_target = x_dist + ( i_sub - 0.5 ) / n_subsamples_per_EMEP_grid - 0.5 y_dist_target = y_dist + ( j_sub - 0.5 ) / n_subsamples_per_EMEP_grid - 0.5 ! use these distances to determine whether the subsample is inside the moving window if ( abs ( x_dist_target ) <= n_EMEP_grids_to_edge_of_moving_window . and . abs ( y_dist_target ) <= n_EMEP_grids_to_edge_of_moving_window ) then ! this subsample is inside the moving window counter_local = counter_local + 1 else ! this subsample is outside the moving window counter_semilocal = counter_semilocal + 1 end if end if end do end do ! Divide counters by total number of subsamples per EMEP grid to get the area fraction weighting_value_local = counter_local * 1.0 / n_subsamples_per_EMEP_grid ** 2 weighting_value_semilocal = counter_semilocal * 1.0 / n_subsamples_per_EMEP_grid ** 2 end if temp_EMEP_local_from_in_region ( i_region ,:,:,:) = temp_EMEP_local_from_in_region ( i_region ,:,:,:) + lc_var3d_nc ( i_dist , j_dist , ii , jj ,:, lc_index , 1 : n_source_index ,:) * weighting_value_local temp_EMEP_semilocal_from_in_region ( i_region ,:,:,:) = temp_EMEP_semilocal_from_in_region ( i_region ,:,:,:) + lc_var3d_nc ( i_dist , j_dist , ii , jj ,:, lc_index , 1 : n_source_index ,:) * weighting_value_semilocal end do ! i_region = 1, n_regions end do end do EMEP_local_from_in_region ( ii , jj ,:,:,:,:) = temp_EMEP_local_from_in_region EMEP_semilocal_from_in_region ( ii , jj ,:,:,:,:) = temp_EMEP_semilocal_from_in_region end do end do ! Deallocate temporary arrays deallocate ( temp_EMEP_local_from_in_region ) deallocate ( temp_EMEP_semilocal_from_in_region ) ! Calculate the additional incremental contribution to each EMEP grid for each region ! NB: we let the interpolation domain extend to the very edge of the LF data, not limited by the EMEP_additional_grid_interpolation_size (this is only used to check >0 to determine whether we should calculate it or not) if ( EMEP_additional_grid_interpolation_size > 0.0 ) then write ( unit_logfile , '(A)' ) 'Allocating arrays for additional increment calculation' allocate ( EMEP_additional_increment_from_in_region ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( temp_EMEP_additional_increment_from_in_region ( n_regions , subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( EMEP_additional_increment_current_lfgrid ( subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( weights_EMEP_additional_increment_current_lfgrid ( n_regions )) write ( unit_logfile , '(A)' ) 'Calculating additional increment to all EMEP grids' ! Use the starting position of the read in EMEP file to initialise the starting point ii_start = mod ( dim_start_EMEP_nc ( x_dim_nc_index ) - 1 , local_fraction_grid_size ( 2 )) jj_start = mod ( dim_start_EMEP_nc ( y_dim_nc_index ) - 1 , local_fraction_grid_size ( 2 )) ! Deduce the max distance (+/-) we have LF data for max_x_dist = ( dim_length_nc ( xdist_dim_nc_index ) - 1 ) / 2 max_y_dist = ( dim_length_nc ( ydist_dim_nc_index ) - 1 ) / 2 ! Loop over all EMEP grids EMEP_additional_increment_from_in_region = 0.0 do ii = 1 , dim_length_nc ( x_dim_nc_index ) do jj = 1 , dim_length_nc ( y_dim_nc_index ) ! Initialize the additional increment of this EMEP cell to zero temp_EMEP_additional_increment_from_in_region = 0.0 ! EMEP grid index of bottom-left-corner-cell of the additional grid associated with that EMEP grid iii = int (( ii - 1 + ii_start ) / local_fraction_grid_size ( 2 )) * local_fraction_grid_size ( 2 ) + 1 - ii_start jjj = int (( jj - 1 + jj_start ) / local_fraction_grid_size ( 2 )) * local_fraction_grid_size ( 2 ) + 1 - jj_start ! Loop over all big (additional) LF grids that give contributions to the EMEP grid do i_dist = 1 , dim_length_nc ( xdist_dim_nc_index ) do j_dist = 1 , dim_length_nc ( ydist_dim_nc_index ) ! Initialize additional increment to the total additional contribution from EMEP from this cell (all times, sources and pollutants) EMEP_additional_increment_current_lfgrid = lc_var3d_nc ( i_dist , j_dist , ii , jj ,:, lc_additional_index , 1 : n_source_index ,:) ! the x_dist and y_dist of this big LF grid (..., -1, 0, 1, ...) xdist_big = i_dist - xdist_centre_nc ydist_big = j_dist - ydist_centre_nc ! deduce what is the xdist and ydist in the 1x1 LF grid of the lower-left EMEP cell falling within this big LF grid xdist_small_first = iii - ii + xdist_big * local_fraction_grid_size ( 2 ) ydist_small_first = jjj - jj + ydist_big * local_fraction_grid_size ( 2 ) ! loop over all EMEP grids contained within this big LF grid ! Reset weights and counter weights_EMEP_additional_increment_current_lfgrid = 0.0 counter = 0 ! count the grids not covered by the small LF grid do iiii = 1 , local_fraction_grid_size ( 2 ) do jjjj = 1 , local_fraction_grid_size ( 2 ) ! Deduce the xdist and ydist of this EMEP grid in the small LF domain xdist_small = xdist_small_first - 1 + iiii ydist_small = ydist_small_first - 1 + jjjj ! and corresponding index in the LF array idist_small = xdist_small + xdist_centre_nc jdist_small = ydist_small + ydist_centre_nc if ( abs ( xdist_small ) > max_x_dist . or . abs ( ydist_small ) > max_y_dist ) then ! This grid is NOT covered by 1x1 LF data, so add its region coverage to the weight ! find index in the normal EMEP grid iiii_nc = ii + xdist_small jjjj_nc = jj + ydist_small ! find corresponding index in the extended EMEP grid of region fractions iiii_extended = iiii_nc + ngrid_extended_margin jjjj_extended = jjjj_nc + ngrid_extended_margin ! check if this is within the extended region mask grid if ( iiii_extended >= 1 . and . iiii_extended <= nx_EMEP_extended . and . jjjj_extended >= 1 . and . jjjj_extended <= ny_EMEP_extended ) then weights_EMEP_additional_increment_current_lfgrid = weights_EMEP_additional_increment_current_lfgrid + regionfraction_per_EMEP_extended_grid ( iiii_extended , jjjj_extended , :) end if ! NB: If the cell is is outside the extended EMEP grid, it is considered to be outside all the regions. If the extended grid size is set properly, this should never be the case for the receptor EMEP grids (ii,jj) that overlap with the target grid. counter = counter + 1 else ! The grid is covered by 1x1 LF data: subtract the 1x1 LF from the additional increment EMEP_additional_increment_current_lfgrid = EMEP_additional_increment_current_lfgrid - lc_var3d_nc ( idist_small , jdist_small , ii , jj ,:, lc_index , 1 : n_source_index ,:) end if end do end do ! ensure the additional increment is not smaller than zero where ( EMEP_additional_increment_current_lfgrid < 0.0 ) EMEP_additional_increment_current_lfgrid = 0.0 ! normalize the weights by the number of grids ! NB: if counter = 0, then the weights are zero so we can go to next LF source grid if ( counter > 0 ) then ! normalize weights by the number of cells summed over weights_EMEP_additional_increment_current_lfgrid = weights_EMEP_additional_increment_current_lfgrid / counter ! For each region, multiply the additional increment by the weight calculated for that region ! and accumulate this in the array for the total additional increment (to be accumulated over all the big LF cells) do i_region = 1 , n_regions temp_EMEP_additional_increment_from_in_region ( i_region ,:,:,:) = temp_EMEP_additional_increment_from_in_region ( i_region ,:,:,:) + EMEP_additional_increment_current_lfgrid * weights_EMEP_additional_increment_current_lfgrid ( i_region ) end do end if end do end do ! The additional increment has now been accumulated over all xdist and ydist source grids and weighted for each region ! So now it can be inserted into the main array EMEP_additional_increment_from_in_region ( ii , jj ,:,:,:,:) = temp_EMEP_additional_increment_from_in_region end do end do EMEP_semilocal_from_in_region = EMEP_semilocal_from_in_region + EMEP_additional_increment_from_in_region deallocate ( temp_EMEP_additional_increment_from_in_region ) deallocate ( EMEP_additional_increment_current_lfgrid ) deallocate ( weights_EMEP_additional_increment_current_lfgrid ) deallocate ( EMEP_additional_increment_from_in_region ) end if ! ***************************************** ! PART 2: Interpolate to the target subgrid ! ***************************************** write ( unit_logfile , '(A)' ) 'Allocating arrays for in-region local and semilocal contribution to the target grid' ! Allocate the arrays for holding the results and initialize them to zero if ( allocated ( subgrid_EMEP_local_from_in_region )) deallocate ( subgrid_EMEP_local_from_in_region ) allocate ( subgrid_EMEP_local_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) subgrid_EMEP_local_from_in_region = 0.0 if ( allocated ( subgrid_EMEP_semilocal_from_in_region )) deallocate ( subgrid_EMEP_semilocal_from_in_region ) allocate ( subgrid_EMEP_semilocal_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) subgrid_EMEP_semilocal_from_in_region = 0.0 write ( unit_logfile , '(A)' ) 'Interpolating local and semilocal contribution from-in-region to the target subgrid' ! go through all target subgrids and interpolate the EMEP contributions calculated above do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) ! Find position along the region dimension of this region index if ( subgrid_region_index ( i , j ) > 0 ) then i_region = regionindex_loop_back_index ( subgrid_region_index ( i , j )) else ! this subgrid is not in any region, so keep it as 0 cycle end if ! Find which EMEP grid the current subgrid is in ii = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) ! Find out where in this EMEP grid we are in EMEP grid coordinates ! E.g. (0,0) for lower-left corner and (1,1) for upper right corner call LL2PROJ ( lon_subgrid ( i , j ), lat_subgrid ( i , j ), x_temp , y_temp , EMEP_projection_attributes , EMEP_projection_type ) ! fractional position inside the EMEP grid (center is (0,0), lower-left corner is (-0.5,-0.5), upper-right corner is (+0.5,+0.5)) ii_frac_target = ( x_temp - var1d_nc ( ii , x_dim_nc_index )) / dgrid_nc ( x_dim_nc_index ) jj_frac_target = ( y_temp - var1d_nc ( jj , y_dim_nc_index )) / dgrid_nc ( y_dim_nc_index ) ! verify that this is within 0-1 (if not, crossreference has gone wrong...) if ( ii_frac_target < - 0.5 . or . ii_frac_target > 0.5 . or . jj_frac_target < - 0.5 . or . jj_frac_target > 0.5 ) then write ( unit_logfile , '(A,2I12)' ) 'Something went wrong with locating target subgrid within EMEP grid!' , ii_frac_target , jj_frac_target stop end if ! Interpolate to the target grid if ( EMEP_grid_interpolation_flag == 0 ) then ! No interpolation: just pick the value of the EMEP cell we are in subgrid_EMEP_local_from_in_region ( i , j ,:,:,:) = EMEP_local_from_in_region ( ii , jj , i_region ,:,:,:) subgrid_EMEP_semilocal_from_in_region ( i , j ,:,:,:) = EMEP_semilocal_from_in_region ( ii , jj , i_region ,:,:,:) else if ( EMEP_grid_interpolation_flag == 6 ) then ! Use area-weighted interpolation weight_check = 0.0 ! loop over a 3x3 EMEP cell domain centered at the closest EMEP cell to the target subgrid do iii = - 1 , 1 do jjj = - 1 , 1 iii_nc = ii + iii jjj_nc = jj + jjj ! verify the EMEP grid covers this index if (. not . ( iii_nc >= 1 . and . iii_nc <= dim_length_nc ( x_dim_nc_index ) . and . jjj_nc >= 1 . and . jjj_nc <= dim_length_nc ( y_dim_nc_index ))) then write ( unit_logfile , '(A)' ) 'ERROR: EMEP grid did not go far enough out to allow area interpolation to the target grid!' stop end if ! calculate the weighting value as the area fraction of an EMEP cell centered at the target subgrid that falls within this EMEP cell x_dist_target = iii - ii_frac_target y_dist_target = jjj - jj_frac_target weighting_val = max ( 0.0 , ( 1.0 - abs ( x_dist_target ))) * max ( 0.0 , ( 1.0 - abs ( y_dist_target ))) weight_check = weight_check + weighting_val ! use this weighting for the data at this EMEP cell if ( weighting_val > 0 ) then subgrid_EMEP_local_from_in_region ( i , j ,:,:,:) = subgrid_EMEP_local_from_in_region ( i , j ,:,:,:) + EMEP_local_from_in_region ( iii_nc , jjj_nc , i_region ,:,:,:) * weighting_val subgrid_EMEP_semilocal_from_in_region ( i , j ,:,:,:) = subgrid_EMEP_semilocal_from_in_region ( i , j ,:,:,:) + EMEP_semilocal_from_in_region ( iii_nc , jjj_nc , i_region ,:,:,:) * weighting_val end if end do end do else write ( unit_logfile , '(A,I0)' ) 'ERROR: uEMEP_subgrid_EMEP_from_in_region is not implemented for EMEP_grid_interpolation_flag =' , EMEP_grid_interpolation_flag stop end if end do end do deallocate ( EMEP_local_from_in_region ) deallocate ( EMEP_semilocal_from_in_region ) ! Set allsources to be the sum of only the sources we calculate for subgrid_EMEP_local_from_in_region (:,:,:, allsource_index ,:) = 0 subgrid_EMEP_semilocal_from_in_region (:,:,:, allsource_index ,:) = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). and . i_source . ne . allsource_index ) then subgrid_EMEP_local_from_in_region (:,:,:, allsource_index ,:) = subgrid_EMEP_local_from_in_region (:,:,:, allsource_index ,:) + subgrid_EMEP_local_from_in_region (:,:,:, i_source ,:) subgrid_EMEP_semilocal_from_in_region (:,:,:, allsource_index ,:) = subgrid_EMEP_semilocal_from_in_region (:,:,:, allsource_index ,:) + subgrid_EMEP_semilocal_from_in_region (:,:,:, i_source ,:) end if end do end subroutine uEMEP_subgrid_EMEP_from_in_region end module subgrid_emep","tags":"","loc":"sourcefile/uemep_subgrid_emep.f90.html"},{"title":"uEMEP_read_shipping_asi_data.f90 – uEMEP","text":"Source Code module read_shipping_asi_data use uemep_configuration use utility_functions , only : nxtdat , ll2utm , ll2ltm , utm2ll use time_functions , only : datestr_to_date , date_to_number , number_to_date use mod_lambert_projection , only : PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical , LL2LAEA use mod_area_interpolation , only : area_weighted_extended_vectorgrid_interpolation_function implicit none private public :: uEMEP_preaggregate_shipping_asi_data , uEMEP_read_netcdf_shipping_latlon , & uEMEP_read_weekly_shipping_asi_data , uEMEP_read_monthly_and_daily_shipping_asi_data , & uEMEP_read_shipping_asi_data contains !uEMEP_read_shipping_asi_data.f90 subroutine uEMEP_read_weekly_shipping_asi_data use uEMEP_definitions implicit none integer i character ( 256 ) temp_str1 integer unit_in logical :: exists real totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t integer , allocatable :: count_subgrid (:,:,:) integer i_pollutant integer a ( 6 ) character ( 256 ) format_temp , week_of_year_str double precision date_num , date_num_start integer week_of_year , ship_week , ship_counts logical nxtdat_flag real ship_delta_x , ship_delta_y real lat_ship , lon_ship write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading weekly shipping asi data  (uEMEP_read_weekly_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. t = 1 allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 !Determine week of year approximately using date string. Needs proper function format_temp = 'yyyymmdd' call datestr_to_date ( config_date_str , format_temp , a ) date_num = date_to_number ( a , ref_year_meteo ) a ( 2 ) = 1 ; a ( 3 ) = 1 ; a ( 4 ) = 1 ; date_num_start = date_to_number ( a , ref_year_meteo ) week_of_year = 1 + int (( date_num - date_num_start ) / 7. ) week_of_year = max ( min ( week_of_year , 52 ), 1 ) !write(*,*) week_of_year write ( week_of_year_str , '(i2)' ) week_of_year write ( unit_logfile , '(a)' ) 'Week of year: ' // trim ( ADJUSTL ( week_of_year_str )) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) // '_week_' // trim ( ADJUSTL ( week_of_year_str )) // '.txt' !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 !Skip over lines starting with # call nxtdat ( unit_in , nxtdat_flag ) !Read data read ( unit_in , * ) temp_str1 , ship_delta_x read ( unit_in , * ) temp_str1 , ship_delta_y read ( unit_in , * ) temp_str1 , ship_week read ( unit_in , * ) temp_str1 , ship_counts !Skip header read ( unit_in , * ) temp_str1 do i = 1 , ship_counts read ( unit_in , * ) x_ship , y_ship , totalnoxemission , totalparticulatematteremission !Special case when saving emissions, convert to either latlon or lambert if ( save_emissions_for_EMEP ( shipping_index )) then call PROJ2LL ( x_ship , y_ship , lon_ship , lat_ship , projection_attributes , projection_type ) ! call utm2ll_modern(1, utm_zone,y_ship,x_ship,lat_ship,lon_ship) if ( EMEP_projection_type . eq . LL_projection_index ) then x_ship = lon_ship y_ship = lat_ship elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) endif endif i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if ( i_ship_index . ge . 1. and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ship_index . ge . 1. and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( totalnoxemission . gt . 0. and . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalnoxemission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 elseif ( totalparticulatematteremission . gt . 0. and .( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index )) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalparticulatematteremission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 endif enddo endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts = ' , ship_counts do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission (g/hr) ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo close ( unit_in ) deallocate ( count_subgrid ) end subroutine uEMEP_read_weekly_shipping_asi_data subroutine uEMEP_read_monthly_and_daily_shipping_asi_data use uEMEP_definitions implicit none integer i character ( 256 ) temp_str1 integer unit_in logical :: exists real totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t , tt integer , allocatable :: count_subgrid (:,:,:) integer i_pollutant integer a ( 6 ) character ( 256 ) format_temp , month_of_year_str integer month_of_year , ship_month , ship_counts logical nxtdat_flag real ship_delta_x , ship_delta_y real lat_ship , lon_ship real daily_cycle ( 24 ) integer i_ship_range , j_ship_range integer date_array ( 6 ) double precision date_num_temp write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading monthly shipping asi data  (uEMEP_read_monthly_and_daily_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. daily_cycle = 1. t = 1 allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 !Determine week of year approximately using date string. Needs proper function format_temp = 'yyyymmdd' call datestr_to_date ( config_date_str , format_temp , a ) !date_num=date_to_number(a,ref_year_meteo) !a(2)=1;a(3)=1;a(4)=1; !date_num_start=date_to_number(a,ref_year_meteo) !week_of_year=1+int((date_num-date_num_start)/7.) month_of_year = a ( 2 ) ! write(*,*) month_of_year write ( month_of_year_str , '(i0.2)' ) month_of_year write ( unit_logfile , '(a)' ) 'Month of year: ' // trim ( ADJUSTL ( month_of_year_str )) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) // '_' // trim ( ADJUSTL ( month_of_year_str )) // '.txt' !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 !Skip over lines starting with # call nxtdat ( unit_in , nxtdat_flag ) !Read data read ( unit_in , * ) temp_str1 , ship_delta_x read ( unit_in , * ) temp_str1 , ship_delta_y read ( unit_in , * ) temp_str1 , ship_month read ( unit_in , * ) temp_str1 , ship_counts !Skip header read ( unit_in , * ) temp_str1 do i = 1 , ship_counts read ( unit_in , * ) x_ship , y_ship , totalnoxemission , totalparticulatematteremission !Special case when saving emissions, convert to either latlon or lambert if ( save_emissions_for_EMEP ( shipping_index )) then call PROJ2LL ( x_ship , y_ship , lon_ship , lat_ship , projection_attributes , projection_type ) ! call utm2ll_modern(1, utm_zone,y_ship,x_ship,lat_ship,lon_ship) if ( EMEP_projection_type . eq . LL_projection_index ) then x_ship = lon_ship y_ship = lat_ship elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) endif endif i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if ( i_ship_index . ge . 1. and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ship_index . ge . 1. and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( totalnoxemission . gt . 0. and . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalnoxemission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 elseif ( totalparticulatematteremission . gt . 0. and .( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index )) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalparticulatematteremission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 endif enddo endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts for monthly mean = ' , ship_counts do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission (g/hr) ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo close ( unit_in ) !Now read in the daily cycle data for the same month and applyt it to the emission grid !Read in as utm33 pathfilename_ship ( 2 ) = trim ( pathname_ship ( 2 )) // trim ( filename_ship ( 2 )) // '_' // trim ( ADJUSTL ( month_of_year_str )) // '.txt' !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 2 )) stop endif count_subgrid = 0 !Set the emission time profile to the default of 1 emission_time_profile_subgrid (:,:,:, source_index ,:) = 1. !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 2 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 2 )) rewind ( unit_in ) subsource_index = 1 !Skip over lines starting with # call nxtdat ( unit_in , nxtdat_flag ) !Read data read ( unit_in , * ) temp_str1 , ship_delta_x read ( unit_in , * ) temp_str1 , ship_delta_y read ( unit_in , * ) temp_str1 , ship_month read ( unit_in , * ) temp_str1 , ship_counts !Skip header read ( unit_in , * ) temp_str1 do i = 1 , ship_counts !read(unit_in,'(2f16.1,24f8.2)') x_ship,y_ship,(daily_cycle(t),t=1,24) read ( unit_in , * ) x_ship , y_ship ,( daily_cycle ( t ), t = 1 , 24 ) !write(*,'(i,2f16.1,24f8.2)') i,x_ship,y_ship,(daily_cycle(t),t=1,24) !Convert to EMEP coordinates if it is to be saved. emission grids are already in the EMEP coordinate system if ( save_emissions_for_EMEP ( shipping_index )) then call PROJ2LL ( x_ship , y_ship , lon_ship , lat_ship , projection_attributes , projection_type ) ! call utm2ll_modern(1, utm_zone,y_ship,x_ship,lat_ship,lon_ship) call lb2lambert2_uEMEP ( x_ship , y_ship , lon_ship , lat_ship , EMEP_projection_attributes ) endif i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) i_ship_range = floor ( ship_delta_x / emission_subgrid_delta ( x_dim_index , source_index ) / 2. ) j_ship_range = floor ( ship_delta_y / emission_subgrid_delta ( x_dim_index , source_index ) / 2. ) !Add to subgrid if ( i_ship_index . ge . 1 + i_ship_range . and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) - i_ship_range & . and . j_ship_index . ge . 1 + j_ship_range . and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index ) - j_ship_range ) then !do i_pollutant=1,n_pollutant_loop do t = 1 , dim_length_nc ( time_dim_nc_index ) date_num_temp = val_dim_nc ( t , time_dim_nc_index ) call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) tt = date_array ( 4 ) if ( tt . eq . 0 ) tt = 24 !write(*,'(4i,f6.2)') i,t,date_array(4),tt,daily_cycle(tt) emission_time_profile_subgrid ( i_ship_index - i_ship_range : i_ship_index + i_ship_range , j_ship_index - j_ship_range : j_ship_index + j_ship_range , t , source_index ,:) = daily_cycle ( tt ) enddo count_subgrid ( i_ship_index , j_ship_index ,:) = count_subgrid ( i_ship_index , j_ship_index ,:) + 1 !enddo endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts for daily cycle = ' , ship_counts write ( unit_logfile , '(A,I)' ) 'Shipping grids found for daily cycle = ' , sum ( count_subgrid (:,:, 1 )) close ( unit_in ) deallocate ( count_subgrid ) end subroutine uEMEP_read_monthly_and_daily_shipping_asi_data subroutine uEMEP_read_shipping_asi_data !Reads in the original ais raw data use uEMEP_definitions implicit none character ( 2048 ) temp_str character ( 256 ) temp_str1 integer unit_in logical :: exists integer count , index_val real ddlatitude , ddlongitude , totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t integer , allocatable :: count_subgrid (:,:,:) real , allocatable :: temp1_subgrid (:,:), temp2_subgrid (:,:), temp3_subgrid (:,:) integer i_pollutant integer :: io write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading shipping asi data  (uEMEP_read_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. t = 1 allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ), n_pollutant_loop )) count_subgrid = 0 allocate ( temp1_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp2_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp3_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) if ( use_aggregated_shipping_emissions_flag ) pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // 'Aggregated_' // trim ( filename_ship ( 1 )) !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 !Read header ddlatitude;ddlongitude;totalnoxemission;totalparticulatematteremission;fk_vessellloydstype;fk_ais_norwegianmainvesselcategory;date;time read ( unit_in , '(A)' ) temp_str !write(*,*) trim(temp_str) count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit ddlatitude = 0. ; ddlongitude = 0. ; totalnoxemission = 0. ; totalparticulatematteremission = 0. !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlatitude !write (*,*) ddlatitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlongitude !write (*,*) ddlongitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) !write(*,*) index_val,trim(temp_str1),trim(temp_str) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalnoxemission !write (*,*) totalnoxemission index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalparticulatematteremission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !temp_str1=temp_str !if (len(temp_str1).gt.0) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission if ( totalnoxemission . gt . 0. or . totalparticulatematteremission . gt . 0 ) then !Convert to EMEP coordinates if it is to be saved. emission grids are already in the EMEP coordinate system !This will not work for lat lon as it is now written but will never be called either if ( save_emissions_for_EMEP ( shipping_index )) then if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ship , y_ship , ddlongitude , ddlatitude , EMEP_projection_attributes ) !elseif (EMEP_projection_type.eq.LL_projection_index) then !lon_ship=ddlongitude !lat_ship=ddlatitude elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ship , y_ship , ddlongitude , ddlatitude , EMEP_projection_attributes ) endif else !Convert lat lon to utm coords if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_ship , y_ship , ddlongitude , ddlatitude , projection_attributes ) endif endif !Find the grid index it belongs to i_ship_index = 1 + floor (( x_ship - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ship_index = 1 + floor (( y_ship - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !(x_subgrid(i,j)-subgrid_min(1))/+subgrid_delta(1)+1=i !Add to subgrid if ( i_ship_index . ge . 1. and . i_ship_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ship_index . ge . 1. and . j_ship_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( totalnoxemission . gt . 0. and . pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalnoxemission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 elseif ( totalparticulatematteremission . gt . 0. and .( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index )) then proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ship_index , j_ship_index , source_index , i_pollutant ) + totalparticulatematteremission count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) = count_subgrid ( i_ship_index , j_ship_index , i_pollutant ) + 1 endif enddo endif endif enddo write ( unit_logfile , '(A,I)' ) 'Shipping counts = ' , count do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,es12.3)' ) 'Total emission ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , i_pollutant )) enddo close ( unit_in ) deallocate ( count_subgrid ) deallocate ( temp1_subgrid , temp2_subgrid , temp3_subgrid ) end subroutine uEMEP_read_shipping_asi_data !Read in the shipping data in netcdf format in latlon grid !This is particularly used for reading in the global shipping dataset subroutine uEMEP_read_netcdf_shipping_latlon use uEMEP_definitions use netcdf implicit none integer status_nc integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc real delta_shipping_nc ( num_dims_shipping_nc ) integer dim_id_nc ( num_dims_shipping_nc ) integer dim_length_shipping_nc ( num_dims_shipping_nc ) integer dim_start_shipping_nc ( num_dims_shipping_nc ) integer source_index logical reduce_shipping_region_flag real temp_lon ( 4 ), temp_lat ( 4 ), temp_x ( 4 ), temp_y ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max real temp_delta ( num_dims_shipping_nc ) real correct_lon ( 2 ) real temp_scale integer i_ship logical :: exists !Temporary reading rvariables real , allocatable :: shipping_nc_dp (:,:,:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: temp_var2d_nc_dp (:,:) source_index = shipping_nc_index !Set the filename pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_ship ( 1 )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_ship ( 1 )) status_nc = NF90_OPEN ( pathfilename_ship ( 1 ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the (lon,lat) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_shipping_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_shipping_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_shipping_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_shipping_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_shipping_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of shipping dimensions (lon,lat): ' , dim_length_shipping_nc !Reduce the size of the grid to the heating emission grid size reduce_shipping_region_flag = . true . if ( reduce_shipping_region_flag ) then write ( unit_logfile , '(A)' ) 'Reducing shipping domain for reading' !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 temp_x = temp_lon ; temp_y = temp_lat do i = 1 , 4 !write(*,*) i,temp_x(i),temp_y(i) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo write ( unit_logfile , '(A,2f12.2)' ) 'Min: ' , temp_x_min , temp_y_min write ( unit_logfile , '(A,2f12.2)' ) 'Max: ' , temp_x_max , temp_y_max !Read the lon and lat values to get the delta and size. Put in temporary array !Allocate the temporary arrays for lat,lon and shipping if (. not . allocated ( temp_var2d_nc_dp )) allocate ( temp_var2d_nc_dp ( max ( dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index )), num_dims_shipping_nc )) !x and y dim_start_shipping_nc = 1 do i = 1 , num_dims_shipping_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_shipping_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var2d_nc_dp ( 1 : dim_length_shipping_nc ( i ), i ), start = ( / dim_start_shipping_nc ( i ) / ), count = ( / dim_length_shipping_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_shipping_nc = temp_var2d_nc_dp ( 2 ,:) - temp_var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Shipping grid delta (degrees): ' , delta_shipping_nc !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = delta_shipping_nc ( 1 ) temp_delta ( 2 ) = delta_shipping_nc ( 2 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max !Increase the region by 5 grids to be certain i_temp_min = max ( 1 , i_temp_min - 5 ) i_temp_max = min ( dim_length_shipping_nc ( x_dim_nc_index ), i_temp_max + 5 ) j_temp_min = max ( 1 , j_temp_min - 5 ) j_temp_max = min ( dim_length_shipping_nc ( y_dim_nc_index ), j_temp_max + 5 ) dim_length_shipping_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_shipping_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_shipping_nc ( x_dim_nc_index ) = i_temp_min dim_start_shipping_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading shipping i grids: ' , i_temp_min , i_temp_max , dim_length_shipping_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading shipping j grids: ' , j_temp_min , j_temp_max , dim_length_shipping_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading shipping lon grids (min,max): ' , temp_var2d_nc_dp ( i_temp_min , x_dim_nc_index ), temp_var2d_nc_dp ( i_temp_max , x_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading shipping lat grids (min,max): ' , temp_var2d_nc_dp ( j_temp_min , y_dim_nc_index ), temp_var2d_nc_dp ( j_temp_max , y_dim_nc_index ) !endif endif if ( i_temp_min . ge . i_temp_max . or . j_temp_min . ge . j_temp_max ) then !No shipping data available write ( unit_logfile , '(A)' ) ' WARNING: No shipping data available in this region. Setting to 0' proxy_emission_subgrid (:,:, source_index ,:) = 0. else if (. not . allocated ( shipping_nc_dp )) allocate ( shipping_nc_dp ( dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index ), num_var_shipping_nc )) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index )), num_dims_shipping_nc )) !x and y !Read the lon and lat values to get the delta do i = 1 , num_dims_shipping_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_shipping_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_shipping_nc ( i ), i ), start = ( / dim_start_shipping_nc ( i ) / ), count = ( / dim_length_shipping_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_shipping_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Shipping grid delta (degrees): ' , delta_shipping_nc !write(*,*) var2d_nc_dp(1,1),var2d_nc_dp(dim_length_shipping_nc(x_dim_nc_index),1) !write(*,*) var2d_nc_dp(1,2),var2d_nc_dp(dim_length_shipping_nc(y_dim_nc_index),2) !Read the shipping data do i_ship = 1 , num_var_shipping_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_shipping_nc ( i_ship ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , shipping_nc_dp (:,:, i_ship ), start = ( / dim_start_shipping_nc ( x_dim_nc_index ), dim_start_shipping_nc ( y_dim_nc_index ) / ), count = ( / dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Shipping variable min and max: ' , trim ( var_name_nc_temp ), minval ( shipping_nc_dp (:,:, i_ship )), maxval ( shipping_nc_dp (:,:, i_ship )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo !Loop through the shipping data and put it in the shipping emission grid !Interpolate to the shipping grid in lat lon coordinates !Temporary emissions cutoff i_ship = 1 where ( shipping_nc_dp . lt . min_proxy_emission_shipping_value ) shipping_nc_dp = 0. write ( unit_logfile , '(2a,2f12.2)' ) 'Shipping min and max: ' , trim ( var_name_nc_temp ), minval ( shipping_nc_dp (:,:, i_ship )), maxval ( shipping_nc_dp (:,:, i_ship )) proxy_emission_subgrid (:,:, source_index ,:) = 0. do j = 1 , emission_subgrid_dim ( y_dim_nc_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_nc_index , source_index ) !Project the centre position to lat lon call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = 1. / cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !Interpolate on same grid then scale, equivalent to interpolating density and then recalculating proxy_emission_subgrid ( i , j , source_index ,:) = area_weighted_extended_vectorgrid_interpolation_function ( & real ( var2d_nc_dp ( 1 : dim_length_shipping_nc ( x_dim_nc_index ), x_dim_nc_index )) * correct_lon ( 1 ), real ( var2d_nc_dp ( 1 : dim_length_shipping_nc ( y_dim_nc_index ), y_dim_nc_index )) & , shipping_nc_dp (:,:, i_ship ), dim_length_shipping_nc ( x_dim_nc_index ), dim_length_shipping_nc ( y_dim_nc_index ) & , delta_shipping_nc * correct_lon , temp_lon ( 1 ) * correct_lon ( 1 ), temp_lat ( 1 ), delta_shipping_nc * correct_lon ) temp_scale = ( temp_delta ( 1 ) * correct_lon ( 1 ) * temp_delta ( 2 ) * correct_lon ( 2 )) / ( delta_shipping_nc ( 1 ) * correct_lon ( 1 ) * delta_shipping_nc ( 2 ) * correct_lon ( 2 )) proxy_emission_subgrid ( i , j , source_index ,:) = proxy_emission_subgrid ( i , j , source_index ,:) * temp_scale if ( isnan ( proxy_emission_subgrid ( i , j , source_index , 1 ))) then write ( * , * ) 'Stopping, nan in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_shipping_nc , temp_delta , temp_lon stop endif if ( proxy_emission_subgrid ( i , j , source_index , 1 ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_shipping_nc , temp_delta , temp_lon stop endif enddo enddo endif !No shipping data available if ( allocated ( shipping_nc_dp )) deallocate ( shipping_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_var2d_nc_dp )) deallocate ( temp_var2d_nc_dp ) end subroutine uEMEP_read_netcdf_shipping_latlon !---------------------------------------------------------------------- subroutine match_string_multi_val ( match_str , unit_in , unit_output , val , n_val ) !Finds a leading string and returns all the integer variables that follows it !Tab delimitted before and free format after implicit none integer n_val real val ( n_val ) character ( * ) match_str character ( 256 ) temp_str1 , temp_str2 , temp_str integer unit_in , unit_output integer index_val character ( len = :), allocatable :: fmt val =- 99 9. temp_str1 = '' temp_str2 = 'Not available' rewind ( unit_in ) do while ( index ( temp_str1 , match_str ). eq . 0 ) read ( unit_in , '(a)' , end = 10 ) temp_str index_val = index ( temp_str , achar ( 9 )) temp_str1 = temp_str ( 1 : index_val - 1 ) temp_str = temp_str ( index_val + 1 :) index_val = index ( temp_str , achar ( 9 )) !if (index_val.gt.0) then !    temp_str2=temp_str(1:index_val-1) !else !    temp_str2=temp_str !endif end do if ( LEN ( trim ( temp_str )). gt . 0 ) then read ( temp_str , * ) val ( 1 : n_val ) else goto 15 endif if ( unit_output . ge . 0 ) then write ( fmt , '(A,I0,A)' ) '(A40,A3' , n_val , 'es10.2)' write ( unit_output , fmt ) trim ( match_str ), ' = ' , val endif return 10 write ( unit_output , * ) 'WARNING: No match found to \"' // trim ( match_str ) // '\" in input files. Set to -999' return 15 write ( unit_output , * ) 'WARNING: No values for \"' // trim ( match_str ) // '\" in input files' end subroutine match_string_multi_val !---------------------------------------------------------------------- subroutine uEMEP_preaggregate_shipping_asi_data !This routine aggregates shipping data in space and time !Reads in ASI data from standard files and aggregates in UTM33 100 m grids !Writes the data out again in standard ASI format !This routine is called if the flag 'preaggregate_shipping_asi_data_flag' is set to true use uEMEP_definitions implicit none character ( 1024 ) temp_str character ( 256 ) temp_str1 integer unit_in logical :: exists integer count , index_val real ddlatitude , ddlongitude , totalnoxemission , totalparticulatematteremission real y_ship , x_ship integer i_ship_index , j_ship_index integer source_index , subsource_index integer t integer ship_i_dim_index , ship_j_dim_index , ship_x_dim_index , ship_y_dim_index , ship_lat_dim_index , ship_lon_dim_index , ship_count_dim_index , ship_pm_dim_index , ship_nox_dim_index parameter ( ship_i_dim_index = 1 , ship_j_dim_index = 2 , ship_count_dim_index = 3 ) parameter ( ship_x_dim_index = 1 , ship_y_dim_index = 2 , ship_lat_dim_index = 3 , ship_lon_dim_index = 4 , ship_pm_dim_index = 5 , ship_nox_dim_index = 6 ) integer max_ship_dim_index parameter ( max_ship_dim_index = 500000 ) integer ship_index ( max_ship_dim_index , 3 ) real ship_value ( max_ship_dim_index , 6 ) integer ship_index_count , i_count logical found_index real :: ship_delta = 25 0. integer :: i_ship_min = 1000000 , i_ship_max =- 1000000 , j_ship_min = 1000000 , j_ship_max =- 1000000 integer i_ship_dim_min , i_ship_dim_max , j_ship_dim_min , j_ship_dim_max parameter ( i_ship_dim_min =- 400 , i_ship_dim_max = 4500 , j_ship_dim_min = 25000 , j_ship_dim_max = 32000 ) integer ship_array_index ( i_ship_dim_min : i_ship_dim_max , j_ship_dim_min : j_ship_dim_max ) logical :: havbase_data_type = . false . integer :: io if (. not . calculate_aggregated_shipping_emissions_flag ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Aggregating shipping asi data  (uEMEP_preaggregate_shipping_asi_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = shipping_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. t = 1 pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // trim ( filename_ship ( 1 )) !Test existence of the shipping filename. If does not exist then use default inquire ( file = trim ( pathfilename_ship ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Shipping file does not exist: ' , trim ( pathfilename_ship ( 1 )) stop endif ship_index_count = 0 ship_value = 0. ship_index = 0 ship_array_index = 0 !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening shipping file ' // trim ( pathfilename_ship ( 1 )) rewind ( unit_in ) subsource_index = 1 havbase_data_type = . true . !Read header old: ddlatitude;ddlongitude;totalnoxemission;totalparticulatematteremission;fk_vessellloydstype;fk_ais_norwegianmainvesselcategory;date;time !Read header new: mmsi;date_time_utc;lat;lon;lloydstype;norvesselcategory;sizegroupgrosston;vesselname;imonumber;dist_nextpoint;sec_nextpoint;fuelconsumption;me_fuelquality;co2emission;so2emission;particulatematteremission;noxemission;nmvocemission;ch4emission;n2oemission;coemission;blackcarbonemission;organiccarbonemission read ( unit_in , '(A)' ) temp_str write ( * , * ) trim ( temp_str ) count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !read(unit_in,*) temp_str !write(*,*) trim(temp_str) ddlatitude = 0. ; ddlongitude = 0. ; totalnoxemission = 0. ; totalparticulatematteremission = 0. if ( havbase_data_type ) then !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip mmsi index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip date_time_utc index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ddlatitude !Read an entry index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ddlongitude !Read an entry index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip lloydstype index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip norvesselcategory index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip sizegroupgrosston index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip vesselname index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip imonumber index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip dist_nextpoint index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip sec_nextpoint index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip fuelconsumption index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip me_fuelquality index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip co2emission index_val = index ( temp_str , ';' , back = . false .); temp_str = temp_str ( index_val + 1 :) !Skip so2emission index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalparticulatematteremission !Read an entry index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalnoxemission !Read an entry else !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlatitude !write (*,*) ddlatitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) ddlongitude !write (*,*) ddlongitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) !write(*,*) index_val,trim(temp_str1),trim(temp_str) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalnoxemission !write (*,*) totalnoxemission index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) if ( index_val . gt . 1 ) read ( temp_str1 , * ) totalparticulatematteremission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !temp_str1=temp_str !if (len(temp_str1).gt.0) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) endif !write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission count = count + 1 if ( mod ( count , 10000 ). eq . 0 ) write ( * , '(2i12,2f12.2,2e12.2)' ) count , ship_index_count , ddlatitude , ddlongitude , totalnoxemission , totalparticulatematteremission if ( totalnoxemission . gt . 0. or . totalparticulatematteremission . gt . 0 ) then !Convert lat lon to utm coords if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , ddlatitude , ddlongitude , y_ship , x_ship ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_ship , y_ship , ddlongitude , ddlatitude , projection_attributes ) endif !Find the grid index it belongs to. This assumes a minimum UTM grid at 0 so the index can be negative !Not certain if this 0.5 is correct i_ship_index = floor (( x_ship - 0 ) / ship_delta + 0.5 ) j_ship_index = floor (( y_ship - 0 ) / ship_delta + 0.5 ) i_ship_min = min ( i_ship_index , i_ship_min ) i_ship_max = max ( i_ship_index , i_ship_max ) j_ship_min = min ( j_ship_index , j_ship_min ) j_ship_max = max ( j_ship_index , j_ship_max ) if ( i_ship_index . lt . i_ship_dim_min . or . i_ship_index . gt . i_ship_dim_max . or . j_ship_index . lt . j_ship_dim_min . or . j_ship_index . gt . j_ship_dim_max ) then write ( * , * ) i_ship_dim_min , i_ship_dim_max , j_ship_dim_min , j_ship_dim_max write ( * , * ) i_ship_index , j_ship_index stop endif i_count = ship_array_index ( i_ship_index , j_ship_index ) if ( i_count . eq . 0 ) then ship_index_count = ship_index_count + 1 ship_array_index ( i_ship_index , j_ship_index ) = ship_index_count i_count = ship_index_count endif ship_index ( i_count , ship_count_dim_index ) = ship_index ( i_count , ship_count_dim_index ) + 1 if ( totalparticulatematteremission . gt . 0. and .. not . isnan ( totalparticulatematteremission )) ship_value ( i_count , ship_pm_dim_index ) = ship_value ( i_count , ship_pm_dim_index ) + totalparticulatematteremission if ( totalnoxemission . gt . 0. and .. not . isnan ( totalnoxemission )) ship_value ( i_count , ship_nox_dim_index ) = ship_value ( i_count , ship_nox_dim_index ) + totalnoxemission ship_index ( i_count , ship_i_dim_index ) = i_ship_index ship_index ( i_count , ship_j_dim_index ) = j_ship_index ship_value ( i_count , ship_x_dim_index ) = ( ship_index ( i_count , ship_i_dim_index ) + . 5 ) * ship_delta ship_value ( i_count , ship_y_dim_index ) = ( ship_index ( i_count , ship_j_dim_index ) + . 5 ) * ship_delta call PROJ2LL ( ship_value ( i_count , ship_x_dim_index ), ship_value ( i_count , ship_y_dim_index ), ship_value ( i_count , ship_lon_dim_index ), ship_value ( i_count , ship_lat_dim_index ), projection_attributes , projection_type ) call utm2ll ( 1 , utm_zone , ship_value ( i_count , ship_y_dim_index ), ship_value ( i_count , ship_x_dim_index ), ship_value ( i_count , ship_lat_dim_index ), ship_value ( i_count , ship_lon_dim_index )) !if (mod(count,10000).eq.0) write(*,'(2i,2f,2e)') count,ship_index_count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission !if (mod(count,10000).eq.0) write(*,'(3i12,4f14.4,2es14.5)') count,i_count,ship_index(i_count,ship_count_dim_index),ship_value(i_count,ship_y_dim_index),ship_value(i_count,ship_x_dim_index),ship_value(i_count,ship_lat_dim_index),ship_value(i_count,ship_lon_dim_index),ship_value(i_count,ship_pm_dim_index),ship_value(i_count,ship_nox_dim_index) !write(*,*) ship_index_count,x_ship,y_ship !write(*,*) i_count,i_ship_index,j_ship_index !write(*,*) ship_index(i_count,ship_i_dim_index),ship_index(i_count,ship_j_dim_index),ship_index(i_count,ship_count_dim_index) endif !Determine if the grid has been found before and add to it if ( 1. eq . 2 ) then if (( totalnoxemission . gt . 0. or . totalparticulatematteremission . gt . 0 )) then found_index = . false . do i_count = 1 , ship_index_count if ( ship_index ( i_count , ship_i_dim_index ). eq . i_ship_index . and . ship_index ( i_count , ship_j_dim_index ). eq . j_ship_index ) then ship_index ( i_count , ship_count_dim_index ) = ship_index ( i_count , ship_count_dim_index ) + 1 ship_value ( i_count , ship_pm_dim_index ) = ship_value ( i_count , ship_pm_dim_index ) + totalparticulatematteremission ship_value ( i_count , ship_nox_dim_index ) = ship_value ( i_count , ship_nox_dim_index ) + totalnoxemission found_index = . true . exit endif enddo if (. not . found_index ) then ship_index_count = ship_index_count + 1 i_count = ship_index_count ship_index ( i_count , ship_i_dim_index ) = i_ship_index ship_index ( i_count , ship_j_dim_index ) = j_ship_index ship_index ( i_count , ship_count_dim_index ) = 1 ship_value ( i_count , ship_pm_dim_index ) = totalparticulatematteremission ship_value ( i_count , ship_nox_dim_index ) = totalnoxemission endif !write(*,*) count,ship_index_count endif endif enddo write ( unit_logfile , '(A,2I)' ) 'Shipping counts = ' , count , ship_index_count close ( unit_in ) !Calculate the x,y, lat,lon of the centre of the valid grids !do i_count=1,ship_index_count !ship_value(i_count,ship_x_dim_index)=(ship_index(i_count,ship_i_dim_index)+.5)*ship_delta !ship_value(i_count,ship_y_dim_index)=(ship_index(i_count,ship_j_dim_index)+.5)*ship_delta !call utm2ll_modern(1,utm_zone,ship_value(i_count,ship_y_dim_index),ship_value(i_count,ship_x_dim_index),ship_value(i_count,ship_lat_dim_index),ship_value(i_count,ship_lon_dim_index)) !enddo !Save the data in the same format as previously provided pathfilename_ship ( 1 ) = trim ( pathname_ship ( 1 )) // 'Aggregated_' // trim ( filename_ship ( 1 )) !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_ship ( 1 ), access = 'sequential' , status = 'unknown' ) write ( unit_logfile , '(a)' ) ' Writing to aggregated shipping file ' // trim ( pathfilename_ship ( 1 )) write ( unit_in , '(a)' ) 'ddlatitude;ddlongitude;totalnoxemission;totalparticulatematteremission;fk_vessellloydstype;fk_ais_norwegianmainvesselcategory;date;time' do i_count = 1 , ship_index_count if ( ship_index ( i_count , ship_count_dim_index ). gt . 1 ) then write ( unit_in , '(f14.5,a1,f14.5,a1,e12.2,a1,e12.2,a4)' ) ship_value ( i_count , ship_lat_dim_index ), ';' , ship_value ( i_count , ship_lon_dim_index ), ';' , ship_value ( i_count , ship_nox_dim_index ), ';' , ship_value ( i_count , ship_pm_dim_index ), ';;;;' endif enddo close ( unit_in ) !Max and min array dimensions found write ( * , * ) i_ship_min , i_ship_max , j_ship_min , j_ship_max stop end subroutine uEMEP_preaggregate_shipping_asi_data end module read_shipping_asi_data","tags":"","loc":"sourcefile/uemep_read_shipping_asi_data.f90.html"},{"title":"uEMEP_read_EMEP.f90 – uEMEP","text":"Source Code module read_emep use uemep_configuration use time_functions , only : number_to_date , date_to_number use kz_functions , only : TROENKz_invL_from_phi use mod_lambert_projection , only : PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: uEMEP_read_EMEP contains !uEMEP_read_EMEP subroutine uEMEP_read_EMEP use uEMEP_definitions use netcdf implicit none integer i , j , k , t integer ii , jj , iii , jjj logical exists integer status_nc !Error message integer id_nc integer dim_id_nc ( num_dims_nc ) character ( 256 ) dimname_temp , var_name_nc_temp , var_name_nc_temp2 , unit_name_nc_temp integer var_id_nc integer i_file , i_source , i_conc , i_dim integer temp_num_dims integer temp_start_time_nc_index , temp_end_time_nc_index integer i_loop integer valid_dim_length_nc ( num_dims_nc ) !dimensions of file 1 integer surface_level_nc_2 real temp_lat ( 4 ), temp_lon ( 4 ) real temp_y ( 4 ), temp_x ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max double precision temp_var1d_nc_dp ( 2 , 2 ) real temp_delta ( 2 ) real H_emep_temp integer n_file double precision date_num_temp , date_num_2000 integer date_array ( 6 ) double precision scale_factor_nc integer i_pollutant , p_loop , p_loop_index integer DMT_start_time_nc_index , DMT_end_time_nc_index , DMT_dim_length_nc logical nonzero_wind_notfound integer i_sp , ii_sp , pmxx_sp_index integer i_depo !Temporary reading variables double precision , allocatable :: var1d_nc_dp (:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: var3d_nc_dp (:,:,:) double precision , allocatable :: var4d_nc_dp (:,:,:,:) !Temporary files for rotating wind field and PM real , allocatable :: temp_var4d_nc (:,:,:,:,:) real , allocatable :: temp_var3d_nc (:,:,:) !Temporary PM arrays for reading in PM10 real , allocatable :: pm_var4d_nc (:,:,:,:,:,:,:) real , allocatable :: pm_var3d_nc (:,:,:,:,:,:) real , allocatable :: pm_lc_var4d_nc (:,:,:,:,:,:,:,:,:) real , allocatable :: species_temp_var3d_nc (:,:,:) !NOTE: temporary for nh3 false is not on logical :: use_comp_temporary = . false . logical :: EMEP_region_outside_domain = . false . real EMEP_grid_interpolation_size_temp real mean_phi_temp , mean_invL_temp integer phi_count write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading EMEP data (uEMEP_read_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !This if statement is already specified in uEMEP_define_subgrid and is not necessary here if ( hourly_calculations ) then temp_start_time_nc_index = start_time_nc_index temp_end_time_nc_index = end_time_nc_index else temp_start_time_nc_index = 1 temp_end_time_nc_index = 1 endif if ( use_single_time_loop_flag ) then temp_start_time_nc_index = start_time_nc_index + t_loop - 1 temp_end_time_nc_index = temp_start_time_nc_index endif !Presettng the surface level to 1. Valid when there is no inverting of layers surface_level_nc = EMEP_surface_level_nc surface_level_nc_2 = EMEP_surface_level_nc_2 write ( unit_logfile , '(A,I0)' ) ' Surface level base set to: ' , surface_level_nc write ( unit_logfile , '(A,I0)' ) ' Surface level local_contribution set to: ' , surface_level_nc_2 if ( allocated ( val_dim_nc )) deallocate ( val_dim_nc ) if ( allocated ( unit_dim_nc )) deallocate ( unit_dim_nc ) if ( allocated ( var1d_nc )) deallocate ( var1d_nc ) if ( allocated ( var2d_nc )) deallocate ( var2d_nc ) if ( allocated ( var3d_nc )) deallocate ( var3d_nc ) if ( allocated ( var4d_nc )) deallocate ( var4d_nc ) if ( allocated ( comp_var3d_nc )) deallocate ( comp_var3d_nc ) if ( allocated ( comp_var4d_nc )) deallocate ( comp_var4d_nc ) if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( lc_var3d_nc )) deallocate ( lc_var3d_nc ) if ( allocated ( lc_var4d_nc )) deallocate ( lc_var4d_nc ) if ( allocated ( DMT_EMEP_grid_nc )) deallocate ( DMT_EMEP_grid_nc ) !Daily mean temperature if ( allocated ( species_var3d_nc )) deallocate ( species_var3d_nc ) if ( allocated ( depo_var3d_nc )) deallocate ( depo_var3d_nc ) if ( allocated ( temp_var3d_nc )) deallocate ( temp_var3d_nc ) !Loop through the EMEP files containing the data n_file = 2 do i_file = 1 , n_file !Temporary fix. Must remove !if (i_file.eq.2) dim_name_nc(z_dim_nc_index)='klevel' !Set the filename pathfilename_EMEP ( i_file ) = trim ( pathname_EMEP ( i_file )) // trim ( filename_EMEP ( i_file )) !Test existence of the filename. If does not exist then stop inquire ( file = trim ( pathfilename_EMEP ( i_file )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_EMEP ( i_file )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_EMEP ( i_file )) status_nc = NF90_OPEN ( pathfilename_EMEP ( i_file ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) write ( unit_logfile , '(A,I0)' ) 'ERROR opening netcdf file: ' , status_nc EMEP_projection_type = LL_projection_index !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'projection_lambert' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) status_nc = nf90_get_att ( id_nc , var_id_nc , 'standard_parallel' , EMEP_projection_attributes ( 1 : 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_central_meridian' , EMEP_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , EMEP_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , EMEP_projection_attributes ( 5 )) EMEP_projection_type = LCC_projection_index !Reset names of the x,y coordinates dim_name_nc ( x_dim_nc_index ) = 'i' dim_name_nc ( y_dim_nc_index ) = 'j' var_name_nc ( lon_nc_index ,:, allsource_index ) = 'lon' var_name_nc ( lat_nc_index ,:, allsource_index ) = 'lat' write ( unit_logfile , '(A,5f12.2)' ) 'Reading lambert_conformal_conic projection. ' , EMEP_projection_attributes ( 1 : 5 ) if ( EMEP_projection_attributes ( 1 ). ne . EMEP_projection_attributes ( 4 ). or . EMEP_projection_attributes ( 2 ). ne . EMEP_projection_attributes ( 4 )) then use_alternative_LCC_projection_flag = . true . write ( unit_logfile , '(A,l)' ) 'Using alternative lambert_conformal_conic projection: ' , use_alternative_LCC_projection_flag else use_alternative_LCC_projection_flag = . false . endif !Always set to true use_alternative_LCC_projection_flag = . true . endif !Find the projection. If no projection then in lat lon coordinates status_nc = NF90_INQ_VARID ( id_nc , 'Polar_Stereographic' , var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) EMEP_projection_attributes = 0. status_nc = nf90_get_att ( id_nc , var_id_nc , 'straight_vertical_longitude_from_pole' , EMEP_projection_attributes ( 1 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'latitude_of_projection_origin' , EMEP_projection_attributes ( 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_easting' , EMEP_projection_attributes ( 3 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 3 ) = 0. status_nc = nf90_get_att ( id_nc , var_id_nc , 'false_northing' , EMEP_projection_attributes ( 4 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 4 ) = 0. status_nc = nf90_get_att ( id_nc , var_id_nc , 'earth_radius' , EMEP_projection_attributes ( 5 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 5 ) = 6.370e6 status_nc = nf90_get_att ( id_nc , var_id_nc , 'scale_factor_at_projection_origin' , EMEP_projection_attributes ( 6 )) if ( status_nc . ne . NF90_NOERR ) EMEP_projection_attributes ( 6 ) = 1. EMEP_projection_type = PS_projection_index !Reset names of the x,y coordinates dim_name_nc ( x_dim_nc_index ) = 'i' dim_name_nc ( y_dim_nc_index ) = 'j' var_name_nc ( lon_nc_index ,:, allsource_index ) = 'lon' var_name_nc ( lat_nc_index ,:, allsource_index ) = 'lat' write ( unit_logfile , '(A,6f12.2)' ) 'Reading Polar_Stereographic: ' , EMEP_projection_attributes ( 1 : 6 ) endif !Find the (x,y,z,time,xdist,ydist) dimensions of the file do i_dim = 1 , num_dims_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(3A,I0)' ) 'No dimension information available for ' , trim ( dim_name_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_nc ( i_dim ) = 1 endif enddo if ( subgrid_dim ( t_dim_index ). gt . dim_length_nc ( time_dim_nc_index )) then write ( unit_logfile , '(A,2I0)' ) 'ERROR: Specified time dimensions are greater than EMEP netcdf dimensions. Stopping ' , subgrid_dim ( t_dim_index ), dim_length_nc ( time_dim_nc_index ) stop endif write ( unit_logfile , '(A,6I0)' ) ' Size of dimensions (x,y,z,t,xdist,ydist): ' , dim_length_nc dim_length_EMEP_nc = dim_length_nc dim_start_nc ( time_dim_nc_index ) = temp_start_time_nc_index dim_length_nc ( time_dim_nc_index ) = min ( dim_length_nc ( time_dim_nc_index ), subgrid_dim ( t_dim_index )) write ( unit_logfile , '(A,6I0)' ) ' New size of dimensions (x,y,z,t,xdist,ydist): ' , dim_length_nc if ( mod ( dim_length_nc ( xdist_dim_nc_index ), 2 ). ne . 1. or . mod ( dim_length_nc ( ydist_dim_nc_index ), 2 ). ne . 1 ) then write ( unit_logfile , '(A,2I0)' ) ' ERROR: Even sized dimensions for local contribution. Must be odd: ' , dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ) stop endif if ( i_file . eq . 2 ) then xdist_centre_nc = 1 + dim_length_nc ( xdist_dim_nc_index ) / 2 ydist_centre_nc = 1 + dim_length_nc ( ydist_dim_nc_index ) / 2 write ( unit_logfile , '(A,2I0)' ) ' Centre index of local contribution dimensions: ' , xdist_centre_nc , ydist_centre_nc endif !Calculate the necessary extent of the EMEP grid region and only read these grids if ( reduce_EMEP_region_flag ) then !EMEP_grid_interpolation_size_temp=max(EMEP_grid_interpolation_size*local_fraction_grid_size_scaling,EMEP_additional_grid_interpolation_size_original*local_fraction_additional_grid_size_scaling) EMEP_grid_interpolation_size_temp = EMEP_grid_interpolation_size * local_fraction_grid_size_scaling write ( unit_logfile , '(A,f12.2)' ) 'Reducing EMEP domain. EMEP grid interpolation size is now = ' , EMEP_grid_interpolation_size_temp !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_min ( x_dim_index ), init_subgrid_max ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( init_subgrid_max ( x_dim_index ), init_subgrid_min ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(init_subgrid_min(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(1),temp_lon(1)) !    call RDM2LL(init_subgrid_max(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(2),temp_lon(2)) !    call RDM2LL(init_subgrid_max(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(3),temp_lon(3)) !    call RDM2LL(init_subgrid_min(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(4),temp_lon(4)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(1),temp_lon(1)) !    call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(2),temp_lon(2)) !    call UTM2LL(utm_zone,init_subgrid_max(y_dim_index),init_subgrid_min(x_dim_index),temp_lat(3),temp_lon(3)) !    call UTM2LL(utm_zone,init_subgrid_min(y_dim_index),init_subgrid_max(x_dim_index),temp_lat(4),temp_lon(4)) !endif !This did not work because it was almost all of the grid and because the min and max lat lon did not cover all stations !if (read_EMEP_only_once_flag.and.use_multiple_receptor_grids_flag) then !    temp_lat(1)=minval(lat_receptor(1:n_receptor_in));temp_lon(1)=minval(lon_receptor(1:n_receptor_in)) !    temp_lat(2)=maxval(lat_receptor(1:n_receptor_in));temp_lon(2)=maxval(lon_receptor(1:n_receptor_in)) !    temp_lat(3)=maxval(lat_receptor(1:n_receptor_in));temp_lon(3)=minval(lon_receptor(1:n_receptor_in)) !    temp_lat(4)=minval(lat_receptor(1:n_receptor_in));temp_lon(4)=maxval(lon_receptor(1:n_receptor_in)) !    write(*,*) temp_lat !    write(*,*) temp_lon !endif temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 if ( EMEP_projection_type . eq . LCC_projection_index ) then !Convert lat lon corners to lambert do i = 1 , 4 !if (use_alternative_LCC_projection_flag) then call lb2lambert2_uEMEP ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), EMEP_projection_attributes ) !else !    call lb2lambert_uEMEP(temp_x(i),temp_y(i),temp_lon(i),temp_lat(i),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) !endif !call lb2lambert_uEMEP(temp_x(i),temp_y(i),temp_lon(i),temp_lat(i),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) enddo !write(*,*) temp_x !write(*,*) temp_y elseif ( EMEP_projection_type . eq . PS_projection_index ) then !Convert lat lon corners to Polar Stereo do i = 1 , 4 call LL2PS_spherical ( temp_x ( i ), temp_y ( i ), temp_lon ( i ), temp_lat ( i ), EMEP_projection_attributes ) enddo elseif ( EMEP_projection_type . eq . LL_projection_index ) then !Set lat lon corners if EMEP is in lat lon temp_x = temp_lon ; temp_y = temp_lat else !Otherwise assume the same coordinate system temp_x ( 1 ) = init_subgrid_min ( x_dim_index ); temp_y ( 1 ) = init_subgrid_min ( y_dim_index ) temp_x ( 2 ) = init_subgrid_max ( x_dim_index ); temp_y ( 2 ) = init_subgrid_min ( y_dim_index ) temp_x ( 3 ) = init_subgrid_min ( x_dim_index ); temp_y ( 3 ) = init_subgrid_max ( y_dim_index ) temp_x ( 4 ) = init_subgrid_max ( x_dim_index ); temp_y ( 4 ) = init_subgrid_max ( y_dim_index ) endif do i = 1 , 4 !write(*,*) temp_x(i),temp_y(i) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo !Read in the first 2 x and y position values from the nc file to get min values and delta values !write(*,*) temp_x_min,temp_x_max,temp_y_min,temp_y_max !Save these values, min and max extent of the calculation grid in emep coordinates, for possible use later if ( limit_emep_grid_interpolation_region_to_calculation_region ) then subgrid_proj_min ( y_dim_index ) = temp_y_min subgrid_proj_max ( y_dim_index ) = temp_y_max subgrid_proj_min ( x_dim_index ) = temp_x_min subgrid_proj_max ( x_dim_index ) = temp_x_max endif status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_nc ( x_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 1 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_nc ( y_dim_nc_index )), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var1d_nc_dp ( 2 , 1 : 2 ), start = ( / 1 / ), count = ( / 2 / )) status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_name_nc_temp ) if ( trim ( unit_name_nc_temp ). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' temp_var1d_nc_dp = temp_var1d_nc_dp * 100 0. endif !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = temp_var1d_nc_dp ( 1 , 2 ) - temp_var1d_nc_dp ( 1 , 1 ) temp_delta ( 2 ) = temp_var1d_nc_dp ( 2 , 2 ) - temp_var1d_nc_dp ( 2 , 1 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size_temp i_temp_min = 1 + floor (( temp_x_min - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) i_temp_min = 1 + floor (( temp_x_min - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + ceiling (( temp_x_max - temp_var1d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + ceiling (( temp_y_max - temp_var1d_nc_dp ( 2 , 1 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max i_temp_min = max ( 1 , i_temp_min - 1 - ceiling ( 1. * EMEP_grid_interpolation_size_temp )) i_temp_max = min ( dim_length_nc ( x_dim_nc_index ), i_temp_max + 1 + ceiling ( 1. * EMEP_grid_interpolation_size_temp )) j_temp_min = max ( 1 , j_temp_min - 1 - ceiling ( 1. * EMEP_grid_interpolation_size_temp )) j_temp_max = min ( dim_length_nc ( y_dim_nc_index ), j_temp_max + 1 + ceiling ( 1. * EMEP_grid_interpolation_size_temp )) dim_length_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_nc ( x_dim_nc_index ) = i_temp_min dim_start_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I0)' ) ' Reading EMEP i grids: ' , i_temp_min , i_temp_max , dim_length_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I0)' ) ' Reading EMEP j grids: ' , j_temp_min , j_temp_max , dim_length_nc ( y_dim_nc_index ) dim_start_EMEP_nc = dim_start_nc !endif endif if ( dim_length_nc ( x_dim_nc_index ). lt . 1. or . dim_length_nc ( y_dim_nc_index ). lt . 1 ) then write ( unit_logfile , '(A,2I0)' ) ' WARNING: Selected EMEP region dimensions are less than 1 (i,j): ' , dim_length_nc write ( unit_logfile , '(A)' ) ' Setting to 1 but this selected region is invalid and should not be calculated ' write ( unit_logfile , '(A)' ) ' This can happen if a receptor is outside the EMEP domain' dim_length_nc = 1 dim_start_nc ( x_dim_nc_index ) = 1 dim_start_nc ( y_dim_nc_index ) = 1 EMEP_region_outside_domain = . true . endif !Allocate the nc arrays for reading if (. not . allocated ( val_dim_nc )) allocate ( val_dim_nc ( maxval ( dim_length_nc ), num_dims_nc )) !x, y, z and time dimension values if (. not . allocated ( unit_dim_nc )) allocate ( unit_dim_nc ( num_dims_nc )) !x, y, z and time dimension values if (. not . allocated ( var1d_nc )) allocate ( var1d_nc ( maxval ( dim_length_nc ), num_dims_nc )) !x, y, z and time maximum dimensions if (. not . allocated ( var2d_nc )) allocate ( var2d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 2 )) !Lat and lon if (. not . allocated ( var3d_nc )) then allocate ( var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , n_pollutant_loop )) var3d_nc = 0. endif if (. not . allocated ( var4d_nc )) then allocate ( var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , n_pollutant_loop )) var4d_nc = 0. endif if (. not . allocated ( comp_var3d_nc )) then allocate ( comp_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_compound_nc_index )) comp_var3d_nc = 0. endif if (. not . allocated ( comp_var4d_nc )) then allocate ( comp_var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_compound_nc_index )) comp_var4d_nc = 0. endif if (. not . allocated ( var1d_nc_dp )) allocate ( var1d_nc_dp ( maxval ( dim_length_nc ))) if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) !Lat and lon if (. not . allocated ( temp_var3d_nc )) allocate ( temp_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ))) !Lat and lon !if (.not.allocated(var3d_nc_dp)) allocate (var3d_nc_dp(dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(time_dim_nc_index))) !allocate (var4d_nc_dp(dim_length_nc(x_index),dim_length_nc(y_index),1,dim_length_nc(time_index))) if ( calculate_deposition_flag ) then if (. not . allocated ( depo_var3d_nc )) then allocate ( depo_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_landuse_index , n_pollutant_loop )) depo_var3d_nc = 0 endif endif if ( save_emep_species . or . save_seasalt ) then if (. not . allocated ( species_var3d_nc )) then allocate ( species_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), n_pmxx_sp_index , n_species_loop_index )) species_var3d_nc = 0 endif if (. not . allocated ( species_temp_var3d_nc )) allocate ( species_temp_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ))) endif if ( i_file . eq . 2. and .. not . allocated ( lc_var3d_nc )) then allocate ( lc_var3d_nc ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_lc_var_nc , n_source_nc_index , n_pollutant_loop )) lc_var3d_nc = 0. endif if ( i_file . eq . 2. and .. not . allocated ( lc_var4d_nc )) then allocate ( lc_var4d_nc ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 1 , dim_length_nc ( time_dim_nc_index ), num_lc_var_nc , n_source_nc_index , n_pollutant_loop )) lc_var4d_nc = 0. endif if ( i_file . eq . 2. and .. not . allocated ( pm_lc_var4d_nc )) then allocate ( pm_lc_var4d_nc ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 1 , dim_length_nc ( time_dim_nc_index ), num_lc_var_nc , n_source_nc_index , 2 )) pm_lc_var4d_nc = 0. endif if (. not . allocated ( pm_var4d_nc )) then allocate ( pm_var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , 2 )) pm_var4d_nc = 0. endif if (. not . allocated ( pm_var3d_nc )) then allocate ( pm_var3d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), num_var_nc , n_source_nc_index , 2 )) pm_var3d_nc = 0. endif if (. not . allocated ( temp_var4d_nc ). and . i_file . eq . 1 ) then allocate ( temp_var4d_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ), 2 )) temp_var4d_nc = 0. endif !write(*,*) x_dim_nc_index,y_dim_nc_index !write(*,*) shape(var1d_nc_dp) !write(*,*) dim_length_nc !Read in the dimensions and check values of the dimensions. Not necessary but diagnostic do i = 1 , num_dims_nc status_nc = NF90_INQ_VARID ( id_nc , trim ( dim_name_nc ( i )), var_id_nc ) !write(*,*) id_nc, trim(dim_name_nc(i)), var_id_nc(i),dim_length_nc(i) var1d_nc_dp = 0. !write(*,*) 'HERE',i,dim_start_nc(i),dim_length_nc(i) unit_dim_nc ( i ) = '' if ( status_nc . EQ . NF90_NOERR ) then status_nc = nf90_get_att ( id_nc , var_id_nc , \"units\" , unit_dim_nc ( i )) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var1d_nc_dp ( 1 : dim_length_nc ( i )), start = ( / dim_start_nc ( i ) / ), count = ( / dim_length_nc ( i ) / )); var1d_nc ( 1 : dim_length_nc ( i ), i ) = real ( var1d_nc_dp ( 1 : dim_length_nc ( i ))) !write(*,*) id_nc, trim(dim_name_nc(i)), var_id_nc,dim_length_nc(i),status_nc !Use the first file to give valid time stamps if ( i_file . eq . 1. and . i . eq . time_dim_nc_index ) then val_dim_nc ( 1 : dim_length_nc ( i ), i ) = ( var1d_nc_dp ( 1 : dim_length_nc ( i ))) valid_dim_length_nc ( i ) = dim_length_nc ( i ) elseif ( i_file . ne . 1. and . i . ne . time_dim_nc_index ) then val_dim_nc ( 1 : dim_length_nc ( i ), i ) = ( var1d_nc_dp ( 1 : dim_length_nc ( i ))) valid_dim_length_nc ( i ) = dim_length_nc ( i ) endif !write(*,*) val_dim_nc(1:dim_length_nc(i),i),trim(unit_dim_nc(i)) else var1d_nc ( 1 : dim_length_nc ( i ), i ) = 0. val_dim_nc ( 1 : dim_length_nc ( i ), i ) = 0. endif !Convert from meters to km for AROME data if necessary if (( i . eq . x_dim_nc_index . or . i . eq . y_dim_nc_index ). and . trim ( unit_dim_nc ( i )). eq . 'km' ) then write ( unit_logfile , '(A)' ) 'Units of x y data are in kilometres. Converting to metres' val_dim_nc ( 1 : dim_length_nc ( i ), i ) = val_dim_nc ( 1 : dim_length_nc ( i ), i ) * 100 0. var1d_nc ( 1 : dim_length_nc ( i ), i ) = var1d_nc ( 1 : dim_length_nc ( i ), i ) * 100 0. endif if ( i . eq . time_dim_nc_index ) then !write(unit_logfile,'(3A,2i12)') ' ',trim(dim_name_nc(i)),' (min, max in hours): ' & !    ,minval(int((var1d_nc(1:dim_length_nc(i),i)-var1d_nc(dim_start_nc(i),i))/3600.+.5)+1) & !    ,maxval(int((var1d_nc(1:divar1d_ncm_length_nc(i),i)-var1d_nc(dim_start_nc(i),i))/3600.+.5)+1) else write ( unit_logfile , '(3A,2f12.2)' ) ' ' , trim ( dim_name_nc ( i )), ' (min, max): ' & , minval ( var1d_nc ( 1 : dim_length_nc ( i ), i )), maxval ( var1d_nc ( 1 : dim_length_nc ( i ), i )) endif enddo !Loop through the pollutants. do p_loop = 1 , n_emep_pollutant_loop + 1 !Set the compound index for this pollutant if ( p_loop . le . n_emep_pollutant_loop ) then i_pollutant = pollutant_loop_index ( p_loop ) p_loop_index = p_loop else !Special case to read in meteo data that is defined as the all_nc_index i_pollutant = all_nc_index !Put the meteo data in the first pollutant index always p_loop_index = meteo_p_loop_index endif !Loop through the sources do i_source = 1 , n_source_nc_index !write(*,*) i_source,trim(source_file_str(i_source)),uEMEP_to_EMEP_sector(i_source),calculate_source(i_source),calculate_EMEP_source(i_source) if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . save_EMEP_source ( i_source ). or . i_source . eq . allsource_index . or .( i_source . eq . extrasource_nc_index . and . use_alternative_ppm_variable_for_lf )) then !var_name_nc(num_var_nc,n_compound_nc_index,n_source_nc_index) !Loop through the variables do i = 1 , num_var_nc !write(*,*) i,trim(var_name_nc(i)) !if (i.eq.frac_nc_index) var_name_nc_temp=var_name_nc(i,i_pollutant,i_source) !if (i.eq.conc_nc_index) var_name_nc_temp=var_name_nc(i,i_pollutant,i_source) !Identify the variable name and ID in the nc file var_name_nc_temp = var_name_nc ( i , i_pollutant , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) !write(*,*) 'Status1: ',status_nc,var_id_nc,trim(var_name_nc_temp),i_source !Exception for pm10: read pmco and pm25 !if ((i.eq.conc_nc_index.or.i.eq.frac_nc_index.or.i.eq.emis_nc_index).and.i_pollutant.eq.pm10_nc_index) then if (( i . eq . conc_nc_index . or .( i . ge . min_frac_nc_loop_index . and . i . le . max_frac_nc_loop_index ). or . i . eq . emis_nc_index ). and . i_pollutant . eq . pm10_nc_index ) then ! check if at least one of them exists ! if pmco exists, use it for var_id_nc, if not use pm25 var_name_nc_temp = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . ne . NF90_NOERR ) then var_name_nc_temp = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) end if !write(*,*) '-------------------',trim(var_name_nc_temp),status_nc endif !If a variable name is found in the file then go further if ( status_nc . eq . NF90_NOERR ) then scale_factor_nc = 1. !Find the dimensions of the variable (temp_num_dims) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) !write(*,*) temp_num_dims,status_nc if ( temp_num_dims . eq . 2. and . i_file . eq . 1 ) then !Read latitude and longitude data into a 2d grid if available. Only lat lon is 2d? Only read for file 1 assuming file 2 is the same. Problem if not if ( i . eq . lat_nc_index . or . i . eq . lon_nc_index ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ); var2d_nc (:,:, i ) = real ( var2d_nc_dp ) write ( unit_logfile , '(A,i3,A,2A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( var2d_nc (:,:, i )), maxval ( var2d_nc (:,:, i )) endif elseif ( temp_num_dims . eq . 3. and . i_file . eq . 1. and . i . eq . emis_nc_index . and . i_pollutant . eq . pm10_nc_index . and . i_source . ne . extrasource_nc_index ) then var_name_nc_temp2 = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var3d_nc (:,:,:, i , i_source , 1 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var3d_nc (:,:,:, i , i_source , 1 )), maxval ( pm_var3d_nc (:,:,:, i , i_source , 1 )) write ( unit_logfile , '(2A,f16.4)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var3d_nc (:,:,:, i , i_source , 1 )) / ( size ( pm_var3d_nc , 1 ) * size ( pm_var3d_nc , 2 ) * size ( pm_var3d_nc , 4 )) end if var_name_nc_temp2 = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var3d_nc (:,:,:, i , i_source , 2 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var3d_nc (:,:,:, i , i_source , 2 )), maxval ( pm_var3d_nc (:,:,:, i , i_source , 2 )) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var3d_nc (:,:,:, i , i_source , 2 )) / ( size ( pm_var3d_nc , 1 ) * size ( pm_var3d_nc , 2 ) * size ( pm_var3d_nc , 4 )), size ( pm_var3d_nc , 1 ), size ( pm_var3d_nc , 2 ), size ( pm_var3d_nc , 4 ) end if var3d_nc (:,:,:, i , i_source , p_loop_index ) = pm_var3d_nc (:,:,:, i , i_source , 1 ) + pm_var3d_nc (:,:,:, i , i_source , 2 ) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc ( i , pm10_nc_index , i_source )), sum ( var3d_nc (:,:,:, i , i_source , p_loop_index )) / ( size ( var3d_nc , 1 ) * size ( var3d_nc , 2 ) * size ( var3d_nc , 4 )), size ( var3d_nc , 1 ), size ( var3d_nc , 2 ), size ( var3d_nc , 4 ) elseif ( temp_num_dims . eq . 3. and . i_file . eq . 1 ) then !write(*,'(6i)') dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),temp_start_time_nc_index,dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var3d_nc (:,:,:, i , i_source , p_loop_index ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) !write(*,*) status_nc write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( var3d_nc (:,:,:, i , i_source , p_loop_index )), maxval ( var3d_nc (:,:,:, i , i_source , p_loop_index )) !if (i.eq.emis_nc_index) write(*,*) 'HERE',sum(var3d_nc(:,:,:,i,i_source,p_loop_index)),i_source,p_loop_index elseif ( temp_num_dims . eq . 4 ) then if ( i_file . eq . 2. and . i . eq . ZTOP_nc_index ) then !Don't try to read elseif ( i . eq . conc_nc_index . and . i_pollutant . eq . pm10_nc_index . and . i_source . ne . extrasource_nc_index ) then var_name_nc_temp2 = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var4d_nc (:,:, dim_start_nc ( z_dim_nc_index ): dim_start_nc ( z_dim_nc_index ) + dim_length_nc ( z_dim_nc_index ) - 1 ,:, i , i_source , 1 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var4d_nc (:,:,:,:, i , i_source , 1 )), maxval ( pm_var4d_nc (:,:,:,:, i , i_source , 1 )) write ( unit_logfile , '(2A,f16.4)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var4d_nc (:,:, 1 ,:, i , i_source , 1 )) / ( size ( pm_var4d_nc , 1 ) * size ( pm_var4d_nc , 2 ) * size ( pm_var4d_nc , 4 )) end if var_name_nc_temp2 = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_var4d_nc (:,:, dim_start_nc ( z_dim_nc_index ): dim_start_nc ( z_dim_nc_index ) + dim_length_nc ( z_dim_nc_index ) - 1 ,:, i , i_source , 2 ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_var4d_nc (:,:,:,:, i , i_source , 2 )), maxval ( pm_var4d_nc (:,:,:,:, i , i_source , 2 )) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc_temp2 ), sum ( pm_var4d_nc (:,:, 1 ,:, i , i_source , 2 )) / ( size ( pm_var4d_nc , 1 ) * size ( pm_var4d_nc , 2 ) * size ( pm_var4d_nc , 4 )), size ( pm_var4d_nc , 1 ), size ( pm_var4d_nc , 2 ), size ( pm_var4d_nc , 4 ) end if var4d_nc (:,:,:,:, i , i_source , p_loop_index ) = pm_var4d_nc (:,:,:,:, i , i_source , 1 ) + pm_var4d_nc (:,:,:,:, i , i_source , 2 ) write ( unit_logfile , '(2A,f16.4,3i0)' ) ' Average of: ' , trim ( var_name_nc ( i , pm10_nc_index , i_source )), sum ( var4d_nc (:,:,:,:, i , i_source , p_loop_index )) / ( size ( var4d_nc , 1 ) * size ( var4d_nc , 2 ) * size ( var4d_nc , 4 )), size ( var4d_nc , 1 ), size ( var4d_nc , 2 ), size ( var4d_nc , 4 ) else status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var4d_nc (:,:, dim_start_nc ( z_dim_nc_index ): dim_start_nc ( z_dim_nc_index ) + dim_length_nc ( z_dim_nc_index ) - 1 ,:, i , i_source , p_loop_index ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) !status_nc = NF90_GET_VAR (id_nc, var_id_nc, temp_var4d_nc(:,:,:,:),start=(/dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index/),count=(/dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index)/)) !var4d_nc(:,:,:,:,i,i_source)=real(temp_var4d_nc(:,:,:,:)) write ( unit_logfile , '(A,I0,A,I0,3A,2f16.4)' ) ' Reading: ' , temp_num_dims , ' p_loop:' , p_loop_index , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( var4d_nc (:,:,:,:, i , i_source , p_loop_index )), maxval ( var4d_nc (:,:,:,:, i , i_source , p_loop_index )) !if (i.eq.precip_nc_index) then !    write(*,*) maxval(var4d_nc(:,:,:,:,i,i_source,p_loop_index)) !    stop !endif endif !write(*,*) shape(var4d_nc) !write(*,*) dim_start_nc(z_dim_nc_index),dim_length_nc(z_dim_nc_index) !write(*,*) maxval(var4d_nc(:,:,1,1,i,i_source)),maxval(var4d_nc(:,:,1,2,i,i_source)) elseif ( temp_num_dims . eq . 6. and . i_file . eq . 2 ) then !if (i.eq.frac_nc_index.and.i_pollutant.eq.pm10_nc_index) then lc_frac_nc_index = convert_frac_to_lc_frac_loop_index ( i ) !write(*,*) i,lc_frac_nc_index if ( i . ge . min_frac_nc_loop_index . and . i . le . max_frac_nc_loop_index . and . i_pollutant . eq . pm10_nc_index ) then var_name_nc_temp2 = var_name_nc ( i , pmco_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 1 ), start = ( / 1 , 1 , dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2I0,3A,2f16.4)' ) ' Reading: ' , i , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 1 )), maxval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 1 )) end if var_name_nc_temp2 = var_name_nc ( i , pm25_nc_index , i_source ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp2 ), var_id_nc ) if ( status_nc . eq . 0 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 2 ), start = ( / 1 , 1 , dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2I0,3A,2f16.4)' ) ' Reading: ' , i , temp_num_dims , ' ' , trim ( var_name_nc_temp2 ), ' (min, max): ' , minval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 2 )), maxval ( pm_lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , 2 )) end if !Not used but calculated for writing !lc_var4d_nc(:,:,:,:,:,:,lc_frac_nc_index,i_source,p_loop_index)=pm_lc_var4d_nc(:,:,:,:,:,:,lc_frac_nc_index,i_source,1)+pm_lc_var4d_nc(:,:,:,:,:,:,lc_frac_nc_index,i_source,2) else status_nc = NF90_GET_VAR ( id_nc , var_id_nc , lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , p_loop_index ), start = ( / 1 , 1 , dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), dim_start_nc ( time_dim_nc_index ) / ), count = ( / dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index ), dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2I0,3A,2f16.4)' ) ' Reading: ' , i , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , p_loop_index )), maxval ( lc_var4d_nc (:,:,:,:,:,:, lc_frac_nc_index , i_source , p_loop_index )) endif !write(*,*) shape(lc_var4d_nc) !write(*,*) maxval(lc_var4d_nc(3,3,:,:,:,1,lc_frac_nc_index,i_source)),maxval(lc_var4d_nc(3,3,:,:,:,2,lc_frac_nc_index,i_source)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot find a correct dimension for: ' , trim ( var_name_nc_temp ) endif else !write(unit_logfile,'(8A,8A)') ' Cannot read: ',trim(var_name_nc_temp) endif enddo !Variable loop endif enddo !Source loop !Loop through the additional compounds that are in the base file !if (i_file.eq.1) then i_source = allsource_index !i=conc_nc_index do i_loop = 1 , n_pollutant_compound_loop ( p_loop ) i_conc = pollutant_compound_loop_index ( p_loop , i_loop ) var_name_nc_temp = comp_name_nc ( i_conc ) !write(*,*) p_loop,i_conc,i_source,trim(var_name_nc_temp) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) !write(*,*) 'Status1: ',status_nc,id_nc,var_id_nc,trim(var_name_nc_temp) !If a variable name is found in the file then go further if ( status_nc . eq . NF90_NOERR ) then !Find the dimensions of the variable (temp_num_dims) status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) if ( temp_num_dims . eq . 3 ) then if ( i_file . eq . 1 ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:, surface_level_nc ,:, i_conc ) = temp_var3d_nc (:,:,:) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 1: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )), maxval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )) !write(*,*) comp_var4d_nc(:,:,1,:,i_conc) elseif ( i_file . eq . 2 ) then !In case the comp data is in the uEMEP file then read it here with no vertical extent status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:, surface_level_nc ,:, i_conc ) = temp_var3d_nc (:,:,:) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 2: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )), maxval ( comp_var4d_nc (:,:, surface_level_nc ,:, i_conc )) endif endif if ( temp_num_dims . eq . 4 ) then if ( i_file . eq . 1 ) then !write(*,'(4i)') dim_start_nc(x_dim_nc_index),dim_start_nc(y_dim_nc_index),dim_start_nc(z_dim_nc_index),temp_start_time_nc_index !write(*,'(4i)') dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),dim_length_nc(z_dim_nc_index),dim_length_nc(time_dim_nc_index) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , comp_var4d_nc (:,:,:,:, i_conc ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), dim_start_nc ( z_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( z_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:,:,:, i_conc ) = comp_var4d_nc (:,:,:,:, i_conc ) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 1: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:,:,:, i_conc )), maxval ( comp_var4d_nc (:,:,:,:, i_conc )) elseif ( i_file . eq . 2 ) then !In case the comp data is in the uEMEP file then read it here with no vertical extent status_nc = NF90_GET_VAR ( id_nc , var_id_nc , comp_var4d_nc (:,:, 1 ,:, i_conc ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), 1 , temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), 1 , dim_length_nc ( time_dim_nc_index ) / )) comp_var4d_nc (:,:, 1 ,:, i_conc ) = comp_var4d_nc (:,:, 1 ,:, i_conc ) * comp_scale_nc ( i_conc ) write ( unit_logfile , '(A,I0,3A,2f16.4)' ) ' Reading compound file 2: ' , temp_num_dims , ' ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( comp_var4d_nc (:,:, 1 ,:, i_conc )), maxval ( comp_var4d_nc (:,:, 1 ,:, i_conc )) endif endif else write ( unit_logfile , '(8A,8A)' ) ' Cannot read compound: ' , trim ( var_name_nc_temp ) endif enddo !pollutant enddo !compound loop !endif if ( calculate_deposition_flag . and . i_file . eq . 1 ) then write ( unit_logfile , '(A)' ) ' Reading deposition velocity data from EMEP (cm/s) and converting to m/s: ' do i_depo = 1 , n_landuse_index do p_loop = 1 , n_emep_pollutant_loop i_pollutant = pollutant_loop_index ( p_loop ) var_name_nc_temp = deposition_name_nc ( i_depo , i_pollutant ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , depo_var3d_nc (:,:,:, i_depo , p_loop ), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading deposition velocity: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( depo_var3d_nc (:,:,:, i_depo , p_loop )), maxval ( depo_var3d_nc (:,:,:, i_depo , p_loop )) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else !write(unit_logfile,'(8A,8A)') ' Cannot read deposition velocity: ',trim(var_name_nc_temp) endif enddo enddo !Converting to m/s depo_var3d_nc = depo_var3d_nc / 10 0. endif !Loop through the species if (( save_emep_species . or . save_seasalt ). and . i_file . eq . 1 ) then write ( unit_logfile , '(A)' ) ' Reading species data from EMEP: ' do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) if ( ii_sp . eq . sp_soa_index ) then !Read a and b soa species_temp_var3d_nc = 0. pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_asoa_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , sp_asoa_index ) = species_temp_var3d_nc (:,:,:) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_bsoa_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , sp_bsoa_index ) = species_temp_var3d_nc (:,:,:) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pmxx_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) endif if ( ii_sp . eq . sp_sia_index ) then !Read pm10 sia but currently not using. Use the sum of PM2.5 + 0.73*NO3_course instead. This is done at the end of the sia reading pmxx_sp_index = pm10_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_sia_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Read course NO3 pmxx_sp_index = pmco_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_no3_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Set to 0 species_var3d_nc (:,:,:, pm25_sp_index , sp_sia_index ) = 0. !Read pm25(fine) no3 pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_no3_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Read so4 and add to no3 pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_so4_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Read nh4 and add to so4 and no3 pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_nh4_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Add up the species species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) !+ 0.27*species_var3d_nc(:,:,:,pmco_sp_index,i_sp) !Not PM2.5 but PMfine species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) !0.73*species_var3d_nc(:,:,:,pmco_sp_index,i_sp) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm25_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(species_name_nc(pm25_sp_index,i_sp)),sum(species_var3d_nc(:,:,:,pm25_sp_index,i_sp))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(species_name_nc(pm10_sp_index,i_sp)),sum(species_var3d_nc(:,:,:,pm10_sp_index,i_sp))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) endif if ( ii_sp . eq . sp_dust_index ) then !Read dust do pmxx_sp_index = 1 , n_pmxx_sp_index if ( pmxx_sp_index . eq . pm25_sp_index . or . pmco_sp_index . eq . pmxx_sp_index ) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_dust_sah_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_dust_wb_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pmxx_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif if ( ii_sp . eq . sp_seasalt_index ) then !Read seasalt do pmxx_sp_index = 1 , n_pmxx_sp_index if ( pmxx_sp_index . eq . pm25_sp_index . or . pmco_sp_index . eq . pmxx_sp_index ) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_seasalt_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif if ( ii_sp . eq . sp_ffire_index ) then !Read fire pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_ffire_bc_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_ffire_rem_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pmxx_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pmxx_sp_index , i_sp )) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) endif if ( ii_sp . eq . sp_ppm_index ) then !Read ppm do pmxx_sp_index = 1 , n_pmxx_sp_index if ( pmxx_sp_index . eq . pm25_sp_index . or . pm10_sp_index . eq . pmxx_sp_index ) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_ppm_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif endif enddo endif if ( ii_sp . eq . sp_water_index ) then !Read water pm25 only pmxx_sp_index = pm25_sp_index var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_water_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !Set water in pm10 the same as pm25 species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) endif !Should there be 0.27*NO3 here for PM2.5? Check naming!! if ( ii_sp . eq . sp_pm_index ) then !Read total pm do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_pm_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo endif if ( save_emep_OP_species ) then if ( ii_sp . eq . sp_BBOA_index ) then !Read total pm do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_FFIRE_OM_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_FFIRE_BC_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_FFIRE_REM_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif !write(*,*) i_sp,ii_sp,n_species_loop_index,size(species_var3d_nc,5) if ( ii_sp . eq . sp_BBOA_RES_index ) then !Read total pm do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_POM_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_NEW_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_AGE_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_REM_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo do pmxx_sp_index = 1 , n_pmxx_sp_index !if (pmxx_sp_index.eq.pm25_sp_index.or.pm10_sp_index.eq.pmxx_sp_index) then var_name_nc_temp = species_name_nc ( pmxx_sp_index , sp_EC_RES_in_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . eq . NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , species_temp_var3d_nc (:,:,:), start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), temp_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), dim_length_nc ( time_dim_nc_index ) / )) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Reading species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_temp_var3d_nc (:,:,:)), maxval ( species_temp_var3d_nc (:,:,:)) species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) = species_var3d_nc (:,:,:, pmxx_sp_index , i_sp ) + species_temp_var3d_nc (:,:,:) !write(unit_logfile,'(2A,f16.4)') ' Average of: ',trim(var_name_nc_temp),sum(species_temp_var3d_nc(:,:,:))/(size(species_temp_var3d_nc,1)*size(species_temp_var3d_nc,2)*size(species_temp_var3d_nc,3)) else write ( unit_logfile , '(8A,8A)' ) ' Cannot read species: ' , trim ( var_name_nc_temp ) endif !endif enddo species_var3d_nc (:,:,:, pm10_sp_index , i_sp ) = species_var3d_nc (:,:,:, pm25_sp_index , i_sp ) + species_var3d_nc (:,:,:, pmco_sp_index , i_sp ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Adding species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )), maxval ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) endif endif !species_name_nc(pm10_sp_index,sp_BBOA_index)='pm10_EMEP_BBOA' !species_name_nc(pm25_sp_index,sp_BBOA_index)='pm25_EMEP_BBOA' !species_name_nc(pmco_sp_index,sp_BBOA_index)='pmco_EMEP_BBOA' !species_name_nc(pm10_sp_index,sp_BBOA_RES_index)='pm10_EMEP_BBOA_RES' !species_name_nc(pm25_sp_index,sp_BBOA_RES_index)='pm25_EMEP_BBOA_RES' !species_name_nc(pmco_sp_index,sp_BBOA_RES_index)='pmco_EMEP_BBOA_RES' !species_name_nc(pm25_sp_index,sp_POM_RES_in_index)='SURF_ug_POM_F_RES' !species_name_nc(pm25_sp_index,sp_EC_RES_NEW_in_index)='SURF_ug_EC_F_RES_NEW' !species_name_nc(pm25_sp_index,sp_EC_RES_AGE_in_index)='SURF_ug_EC_F_RES_AGE' !species_name_nc(pm25_sp_index,sp_REM_RES_in_index)='SURF_ug_REMPPM25_RES' !species_name_nc(pm25_sp_index,sp_FFIRE_OM_in_index)='SURF_ug_FFIRE_OM' !species_name_nc(pm25_sp_index,sp_FFIRE_BC_in_index)='SURF_ug_FFIRE_BC' !species_name_nc(pm25_sp_index,sp_FFIRE_REM_in_index)='SURF_ug_FFIRE_REMPPM25' !species_name_nc(pmco_sp_index,sp_EC_RES_in_index)='SURF_ug_EC_C_RES' !species_name_nc(pmco_sp_index,sp_POM_RES_in_index)='SURF_ug_POM_C_RES' !species_name_nc(pmco_sp_index,sp_REM_RES_in_index)='SURF_ug_REMPPM_C_RES' !species_name_nc(pmco_sp_index,sp_FFIRE_in_index)='SURF_ug_FFIRE_C' enddo !sp_index !Derive SOA from the other species. Based on using PMFINE as the pm25 total if ( save_emep_species . and . derive_SOA_from_other_species ) then species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index ) = & species_var3d_nc (:,:,:, pm25_sp_index , sp_pm_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_sia_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_seasalt_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_dust_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_ffire_index ) & - species_var3d_nc (:,:,:, pm25_sp_index , sp_ppm_index ) species_var3d_nc (:,:,:, pm10_sp_index , sp_soa_index ) = species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index ) species_var3d_nc (:,:,:, pm10_sp_index , sp_asoa_index ) = species_var3d_nc (:,:,:, pm25_sp_index , sp_asoa_index ) species_var3d_nc (:,:,:, pm10_sp_index , sp_bsoa_index ) = species_var3d_nc (:,:,:, pm25_sp_index , sp_bsoa_index ) var_name_nc_temp = species_name_nc ( pm25_sp_index , sp_soa_index ) write ( unit_logfile , '(A,2A,2f16.4)' ) ' Calculating species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )) where ( species_var3d_nc (:,:,:,:, sp_soa_index ). le . 0 ) species_var3d_nc (:,:,:,:, sp_soa_index ) = 0 write ( unit_logfile , '(A,2A,2f16.4)' ) ' Limitting species: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )), maxval ( species_var3d_nc (:,:,:, pm25_sp_index , sp_soa_index )) !SURF_ug_SOA=SURF_ug_PMFINE- SURF_ug_SO4- SURF_ug_NO3_F- SURF_ug_NH4_F- SURF_ug_SEASALT_F- SURF_ug_DUST_SAH_F- SURF_ug_DUST_WB_F- SURF_ug_FFIRE_REMPPM25- SURF_ug_FFIRE_BC- SURF_ug_PPM2.5 endif !Calculate the total of the parts by adding all and subtracting the total !Do not so this when only using sea salt if ( save_emep_species ) then write ( unit_logfile , '(A)' ) ' Cross check average of species' do i_sp = 1 , n_species_loop_index ii_sp = species_loop_index ( i_sp ) if ( i_sp . ne . sp_pm_index ) then !Do not include the total here write ( unit_logfile , '(A,2A,2f16.4)' ) ' Average of species: ' , trim ( species_name_nc ( pm10_sp_index , ii_sp )), ' (pm25, pm10): ' , & sum ( species_var3d_nc (:,:,:, pm25_sp_index , i_sp )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( species_var3d_nc (:,:,:, pm10_sp_index , i_sp )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )) endif enddo species_temp_var3d_nc (:,:,:) = sum ( species_var3d_nc (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) write ( unit_logfile , '(A,2A,4f16.4)' ) ' Average of: ' , 'pm25' , ' (sum species, total pm, D3, SURF): ' , & sum ( species_temp_var3d_nc (:,:,:)) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( species_var3d_nc (:,:,:, pm25_sp_index , sp_pm_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( comp_var4d_nc (:,:, surface_level_nc ,:, pm25_nc_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( var3d_nc (:,:,:, conc_nc_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )) species_temp_var3d_nc (:,:,:) = sum ( species_var3d_nc (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) write ( unit_logfile , '(A,2A,4f16.4)' ) ' Average of: ' , 'pm10' , ' (sum species, total pm, D3, SURF): ' , & sum ( species_temp_var3d_nc (:,:,:)) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( species_var3d_nc (:,:,:, pm10_sp_index , sp_pm_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( comp_var4d_nc (:,:, surface_level_nc ,:, pm10_nc_index )) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )), & sum ( var3d_nc (:,:,:, conc_nc_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) / ( size ( species_temp_var3d_nc , 1 ) * size ( species_temp_var3d_nc , 2 ) * size ( species_temp_var3d_nc , 3 )) endif endif !Read in 2m temperature over the whole period to get the daily average for home heating if ( use_RWC_emission_data ) then DMT_start_time_nc_index = start_time_nc_index DMT_end_time_nc_index = end_time_nc_index DMT_dim_length_nc = DMT_end_time_nc_index - DMT_start_time_nc_index + 1 if (. not . allocated ( DMT_EMEP_grid_nc )) allocate ( DMT_EMEP_grid_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), DMT_dim_length_nc )) if ( calculate_source ( heating_index ). and . i_file . eq . 1 ) then var_name_nc_temp = var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , DMT_EMEP_grid_nc , start = ( / dim_start_nc ( x_dim_nc_index ), dim_start_nc ( y_dim_nc_index ), DMT_start_time_nc_index / ), count = ( / dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), DMT_dim_length_nc / )) write ( unit_logfile , '(3A,2f16.4)' ) ' Reading: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc ), maxval ( DMT_EMEP_grid_nc ) DMT_EMEP_grid_nc (:,:, 1 ) = sum ( DMT_EMEP_grid_nc , 3 ) / DMT_dim_length_nc - 27 3.13 write ( unit_logfile , '(3A,2f16.4,a,i0)' ) ' Calculating mean: ' , trim ( var_name_nc_temp ), ' (min, max): ' , minval ( DMT_EMEP_grid_nc (:,:, 1 )), maxval ( DMT_EMEP_grid_nc (:,:, 1 )), ' over this number of time steps: ' , DMT_dim_length_nc endif endif status_nc = NF90_CLOSE ( id_nc ) enddo !End file loop !Set the correct time dimensions to the first file value dim_length_nc ( time_dim_nc_index ) = valid_dim_length_nc ( time_dim_nc_index ) !Set the grid spacing if ( EMEP_projection_type . eq . LL_projection_index ) then dgrid_nc ( lon_nc_index ) = var1d_nc ( 2 , x_dim_nc_index ) - var1d_nc ( 1 , x_dim_nc_index ) dgrid_nc ( lat_nc_index ) = var1d_nc ( 2 , y_dim_nc_index ) - var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing (lon,lat): ' , dgrid_nc ( lon_nc_index ), dgrid_nc ( lat_nc_index ) else dgrid_nc ( lon_nc_index ) = var1d_nc ( 2 , x_dim_nc_index ) - var1d_nc ( 1 , x_dim_nc_index ) dgrid_nc ( lat_nc_index ) = var1d_nc ( 2 , y_dim_nc_index ) - var1d_nc ( 1 , y_dim_nc_index ) write ( unit_logfile , '(A,2f16.4)' ) ' Grid spacing (x,y) in meters: ' , dgrid_nc ( lon_nc_index ), dgrid_nc ( lat_nc_index ) ! endif !EMEP emissions for traffic do not differentiate between exhaust and nonexhaust !Place the read PM2.5 emissions also into the exhaust emissions. If PM10 is higher then these are then the non-exhaust emissions !This only needs to be done when the EMEP emissions are used and distributed using a proxy but we do it in general anyway !if (local_subgrid_method_flag.eq.3) then !write(unit_logfile,'(A,2es12.2)') ' In: Filling the EMEP exhaust emissions with PM25 emissions ',sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))=var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index)) !write(unit_logfile,'(A,2es12.2)') ' Out: Filling the EMEP exhaust emissions with PM25 emissions ',sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))=var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index)) !var4d_nc(:,:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))=var4d_nc(:,:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index)) !write(unit_logfile,'(A,2es12.2)') ' 3D Filling the EMEP exhaust concentrations with PM25 emissions ',sum(var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !write(unit_logfile,'(A,2es12.2)') ' 4D Filling the EMEP exhaust emissions with PM25 emissions ',sum(var4d_nc(:,:,:,:,conc_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var4d_nc(:,:,:,:,,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !endif if ( use_alternative_ppm_variable_for_lf ) then write ( unit_logfile , '(4A)' ) ' Replacing variable ' , trim ( var_name_nc ( conc_nc_index , pm25_nc_index , allsource_nc_index )), ' with ' , trim ( var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index )) write ( unit_logfile , '(4A)' ) ' Replacing variable ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , allsource_nc_index )), ' with ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index )) write ( unit_logfile , '(A,f12.3)' ) ' LF PPM2.5 before correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 2 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) write ( unit_logfile , '(A,f12.3)' ) ' LF PPMCO  before correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 1 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) if ( alternative_ppm_variable_for_lf_dim . eq . 4 ) then var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) = var4d_nc (:,:, surface_level_nc ,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,2)=var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm25_nc_index)) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,1)=var4d_nc(:,:,surface_level_nc,:,conc_nc_index,extrasource_nc_index,pollutant_loop_back_index(pm10_nc_index)) !var4d_nc(:,:,:,:,conc_nc_index,allsource_nc_index,pmco_nc_index)=var4d_nc(:,:,:,:,conc_nc_index,extrasource_nc_index,pmco_nc_index) ! write(unit_logfile,'(4A)')' Replacing variable ',trim(var_name_nc(conc_nc_index,pm10_nc_index,allsource_nc_index)),' with ',trim(var_name_nc(conc_nc_index,pm10_nc_index,extrasource_nc_index)) var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) + var4d_nc (:,:, surface_level_nc ,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) elseif ( alternative_ppm_variable_for_lf_dim . eq . 3 ) then var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) = var3d_nc (:,:,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,2)=var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm25_nc_index)) !pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,1)=var3d_nc(:,:,:,conc_nc_index,extrasource_nc_index,pollutant_loop_back_index(pm10_nc_index)) !var4d_nc(:,:,:,:,conc_nc_index,allsource_nc_index,pmco_nc_index)=var4d_nc(:,:,:,:,conc_nc_index,extrasource_nc_index,pmco_nc_index) ! write(unit_logfile,'(4A)')' Replacing variable ',trim(var_name_nc(conc_nc_index,pm10_nc_index,allsource_nc_index)),' with ',trim(var_name_nc(conc_nc_index,pm10_nc_index,extrasource_nc_index)) !var4d_nc(:,:,surface_level_nc,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm10_nc_index))=var3d_nc(:,:,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm25_nc_index))+var3d_nc(:,:,:,conc_nc_index,extrasource_nc_index,pollutant_loop_back_index(pm10_nc_index)) !var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,pollutant_loop_back_index(pm10_nc_index))=pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,2)+pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,allsource_nc_index,1) var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = var3d_nc (:,:,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm10_nc_index )) + var3d_nc (:,:,:, conc_nc_index , extrasource_nc_index , pollutant_loop_back_index ( pm25_nc_index )) else write ( unit_logfile , '(4A)' ) ' Not replacing variable ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , allsource_nc_index )), ' with ' , trim ( var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index )) endif write ( unit_logfile , '(A,f12.3)' ) ' LF PPM2.5 after correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 2 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) write ( unit_logfile , '(A,f12.3)' ) ' LF PPMCO  after correction variables are used: ' , sum ( pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index , allsource_nc_index , 1 )) / size ( pm_var4d_nc , 1 ) / size ( pm_var4d_nc , 2 ) / size ( pm_var4d_nc , 4 ) endif !Transfer all source values to all the sources for use in source looping later do i_source = 1 , n_source_nc_index !if (calculate_source(i_source).and.i_source.ne.allsource_nc_index) then if ( i_source . ne . allsource_nc_index ) then var3d_nc (:,:,:, conc_nc_index , i_source ,:) = var3d_nc (:,:,:, conc_nc_index , allsource_nc_index ,:) var4d_nc (:,:,:,:, conc_nc_index , i_source ,:) = var4d_nc (:,:,:,:, conc_nc_index , allsource_nc_index ,:) pm_var4d_nc (:,:,:,:, conc_nc_index , i_source ,:) = pm_var4d_nc (:,:,:,:, conc_nc_index , allsource_nc_index ,:) endif enddo !Transfer local contribution 4d to 3d since this is the only one currently used !write(*,*) shape(var4d_nc) !write(*,*) surface_level_nc lc_var3d_nc = lc_var4d_nc (:,:,:,:, surface_level_nc_2 ,:,:,:,:) !var3d_nc(:,:,:,conc_nc_index,:)=var4d_nc(:,:,surface_level_nc,:,conc_nc_index,:) !Don't do this because if 3d is read then it is obliterated !if (sum(var3d_nc(:,:,:,conc_nc_index,:,:)).eq.0) then var3d_nc (:,:,:, conc_nc_index ,:,:) = var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:,:) !Changed tis from surface_level_nc_2 to surface_level_nc under lf changes !endif !if (sum(comp_var3d_nc(:,:,:,:)).eq.0) then comp_var3d_nc (:,:,:,:) = comp_var4d_nc (:,:, surface_level_nc ,:,:) !endif if ( allocated ( lc_var4d_nc )) deallocate ( lc_var4d_nc ) if ( allocated ( comp_var4d_nc )) deallocate ( comp_var4d_nc ) !Adjust the depositions to be total depositions and not just, for example, N do i_pollutant = 1 , n_emep_pollutant_loop var3d_nc (:,:,:, drydepo_nc_index ,:, i_pollutant ) = var3d_nc (:,:,:, drydepo_nc_index ,:, i_pollutant ) * depo_scale_nc ( pollutant_loop_index ( i_pollutant )) var3d_nc (:,:,:, wetdepo_nc_index ,:, i_pollutant ) = var3d_nc (:,:,:, wetdepo_nc_index ,:, i_pollutant ) * depo_scale_nc ( pollutant_loop_index ( i_pollutant )) enddo !Use average lowest level grid thickness H_emep_temp = sum ( var4d_nc (:,:, surface_level_nc ,:, ZTOP_nc_index , allsource_index , meteo_p_loop_index )) / dim_length_nc ( x_dim_nc_index ) / dim_length_nc ( y_dim_nc_index ) / dim_length_nc ( time_dim_nc_index ) if ( H_emep_temp . ne . 0 ) then H_emep = H_emep_temp write ( unit_logfile , '(A,f8.2)' ) ' Using model depth info. Setting lowest level depth = ' , H_emep else write ( unit_logfile , '(A,f8.2)' ) ' No model depth info available. Setting lowest level depth = ' , H_emep endif H_meteo = H_emep / 2. write ( unit_logfile , '(A,f8.2)' ) ' Setting lowest meteo grid height = ' , H_meteo !var3d_nc(:,:,:,conc_nc_index,:,:)=var4d_nc(:,:,surface_level_nc,:,conc_nc_index,:,:) !For nh3 only use the comp value not the value in the local fraction file !NOTE: TEMPORARY if ( use_comp_temporary ) then write ( * , * ) 'WARNING: TEMPORARALLY USING COMP FOR LF SOURCE SCALING FOR NH3' , pollutant_loop_back_index ( nh3_nc_index ), nh3_nc_index do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . i_source . eq . allsource_index ) then var3d_nc (:,:,:, conc_nc_index , i_source , pollutant_loop_back_index ( nh3_nc_index )) = comp_var3d_nc (:,:,:, nh3_nc_index ) endif enddo endif !At the moment the local contribution based on fraction. Convert to local contributions here !Remove this if we read local contributions in a later version do j = 1 , dim_length_nc ( ydist_dim_nc_index ) do i = 1 , dim_length_nc ( xdist_dim_nc_index ) do p_loop = 1 , n_pollutant_loop !do lc_local_nc_index=minval(lc_local_nc_loop_index),maxval(lc_local_nc_loop_index) do ii = 1 , n_local_fraction_grids lc_local_nc_index = lc_local_nc_loop_index ( ii ) lc_frac_nc_index = lc_frac_nc_loop_index ( ii ) !lc_frac_nc_index=convert_local_to_fraction_loop_index(lc_local_nc_index) !write(*,*) lc_local_nc_index,lc_frac_nc_index if ( pollutant_loop_index ( p_loop ). eq . pm10_nc_index ) then lc_var3d_nc ( i , j ,:,:,:, lc_local_nc_index ,:, p_loop ) = pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, 1 ) * pm_lc_var4d_nc ( i , j ,:,:, surface_level_nc_2 ,:, lc_frac_nc_index ,:, 1 ) & + pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, 2 ) * pm_lc_var4d_nc ( i , j ,:,:, surface_level_nc_2 ,:, lc_frac_nc_index ,:, 2 ) elseif ( pollutant_loop_index ( p_loop ). eq . pm25_nc_index ) then lc_var3d_nc ( i , j ,:,:,:, lc_local_nc_index ,:, p_loop ) = pm_var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, 2 ) * pm_lc_var4d_nc ( i , j ,:,:, surface_level_nc_2 ,:, lc_frac_nc_index ,:, 2 ) else lc_var3d_nc ( i , j ,:,:,:, lc_local_nc_index ,:, p_loop ) = var4d_nc (:,:, surface_level_nc_2 ,:, conc_nc_index ,:, p_loop ) * lc_var3d_nc ( i , j ,:,:,:, lc_frac_nc_index ,:, p_loop ) !This was before, so it used the D3 value, but not the surface value. D3 is not always read !lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop)=max(lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop),var3d_nc(:,:,:,conc_nc_index,:,p_loop)*lc_var3d_nc(i,j,:,:,:,lc_frac_nc_index,:,p_loop)) !Choose the max of the 3d and 4d values, so chooses one or the other !lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop)=pm_var4d_nc(:,:,surface_level_nc_2,:,conc_nc_index,:,2)*lc_var3d_nc(i,j,:,:,:,lc_frac_nc_index,:,p_loop) !write(*,*) sum(lc_var3d_nc(i,j,:,:,:,lc_local_nc_index,:,p_loop)),sum(var3d_nc(:,:,:,conc_nc_index,:,p_loop)),sum(lc_var3d_nc(i,j,:,:,:,lc_frac_nc_index,:,p_loop)) endif enddo enddo enddo enddo !Take account of the fact that the GNFR emissions can be version 13 or 19 !In which case traffic is split into 4 and power is split into 2 !This is valid only for the local fraction sources if ( use_GNFR19_emissions_from_EMEP_flag ) then write ( unit_logfile , '(3A,f16.4)' ) ' Aggregating GNFR19 to GNFR13 or GNFR14' !Reset these flags so they are no longer calculated as EMEP contributions after being read !calculate_EMEP_source(traffic_exhaust_nc_index)=.false. !calculate_EMEP_source(traffic_nonexhaust_nc_index)=.false. do lc_local_nc_index = minval ( lc_local_nc_loop_index ), maxval ( lc_local_nc_loop_index ) !No allocation of exhaust emissions to PM10 because only course is read !Is this correct? Removing. PM10 should have been set earlier lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index , pollutant_loop_back_index ( pm25_nc_index )) lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index , pollutant_loop_back_index ( pm25_nc_index )) lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index , pollutant_loop_back_index ( pm10_nc_index )) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index , pollutant_loop_back_index ( pm25_nc_index )) !Put all source into traffic lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_nc_index ,:) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_nonexhaust_nc_index ,:) !Put the three exhaust into traffic. If exhaust not included then it will be 0 !lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm25_nc_index))=lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_gasoline_nc_index,pollutant_loop_back_index(pm25_nc_index)) & !                                                            +lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_diesel_nc_index,pollutant_loop_back_index(pm25_nc_index)) & !                                                            +lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_gas_nc_index,pollutant_loop_back_index(pm25_nc_index)) !lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm10_nc_index))=lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm25_nc_index)) lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_exhaust_nc_index ,:) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gasoline_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_diesel_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , traffic_gas_nc_index ,:) !Special case for PM10 because traffic exhaust is not read for PM10 !lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm10_nc_index))=lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_exhaust_nc_index,pollutant_loop_back_index(pm25_nc_index)) !Aggregate the two public powers lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_nc_index ,:) = lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_point_nc_index ,:) & + lc_var3d_nc (:,:,:,:,:, lc_local_nc_index , publicpower_area_nc_index ,:) enddo do lc_local_nc_index = minval ( lc_local_nc_loop_index ), maxval ( lc_local_nc_loop_index ) write ( unit_logfile , '(A,i0,a,f16.4)' ) 'Mean exhaust PM2.5 EMEP contribution centre lc grid: ' , lc_local_nc_index , ' ' & , sum ( lc_var3d_nc ( xdist_centre_nc , ydist_centre_nc ,:,:,:, lc_local_nc_index , traffic_exhaust_nc_index , pollutant_loop_back_index ( pm25_nc_index ))) / ( size ( lc_var3d_nc , 3 ) * size ( lc_var3d_nc , 4 ) * size ( lc_var3d_nc , 5 )) write ( unit_logfile , '(A,i0,a,f16.4)' ) 'Mean nonexhaust PM2.5 EMEP contribution centre lc grid: ' , lc_local_nc_index , ' ' & , sum ( lc_var3d_nc ( xdist_centre_nc , ydist_centre_nc ,:,:,:, lc_local_nc_index , traffic_nonexhaust_nc_index , pollutant_loop_back_index ( pm25_nc_index ))) / ( size ( lc_var3d_nc , 3 ) * size ( lc_var3d_nc , 4 ) * size ( lc_var3d_nc , 5 )) enddo !else !    do lc_local_nc_index=minval(lc_local_nc_loop_index),maxval(lc_local_nc_loop_index) !    lc_var3d_nc(:,:,:,:,:,lc_local_nc_index,traffic_nc_index,pollutant_loop_back_index(pmex_nc_index))=0 !    enddo endif !With GNFR19 add up all the traffic emissions and put them in the traffic emissions, according to the use of all or all_totals if ( use_GNFR19_emissions_from_EMEP_flag ) then if ( pollutant_index . eq . all_totals_nc_index ) write ( unit_logfile , '(A)' ) 'Aggregating exhaust and non-exhaust traffic emissions when using GNFR19: ' if ( pollutant_index . eq . all_nc_index ) write ( unit_logfile , '(A)' ) 'Aggregating exhaust and non-exhaust traffic emissions seperately when using GNFR19: ' !Aggregate exhaust emissions var3d_nc (:,:,:, emis_nc_index , traffic_exhaust_nc_index ,:) = var3d_nc (:,:,:, emis_nc_index , traffic_gasoline_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_diesel_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_gas_nc_index ,:) !Aggregating total emissions var3d_nc (:,:,:, emis_nc_index , traffic_nc_index ,:) = var3d_nc (:,:,:, emis_nc_index , traffic_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_exhaust_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , traffic_nonexhaust_nc_index ,:) !Aggregating public power emissions var3d_nc (:,:,:, emis_nc_index , publicpower_nc_index ,:) = var3d_nc (:,:,:, emis_nc_index , publicpower_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , publicpower_point_nc_index ,:) & + var3d_nc (:,:,:, emis_nc_index , publicpower_area_nc_index ,:) endif !Scale the read in voc emissions so they are split into benzene if ( extract_benzene_from_voc_emissions ) then write ( unit_logfile , '(A)' ) 'Converting VOC emissions to Benzene emissions: ' do i_source = 1 , n_source_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . save_EMEP_source ( i_source )) then var3d_nc (:,:,:, emis_nc_index , i_source , pollutant_loop_back_index ( c6h6_nc_index )) = benzene_split_voc_in_GNFR_sectors ( uEMEP_to_EMEP_sector ( i_source )) * var3d_nc (:,:,:, emis_nc_index , i_source , pollutant_loop_back_index ( c6h6_nc_index )) write ( unit_logfile , '(A,i4,a,a,a,f12.3)' ) 'GNFR Source=' , uEMEP_to_EMEP_sector ( i_source ), ' , uEMEP source= ' , trim ( source_file_str ( i_source )), ' , split(%)= ' , benzene_split_voc_in_GNFR_sectors ( uEMEP_to_EMEP_sector ( i_source )) * 10 0. endif enddo endif !Check output for PM10. Not needed anymore !do i_source=1,n_source_index !    if (calculate_source(i_source).or.calculate_EMEP_source(i_source).or.save_EMEP_source(i_source)) then !    do lc_local_nc_index=minval(lc_local_nc_loop_index),maxval(lc_local_nc_loop_index) !        p_loop=pollutant_loop_back_index(pm10_nc_index) !        write(unit_logfile,'(3A,f16.4)') ' Average local contribution of: ',trim(var_name_nc(conc_nc_index,pm10_nc_index,allsource_index)),' '//trim(source_file_str(i_source)), & !        sum(lc_var3d_nc(xdist_centre_nc,ydist_centre_nc,:,:,:,lc_local_nc_index,i_source,p_loop))/(size(lc_var3d_nc,3)*size(lc_var3d_nc,4)*size(lc_var3d_nc,5)) !    enddo !    endif !enddo if ( allocated ( pm_lc_var4d_nc )) deallocate ( pm_lc_var4d_nc ) if ( allocated ( pm_var4d_nc )) deallocate ( pm_var4d_nc ) if ( allocated ( pm_var3d_nc )) deallocate ( pm_var3d_nc ) !Set the local grid contribution for the individual grid !write(*,*) shape(lc_var4d_nc) !write(*,*) shape(var4d_nc) !Commented out as these are not used? !Reset these variables to what they would be with 1 EMEP grid !Not necessary once the rest of the code is adapted to the loop data frac_nc_index = num_var_nc_start + 1 lc_frac_nc_index = 1 local_nc_index = num_var_nc_start + n_local_fraction_grids + 1 lc_local_nc_index = n_local_fraction_grids + 1 !This is no longer in use, but just in case set the variables to the first EMEP LC grid var3d_nc (:,:,:, frac_nc_index ,:,:) = lc_var3d_nc ( xdist_centre_nc , ydist_centre_nc ,:,:,:, lc_frac_nc_index ,:,:) var3d_nc (:,:,:, local_nc_index ,:,:) = var3d_nc (:,:,:, conc_nc_index ,:,:) * var3d_nc (:,:,:, frac_nc_index ,:,:) !write(*,*) minval(var4d_nc(:,:,:,:,local_nc_index,:)),maxval(var4d_nc(:,:,:,:,local_nc_index,:)) !write(*,*) minval(var4d_nc(:,:,:,:,frac_nc_index,:)),maxval(var4d_nc(:,:,:,:,frac_nc_index,:)) !write(*,*) minval(var3d_nc(:,:,:,frac_nc_index,:)),maxval(var3d_nc(:,:,:,frac_nc_index,:)) !write(*,*) minval(var4d_nc(:,:,:,:,conc_nc_index,:)),maxval(var4d_nc(:,:,:,:,conc_nc_index,:)) !write(*,*) minval(var3d_nc(:,:,:,conc_nc_index,:)),maxval(var3d_nc(:,:,:,conc_nc_index,:)) !write(*,*) minval(var3d_nc(:,:,:,inv_FF10_nc_index,allsource_index)),maxval(var3d_nc(:,:,:,inv_FF10_nc_index,allsource_index)) !write(*,*) minval(var3d_nc(:,:,:,FF10_nc_index,allsource_index)),maxval(var3d_nc(:,:,:,FF10_nc_index,allsource_index)) where ( var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ). lt . ustar_min ) var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ) = ustar_min !Test for 0 wind speed components if valid if (. not . EMEP_region_outside_domain ) then do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) do t = 1 , dim_length_nc ( time_dim_nc_index ) if ( var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. . and . var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. ) then write ( unit_logfile , '(a,3i0)' ) 'Zero wind fields at (i,j,t): ' , i , j , t !Search for the nearest non double zero value k = 0 nonzero_wind_notfound = . true . do while ( k . lt . 2 0. and . nonzero_wind_notfound ) k = k + 1 do ii =- k , k do jj =- k , k iii = i + ii jjj = j + jj iii = min ( max ( 1 , iii ), dim_length_nc ( x_dim_nc_index )) jjj = min ( max ( 1 , jjj ), dim_length_nc ( y_dim_nc_index )) if ( var4d_nc ( iii , jjj , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ). ne . 0. & . or . var4d_nc ( iii , jjj , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ). ne . 0. ) then nonzero_wind_notfound = . false . var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = var4d_nc ( iii , jjj , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ) var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = var4d_nc ( iii , jjj , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) !write(unit_logfile,'(a,4i,2f10.2)') 'Wind found for (i,j,t): ',k,i,j,t,var4d_nc(i,j,surface_level_nc,t,ugrid_nc_index,allsource_nc_index,meteo_p_loop_index),var4d_nc(i,j,surface_level_nc,t,vgrid_nc_index,allsource_nc_index,meteo_p_loop_index) endif enddo enddo enddo if ( nonzero_wind_notfound ) then write ( unit_logfile , '(a,4i0,2f10.2)' ) 'Wind not found for (loop,i,j,t): ' , k , i , j , t , var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ), var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) else write ( unit_logfile , '(a,4i0,2f10.2)' ) 'Wind found for (loop,i,j,t): ' , k , i , j , t , var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ), var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) endif endif enddo enddo enddo do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) do t = 1 , dim_length_nc ( time_dim_nc_index ) if ( var4d_nc ( i , j , surface_level_nc , t , ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. . and . var4d_nc ( i , j , surface_level_nc , t , vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ). eq . 0. ) then write ( unit_logfile , '(a,3i0)' ) 'ERROR: Found zero wind fields in both components (i,j,t). Stopping: ' , i , j , t stop endif enddo enddo enddo endif !If no logz0 available. Set to log(0.1) !For urban areas a value of 0.3 is used where ( var3d_nc (:,:,:, logz0_nc_index ,:, meteo_p_loop_index ). eq . 0.0 ) var3d_nc (:,:,:, logz0_nc_index ,:, meteo_p_loop_index ) = log ( 0.3 ) if ( replace_z0 . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing z0 everywhere with: ' , replace_z0 var3d_nc (:,:,:, logz0_nc_index ,:, meteo_p_loop_index ) = log ( replace_z0 ) endif if ( replace_invL . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing inverse L everywhere with: ' , replace_invL var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ) = replace_invL endif if ( replace_hmix . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Replacing HMIX everywhere with: ' , replace_hmix var3d_nc (:,:,:, hmix_nc_index ,:, meteo_p_loop_index ) = replace_hmix endif if ( use_phi_for_invL ) then phi_count = 0 mean_phi_temp = 0 mean_invL_temp = 0 do j = 1 , dim_length_nc ( y_dim_nc_index ) do i = 1 , dim_length_nc ( x_dim_nc_index ) do t = 1 , dim_length_nc ( time_dim_nc_index ) call TROENKz_invL_from_phi ( z_invL , var3d_nc ( i , j , t , phi_nc_index , allsource_nc_index , meteo_p_loop_index ), var3d_nc ( i , j , t , invL_nc_index , allsource_nc_index , meteo_p_loop_index )) phi_count = phi_count + 1 mean_phi_temp = mean_phi_temp + var3d_nc ( i , j , t , phi_nc_index , allsource_nc_index , meteo_p_loop_index ) mean_invL_temp = mean_invL_temp + var3d_nc ( i , j , t , invL_nc_index , allsource_nc_index , meteo_p_loop_index ) enddo enddo enddo mean_phi_temp = mean_phi_temp / phi_count mean_invL_temp = mean_invL_temp / phi_count write ( unit_logfile , '(A,2f8.4)' ) ' Using phi instead of invL. Mean phi and invL: ' , mean_phi_temp , mean_invL_temp endif !Limit stable L to lowest_stable_L and to lowest_unstable_L (negative number) for unstable. where ( var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ). lt . 1.0 / lowest_unstable_L ) var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ) = 1.0 / lowest_unstable_L where ( var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ). gt . 1.0 / lowest_stable_L ) var3d_nc (:,:,:, invL_nc_index ,:, meteo_p_loop_index ) = 1.0 / lowest_stable_L where ( var3d_nc (:,:,:, hmix_nc_index ,:, meteo_p_loop_index ). lt . hmix_min ) var3d_nc (:,:,:, hmix_nc_index ,:, meteo_p_loop_index ) = hmix_min !Limit Jd as well in case there is something wrong where ( var4d_nc (:,:,:,:, J_nc_index ,:,:). lt . 0 ) var4d_nc (:,:,:,:, J_nc_index ,:,:) = 0. if ( J_scale . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Scaling J(NO2) everywhere with: ' , J_scale var4d_nc (:,:,:,:, J_nc_index ,:,:) = var4d_nc (:,:,:,:, J_nc_index ,:,:) * J_scale endif !Correct the inverse of the wind speed for the factor 0.2 used to create it in EMEP write ( unit_logfile , '(A)' ) ' Correcting inverse wind speed to account for the 0.2 m/s offset: ' var3d_nc (:,:,:, inv_FF10_nc_index ,:,:) = var3d_nc (:,:,:, inv_FF10_nc_index ,:,:) / ( 1. - 0.2 * var3d_nc (:,:,:, inv_FF10_nc_index ,:,:)) var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:) = var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:) / ( 1. - 0.2 * var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:)) var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:) = var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:) / ( 1. - 0.2 * var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:)) where ( var3d_nc (:,:,:, inv_FF10_nc_index ,:,:). gt . 4.5 ) var3d_nc (:,:,:, inv_FF10_nc_index ,:,:) = 4.5 !Set the limit so that FF can not be less than 0.2222 where ( var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:). gt . 4.5 ) var3d_nc (:,:,:, inv_FFgrid_nc_index ,:,:) = 4.5 !Set the limit so that FF can not be less than 0.2222 where ( var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:). gt . 4.5 ) var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:,:) = 4.5 !Set the limit so that FF can not be less than 0.2222 if ( FF_scale . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rescaling wind fields everywhere with factor: ' , FF_scale var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, ustar_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, inv_FF10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, inv_FF10_nc_index ,:, meteo_p_loop_index ) / FF_scale var3d_nc (:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, u10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, u10_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, v10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, v10_nc_index ,:, meteo_p_loop_index ) * FF_scale var3d_nc (:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) / FF_scale var4d_nc (:,:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) = var4d_nc (:,:,:,:, ugrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var4d_nc (:,:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) = var4d_nc (:,:,:,:, vgrid_nc_index ,:, meteo_p_loop_index ) * FF_scale var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) = var4d_nc (:,:,:,:, inv_FFgrid_nc_index ,:, meteo_p_loop_index ) / FF_scale endif if ( FF10_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Offsetting 10 m wind fields everywhere with a value: ' , FF10_offset var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, FF10_nc_index ,:, meteo_p_loop_index ) + FF10_offset endif if ( DD_offset . ne . NODATA_value ) then write ( unit_logfile , '(A,f8.4)' ) ' Rotating wind fields everywhere with a value: ' , DD_offset !Make use of the spare source index parts of the array for the conversion temp_var4d_nc = 0 temp_var4d_nc (:,:,:,:, 1 ) = var4d_nc (:,:,:,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) + var4d_nc (:,:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) temp_var4d_nc (:,:,:,:, 2 ) =- var4d_nc (:,:,:,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) + var4d_nc (:,:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) var4d_nc (:,:,:,:, ugrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:,:, 1 ) var4d_nc (:,:,:,:, vgrid_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:,:, 2 ) temp_var4d_nc = 0 temp_var4d_nc (:,:,:, 1 , 1 ) = var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) + var3d_nc (:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) temp_var4d_nc (:,:,:, 1 , 2 ) =- var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ) * sin ( DD_offset / 18 0. * 3.14159 ) + var3d_nc (:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * cos ( DD_offset / 18 0. * 3.14159 ) var3d_nc (:,:,:, u10_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:, 1 , 1 ) var3d_nc (:,:,:, v10_nc_index , allsource_nc_index , meteo_p_loop_index ) = temp_var4d_nc (:,:,:, 1 , 2 ) endif !Set the magnitude of the gridded wind fields. Should probably be done after subgridding? var4d_nc (:,:,:,:, FFgrid_nc_index , allsource_index , meteo_p_loop_index ) = sqrt ( var4d_nc (:,:,:,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) ** 2 + var4d_nc (:,:,:,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) ** 2 ) !Will override the read in FF10 if it is available if ( sum ( abs ( var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ))). ne . 0. and . sum ( abs ( var3d_nc (:,:,:, v10_nc_index , allsource_index , meteo_p_loop_index ))). ne . 0 ) then wind_vectors_10m_available = . true . var3d_nc (:,:,:, FF10_nc_index , allsource_index , meteo_p_loop_index ) = sqrt ( var3d_nc (:,:,:, u10_nc_index , allsource_index , meteo_p_loop_index ) ** 2 + var3d_nc (:,:,:, v10_nc_index , allsource_index , meteo_p_loop_index ) ** 2 ) endif write ( unit_logfile , '(A,L)' ) ' 10 m wind vectors available: ' , wind_vectors_10m_available !Check EMEP time date_num_temp = dble ( ceiling ( val_dim_nc ( 1 , time_dim_nc_index ) * 2 4. )) / 2 4. call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) write ( unit_logfile , '(a,i6)' ) ' Time dimension EMEP:  ' , dim_length_nc ( time_dim_nc_index ) write ( unit_logfile , '(a,6i6)' ) ' Date start EMEP =  ' , date_array date_num_temp = dble ( ceiling ( val_dim_nc ( dim_length_nc ( time_dim_nc_index ), time_dim_nc_index ) * 2 4. )) / 2 4. call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) write ( unit_logfile , '(a,6i6)' ) ' Date end EMEP =    ' , date_array !Test and correct dates if ( 1. eq . 1 ) then if (. not . allocated ( time_seconds_output )) allocate ( time_seconds_output ( dim_length_nc ( time_dim_nc_index ))) do t = 1 , dim_length_nc ( time_dim_nc_index ) date_num_temp = dble ( ceiling ( val_dim_nc ( t , time_dim_nc_index ) * 2 4. )) / 2 4. date_num_temp = val_dim_nc ( t , time_dim_nc_index ) + 0.55 / 2 4. !Add a bit over half an hour to compensate for average of time call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) !write(unit_logfile,'(a,i4,6i6,d)') ' Date EMEP =   ',t,date_array,date_num_temp date_array ( 5 : 6 ) = 0 !Set minutes and hours to 0 date_num_temp = date_to_number ( date_array , ref_year_EMEP ) call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) !write(unit_logfile,'(a,i4,6i6,d)') ' Date EMEP =   ',t,date_array,date_num_temp !val_dim_nc(t,time_dim_nc_index)=ceiling(date_num_temp*dble(24.)*dble(3600.))/dble(24.)/dble(3600.) date_num_temp = date_num_temp + dble ( 0.01 ) / dble ( 2 4. ) / dble ( 360 0. ) !Add 0.01 of a second to avoid any rounding off errors call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) !write(unit_logfile,'(a,i4,6i6,d)') ' Date EMEP =   ',t,date_array,date_num_temp val_dim_nc ( t , time_dim_nc_index ) = date_num_temp !Convert to seconds since 2000 date_array = 0 date_array ( 1 ) = 2000 ; date_array ( 2 ) = 1 ; date_array ( 3 ) = 1 date_num_2000 = date_to_number ( date_array , ref_year_EMEP ) time_seconds_output ( t ) = int (( date_num_temp - date_num_2000 ) * 24 * 3600 , kind = 4 ) unit_dim_nc ( time_dim_nc_index ) = \"seconds since 2000-1-1 0:0:0\" ;; enddo !stop endif !Test for Ceclius or Kelvin if ( maxval ( var3d_nc (:,:,:, t2m_nc_index ,:, meteo_p_loop_index )). lt . 150 ) then write ( unit_logfile , '(a,f12.2)' ) 'WARNING: Temperature appears to be in Celcius. Converting to Kelvin. Max temperature is: ' , maxval ( var3d_nc (:,:,:, T2m_nc_index ,:, meteo_p_loop_index )) var3d_nc (:,:,:, t2m_nc_index ,:, meteo_p_loop_index ) = var3d_nc (:,:,:, T2m_nc_index ,:, meteo_p_loop_index ) + 27 3.13 endif !Deallocate temporary arrays if ( allocated ( var1d_nc_dp )) deallocate ( var1d_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( var3d_nc_dp )) deallocate ( var3d_nc_dp ) if ( allocated ( var4d_nc_dp )) deallocate ( var4d_nc_dp ) if ( allocated ( temp_var4d_nc )) deallocate ( temp_var4d_nc ) if ( allocated ( temp_var3d_nc )) deallocate ( temp_var3d_nc ) if ( allocated ( species_temp_var3d_nc )) deallocate ( species_temp_var3d_nc ) !Shift the EMEP grid to the west by 0.1 degrees. Portugal test !var1d_nc(:,x_dim_nc_index)=var1d_nc(:,x_dim_nc_index)-0.1 end subroutine uEMEP_read_EMEP end module read_emep","tags":"","loc":"sourcefile/uemep_read_emep.f90.html"},{"title":"uEMEP_read_RWC_heating_data.f90 – uEMEP","text":"Source Code module read_rwc_heating_data use uemep_configuration use utility_functions , only : nxtdat , utm2ll use mod_lambert_projection , only : lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: uEMEP_read_RWC_heating_data contains !uEMEP_read_RWC_heating_data.f90 !Reads in MetVed data in SSB format at 250 m !Reads in HDD cdf file in same file !Allocates emissions to 250 m grid subroutine uEMEP_read_RWC_heating_data use uEMEP_definitions use netcdf implicit none logical exists logical nxtdat_flag integer source_index character ( 256 ) header_str ( 5 ) integer count , count_grid integer unit_in integer RWC_pm25_index , RWC_pm10_index , RWC_nox_index parameter ( RWC_pm25_index = 1 , RWC_pm10_index = 2 , RWC_nox_index = 3 ) integer RWC_HDD5_index , RWC_HDD8_index , RWC_HDD11_index , RWC_HDD15_index parameter ( RWC_HDD5_index = 1 , RWC_HDD8_index = 2 , RWC_HDD11_index = 3 , RWC_HDD15_index = 4 ) integer * 8 ssb_id real x_ssb , y_ssb , lon_ssb , lat_ssb integer i_ssb_index , j_ssb_index integer :: threshold_index = 0 real :: f_easting = 2.e6 real :: ssb_dx = 25 0. , ssb_dy = 25 0. integer RWC_compound_index real sum_RWC_grid_emission ( 3 ) real sum_RWC_grid_height ( 3 ) integer :: subsource_index = 1 real emission_scaling ( 3 ) logical :: read_file_with_nox_and_kommune_number = . true . integer :: n_region_max , n_region_back_max parameter ( n_region_max = 1000 , n_region_back_max = 10000 ) integer :: region_scaling_id ( n_region_max ) = 0 real total_emissions ( n_compound_nc_index ) integer region_scaling_id_back_index ( n_region_back_max ) real , allocatable :: region_heating_scaling (:,:) integer n_region , k , k_index integer , allocatable :: count_subgrid (:,:) real , allocatable :: emission_properties_subgrid_sigz00_temp (:,:) integer :: io integer i_pollutant if ( filename_heating ( RWC_heating_index ). eq . '' ) then write ( unit_logfile , '(A)' ) 'WARNING: No RWC heating data file available. Will not use RWC data' return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading RWC heating data  (uEMEP_read_RWC_heating_data)' write ( unit_logfile , '(A)' ) '================================================================' !threshold_index=RWC_HDD15_index if ( HDD_threshold_value . eq . 15 ) then threshold_index = RWC_HDD15_index elseif ( HDD_threshold_value . eq . 11 ) then threshold_index = RWC_HDD11_index elseif ( HDD_threshold_value . eq . 8 ) then threshold_index = RWC_HDD8_index elseif ( HDD_threshold_value . eq . 5 ) then threshold_index = RWC_HDD5_index else write ( unit_logfile , '(A,i6)' ) 'HDD_threshold_value is not valid. Stopping. ' , HDD_threshold_value stop endif write ( unit_logfile , '(A,2i6)' ) 'HDD_threshold_value and index = ' , HDD_threshold_value , threshold_index if ( read_RWC_file_with_extra_HDD ) write ( unit_logfile , '(A,L)' ) 'read_RWC_file_with_extra_HDD = ' , read_RWC_file_with_extra_HDD if ( read_RWC_file_with_extra_HDD_and_height ) write ( unit_logfile , '(A,L)' ) 'read_RWC_file_with_extra_HDD_and_height = ' , read_RWC_file_with_extra_HDD_and_height subsource_index = 1 !Emission scaling for nox compared to pm25. emission_scaling = 1. emission_scaling ( RWC_nox_index ) = emission_factor ( nox_index , heating_index , subsource_index ) / emission_factor ( pm25_index , heating_index , subsource_index ) write ( unit_logfile , '(A,f12.4,2es12.2)' ) 'NOx/PM2.5 emission ratio =' , emission_scaling ( RWC_nox_index ), emission_factor ( nox_index , heating_index , subsource_index ), emission_factor ( pm25_index , heating_index , subsource_index ) source_index = heating_index n_subsource ( source_index ) = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. !Read in the data in the first g_loop and t_loop if ( first_g_loop ) then !if (g_loop.eq.1) then pathfilename_heating ( RWC_heating_index ) = trim ( pathname_heating ( RWC_heating_index )) // trim ( filename_heating ( RWC_heating_index )) !Test existence of the heating filename. If does not exist then stop inquire ( file = trim ( pathfilename_heating ( RWC_heating_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: RWC file does not exist: ' , trim ( pathfilename_heating ( RWC_heating_index )) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_heating ( RWC_heating_index ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening RWC heating file ' // trim ( pathfilename_heating ( RWC_heating_index )) rewind ( unit_in ) !read (unit_in,'(a)') header_str(1) ! read (unit_in,'(a)') header_str(2) !read (unit_in,'(a)') header_str(3) !write(*,*) header_str(1:3) call nxtdat ( unit_in , nxtdat_flag ) !Read number of grids read ( unit_in , '(i)' ) n_RWC_grids write ( unit_logfile , '(A,i)' ) 'Number of RWC grids =' , n_RWC_grids !Allocate the arrays in the first g_loop and t_loop allocate ( RWC_grid_emission ( n_RWC_grids , 3 )) allocate ( RWC_grid_HDD ( n_RWC_grids , 4 )) allocate ( RWC_grid_id ( n_RWC_grids )) allocate ( RWC_grid_height ( n_RWC_grids , 2 )) allocate ( RWC_region_id ( n_RWC_grids )) !Read header      SSBID    PM25_2016    PM10_2016       HDD_11       HDD_15 read ( unit_in , * ) header_str ! write(unit_logfile,'(6A24)') 'Headers: ',trim(header_str(1)),trim(header_str(2)),trim(header_str(3)),trim(header_str(4)),trim(header_str(5)) count = 0 RWC_grid_emission = 0. if ( read_RWC_file_with_extra_HDD_and_height ) then !Read new version do count = count + 1 read ( unit_in , * , iostat = io ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_emission ( count , RWC_nox_index ), RWC_grid_HDD ( count , RWC_HDD5_index ), RWC_grid_HDD ( count , RWC_HDD8_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ), RWC_grid_height ( count , 1 ), RWC_grid_height ( count , 2 ), RWC_region_id ( count ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(i,9es,i)') RWC_grid_id(count),RWC_grid_emission(count,RWC_pm25_index),RWC_grid_emission(count,RWC_pm10_index),RWC_grid_emission(count,RWC_nox_index),RWC_grid_HDD(count,RWC_HDD5_index),RWC_grid_HDD(count,RWC_HDD8_index),RWC_grid_HDD(count,RWC_HDD11_index),RWC_grid_HDD(count,RWC_HDD15_index),RWC_grid_height(count,1),RWC_grid_height(count,2),RWC_region_id(count) if ( count == n_RWC_grids ) then exit end if enddo elseif ( read_RWC_file_with_extra_HDD ) then !Read new version do count = count + 1 read ( unit_in , * , iostat = io ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_emission ( count , RWC_nox_index ), RWC_grid_HDD ( count , RWC_HDD5_index ), RWC_grid_HDD ( count , RWC_HDD8_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ), RWC_region_id ( count ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(i,5es,i)') RWC_grid_id(count),RWC_grid_emission(count,RWC_pm25_index),RWC_grid_emission(count,RWC_pm10_index),RWC_grid_emission(count,RWC_nox_index),RWC_grid_HDD(count,RWC_HDD11_index),RWC_grid_HDD(count,RWC_HDD15_index),RWC_region_id(count) enddo elseif ( read_file_with_nox_and_kommune_number ) then !Read new version do count = count + 1 read ( unit_in , * , iostat = io ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_emission ( count , RWC_nox_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ), RWC_region_id ( count ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(i,5es,i)') RWC_grid_id(count),RWC_grid_emission(count,RWC_pm25_index),RWC_grid_emission(count,RWC_pm10_index),RWC_grid_emission(count,RWC_nox_index),RWC_grid_HDD(count,RWC_HDD11_index),RWC_grid_HDD(count,RWC_HDD15_index),RWC_region_id(count) enddo else !Read old version do count = count + 1 !read(unit_in,'(i,4es)') RWC_grid_id(count),RWC_grid_val(count,1:4) read ( unit_in , * ) RWC_grid_id ( count ), RWC_grid_emission ( count , RWC_pm25_index ), RWC_grid_emission ( count , RWC_pm10_index ), RWC_grid_HDD ( count , RWC_HDD11_index ), RWC_grid_HDD ( count , RWC_HDD15_index ) if ( io /= 0 ) then count = count - 1 exit end if !write(*,'(2i,4es)') count,RWC_grid_id(count),RWC_grid_val(count,1:4) RWC_grid_emission ( count , RWC_nox_index ) = RWC_grid_emission ( count , RWC_pm25_index ) * emission_scaling ( RWC_nox_index ) RWC_region_id ( count ) = 1 enddo endif !For annual calculations use the provided emissions in g/year without any HDD if ( annual_calculations ) then RWC_grid_HDD = 1. endif if ( count . ne . n_RWC_grids ) then write ( unit_logfile , '(A,2i)' ) 'ERROR: Total number of RWC grids in file is not the same as given. Stopping: ' , n_RWC_grids , count stop endif write ( unit_logfile , '(A,i)' ) 'Total number of RWC grids read =' , count write ( unit_logfile , '(A,3f12.2)' ) 'Total emissions PM2.5, PM10 and NOX (tonne/year) =' , sum ( RWC_grid_emission (:, RWC_pm25_index )) / 1.e6 , sum ( RWC_grid_emission (:, RWC_pm10_index )) / 1.e6 , sum ( RWC_grid_emission (:, RWC_nox_index )) / 1.e6 endif !Read in regional scaling data if available pathfilename_region_heating_scaling = trim ( inpath_region_heating_scaling ) // trim ( infile_region_heating_scaling ) !Test existence of the filename. If does not exist then use default inquire ( file = trim ( pathfilename_region_heating_scaling ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' WARNING: Regional heating scaling data file does not exist and no scaling will be applied: ' , trim ( pathfilename_region_heating_scaling ) n_region = 1 region_scaling_id_back_index = n_region allocate ( region_heating_scaling ( n_region , n_compound_nc_index )) region_heating_scaling = 1. else unit_in = 20 open ( unit_in , file = pathfilename_region_heating_scaling , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening regional scaling heating file: ' // trim ( pathfilename_region_heating_scaling ) !Skip over header lines starting with * rewind ( unit_in ) call nxtdat ( unit_in , nxtdat_flag ) !Read the data read ( unit_in , * , ERR = 10 ) n_region write ( unit_logfile , '(a,i)' ) ' Number of regions read: ' , n_region if ( allocated ( region_heating_scaling )) deallocate ( region_heating_scaling ) allocate ( region_heating_scaling ( n_region , n_compound_nc_index )) call nxtdat ( unit_in , nxtdat_flag ) do k = 1 , n_region read ( unit_in , * , ERR = 10 ) & k_index , region_scaling_id ( k ), & total_emissions ( pm25_index ), total_emissions ( pm10_index ), total_emissions ( nox_index ), & region_heating_scaling ( k , pm25_nc_index ), region_heating_scaling ( k , pm10_nc_index ), region_heating_scaling ( k , nox_nc_index ) !write(*,'(2i,3es10.2,3f10.3)')  & !    k_index,region_scaling_id(k), & !    total_emissions(pm25_index),total_emissions(pm10_index),total_emissions(nox_index), & !    region_heating_scaling(k,pm25_nc_index),region_heating_scaling(k,pm10_nc_index),region_heating_scaling(k,nox_nc_index) !Set a back referencing value for speed. Note the region_scaling_id cannot be larger than the hardcoded dimensions region_scaling_id_back_index ( region_scaling_id ( k )) = k enddo close ( unit_in , status = 'keep' ) endif !Put the data into the subgrid for all g_loop calls if ( allocated ( count_subgrid )) deallocate ( count_subgrid ) allocate ( count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) count_subgrid = 0 count_grid = 0 sum_RWC_grid_emission = 0 sum_RWC_grid_height = 0 if ( read_RWC_file_with_extra_HDD_and_height ) then !Set the existing heights to 0 as these will be replaced emission_properties_subgrid (:,:, emission_h_index , source_index ) = 0 endif if ( read_RWC_file_with_extra_HDD_and_height ) then !Set the existing heights to 0 as these will be replaced if ( allocated ( emission_properties_subgrid_sigz00_temp )) deallocate ( emission_properties_subgrid_sigz00_temp ) allocate ( emission_properties_subgrid_sigz00_temp ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ))) emission_properties_subgrid_sigz00_temp = 0. endif do count = 1 , n_RWC_grids ssb_id = RWC_grid_id ( count ) x_ssb = ssb_id / 10000000 - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. !Convert to EMEP coordinates. SSB data always in UTM coordinates if ( save_emissions_for_EMEP ( heating_index )) then call utm2ll ( 1 , utm_zone , y_ssb , x_ssb , lat_ssb , lon_ssb ) if ( EMEP_projection_type . eq . LL_projection_index ) then x_ssb = lon_ssb y_ssb = lat_ssb elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_ssb , y_ssb , lon_ssb , lat_ssb , EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_ssb , y_ssb , lon_ssb , lat_ssb , EMEP_projection_attributes ) endif endif k = region_scaling_id_back_index ( RWC_region_id ( count )) if ( k . lt . 1. or . k . gt . n_region ) then write ( unit_logfile , '(A,4i)' ) ' ERROR: Region index out of bounds, stopping: ' , count , RWC_region_id ( count ), k , n_region stop endif !Find the grid index it belongs to i_ssb_index = 1 + floor (( x_ssb - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ssb_index = 1 + floor (( y_ssb - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then !write(*,*) x_ssb,y_ssb,emission_subgrid_delta(x_dim_index,source_index),i_ssb_index,j_ssb_index !Set the proxy emssion subgrid. This will be multiplied by the hdd later in the read_time_profiles routine do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then RWC_compound_index = RWC_pm10_index proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) & + RWC_grid_emission ( count , RWC_compound_index ) / RWC_grid_HDD ( count , threshold_index ) * region_heating_scaling ( k , pm10_nc_index ) sum_RWC_grid_emission ( RWC_compound_index ) = sum_RWC_grid_emission ( RWC_compound_index ) + RWC_grid_emission ( count , RWC_compound_index ) elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then RWC_compound_index = RWC_pm25_index proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) & + RWC_grid_emission ( count , RWC_compound_index ) / RWC_grid_HDD ( count , threshold_index ) * region_heating_scaling ( k , pm25_nc_index ) sum_RWC_grid_emission ( RWC_compound_index ) = sum_RWC_grid_emission ( RWC_compound_index ) + RWC_grid_emission ( count , RWC_compound_index ) elseif ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then RWC_compound_index = RWC_nox_index proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index , i_pollutant ) & + RWC_grid_emission ( count , RWC_compound_index ) / RWC_grid_HDD ( count , threshold_index ) * region_heating_scaling ( k , nox_nc_index ) sum_RWC_grid_emission ( RWC_compound_index ) = sum_RWC_grid_emission ( RWC_compound_index ) + RWC_grid_emission ( count , RWC_compound_index ) endif enddo if ( read_RWC_file_with_extra_HDD_and_height ) then !Replace the existing height that is given by h_emis emission_properties_subgrid ( i_ssb_index , j_ssb_index , emission_h_index , source_index ) = emission_properties_subgrid ( i_ssb_index , j_ssb_index , emission_h_index , source_index ) + RWC_grid_height ( count , 1 ) sum_RWC_grid_height ( 1 ) = sum_RWC_grid_height ( 1 ) + RWC_grid_height ( count , 1 ) !Add additional standard deviation to the pre-existing value based on variability within the sub-grid !emission_properties_subgrid(i_ssb_index,j_ssb_index,emission_sigz00_index,source_index)=sqrt(emission_properties_subgrid(i_ssb_index,j_ssb_index,emission_sigz00_index,source_index)**2+RWC_grid_height(count,2)**2) emission_properties_subgrid_sigz00_temp ( i_ssb_index , j_ssb_index ) = emission_properties_subgrid_sigz00_temp ( i_ssb_index , j_ssb_index ) + RWC_grid_height ( count , 2 ) ** 2 sum_RWC_grid_height ( 2 ) = sum_RWC_grid_height ( 2 ) + RWC_grid_height ( count , 2 ) ** 2 sum_RWC_grid_height ( 3 ) = sum_RWC_grid_height ( 3 ) + emission_properties_subgrid_sigz00_temp ( i_ssb_index , j_ssb_index ) endif !write(*,*) count,i_ssb_index,j_ssb_index,emission_subgrid_dim(x_dim_index,source_index),emission_subgrid_dim(y_dim_index,source_index) count_subgrid ( i_ssb_index , j_ssb_index ) = count_subgrid ( i_ssb_index , j_ssb_index ) + 1 count_grid = count_grid + 1 endif enddo !It is assumed that it is possible that more than one ssb_grid can be found in a subgrid, so the total becomes the mean, no weighted avraging if ( read_RWC_file_with_extra_HDD_and_height ) then where ( count_subgrid . gt . 0 ) emission_properties_subgrid (:,:, emission_h_index , source_index ) = emission_properties_subgrid (:,:, emission_h_index , source_index ) / count_subgrid !where(count_subgrid.gt.0) emission_properties_subgrid(:,:,emission_sigz00_index,source_index)=emission_properties_subgrid(:,:,emission_sigz00_index,source_index)/count_subgrid where ( count_subgrid . gt . 0 ) emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) = sqrt ( emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) ** 2 + emission_properties_subgrid_sigz00_temp / count_subgrid ) endif write ( unit_logfile , '(A,i)' ) 'Number of RWC grid placements in emission subgrid =' , count_grid do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then RWC_compound_index = RWC_pm10_index write ( unit_logfile , '(A,f12.2)' ) 'Total subgrid RWC emissions for ' // trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // ' (tonne/year) =' , sum_RWC_grid_emission ( RWC_compound_index ) / 1.e6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then RWC_compound_index = RWC_pm25_index write ( unit_logfile , '(A,f12.2)' ) 'Total subgrid RWC emissions for ' // trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // ' (tonne/year) =' , sum_RWC_grid_emission ( RWC_compound_index ) / 1.e6 elseif ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then RWC_compound_index = RWC_nox_index write ( unit_logfile , '(A,f12.2)' ) 'Total subgrid RWC emissions for ' // trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_index )) // ' (tonne/year) =' , sum_RWC_grid_emission ( RWC_compound_index ) / 1.e6 endif enddo if ( read_RWC_file_with_extra_HDD_and_height ) then write ( unit_logfile , '(A,f12.2)' ) 'Average heating emission height for replaced values = ' , sum_RWC_grid_height ( 1 ) / count_grid write ( unit_logfile , '(A,f12.2)' ) 'Average heating emission height total standard deviation = ' , sqrt ( sum_RWC_grid_height ( 3 ) / count_grid ) write ( unit_logfile , '(A,f12.2)' ) 'Additional RMS average heating emission height standard deviation = ' , sqrt ( sum_RWC_grid_height ( 2 ) / count_grid ) endif if ( allocated ( region_heating_scaling )) deallocate ( region_heating_scaling ) if ( allocated ( count_subgrid )) deallocate ( count_subgrid ) return 10 write ( unit_logfile , '(A)' ) 'ERROR reading scaling heating file' stop end subroutine uEMEP_read_RWC_heating_data end module read_rwc_heating_data","tags":"","loc":"sourcefile/uemep_read_rwc_heating_data.f90.html"},{"title":"uEMEP_indices.f90 – uEMEP","text":"Source Code module uEMEP_indices implicit none end module uEMEP_indices","tags":"","loc":"sourcefile/uemep_indices.f90.html"},{"title":"uEMEP_redistribute_data.f90 – uEMEP","text":"Source Code module redistribute_data use uemep_configuration use save_netcdf_file , only : mean_mask implicit none private public :: uEMEP_redistribute_local_source , uEMEP_disperse_local_source , & uEMEP_combine_local_source contains !uEMEP_redistribute_local_source !Same routine for all sources subroutine uEMEP_redistribute_local_source ( source_index ) use uEMEP_definitions implicit none integer i , j integer source_index integer ii , jj , tt integer integral_counter real sum_integral ( n_pollutant_loop ) integer i_start , i_end , j_start , j_end , t_start , t_end integer emep_subsource integer i_cross_integral , j_cross_integral real xpos_limit , ypos_limit real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_integral_subgrid , ypos_integral_subgrid integer i_pollutant !allocate (sum_integral(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (scaling_factor_traffic_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (traffic_redistributed_local_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar if ( local_subgrid_method_flag . ne . 1 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Redistribute local source using EMEP concentrations (uEMEP_redistribute_local_source)' write ( unit_logfile , '(A)' ) '================================================================' !No subsources for the emep related arrays emep_subsource = 1 write ( unit_logfile , '(2A)' ) 'Calculating the scaling factor and local contribution at each subgrid for ' , trim ( source_file_str ( source_index )) xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) do tt = t_start , t_end !Calculate the mean concentration of the integral values for each subgrid point do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then sum_integral = 0. integral_counter = 0 i_cross_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) xpos_integral_subgrid = xproj_subgrid ( i , j ) ypos_integral_subgrid = yproj_subgrid ( i , j ) !Use the wind direction to move the target area downwind if ( use_downwind_position_flag . and . hourly_calculations ) then !Use the same area as for non upwind i_start = max ( 1 , i_cross_integral - integral_subgrid_loop_index ( x_dim_index )) i_end = min ( integral_subgrid_dim ( x_dim_index ), i_cross_integral + integral_subgrid_loop_index ( x_dim_index )) j_start = max ( 1 , j_cross_integral - integral_subgrid_loop_index ( y_dim_index )) j_end = min ( integral_subgrid_dim ( y_dim_index ), j_cross_integral + integral_subgrid_loop_index ( y_dim_index )) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit else i_start = max ( 1 , i_cross_integral - integral_subgrid_loop_index ( x_dim_index )) i_end = min ( integral_subgrid_dim ( x_dim_index ), i_cross_integral + integral_subgrid_loop_index ( x_dim_index )) j_start = max ( 1 , j_cross_integral - integral_subgrid_loop_index ( y_dim_index )) j_end = min ( integral_subgrid_dim ( y_dim_index ), j_cross_integral + integral_subgrid_loop_index ( y_dim_index )) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit endif !write(*,*) i_start-i_cross_integral,i_end-i_cross_integral,j_start-j_cross_integral,j_end-j_cross_integral !Calculate the average grid concentration at each integral subgrid based on proxy integral do jj = j_start , j_end do ii = i_start , i_end xpos_integral_subgrid = xproj_integral_subgrid ( ii , jj ) ypos_integral_subgrid = yproj_integral_subgrid ( ii , jj ) if ( xpos_integral_subgrid . ge . xpos_area_min . and . xpos_integral_subgrid . le . xpos_area_max & . and . ypos_integral_subgrid . ge . ypos_area_min . and . ypos_integral_subgrid . le . ypos_area_max ) then !do i_pollutant=1,n_pollutant_loop sum_integral (:) = sum_integral (:) + integral_subgrid ( ii , jj , tt , hsurf_average_subgrid_index , source_index ,:) !write(*,*) ii,jj,integral_subgrid(ii,jj,tt,hsurf_average_subgrid_index,source_index,1) !enddo integral_counter = integral_counter + 1 !write(*,*) i,j,ii-i_cross_integral,jj-j_cross_integral endif enddo enddo !Calculate scaling factor do i_pollutant = 1 , n_pollutant_loop if ( sum_integral ( i_pollutant ). ne . 0 ) then subgrid ( i , j , tt , scaling_factor_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) / sum_integral ( i_pollutant ) * integral_counter else subgrid ( i , j , tt , scaling_factor_subgrid_index , source_index , i_pollutant ) = 0. endif !write(*,*) i_pollutant,subgrid(i,j,tt,proxy_subgrid_index,source_index,i_pollutant),sum_integral(i_pollutant) if ( isnan ( subgrid ( i , j , tt , scaling_factor_subgrid_index , source_index , i_pollutant ))) write ( * , * ) i , j , sum_integral ( i_pollutant ), integral_counter if ( isnan ( subgrid ( i , j , tt , emep_local_subgrid_index , source_index , i_pollutant ))) write ( * , * ) 'L' , i , j , sum_integral ( i_pollutant ), integral_counter enddo endif enddo !write(*,*) 'Redistribution',j,' of ',subgrid_dim(2) enddo write ( * , * ) 'Redistribution time ' , tt , ' of ' , subgrid_dim ( t_dim_index ) enddo do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(i,A,f12.4)' ) i_pollutant , ' Max scaling factor for pollutant  =' , maxval ( subgrid (:,:,:, scaling_factor_subgrid_index , source_index , i_pollutant )) write ( unit_logfile , '(i,A,f12.4)' ) i_pollutant , ' Mean scaling factor for pollutant =' , sum ( subgrid (:,:,:, scaling_factor_subgrid_index , source_index , i_pollutant )) & / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) enddo !Calculate redistributed subgrid source concentrations subgrid (:,:,:, local_subgrid_index , source_index ,:) = subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) * subgrid (:,:,:, emep_local_subgrid_index , source_index ,:) end subroutine uEMEP_redistribute_local_source !uEMEP_disperse_local_source !Same routine for all sources !This routine uses the emission factors and meteorology to calculate the local concentrations !This is instead of redistributing using proxy data !Gives the same output as the uEMEP_redistribute_local_source subroutine uEMEP_disperse_local_source ( source_index ) use uEMEP_definitions implicit none integer source_index !allocate (sum_integral(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (scaling_factor_traffic_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar !allocate (traffic_redistributed_local_subgrid(subgrid_dim(1),subgrid_dim(2))) !Can just be a scalar if ( local_subgrid_method_flag . ne . 2. and . local_subgrid_method_flag . ne . 3. and . local_subgrid_method_flag . ne . 4 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Redistribute local source using dispersion (uEMEP_disperse_local_source)' write ( unit_logfile , '(A)' ) '================================================================' !do subsource_index=1,n_subsource(source_index) !Calculate redistributed subgrid source concentrations subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) = 1. subgrid (:,:,:, local_subgrid_index , source_index ,:) = subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) * subgrid (:,:,:, proxy_subgrid_index , source_index ,:) if ( trace_emissions_from_in_region ) then subgrid_local_from_in_region (:,:,:, source_index ,:) = subgrid (:,:,:, scaling_factor_subgrid_index , source_index ,:) * subgrid_proxy_from_in_region (:,:,:, source_index ,:) end if !enddo !Subsource loop end subroutine uEMEP_disperse_local_source !uEMEP_combine_local_source !Saves the combination of local sources for final results subroutine uEMEP_combine_local_source use uEMEP_definitions implicit none integer source_index integer i_pollutant integer i , j integer i_sp real sum_temp ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !if (interpolate_subgrids_flag) then !write(unit_logfile,'(a)') 'Interpolate routines not currently active. Doing nothing' !call uEMEP_interpolate_auto_subgrid !return !stop !call uEMEP_interpolate_subgrids !call uEMEP_linear_interpolate_subgrids !call uEMEP_bilinear_interpolate_subgrids !Remember to reset the use_subgrids val and logical so that everything will be used in the end !endif write ( unit_logfile , '(a)' ) '--------------------------' write ( unit_logfile , '(a)' ) 'Combining the local and nonlocal contributions at each subgrid' write ( unit_logfile , '(a)' ) '--------------------------' !Calculate redistributed subgrid allsource concentrations subgrid (:,:,:, local_subgrid_index , allsource_index ,:) = 0. do source_index = 1 , n_source_index if ( calculate_source ( source_index ). and . source_index . ne . allsource_index ) then subgrid (:,:,:, local_subgrid_index , allsource_index ,:) = subgrid (:,:,:, local_subgrid_index , allsource_index ,:) + subgrid (:,:,:, local_subgrid_index , source_index ,:) endif !Add the selected EMEP local sources to this as well, if they are not already included in the subgrid downscaling if ( calculate_EMEP_source ( source_index ). and .. not . calculate_source ( source_index ). and . source_index . ne . allsource_index ) then subgrid (:,:,:, local_subgrid_index , allsource_index ,:) = subgrid (:,:,:, local_subgrid_index , allsource_index ,:) + subgrid (:,:,:, emep_local_subgrid_index , source_index ,:) !write(*,*) source_index,sum(subgrid(:,:,:,emep_local_subgrid_index,source_index,:)),sum(subgrid(:,:,:,local_subgrid_index,allsource_index,:)),sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,:)) endif enddo if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then do i_pollutant = 1 , n_pollutant_loop !If the compound is PM2.5 or PM10 then add the non PPM part to the non-local if ( pollutant_loop_index ( i_pollutant ). eq . pm25_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_index ) then write ( unit_logfile , '(A,A)' ) 'Pollutant: ' , trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_nc_index )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM NONLOCAL ADDITIONAL: ' , sum (( subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid (:,:,:, emep_additional_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN ADD REST NONLOCAL ADDITIONAL: ' , sum (( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) endif !subgrid(:,:,:,total_subgrid_index,allsource_index,i_pollutant)=subgrid(:,:,:,local_subgrid_index,allsource_index,i_pollutant)+subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant) enddo endif do i_pollutant = 1 , n_pollutant_loop !If the compound is PM2.5 or PM10 then add the non PPM part to the non-local if ( pollutant_loop_index ( i_pollutant ). eq . pm25_index . or . pollutant_loop_index ( i_pollutant ). eq . pm10_index ) then write ( unit_logfile , '(A,A)' ) 'Pollutant: ' , trim ( var_name_nc ( conc_nc_index , pollutant_loop_index ( i_pollutant ), allsource_nc_index )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM NONLOCAL: ' , mean_mask ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM LOCAL: ' , mean_mask ( subgrid (:,:,:, emep_local_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_local_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN PPM TOTAL: ' , mean_mask ( subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN COMP PM TOTAL: ' , mean_mask ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((comp_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN COMP PM ORIGINAL: ' , mean_mask ( orig_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((orig_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )) write ( unit_logfile , '(A,f12.2)' ) 'MEAN ADD REST NONLOCAL: ' , mean_mask ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((comp_EMEP_subgrid(:,:,:,pollutant_loop_index(i_pollutant))-subgrid(:,:,:,emep_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) write ( unit_logfile , '(A,f12.2)' ) 'MEAN NEW PM NONLOCAL: ' , mean_mask ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ), use_subgrid (:,:, allsource_index ), subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index )) !sum((subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant)))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index) if ( sum ( comp_EMEP_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) - subgrid (:,:,:, emep_subgrid_index , allsource_index , i_pollutant )). lt . 0 ) write ( unit_logfile , '(A)' ) 'WARNING!!!: PPM EMEP is more than total EMEP PM. Negative non PPM contributions.' endif subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) = subgrid (:,:,:, local_subgrid_index , allsource_index , i_pollutant ) + subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) enddo do i_pollutant = 1 , n_pollutant_loop !Place the results in the compound results !do i_loop=1,n_pollutant_compound_loop(i_pollutant) comp_subgrid (:,:,:, pollutant_loop_index ( i_pollutant )) = subgrid (:,:,:, total_subgrid_index , allsource_index , i_pollutant ) !enddo !write(*,'(2i,4f16.2)') i_pollutant,pollutant_loop_index(i_pollutant)& !    ,sum(subgrid(:,:,:,total_subgrid_index,allsource_index,i_pollutant))/subgrid_dim(x_dim_index)/subgrid_dim(y_dim_index)/subgrid_dim(t_dim_index)& !    ,sum(subgrid(:,:,:,local_subgrid_index,allsource_index,i_pollutant))& !    ,sum(subgrid(:,:,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant))& !    ,sum(comp_subgrid(:,:,:,pollutant_loop_index(i_pollutant))) enddo !Replace the species PPM with the actual species PPM used in the local fraction and then replace this with the nonlocal part. !Only works for the complete group of species if ( save_emep_species ) then !Replace the primary species value with the one used in the calculations for consistency write ( unit_logfile , '(A)' ) 'ppm read from surf and read emep. Difference should just be deposition' write ( unit_logfile , '(A,2f12.2)' ) 'PPM25 (init_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,2f12.2)' ) 'PPM10 (init_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A)' ) 'pm surf init species and summed species should be the same. comp should be different (difference between SURF and SURF_rh50)' write ( unit_logfile , '(A,3f12.2)' ) 'PM25 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,3f12.2)' ) 'PM10 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) !The remaining species will not, most likely, be normalised with the total. This is done here but the total ppm is kept !Something weird is going on here. Need to check !Normalise the species surface values with the total grid values to account for any difference du to deposition and water !Because t can have dimension 1 and 'sum' function does not think it is a dimension anymore then need to do the sum over the time loop. This turned out to not be the case so they are the same if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) endif do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 enddo if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) endif do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 enddo write ( unit_logfile , '(A)' ) 'sum_sp should be the same as comp after scaling, init should be unchanged' write ( unit_logfile , '(A,3f12.2)' ) 'PM25 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,3f12.2)' ) 'PM10 (init_sp,sum_sp,comp)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) !Replace the ppm values in the species with the emep read version !This is not correct. emep_subgrid_index,allsource_index is the sum of all local and nonlocal sources, so a larger number than the primary. !This will lead to negative values set to 0. So comment out this line (21.03.2022) !species_EMEP_subgrid(:,:,:,pm25_sp_index,sp_ppm_index)=subgrid(:,:,:,emep_subgrid_index,allsource_index,pollutant_loop_back_index(pm25_nc_index)) !species_EMEP_subgrid(:,:,:,pm10_sp_index,sp_ppm_index)=subgrid(:,:,:,emep_subgrid_index,allsource_index,pollutant_loop_back_index(pm10_nc_index)) !Normalise the species other than ppm again after subtracting the ppm !This should not change anything if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index - 1 ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index - 1 ), 4 ) endif do i_sp = 1 , sp_ppm_index - 1 species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm25_nc_index ) - species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 enddo if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index - 1 ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index - 1 ), 4 ) endif do i_sp = 1 , sp_ppm_index - 1 species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) & * ( comp_EMEP_subgrid (:,:,:, pm10_nc_index ) - species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index )) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 enddo !Remove the primary based on the local contribution. species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ) - subgrid (:,:,:, emep_local_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index )) species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ) - subgrid (:,:,:, emep_local_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index )) where ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ). lt . 0. or . isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ))) species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_ppm_index ) = 0 where ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ). lt . 0. or . isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ))) species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_ppm_index ) = 0 !Normalise again after the subtraction to the nonlocal contribution (21.03.2022) sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index ), 4 ) do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) & * ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm25_sp_index , i_sp ) = 0 enddo if ( use_single_time_loop_flag ) then sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) else sum_temp (:,:,:) = sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index ), 4 ) endif do i_sp = 1 , sp_ppm_index species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) & * ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) & / sum_temp where ( sum_temp . le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 where ( isnan ( species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp )). or . species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ). le . 0 ) species_EMEP_subgrid (:,:,:, pm10_sp_index , i_sp ) = 0 enddo write ( unit_logfile , '(A)' ) 'init_sp should be the same as before, sum_sp should be the same as nonlocal, comp should be larger' write ( unit_logfile , '(A,4f12.2)' ) 'PM25 (init_sp,sum_sp,comp,nonlocal)' , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm25_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm25_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm25_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,4f12.2)' ) 'PM10 (init_sp,sum_sp,comp,nonlocal)' , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , sp_pm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( species_EMEP_subgrid (:,:,:, pm10_sp_index , 1 : sp_ppm_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( comp_EMEP_subgrid (:,:,:, pm10_nc_index )) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) & , sum ( subgrid (:,:,:, emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( pm10_nc_index ))) / subgrid_dim ( x_dim_index ) / subgrid_dim ( y_dim_index ) / subgrid_dim ( t_dim_index ) endif !Only show results where all the subgrids and all sources are valid !This is temporary if ( interpolate_subgrids_flag ) then do source_index = 1 , n_source_index if ( calculate_source ( source_index )) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if (. not . use_subgrid ( i , j , source_index )) then !subgrid(i,j,:,total_subgrid_index,allsource_index,:)=NODATA_value !subgrid(i,j,:,total_subgrid_index,source_index,:)=NODATA_value !comp_subgrid(i,j,:,:)=NODATA_value endif enddo enddo endif enddo endif end subroutine uEMEP_combine_local_source end module redistribute_data","tags":"","loc":"sourcefile/uemep_redistribute_data.f90.html"},{"title":"uEMEP_subgrid_meteo_EMEP.f90 – uEMEP","text":"Source Code module subgrid_meteo_emep use uEMEP_definitions use uemep_constants , only : pi use uemep_configuration implicit none private public :: uEMEP_subgrid_meteo_EMEP contains subroutine uEMEP_subgrid_meteo_EMEP () !========================================================================== !   uEMEP_subgrid_meteo_EMEP !   Bruce Rolstad Denby !   MET Norway ! !   This routine interpolates EMEP meteo data to the integral subgrid !   using either nearest neighbour EMEP_meteo_grid_interpolation_flag=0 !   or area weighted interpolation EMEP_meteo_grid_interpolation_flag=1 !   It also generates cos and sin wind field data for dispersion modelling !========================================================================== ! Local variables integer :: i , j integer :: ii , jj , iii , jjj real , allocatable :: weighting_nc (:,:) integer :: t_start , t_end real :: xpos_min , xpos_max , ypos_min , ypos_max real :: xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max integer :: i_nc , j_nc real :: angle_utm , angle_lcc , angle_utm2 real , allocatable :: u_utm (:), v_utm (:), th (:), ff (:) real :: dlatx , dlaty real :: xpos_limit , ypos_limit real :: xpos_integral_subgrid , ypos_integral_subgrid write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Interpolating meteo data to subgrids (uEMEP_subgrid_meteo_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' if ( . not . allocated ( u_utm )) allocate ( u_utm ( dim_length_nc ( time_dim_nc_index ))) if ( . not . allocated ( v_utm )) allocate ( v_utm ( dim_length_nc ( time_dim_nc_index ))) if ( . not . allocated ( th )) allocate ( th ( dim_length_nc ( time_dim_nc_index ))) if ( . not . allocated ( ff )) allocate ( ff ( dim_length_nc ( time_dim_nc_index ))) ! Set the last meteo data to be the previous for the external time loop before updating if ( use_single_time_loop_flag ) then if ( t_loop . gt . start_time_loop_index ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, 1 ,:) end if end if ! Initialise all meteo subgrid fields meteo_subgrid = 0.0 ! Set the time dimensions for transfering the alternative meteorology which has a time index that starts at 0 t_start = 1 t_end = subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,I4)' ) 'Setting EMEP subgrid meteo data using method ' , EMEP_meteo_grid_interpolation_flag ! Loop through the integral subgrid and find those subgrids within EMEP grids and allocate values directly from EMEP grids. Nearest neighbour if ( EMEP_meteo_grid_interpolation_flag . eq . 0 ) then do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, FFgrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, FFgrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, u10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, u10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, v10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, v10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, FF10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, FF10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, kz_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, kz_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, hmix_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, hmix_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, logz0_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, logz0_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, invL_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, invL_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, inv_FFgrid_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, inv_FFgrid_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, inv_FF10_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, inv_FF10_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, ustar_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, ustar_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, J_subgrid_index ) = var4d_nc ( i_nc , j_nc , surface_level_nc ,:, J_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, t2m_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, t2m_nc_index , allsource_index , meteo_p_loop_index ) meteo_subgrid ( i , j ,:, precip_subgrid_index ) = var3d_nc ( i_nc , j_nc ,:, precip_nc_index , allsource_index , meteo_p_loop_index ) if ( use_alternative_meteorology_flag ) then i_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) meteo_subgrid ( i , j , t_start : t_end , ugrid_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , ugrid_nc_index ) meteo_subgrid ( i , j , t_start : t_end , vgrid_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , vgrid_nc_index ) meteo_subgrid ( i , j , t_start : t_end , u10_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , u10_nc_index ) meteo_subgrid ( i , j , t_start : t_end , v10_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , v10_nc_index ) meteo_subgrid ( i , j , t_start : t_end , FFgrid_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , FFgrid_nc_index ) meteo_subgrid ( i , j , t_start : t_end , FF10_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , FF10_nc_index ) meteo_subgrid ( i , j , t_start : t_end , hmix_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , hmix_nc_index ) meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , logz0_nc_index ) meteo_subgrid ( i , j , t_start : t_end , invL_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , invL_nc_index ) !meteo_subgrid(i,j,t_start:t_end,inv_FFgrid_subgrid_index)=meteo_var3d_nc(i_nc,j_nc,,t_start:t_end,inv_FFgrid_nc_index) !meteo_subgrid(i,j,t_start:t_end,inv_FF10_subgrid_index)=meteo_var3d_nc(i_nc,j_nc,t_start:t_end,inv_FF10_nc_index) meteo_subgrid ( i , j , t_start : t_end , ustar_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , ustar_nc_index ) meteo_subgrid ( i , j , t_start : t_end , t2m_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , t2m_nc_index ) meteo_subgrid ( i , j , t_start : t_end , precip_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , precip_nc_index ) end if ! Not properly implemented. Always false if ( use_alternative_z0_flag ) then meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_var3d_nc ( i_nc , j_nc , t_start : t_end , logz0_nc_index ) end if end do end do end if ! Area weighted interpolation of meteorology to integral grid if ( EMEP_meteo_grid_interpolation_flag . ge . 1 ) then xpos_limit = dgrid_nc ( lon_nc_index ) / 2.0 ypos_limit = dgrid_nc ( lat_nc_index ) / 2.0 allocate ( weighting_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid. Something wrong if it fails i_nc = crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) xpos_integral_subgrid = xproj_integral_subgrid ( i , j ) ypos_integral_subgrid = yproj_integral_subgrid ( i , j ) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit do jjj = j_nc - 1 , j_nc + 1 do iii = i_nc - 1 , i_nc + 1 ii = max ( 1 , iii ) ii = min ( dim_length_nc ( x_dim_nc_index ), iii ) jj = max ( 1 , jjj ) jj = min ( dim_length_nc ( y_dim_nc_index ), jjj ) xpos_min = max ( xpos_area_min , var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2.0 ) xpos_max = min ( xpos_area_max , var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2.0 ) ypos_min = max ( ypos_area_min , var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2.0 ) ypos_max = min ( ypos_area_max , var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2.0 ) ! Determine the area intersection of the EMEP grid and an EMEP grid size centred on the integral subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii , jj ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii , jj ) = 0.0 end if meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) = meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, ugrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) = meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, vgrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, FFgrid_subgrid_index ) = meteo_subgrid ( i , j ,:, FFgrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, FFgrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, kz_subgrid_index ) = meteo_subgrid ( i , j ,:, kz_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, kz_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, hmix_subgrid_index ) = meteo_subgrid ( i , j ,:, hmix_subgrid_index ) + var3d_nc ( ii , jj ,:, hmix_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, u10_subgrid_index ) = meteo_subgrid ( i , j ,:, u10_subgrid_index ) + var3d_nc ( ii , jj ,:, u10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, v10_subgrid_index ) = meteo_subgrid ( i , j ,:, v10_subgrid_index ) + var3d_nc ( ii , jj ,:, v10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, FF10_subgrid_index ) = meteo_subgrid ( i , j ,:, FF10_subgrid_index ) + var3d_nc ( ii , jj ,:, FF10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, logz0_subgrid_index ) = meteo_subgrid ( i , j ,:, logz0_subgrid_index ) + var3d_nc ( ii , jj ,:, logz0_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, invL_subgrid_index ) = meteo_subgrid ( i , j ,:, invL_subgrid_index ) + var3d_nc ( ii , jj ,:, invL_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, inv_FFgrid_subgrid_index ) = meteo_subgrid ( i , j ,:, inv_FFgrid_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, inv_FFgrid_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, inv_FF10_subgrid_index ) = meteo_subgrid ( i , j ,:, inv_FF10_subgrid_index ) + var3d_nc ( ii , jj ,:, inv_FF10_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, ustar_subgrid_index ) = meteo_subgrid ( i , j ,:, ustar_subgrid_index ) + var3d_nc ( ii , jj ,:, ustar_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, J_subgrid_index ) = meteo_subgrid ( i , j ,:, J_subgrid_index ) + var4d_nc ( ii , jj , surface_level_nc ,:, J_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, t2m_subgrid_index ) = meteo_subgrid ( i , j ,:, t2m_subgrid_index ) + var3d_nc ( ii , jj ,:, t2m_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j ,:, precip_subgrid_index ) = meteo_subgrid ( i , j ,:, precip_subgrid_index ) + var3d_nc ( ii , jj ,:, precip_nc_index , allsource_index , meteo_p_loop_index ) * weighting_nc ( ii , jj ) end do end do end do end do if ( use_alternative_meteorology_flag . or . use_alternative_z0_flag ) then if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) allocate ( weighting_nc ( dim_length_meteo_nc ( x_dim_nc_index ), dim_length_meteo_nc ( y_dim_nc_index ))) xpos_limit = meteo_dgrid_nc ( lon_nc_index ) / 2.0 ypos_limit = meteo_dgrid_nc ( lat_nc_index ) / 2.0 if ( use_alternative_meteorology_flag ) then meteo_subgrid (:,:,:, ugrid_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, vgrid_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, FFgrid_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, hmix_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, FF10_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, logz0_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, invL_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, ustar_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, t2m_subgrid_index ) = 0.0 meteo_subgrid (:,:,:, precip_subgrid_index ) = 0.0 end if if ( use_alternative_z0_flag ) then meteo_subgrid (:,:,:, logz0_subgrid_index ) = 0.0 end if do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) xpos_integral_subgrid = meteo_nc_xproj_integral_subgrid ( i , j ) ypos_integral_subgrid = meteo_nc_yproj_integral_subgrid ( i , j ) xpos_area_max = xpos_integral_subgrid + xpos_limit xpos_area_min = xpos_integral_subgrid - xpos_limit ypos_area_max = ypos_integral_subgrid + ypos_limit ypos_area_min = ypos_integral_subgrid - ypos_limit do jj = j_nc - 1 , j_nc + 1 do ii = i_nc - 1 , i_nc + 1 xpos_min = max ( xpos_area_min , meteo_var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2.0 ) xpos_max = min ( xpos_area_max , meteo_var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2.0 ) ypos_min = max ( ypos_area_min , meteo_var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2.0 ) ypos_max = min ( ypos_area_max , meteo_var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2.0 ) ! Determine the area intersection of the EMEP grid and an EMEP grid size centred on the integral subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii , jj ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii , jj ) = 0.0 end if if ( use_alternative_meteorology_flag ) then meteo_subgrid ( i , j , t_start : t_end , ugrid_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , ugrid_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , ugrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , vgrid_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , vgrid_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , vgrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , FFgrid_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , FFgrid_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , FFgrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , hmix_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , hmix_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , hmix_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , u10_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , u10_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , ugrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , v10_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , v10_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , vgrid_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , FF10_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , FF10_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , FF10_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , logz0_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , invL_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , invL_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , invL_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , ustar_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , ustar_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , ustar_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , t2m_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , t2m_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , t2m_nc_index ) * weighting_nc ( ii , jj ) meteo_subgrid ( i , j , t_start : t_end , precip_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , precip_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , precip_nc_index ) * weighting_nc ( ii , jj ) end if if ( use_alternative_z0_flag ) then meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) = meteo_subgrid ( i , j , t_start : t_end , logz0_subgrid_index ) + meteo_var3d_nc ( ii , jj , t_start : t_end , logz0_nc_index ) * weighting_nc ( ii , jj ) end if end do end do end do end do end if end if ! Rotate wind fields if necessary and define cos and sin of the wind direction do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) ! Adjust wind direction to utm projection. ! First determine rotation for grids that are not lat lon ! Will fail for 90 degree rotations though this should never be the case if ( EMEP_projection_type . ne . LL_projection_index ) then dlatx = var2d_nc ( i_nc + 1 , j_nc , lat_nc_index ) - var2d_nc ( i_nc - 1 , j_nc , lat_nc_index ) dlaty = var2d_nc ( i_nc , j_nc + 1 , lat_nc_index ) - var2d_nc ( i_nc , j_nc - 1 , lat_nc_index ) angle_lcc = atan ( dlatx / dlaty ) else angle_lcc = 0.0 end if if ( use_alternative_meteorology_flag ) then ! Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) j_nc = crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) ! Adjust wind direction to utm projection. ! First determine rotation for grids that are not lat lon ! Will fail for 90 degree rotations though this should never be the case if ( meteo_nc_projection_type . ne . LL_projection_index ) then dlatx = meteo_var2d_nc ( i_nc + 1 , j_nc , lat_nc_index ) - meteo_var2d_nc ( i_nc - 1 , j_nc , lat_nc_index ) dlaty = meteo_var2d_nc ( i_nc , j_nc + 1 , lat_nc_index ) - meteo_var2d_nc ( i_nc , j_nc - 1 , lat_nc_index ) angle_lcc = atan ( dlatx / dlaty ) else angle_lcc = 0.0 end if end if ! Rotation from lat lon grid to UTM grid. No alternatives if ( projection_type . eq . UTM_projection_index ) then angle_utm2 = atan ( tan (( lon_integral_subgrid ( i , j ) - utm_lon0 ) / 18 0.0 * pi ) * sin ( lat_integral_subgrid ( i , j ) / 18 0.0 * pi )) else if ( projection_type . eq . LTM_projection_index ) then angle_utm2 = atan ( tan (( lon_integral_subgrid ( i , j ) - ltm_lon0 ) / 18 0.0 * pi ) * sin ( lat_integral_subgrid ( i , j ) / 18 0.0 * pi )) else angle_utm2 = 0.0 end if ! Sum the angles (Triple check this is correct in regard to signs) angle_utm = angle_utm2 + angle_lcc ! Rotate u_utm = meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) * cos ( angle_utm ) + meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) * sin ( angle_utm ) v_utm = - meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) * sin ( angle_utm ) + meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) * cos ( angle_utm ) meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) = u_utm meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) = v_utm ! Create cos and sin's of the lowest level wind direction for efficient use in the dispersion equations if ( wind_vectors_10m_available ) then ff = sqrt ( meteo_subgrid ( i , j ,:, v10_subgrid_index ) * meteo_subgrid ( i , j ,:, v10_subgrid_index ) + meteo_subgrid ( i , j ,:, u10_subgrid_index ) * meteo_subgrid ( i , j ,:, u10_subgrid_index )) meteo_subgrid ( i , j ,:, sin_subgrid_index ) = meteo_subgrid ( i , j ,:, v10_subgrid_index ) / ff meteo_subgrid ( i , j ,:, cos_subgrid_index ) = meteo_subgrid ( i , j ,:, u10_subgrid_index ) / ff else ff = sqrt ( meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) * meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) + meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) * meteo_subgrid ( i , j ,:, ugrid_subgrid_index )) meteo_subgrid ( i , j ,:, sin_subgrid_index ) = meteo_subgrid ( i , j ,:, vgrid_subgrid_index ) / ff meteo_subgrid ( i , j ,:, cos_subgrid_index ) = meteo_subgrid ( i , j ,:, ugrid_subgrid_index ) / ff end if ! In case where no wind. Hopefully this never happens where ( ff . eq . 0.0 ) meteo_subgrid ( i , j ,:, sin_subgrid_index ) = 0.0 meteo_subgrid ( i , j ,:, cos_subgrid_index ) = 1.0 end where end do end do ! Set the last meteo data to be the current for the first value of the external time loop if ( use_single_time_loop_flag ) then if ( t_loop . eq . start_time_loop_index ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, 1 ,:) end if end if if ( allocated ( u_utm )) deallocate ( u_utm ) if ( allocated ( v_utm )) deallocate ( v_utm ) if ( allocated ( th )) deallocate ( th ) if ( allocated ( ff )) deallocate ( ff ) if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) end subroutine uEMEP_subgrid_meteo_EMEP end module subgrid_meteo_emep","tags":"","loc":"sourcefile/uemep_subgrid_meteo_emep.f90.html"},{"title":"uEMEP_auto_subgrid.f90 – uEMEP","text":"Source Code module auto_subgrid use uemep_configuration use uEMEP_definitions use mod_area_interpolation , only : area_weighted_interpolation_function use mod_lambert_projection , only : LL2PROJ , PROJ2LL use netcdf implicit none private public :: uEMEP_auto_subgrid , uEMEP_region_mask , uEMEP_interpolate_auto_subgrid , uEMEP_region_mask_new contains subroutine uEMEP_auto_subgrid () !! uEMEP model uEMEP_auto_subgrid !! Automatically creates a grid dependent on the distance to source integer :: i , j , k integer :: i_source integer :: t real :: max_use_subgrid_size ( n_source_index ) real :: use_subgrid_range ( n_source_index ) integer :: use_subgrid_step integer :: use_emission_subgrid_space integer :: i_cross , j_cross integer :: i_start , i_end , j_start , j_end integer :: i_start_k , i_end_k , j_start_k , j_end_k real :: sum_emission ! Exit if emission positions are not to be used and if one of the other auto positions is to be used if ( . not . use_emission_positions_for_auto_subgrid_flag ( allsource_index ) . and . ( use_population_positions_for_auto_subgrid_flag . or . use_receptor_positions_for_auto_subgrid_flag )) then return end if ! Exit and fill subgrid if none of the auto subgrids are to be used if ( . not . use_emission_positions_for_auto_subgrid_flag ( allsource_index ) . and . . not . use_population_positions_for_auto_subgrid_flag . and . . not . use_receptor_positions_for_auto_subgrid_flag ) then use_subgrid = . true . return end if write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Setting subgrids automatically (uEMEP_auto_subgrid)' write ( unit_logfile , '(A)' ) '================================================================' ! Set all subgrids to do not use use_subgrid_val = 0 use_subgrid_interpolation_index = - 1 ! Set time index used for emissions to 1, so only tests for the first hour if there are emissions t = 1 ! Set the maximum grid size max_use_subgrid_size = max_interpolation_subgrid_size use_subgrid_range = 8.0 use_subgrid_range ( traffic_index ) = 4.0 use_subgrid_range ( shipping_index ) = 1 2.0 n_use_subgrid_levels = 0 ! Sets the auto gridding if ( subgrid_delta ( x_dim_index ) . eq . 10 0.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 5 use_subgrid_step_delta ( 3 ) = 10 use_subgrid_step_delta ( 4 ) = 20 if ( max_interpolation_subgrid_size . eq . 25 0.0 ) n_use_subgrid_levels = 1 if ( max_interpolation_subgrid_size . eq . 50 0.0 ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 100 0.0 ) n_use_subgrid_levels = 3 if ( max_interpolation_subgrid_size . eq . 200 0.0 ) n_use_subgrid_levels = 4 use_subgrid_range ( traffic_index ) = 6.0 else if ( subgrid_delta ( x_dim_index ) . eq . 2 5.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 4 use_subgrid_step_delta ( 3 ) = 10 use_subgrid_step_delta ( 4 ) = 20 use_subgrid_step_delta ( 5 ) = 40 use_subgrid_step_delta ( 5 ) = 80 if ( max_interpolation_subgrid_size . eq . 25 0.0 ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 50 0.0 ) n_use_subgrid_levels = 3 if ( max_interpolation_subgrid_size . eq . 100 0.0 ) n_use_subgrid_levels = 4 if ( max_interpolation_subgrid_size . eq . 200 0.0 ) n_use_subgrid_levels = 5 use_subgrid_range ( traffic_index ) = 4.0 else if ( subgrid_delta ( x_dim_index ) . eq . 5 0.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 4 use_subgrid_step_delta ( 3 ) = 10 use_subgrid_step_delta ( 4 ) = 20 use_subgrid_step_delta ( 5 ) = 40 if ( max_interpolation_subgrid_size . eq . 25 0.0 ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 50 0.0 ) n_use_subgrid_levels = 3 if ( max_interpolation_subgrid_size . eq . 100 0.0 ) n_use_subgrid_levels = 4 if ( max_interpolation_subgrid_size . eq . 200 0.0 ) n_use_subgrid_levels = 5 use_subgrid_range ( traffic_index ) = 6.0 else if ( subgrid_delta ( x_dim_index ) . eq . 25 0.0 ) then use_subgrid_step_delta ( 0 ) = 1 use_subgrid_step_delta ( 1 ) = 2 use_subgrid_step_delta ( 2 ) = 4 use_subgrid_step_delta ( 3 ) = 8 if ( max_interpolation_subgrid_size . eq . 25 0. ) n_use_subgrid_levels = 0 if ( max_interpolation_subgrid_size . eq . 50 0. ) n_use_subgrid_levels = 1 if ( max_interpolation_subgrid_size . eq . 100 0. ) n_use_subgrid_levels = 2 if ( max_interpolation_subgrid_size . eq . 200 0. ) n_use_subgrid_levels = 3 use_subgrid_range ( traffic_index ) = 8.0 else write ( unit_logfile , '(a,f12.2)' ) 'When auto gridding target grid sizes must be either 25, 50, 100 or 250 metres. Stopping because target grid size is:' , subgrid_delta ( x_dim_index ) stop end if if ( n_use_subgrid_levels ( allsource_index ). eq . 0 ) then write ( unit_logfile , '(a,f12.2)' ) 'When auto gridding maximum grid sizes must be either 250, 500, 1000 or 2000 metres. Stopping because max grid size is:' , max_interpolation_subgrid_size stop 1 end if ! Set the number of levels to match this do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( * , * ) 'Using auto subgrid for source ' , trim ( source_file_str ( i_source )), use_emission_positions_for_auto_subgrid_flag ( i_source ) end if end do do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . use_emission_positions_for_auto_subgrid_flag ( i_source )) then write ( unit_logfile , '(a,2f10.1,i10)' ) trim ( source_file_str ( i_source )) // ': maximum use subgrid size (m), grid range and number of levels: ' , & max_use_subgrid_size ( i_source ), use_subgrid_range ( i_source ), n_use_subgrid_levels ( i_source ) ! Fill the interpolation index with the highest level do k = n_use_subgrid_levels ( i_source ), 0 , - 1 use_subgrid_step = 2 ** k use_subgrid_step = use_subgrid_step_delta ( k ) use_emission_subgrid_space = floor ( use_subgrid_step / sqrt ( emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) & / subgrid_delta ( x_dim_index ) / subgrid_delta ( y_dim_index )) / 2.0 * use_subgrid_range ( i_source )) use_emission_subgrid_space = max ( 1 , use_emission_subgrid_space ) do j = 1 , subgrid_dim ( y_dim_index ), use_subgrid_step do i = 1 , subgrid_dim ( x_dim_index ), use_subgrid_step i_cross = crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) j_cross = crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) ! Search in the neighbourhood and find the sum of the emissions i_start = max ( 1 , i_cross - use_emission_subgrid_space ) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i_cross + use_emission_subgrid_space ) j_start = max ( 1 , j_cross - use_emission_subgrid_space ) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j_cross + use_emission_subgrid_space ) sum_emission = sum ( proxy_emission_subgrid ( i_start : i_end , j_start : j_end , i_source ,:)) ! Select those with emission sums > 0 but always include the coarsest level everywhere if ( sum_emission . gt . 0. . or . k . eq . n_use_subgrid_levels ( i_source )) then use_subgrid_val ( i , j , i_source ) = 1 ! Label the grids for interpolation later i_start_k = max ( 1 , i - use_subgrid_step / 2 ) i_end_k = min ( subgrid_dim ( x_dim_index ), i + use_subgrid_step / 2 ) j_start_k = max ( 1 , j - use_subgrid_step / 2 ) j_end_k = min ( subgrid_dim ( y_dim_index ), j + use_subgrid_step / 2 ) use_subgrid_interpolation_index ( i_start_k : i_end_k , j_start_k : j_end_k , i_source ) = k end if end do end do end do use_subgrid_val (:,:, allsource_index ) = use_subgrid_val (:,:, allsource_index ) + use_subgrid_val (:,:, i_source ) ! Check do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid_interpolation_index ( i , j , i_source ) . lt . 0 ) write ( * , * ) i , j , use_subgrid_interpolation_index ( i , j , i_source ) end do end do end if end do use_subgrid_val = min ( 1 , use_subgrid_val ) ! Convert values to logical do i_source = 1 , n_source_index if ( use_emission_positions_for_auto_subgrid_flag ( i_source )) then if ( calculate_source ( i_source ) . or . i_source . eq . allsource_index ) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid_val ( i , j , i_source ) . gt . 0 ) then use_subgrid ( i , j , i_source ) = . true . else use_subgrid ( i , j , i_source ) = . false . end if end do end do end if else ! If not to be auto gridded then set use to true use_subgrid (:,:, i_source ) = . true . end if end do do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . use_emission_positions_for_auto_subgrid_flag ( i_source )) then write ( unit_logfile , '(a,2i10,f6.1)' ) 'Number of calculation subgrids for ' // trim ( source_file_str ( i_source )) // ' (number, total, percent):' , & sum ( use_subgrid_val (:,:, i_source )), subgrid_dim ( 1 ) * subgrid_dim ( 2 ), sum ( use_subgrid_val (:,:, i_source )) * 10 0.0 / ( subgrid_dim ( 1 ) * subgrid_dim ( 2 )) end if end do end subroutine uEMEP_auto_subgrid subroutine uEMEP_interpolate_auto_subgrid () ! This is the corresponding routine for interpolating the auto selected data integer :: xdim , ydim real :: delta ( 2 ) real :: xval , yval real :: xgrid ( 3 , 3 ), ygrid ( 3 , 3 ), zgrid ( 3 , 3 ) integer :: i , j , k , ii , jj integer :: i_source , i_pollutant , t integer :: i_in ( 3 ), j_in ( 3 ) integer :: use_subgrid_step write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Interpolating auto grid (uEMEP_interpolate_auto_subgrid)' write ( unit_logfile , '(A)' ) '================================================================' xdim = 3 ydim = 3 do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . i_source . ne . allsource_index . and . use_emission_positions_for_auto_subgrid_flag ( i_source )) then ! Only interpolate for chosen sources that have been auto gridded based on emissions do k = n_use_subgrid_levels ( i_source ), 1 , - 1 use_subgrid_step = use_subgrid_step_delta ( k ) delta = use_subgrid_step * subgrid_delta do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) xval = x_subgrid ( i , j ) yval = y_subgrid ( i , j ) ! Only do the interpolation if it is the right interpolation_index, it is inside the region and it is not a valid subgrid ! TODO: use a logical flag here? ! if (use_subgrid_interpolation_index(i,j,i_source).eq.k.and.use_subgrid_val(i,j,i_source).ne.outside_interpolation_region_index.and..not.use_subgrid_val(i,j,i_source)) then ! Do it everywhere in the grid if ( use_subgrid_interpolation_index ( i , j , i_source ) . eq . k . and . use_subgrid_val ( i , j , i_source ) . ne . & outside_interpolation_region_index . and . . not . use_subgrid ( i , j , i_source )) then i_in ( 2 ) = floor ( real ( i - 1 ) / use_subgrid_step + 0.5 ) * use_subgrid_step + 1 i_in ( 2 ) = min ( subgrid_dim ( x_dim_index ), max ( 1 , i_in ( 2 ))) i_in ( 1 ) = i_in ( 2 ) - use_subgrid_step i_in ( 3 ) = i_in ( 2 ) + use_subgrid_step j_in ( 2 ) = floor ( real ( j - 1 ) / use_subgrid_step + 0.5 ) * use_subgrid_step + 1 j_in ( 2 ) = min ( subgrid_dim ( y_dim_index ), max ( 1 , j_in ( 2 ))) j_in ( 1 ) = j_in ( 2 ) - use_subgrid_step j_in ( 3 ) = j_in ( 2 ) + use_subgrid_step if ( i_in ( 1 ) . lt . 1 ) i_in ( 1 ) = i_in ( 2 ) if ( j_in ( 1 ) . lt . 1 ) j_in ( 1 ) = j_in ( 2 ) if ( i_in ( 3 ) . gt . subgrid_dim ( x_dim_index )) i_in ( 3 ) = i_in ( 2 ) if ( j_in ( 3 ) . gt . subgrid_dim ( y_dim_index )) j_in ( 3 ) = j_in ( 2 ) do t = 1 , subgrid_dim ( t_dim_index ) do i_pollutant = 1 , n_pollutant_loop do jj = 1 , 3 do ii = 1 , 3 xgrid ( ii , jj ) = x_subgrid ( i_in ( 2 ), j_in ( 2 )) + ( ii - 2 ) * delta ( 1 ) ygrid ( ii , jj ) = y_subgrid ( i_in ( 2 ), j_in ( 2 )) + ( jj - 2 ) * delta ( 2 ) zgrid ( ii , jj ) = subgrid ( i_in ( ii ), j_in ( jj ), t , proxy_subgrid_index , i_source , i_pollutant ) if ( i_in ( ii ) . lt . 1 . or . i_in ( ii ) . gt . subgrid_dim ( x_dim_index ) . or . j_in ( jj ) . lt . 1 . or . j_in ( jj ) . gt . subgrid_dim ( y_dim_index )) then zgrid ( ii , jj ) = subgrid ( i_in ( 2 ), j_in ( 2 ), t , proxy_subgrid_index , i_source , i_pollutant ) else if ( use_subgrid_val ( i_in ( ii ), j_in ( jj ), i_source ). eq . outside_interpolation_region_index ) then zgrid ( ii , jj ) = subgrid ( i_in ( 2 ), j_in ( 2 ), t , proxy_subgrid_index , i_source , i_pollutant ) end if end do end do subgrid ( i , j , t , proxy_subgrid_index , i_source , i_pollutant ) = area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) ! Travel time interpolation as well do jj = 1 , 3 do ii = 1 , 3 zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( ii ), j_in ( jj ), t , 1 , i_pollutant ) if ( i_in ( ii ) . lt . 1 . or . i_in ( ii ) . gt . subgrid_dim ( x_dim_index ) . or . j_in ( jj ) . lt . 1 . or . j_in ( jj ) . gt . subgrid_dim ( y_dim_index )) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 1 , i_pollutant ) else if ( use_subgrid_val ( i_in ( ii ), j_in ( jj ), i_source ) . eq . outside_interpolation_region_index ) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 1 , i_pollutant ) end if end do end do traveltime_subgrid ( i , j , t , 1 , i_pollutant ) = area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) do jj = 1 , 3 do ii = 1 , 3 zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( ii ), j_in ( jj ), t , 2 , i_pollutant ) if ( i_in ( ii ) . lt . 1 . or . i_in ( ii ) . gt . subgrid_dim ( x_dim_index ) . or . j_in ( jj ) . lt . 1 . or . j_in ( jj ) . gt . subgrid_dim ( y_dim_index )) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 2 , i_pollutant ) else if ( use_subgrid_val ( i_in ( ii ), j_in ( jj ), i_source ) . eq . outside_interpolation_region_index ) then zgrid ( ii , jj ) = traveltime_subgrid ( i_in ( 2 ), j_in ( 2 ), t , 2 , i_pollutant ) end if end do end do traveltime_subgrid ( i , j , t , 2 , i_pollutant ) = area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) end do end do end if end do end do end do end if end do ! Reset the use_subgrid values so chemistry and exposure happens everywhere but not outside the region use_subgrid (:,:, allsource_index ) = . true . where ( use_subgrid_val (:,:, allsource_index ) . eq . outside_region_index ) use_subgrid (:,:, allsource_index ) = . false . end subroutine uEMEP_interpolate_auto_subgrid subroutine uEMEP_region_mask () ! This routine defines use_subgrid_val=2 for regions outside the selected region. This can be used to control the interpolation routine ! It also sets use_subgrid=.false. outside the region so that no calculations are made there either character ( 256 ) :: temp_name , temp_str , temp_str1 integer , allocatable :: tile_municipality_subgrid (:,:,:) integer :: municipality_id real :: x_ssb , f_easting , ssb_dx , y_ssb , ssb_dy integer :: count integer ( kind = 8 ) :: ssb_id integer :: i , j , k , i_range , j_range , i_range_interp , j_range_interp , i_tile , j_tile logical :: exists integer :: unit_in integer :: index_val integer :: i_source character ( 256 ) :: region_number_str integer , parameter :: n_search = 5 character ( 16 ) :: search_str ( n_search ) real :: search_delta ( n_search ) integer :: temp_search integer :: io search_str = [ '_1000m' , '_500m ' , '_250m ' , '_100m ' , '_50m  ' ] search_delta = [ 100 0.0 , 50 0.0 , 25 0.0 , 10 0.0 , 5 0.0 ] write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Masking region (uEMEP_region_mask)' write ( unit_logfile , '(A)' ) '================================================================' if ( . not . allocated ( tile_municipality_subgrid )) allocate ( tile_municipality_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) tile_municipality_subgrid = 0 i_source = allsource_index ! Search file name to define the grid size ssb_dx = 0.0 ; ssb_dy = 0.0 do k = 1 , n_search temp_search = index ( filename_population ( municipality_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality data with resolution ' // trim ( adjustl ( search_str ( k ))) end if end do if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( municipality_index )) stop 1 end if region_number_str = '' write ( region_number_str , * ) region_index region_number_str = trim ( region_number_str ) // '_' ! Read in SSB file containing gridded municipality ids f_easting = 2.0e6 pathfilename_population ( municipality_index ) = trim ( pathname_population ( municipality_index )) // trim ( adjustl ( region_number_str )) // trim ( filename_population ( municipality_index )) ! Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( municipality_index )), exist = exists ) if ( . not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Masking region SSB file with municipality IDs does not exist: ' , trim ( pathfilename_population ( municipality_index )) stop 1 end if temp_name = pathfilename_population ( municipality_index ) ! Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB municipality file ' // trim ( temp_name ) rewind ( unit_in ) ! Read header SSBID0250M;kommunenum read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 i_range = ceiling ( ssb_dx / subgrid_delta ( x_dim_index ) / 2.0 ) + 1 j_range = ceiling ( ssb_dy / subgrid_delta ( y_dim_index ) / 2.0 ) + 1 i_range_interp = ceiling ( ssb_dx / subgrid_delta ( x_dim_index ) / 2.0 + max_interpolation_subgrid_size / subgrid_delta ( x_dim_index )) + 1 j_range_interp = ceiling ( ssb_dy / subgrid_delta ( y_dim_index ) / 2.0 + max_interpolation_subgrid_size / subgrid_delta ( y_dim_index )) + 1 do ssb_id = 0 ; municipality_id = 0 ! Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit index_val = index ( temp_str , ';' , back = . false .) temp_str1 = temp_str ( 1 : index_val - 1 ) temp_str = temp_str ( index_val + 1 :) if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id read ( temp_str , * ) municipality_id ! If this ssb municipality grid has the correct ID then find the target grid that matches it if ( municipality_id . eq . region_id ) then count = count + 1 !Convert id to grid centre coordinates that are already in UTM33 for SSB data x_ssb = floor ( ssb_id / 1000000 0.0 ) - f_easting + ssb_dx / 2.0 y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2.0 ! Find the tile this ssb grid is in i_tile = 1 + floor (( x_ssb - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) ! New definition j_tile = 1 + floor (( y_ssb - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) !New definition do j = j_tile - j_range , j_tile + j_range do i = i_tile - i_range , i_tile + i_range ! Make sure i and j are inside a valid range if ( i . ge . 1 . and . i . le . subgrid_dim ( x_dim_index ) . and . j . ge . 1 . and . j . le . subgrid_dim ( y_dim_index )) then ! Find the target subgrid within the ssb grid and the region if ( x_subgrid ( i , j ) . ge . x_ssb - ssb_dx / 2.0 . and . x_subgrid ( i , j ) . lt . x_ssb + ssb_dx / 2.0 . and . & y_subgrid ( i , j ) . ge . y_ssb - ssb_dy / 2.0 . and . y_subgrid ( i , j ) . lt . y_ssb + ssb_dy / 2.0 ) then !If there is a target subgrid within this range then allocate the mask value if it is not the correct region_id tile_municipality_subgrid ( i , j , 1 ) = 1 end if end if end do end do do j = j_tile - j_range_interp , j_tile + j_range_interp do i = i_tile - i_range_interp , i_tile + i_range_interp ! Make sure i and j are inside a valid range if ( i . ge . 1 . and . i . le . subgrid_dim ( x_dim_index ) . and . j . ge . 1 . and . j . le . subgrid_dim ( y_dim_index )) then ! Find the target subgrid within the ssb grid and the region if ( x_subgrid ( i , j ) . ge . x_ssb - ssb_dx / 2.0 - max_interpolation_subgrid_size . and . x_subgrid ( i , j ) . le . x_ssb + ssb_dx / 2.0 + max_interpolation_subgrid_size . and . & y_subgrid ( i , j ) . ge . y_ssb - ssb_dy / 2.0 - max_interpolation_subgrid_size . and . y_subgrid ( i , j ) . le . y_ssb + ssb_dy / 2.0 + max_interpolation_subgrid_size ) then ! If there is a target subgrid within this range then allocate the mask value if it is not the correct region_id tile_municipality_subgrid ( i , j , 2 ) = 1 end if end if end do end do end if end do close ( unit_in ) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i , j , 2 ) . eq . 0 ) then use_subgrid_val ( i , j ,:) = outside_interpolation_region_index use_subgrid ( i , j ,:) = . false . end if if ( tile_municipality_subgrid ( i , j , 1 ) . eq . 0 ) then use_subgrid_val ( i , j ,:) = outside_region_index end if end do end do if ( allocated ( tile_municipality_subgrid )) deallocate ( tile_municipality_subgrid ) end subroutine uEMEP_region_mask subroutine uEMEP_region_mask_new () ! Variables used for reading the region mask netcdf file ! help-parameters for reading the file character ( 256 ) pathfilename_region_mask logical exists integer status_nc integer id_nc , var_id_nc , x_dim_id_nc , y_dim_id_nc integer temp_num_dims ! projection of the region mask integer region_mask_projection_type double precision region_mask_projection_attributes ( 10 ) ! the x and y coordinates real , allocatable :: x_values_regionmask (:) real , allocatable :: y_values_regionmask (:) ! the region ID data themselves integer , allocatable :: region_mask (:, :) ! assumed names for dimensions of the region mask file character ( 256 ) x_dim_name_regionmask , y_dim_name_regionmask , dimname_temp ! length of dimensions of the region mask integer nx_regionmask , ny_regionmask ! grid spacing of the region mask (to be verified is constant!) real dx_regionmask , dy_regionmask ! subset needed to read from the region mask file real x_min , x_max , y_min , y_max integer x_min_index , x_max_index , y_min_index , y_max_index ! grid dimension looping indices integer i , j , ii , jj , i_sub , j_sub , i_source ! variables used for defining the extended EMEP grid integer max_lf_distance integer ii_nc , jj_nc ! Variables used when applying the region mask to the EMEP and uEMEP grids ! x and y value of current location in the region mask projection real x_location , y_location ! index of closest grid-cell in the region mask to the current location integer x_index , y_index ! grid resolution in EMEP real dx_emep , dy_emep ! x and y value of midpoint of an EMEP grid and of subsamples of the EMEP grid real x_emepmid , y_emepmid real x_emepsub , y_emepsub ! corresponding lon and lat real lon_emepsub , lat_emepsub ! current location in emission subgrid (x and y in uEMEP projection, longitude and latitude) real x_emis , y_emis , lon_emis , lat_emis ! Additional variables used for creating list of regions, calculating fraction of EMEP cells in each region and setting the use_subgrid array integer i_region integer , allocatable :: temp_regionindex_loop_index (:) integer counter integer current_region_index , previous_region_index , region_select logical outofbounds_warning_has_been_printed if (. not . ( trace_emissions_from_in_region . or . use_region_select_and_mask_flag )) then return end if write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Creating region mask arrays (uEMEP_region_mask_new)' write ( unit_logfile , '(A)' ) '================================================================' ! Ensure arrays are not already allocated if ( allocated ( subgrid_region_index )) then deallocate ( subgrid_region_index ) end if if ( allocated ( regionindex_loop_index )) then deallocate ( regionindex_loop_index ) end if if ( allocated ( emission_subgrid_region_index )) then deallocate ( emission_subgrid_region_index ) end if if ( allocated ( EMEP_extended_subsample_region_id )) then deallocate ( EMEP_extended_subsample_region_id ) end if if ( allocated ( regionfraction_per_EMEP_extended_grid )) then deallocate ( regionfraction_per_EMEP_extended_grid ) end if ! Read the region mask netcdf file (implementation based on uEMEP_read_EMEP) ! determine full filename pathfilename_region_mask = trim ( pathname_region_mask ) // trim ( filename_region_mask ) !Test existence of the region mask file. If does not exist then stop inquire ( file = trim ( pathfilename_region_mask ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_region_mask ) write ( unit_logfile , '(A)' ) '  STOPPING' stop end if !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_region_mask ) status_nc = NF90_OPEN ( pathfilename_region_mask , nf90_nowrite , id_nc ) if ( status_nc /= NF90_NOERR ) write ( unit_logfile , '(A,I0)' ) 'ERROR opening netcdf file: ' , status_nc ! Initialize projection type to longitude-latitude region_mask_projection_type = LL_projection_index ! Check if it is a UTM projection status_nc = NF90_INQ_VARID ( id_nc , 'projection_utm' , var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_central_meridian' , region_mask_projection_attributes ( 2 )) ! calculate the UTM zone region_mask_projection_attributes ( 1 ) = ( region_mask_projection_attributes ( 2 ) + 180 + 3 ) / 6 ! verify this is an exact UTM zone if ( abs ( region_mask_projection_attributes ( 1 ) - floor ( region_mask_projection_attributes ( 1 ) + 0.1 )) > 1e-6 ) then write ( unit_logfile , '(3A,f,A)' ) ' ERROR during reading of attributes for \"projection_utm\" in file ' , trim ( pathfilename_region_mask ), ': \"longitude_of_central_meridian\" = ' , region_mask_projection_attributes ( 2 ), ', which does not correspond to a UTM zone.' ! IS THIS STRING FORMATTED CORRECTLY? stop end if region_mask_projection_type = UTM_projection_index x_dim_name_regionmask = 'x' y_dim_name_regionmask = 'y' write ( unit_logfile , '(A,f3.0)' ) 'Region mask file has projection UTM zone ' , region_mask_projection_attributes ( 1 ) end if if ( region_mask_projection_type == LL_projection_index ) then x_dim_name_regionmask = 'lon' y_dim_name_regionmask = 'lat' write ( unit_logfile , '(A)' ) 'Assuming region mask file is in lon-lat, since it is variable projection_utm was not found. Other projections than UTM are not implemented' end if !Read dimensions of the file (x,y) ! x status_nc = NF90_INQ_DIMID ( id_nc , x_dim_name_regionmask , x_dim_id_nc ) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , x_dim_id_nc , dimname_temp , nx_regionmask ) if ( status_nc /= NF90_NOERR ) then write ( unit_logfile , '(A,I0)' ) 'ERROR: Reading of x dimension failed with status: ' , status_nc stop end if ! y status_nc = NF90_INQ_DIMID ( id_nc , y_dim_name_regionmask , y_dim_id_nc ) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , y_dim_id_nc , dimname_temp , ny_regionmask ) if ( status_nc /= NF90_NOERR ) then write ( unit_logfile , '(A,I0)' ) 'Reading of y dimension failed with status: ' , status_nc stop end if write ( unit_logfile , '(A,I0,A,I0)' ) ' Dimensions of full region mask (x,y): ' , nx_regionmask , ' ' , ny_regionmask ! Verify the dimensions are at least 2x2 if (. not . ( nx_regionmask > 1 . and . ny_regionmask > 1 )) then write ( unit_logfile , '(A)' ) 'ERROR: Dimensions of regionmask are not at least 2x2' stop end if ! Allocate memory for the full coordinates of the region mask allocate ( x_values_regionmask ( nx_regionmask )) allocate ( y_values_regionmask ( ny_regionmask )) ! NB: should I set these arrays to 0 before they are read from file? ! Read coordinate values ! x status_nc = NF90_INQ_VARID ( id_nc , trim ( x_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , x_values_regionmask ) else write ( unit_logfile , '(A)' ) 'Error while reading x values from region mask' stop end if ! y status_nc = NF90_INQ_VARID ( id_nc , trim ( y_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , y_values_regionmask ) else write ( unit_logfile , '(A)' ) 'Error while reading y values from region mask' stop end if ! Determine grid spacing and verify it is constant dx_regionmask = x_values_regionmask ( 2 ) - x_values_regionmask ( 1 ) do i = 2 , nx_regionmask if (. not . ( x_values_regionmask ( i ) - x_values_regionmask ( i - 1 ) == dx_regionmask )) then write ( unit_logfile , '(A)' ) 'Not constant spacing in x coordinate in region mask' stop end if end do dy_regionmask = y_values_regionmask ( 2 ) - y_values_regionmask ( 1 ) do i = 2 , ny_regionmask if (. not . ( y_values_regionmask ( i ) - y_values_regionmask ( i - 1 ) == dy_regionmask )) then write ( unit_logfile , '(A)' ) 'Not constant spacing in y coordinate in region mask' stop end if end do ! Determine required subset of region mask to read (in the projection coordinates of the target grid) write ( unit_logfile , '(A)' ) 'Determining the subset of the region mask needed' ! First initialize both min and max value to the first value in the target subgrid write ( unit_logfile , '(A)' ) 'Checking target subgrid' call LL2PROJ ( lon_subgrid ( 1 , 1 ), lat_subgrid ( 1 , 1 ), x_min , y_min , region_mask_projection_attributes , region_mask_projection_type ) x_max = x_min y_max = y_min ! Go through the target grid cells to update the range of x and y values do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) call LL2PROJ ( lon_subgrid ( i , j ), lat_subgrid ( i , j ), x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) x_min = min ( x_min , x_location ) x_max = max ( x_max , x_location ) y_min = min ( y_min , y_location ) y_max = max ( y_max , y_location ) end do end do ! If tracing in-region contributions, go through all cells to be traced from and update required range of x and y values if ( trace_emissions_from_in_region ) then ! Emission subgrid write ( unit_logfile , '(A)' ) 'Checking emission subgrids' do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) ! get location in uEMEP projection of this emission subgrid x_emis = x_emission_subgrid ( i , j , i_source ) y_emis = y_emission_subgrid ( i , j , i_source ) ! transform to the region mask projection call PROJ2LL ( x_emis , y_emis , lon_emis , lat_emis , projection_attributes , projection_type ) call LL2PROJ ( lon_emis , lat_emis , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! update min and max x_min = min ( x_min , x_location ) x_max = max ( x_max , x_location ) y_min = min ( y_min , y_location ) y_max = max ( y_max , y_location ) end do end do end if end do ! Extended EMEP grid for region masking of the EMEP LF data write ( unit_logfile , '(A)' ) 'Checking extended EMEP grid' ! Determine how large the extended EMEP grid must be ! We assume the reduced EMEP grid is just big enough to cover the 'normal' LF contributions to the target grid if ( EMEP_additional_grid_interpolation_size > 0.0 ) then ! We want to calculate additional. So we need to increase the grid to ensure it covers additial contributions to the target grid ! First, calculate the max nr of LF cells that the source can be away from edge of target grid max_lf_distance = 1 + int ( max ( dim_length_nc ( xdist_dim_nc_index ), dim_length_nc ( ydist_dim_nc_index )) / 2 ) ! - assuming reduced EMEP grid already covers the small local fraction domain, this is the number of EMEP grid-cells we need to add to all sides in the extended grid ngrid_extended_margin = ( local_fraction_grid_size ( 2 ) - local_fraction_grid_size ( 1 )) * max_lf_distance write ( unit_logfile , '(A,2I6)' ) '  reduced EMEP grid dimensions: nx,ny =' , dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2I6)' ) \"  max_lf_distance, ngrid_extended_margin =\" , max_lf_distance , ngrid_extended_margin ! Size of extended EMEP grid nx_EMEP_extended = dim_length_nc ( x_dim_nc_index ) + 2 * ngrid_extended_margin ny_EMEP_extended = dim_length_nc ( y_dim_nc_index ) + 2 * ngrid_extended_margin write ( unit_logfile , '(A,2I6)' ) '  -> extended EMEP grid dimensions: nx,ny =' , nx_EMEP_extended , ny_EMEP_extended else ! We don't calculate additional. Then the extended EMEP grid can be the same size as the reduced EMEP grid ngrid_extended_margin = 0 nx_EMEP_extended = dim_length_nc ( x_dim_nc_index ) ny_EMEP_extended = dim_length_nc ( y_dim_nc_index ) end if ! Determine spacing in EMEP grid (NB: maybe this is alredy available somewhere?) ! NB: I will not verify it is constant, but I will assume it is dx_emep = var1d_nc ( 2 , x_dim_nc_index ) - var1d_nc ( 1 , x_dim_nc_index ) dy_emep = var1d_nc ( 2 , y_dim_nc_index ) - var1d_nc ( 1 , y_dim_nc_index ) ! loop over the extended EMEP grid to update range of x and y values we need from region mask do ii = 1 , nx_EMEP_extended do jj = 1 , ny_EMEP_extended ! calculate the corresponding index in the normal EMEP grid ii_nc = ii - ngrid_extended_margin jj_nc = jj - ngrid_extended_margin ! -> deduce EMEP projection coordinate values at centre of this EMEP grid x_emepmid = var1d_nc ( 1 , x_dim_nc_index ) + dx_emep * ( ii_nc - 1 ) y_emepmid = var1d_nc ( 1 , y_dim_nc_index ) + dy_emep * ( jj_nc - 1 ) ! go through all subsamples of this EMEP grid do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid ! EMEP projection coordinate value at this subsample of the EMEP grid x_emepsub = x_emepmid - dx_emep / 2 + ( i_sub - 0.5 ) * dx_emep / n_subsamples_per_EMEP_grid y_emepsub = y_emepmid - dy_emep / 2 + ( j_sub - 0.5 ) * dy_emep / n_subsamples_per_EMEP_grid ! calculate longitude and latitude from the EMEP projection call PROJ2LL ( x_emepsub , y_emepsub , lon_emepsub , lat_emepsub , EMEP_projection_attributes , EMEP_projection_type ) ! calculate projection coordinates in the region mask grid call LL2PROJ ( lon_emepsub , lat_emepsub , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! update min and max x_min = min ( x_min , x_location ) x_max = max ( x_max , x_location ) y_min = min ( y_min , y_location ) y_max = max ( y_max , y_location ) end do end do end do end do end if ! Determine the subset of the region mask we need to read based on the range of x and y to use it for x_min_index = nint (( x_min - x_values_regionmask ( 1 )) / dx_regionmask ) x_max_index = nint ( 1 + ( x_max - x_values_regionmask ( 1 )) / dx_regionmask ) y_min_index = nint (( y_min - y_values_regionmask ( 1 )) / dy_regionmask ) y_max_index = nint ( 1 + ( y_max - y_values_regionmask ( 1 )) / dy_regionmask ) ! ensure we don't go outside the boundaries of the region mask x_min_index = max ( x_min_index , 1 ) x_max_index = min ( x_max_index , nx_regionmask ) y_min_index = max ( y_min_index , 1 ) y_max_index = min ( y_max_index , ny_regionmask ) ! Update region mask dimensions based on this subset nx_regionmask = x_max_index - x_min_index + 1 ny_regionmask = y_max_index - y_min_index + 1 write ( unit_logfile , '(A)' ) 'Required subset of region mask (in region mask projection):' write ( unit_logfile , '(A,2e12.4,2i7)' ) '  x_min, x_max, x_min_index, x_max_index =' , x_min , x_max , x_min_index , x_max_index write ( unit_logfile , '(A,2e12.4,2i7)' ) '  y_min, y_max, y_min_index, x_max_index =' , y_min , y_max , y_min_index , y_max_index write ( unit_logfile , '(A,2i7)' ) '-> Dimensions of subset of region mask to be read (x,y):' , nx_regionmask , ny_regionmask ! Read region mask coordinates again, selecting only the required subset deallocate ( x_values_regionmask ) deallocate ( y_values_regionmask ) allocate ( x_values_regionmask ( nx_regionmask )) allocate ( y_values_regionmask ( ny_regionmask )) ! x status_nc = NF90_INQ_VARID ( id_nc , trim ( x_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , x_values_regionmask , start = ( / x_min_index / ), count = ( / nx_regionmask / )) else write ( unit_logfile , '(A)' ) 'Error while reading x values from region mask' stop end if ! y status_nc = NF90_INQ_VARID ( id_nc , trim ( y_dim_name_regionmask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_GET_VAR ( id_nc , var_id_nc , y_values_regionmask , start = ( / y_min_index / ), count = ( / ny_regionmask / )) else write ( unit_logfile , '(A)' ) 'Error while reading y values from region mask' stop end if ! Read the mask itself allocate ( region_mask ( nx_regionmask , ny_regionmask )) status_nc = NF90_INQ_VARID ( id_nc , trim ( varname_region_mask ), var_id_nc ) if ( status_nc == NF90_NOERR ) then status_nc = NF90_INQUIRE_VARIABLE ( id_nc , var_id_nc , ndims = temp_num_dims ) ! NB: the following line fails if the region_mask subset is bigger than ca. 1 million elements when runnning interactively, but not as a qsub job (fix by increasing 'ulimit -s', e.g. 'ulimit -s unlimited') status_nc = NF90_GET_VAR ( id_nc , var_id_nc , region_mask , start = ( / x_min_index , y_min_index / ), count = ( / nx_regionmask , ny_regionmask / )) write ( unit_logfile , '(A,i3,A,2A,2i16)' ) ' Reading: ' , temp_num_dims , ' ' , trim ( varname_region_mask ), ' (min, max): ' , minval ( region_mask ), maxval ( region_mask ) else write ( unit_logfile , '(A)' ) 'Could not read region mask values from file' stop end if ! verify that no region index values in the file are negative or higher than the max allowed value if ( minval ( region_mask ) < 0 ) then write ( unit_logfile , '(A)' ) 'Found negative values of region index in file' // trim ( pathfilename_region_mask ) // '. This is not allowed' stop end if if ( maxval ( region_mask ) > maxvalue_region_index ) then write ( unit_logfile , '(A,i0,A,i0)' ) 'Max value of region index in file ' // trim ( pathfilename_region_mask ) // ' is' , maxval ( region_mask ), ', which is higher than the max allowed value: maxvalue_region_index=' , maxvalue_region_index stop end if ! Close the region mask netcdf file status_nc = NF90_CLOSE ( id_nc ) write ( unit_logfile , '(A)' ) 'Done reading region mask.' ! Determine region ID of each cell of the uEMEP target subgrid write ( unit_logfile , '(A)' ) 'Calculating region mask for the target grid' ! Allocate array for region mask on uEMEP target subgrid and initialize to 0 (no region) allocate ( subgrid_region_index ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) subgrid_region_index = 0 ! Set region ID of each target subgrid outofbounds_warning_has_been_printed = . false . do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) ! calculate x- and y- position in the region mask projection call LL2PROJ ( lon_subgrid ( i , j ), lat_subgrid ( i , j ), x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! Determine index in the region mask grid for this location x_index = nint ( 1 + ( x_location - x_values_regionmask ( 1 )) / dx_regionmask ) y_index = nint ( 1 + ( y_location - y_values_regionmask ( 1 )) / dy_regionmask ) ! Verify that this index is inside the region mask grid and has a positive region ID if ( x_index >= 1 . and . x_index <= nx_regionmask . and . y_index >= 1 . and . y_index <= ny_regionmask ) then subgrid_region_index ( i , j ) = region_mask ( x_index , y_index ) else ! this receptor location is not within the region mask grid if (. not . outofbounds_warning_has_been_printed ) then write ( unit_logfile , '(A)' ) 'WARNING: The target subgrid extends outside the given region mask.' outofbounds_warning_has_been_printed = . true . end if end if !write(unit_logfile,'(A,2i12,2f12.4,2f12.2,2i12,i4)') 'i,j,lon_subgrid(i,j),lat_subgrid(i,j),x_location,y_location,x_index,y_index,region_index = ',i,j,lon_subgrid(i,j),lat_subgrid(i,j),x_location,y_location,x_index,y_index,subgrid_region_index(i,j) end do end do write ( unit_logfile , '(A)' ) 'Finding the regions occurring in the target grid' ! Determine which regions occur in the target grid ! (NB: We don't care about regions occurring only in the EMEP grid but not in the target grid!) allocate ( temp_regionindex_loop_index ( maxvalue_region_index )) temp_regionindex_loop_index = 0 regionindex_loop_back_index = 0 counter = 0 previous_region_index = - 1 do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) current_region_index = subgrid_region_index ( i , j ) if ( current_region_index > 0 . and . . not . current_region_index == previous_region_index ) then ! Region index is different from previous subgrid ! check if we have not already found it before if ( regionindex_loop_back_index ( current_region_index ) == 0 ) then ! new region ID found counter = counter + 1 temp_regionindex_loop_index ( counter ) = current_region_index regionindex_loop_back_index ( current_region_index ) = counter end if previous_region_index = current_region_index end if end do end do n_regions = counter allocate ( regionindex_loop_index ( n_regions )) regionindex_loop_index = temp_regionindex_loop_index ( 1 : n_regions ) deallocate ( temp_regionindex_loop_index ) write ( unit_logfile , '(A,I0)' ) 'Number of regions within target grid: ' , n_regions write ( unit_logfile , '(A,100I5)' ) 'index of these regions are (printing max 100): ' , regionindex_loop_index ! Determine which subgrid cells are inside the selected region ! and use this to set use_subgrid if ( use_region_select_and_mask_flag ) then ! Set 'use_subgrid' ! NB: This will override previously set values for this array use_subgrid = . false . region_select = region_index write ( unit_logfile , '(A,I0)' ) 'Setting \"use_subgrid\" based on where in the target grid the region index is' , region_select do i = 1 , subgrid_dim ( x_dim_index ) do j = 1 , subgrid_dim ( y_dim_index ) if ( subgrid_region_index ( i , j ) == region_select ) then use_subgrid ( i , j ,:) = . true . else use_subgrid ( i , j ,:) = . false . end if end do end do end if if ( trace_emissions_from_in_region ) then ! Set region ID of the emission subgrids write ( unit_logfile , '(A)' ) 'Setting region ID of the emission subgrids' ! initialize to -1 (\"no-region\") allocate ( emission_subgrid_region_index ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) emission_subgrid_region_index = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) ! get location in uEMEP projection of this emission subgrid x_emis = x_emission_subgrid ( i , j , i_source ) y_emis = y_emission_subgrid ( i , j , i_source ) ! transform to the region mask projection call PROJ2LL ( x_emis , y_emis , lon_emis , lat_emis , projection_attributes , projection_type ) call LL2PROJ ( lon_emis , lat_emis , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! find nearest grid-cell in the region mask array to get the region ID of this emission subgrid x_index = nint ( 1 + ( x_location - x_values_regionmask ( 1 )) / dx_regionmask ) y_index = nint ( 1 + ( y_location - y_values_regionmask ( 1 )) / dy_regionmask ) ! Check if this location is inside the region mask grid if ( x_index >= 1 . and . x_index <= nx_regionmask . and . y_index >= 1 . and . y_index <= ny_regionmask ) then emission_subgrid_region_index ( i , j , i_source ) = region_mask ( x_index , y_index ) end if ! NB: contrary to the target grid, we will allow non-positive region ID in the emission subgrid, indicating \"no-region\", and we will also allow that the emision subgrid extends beyond the boundaries of the region mask file end do end do end if end do ! Set region ID of each subsample of the extended EMEP grid write ( unit_logfile , '(A)' ) 'Calculating region mask for subsamples of the (extended) EMEP grid' ! Allocate array for region subsamples and initialize to -1 (no region) allocate ( EMEP_extended_subsample_region_id ( n_subsamples_per_EMEP_grid , n_subsamples_per_EMEP_grid , nx_EMEP_extended , ny_EMEP_extended )) EMEP_extended_subsample_region_id = - 1 ! loop over the extended EMEP grid and fill subsample region ID do ii = 1 , nx_EMEP_extended do jj = 1 , ny_EMEP_extended ! calculate the corresponding index in the normal EMEP grid ii_nc = ii - ngrid_extended_margin jj_nc = jj - ngrid_extended_margin ! -> deduce EMEP projection coordinate values at centre of this EMEP grid x_emepmid = var1d_nc ( 1 , x_dim_nc_index ) + dx_emep * ( ii_nc - 1 ) y_emepmid = var1d_nc ( 1 , y_dim_nc_index ) + dy_emep * ( jj_nc - 1 ) ! go through all subsamples of this EMEP grid do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid ! EMEP projection coordinate value at this subsample of the EMEP grid x_emepsub = x_emepmid - dx_emep / 2 + ( i_sub - 0.5 ) * dx_emep / n_subsamples_per_EMEP_grid y_emepsub = y_emepmid - dy_emep / 2 + ( j_sub - 0.5 ) * dy_emep / n_subsamples_per_EMEP_grid ! calculate longitude and latitude from the EMEP projection call PROJ2LL ( x_emepsub , y_emepsub , lon_emepsub , lat_emepsub , EMEP_projection_attributes , EMEP_projection_type ) ! calculate projection coordinates in the region mask grid call LL2PROJ ( lon_emepsub , lat_emepsub , x_location , y_location , region_mask_projection_attributes , region_mask_projection_type ) ! Determine index in the region mask grid for this location x_index = nint ( 1 + ( x_location - x_values_regionmask ( 1 )) / dx_regionmask ) y_index = nint ( 1 + ( y_location - y_values_regionmask ( 1 )) / dy_regionmask ) ! If this location is inside the region mask grid, then set the region ID if ( x_index >= 1 . and . x_index <= nx_regionmask . and . y_index >= 1 . and . y_index <= ny_regionmask ) then EMEP_extended_subsample_region_id ( i_sub , j_sub , ii , jj ) = region_mask ( x_index , y_index ) end if ! NB: if it is outside the region mask grid, the 'no-region' value -1 is kept end do end do end do end do write ( unit_logfile , '(A)' ) 'Calculating fraction of each cell in the (extended) EMEP grid that is in each region' ! Calculate the fraction of each EMEP grid (in the extended grid) that is within each region, by counting the subsamples allocate ( regionfraction_per_EMEP_extended_grid ( nx_EMEP_extended , ny_EMEP_extended , n_regions )) do ii = 1 , nx_EMEP_extended do jj = 1 , ny_EMEP_extended do i_region = 1 , n_regions current_region_index = regionindex_loop_index ( i_region ) counter = 0 do i_sub = 1 , n_subsamples_per_EMEP_grid do j_sub = 1 , n_subsamples_per_EMEP_grid if ( EMEP_extended_subsample_region_id ( i_sub , j_sub , ii , jj ) == current_region_index ) then counter = counter + 1 end if end do end do regionfraction_per_EMEP_extended_grid ( ii , jj , i_region ) = counter * 1.0 / n_subsamples_per_EMEP_grid ** 2 end do end do end do end if !(trace_emissions_from_in_region) ! Deallocate the region mask deallocate ( region_mask ) deallocate ( x_values_regionmask ) deallocate ( y_values_regionmask ) end subroutine uEMEP_region_mask_new end module auto_subgrid","tags":"","loc":"sourcefile/uemep_auto_subgrid.f90.html"},{"title":"uEMEP_local_trajectory.f90 – uEMEP","text":"Source Code module local_trajectory use uemep_constants , only : NODATA_value use utility_functions , only : distrl_sqr implicit none private public :: uEMEP_calculate_all_trajectory , uEMEP_minimum_distance_trajectory_fast contains !uEMEP_local_trajectory !subroutine uEMEP_local_trajectory(i_rec,j_rec,i_emis,j_emis,t,traj_max_index,dr_traj,i_source,x_loc,y_loc,valid_traj) subroutine uEMEP_local_trajectory ( x_r , y_r , x_emis , y_emis , t , traj_max_index , dr_traj , x_loc , y_loc , valid_traj ) use uEMEP_definitions implicit none integer k real x_loc , y_loc !integer i_rec,j_rec,i_emis,j_emis integer t , traj_max_index !integer i_source real dr_traj real x_r , y_r , x_emis , y_emis real x_traj ( traj_max_index ), y_traj ( traj_max_index ) real distance_traj ( traj_max_index ), distance_intercept_traj ( traj_max_index ) real x_intercept_traj ( traj_max_index ), y_intercept_traj ( traj_max_index ), frac_length_traj ( traj_max_index ) logical exit_traj , valid_traj integer i_integral , j_integral !real x_r,y_r k = 1 !Set the initial trajectory position to the emission source !x_traj(k)=x_emission_subgrid(i_emis,j_emis,i_source) !y_traj(k)=y_emission_subgrid(i_emis,j_emis,i_source) x_traj ( k ) = x_emis y_traj ( k ) = y_emis !Set the position of the receptor !x_r=x_subgrid(i_rec,j_rec) !y_r=y_subgrid(i_rec,j_rec) !Set the distances for the initial emission grid !distance_traj(k)=sqrt((x_traj(k)-x_r)*(x_traj(k)-x_r)+(y_traj(k)-y_r)*(y_traj(k)-y_r)) !distance_intercept_traj(k)=distance_traj(k) distance_traj ( k ) = ( x_traj ( k ) - x_r ) * ( x_traj ( k ) - x_r ) + ( y_traj ( k ) - y_r ) * ( y_traj ( k ) - y_r ) distance_intercept_traj ( k ) = distance_traj ( k ) * distance_traj ( k ) y_loc = 0. x_loc = 0. exit_traj = . false . valid_traj = . false . do while (. not . exit_traj . and . k . lt . traj_max_index ) !Find what meteorological grid the trajectory point is in !i_integral=1+floor((x_traj(k)-integral_subgrid_min(x_dim_index))/(integral_subgrid_max(x_dim_index)-integral_subgrid_min(x_dim_index))*integral_subgrid_dim(x_dim_index)) !j_integral=1+floor((y_traj(k)-integral_subgrid_min(y_dim_index))/(integral_subgrid_max(y_dim_index)-integral_subgrid_min(y_dim_index))*integral_subgrid_dim(y_dim_index)) i_integral = 1 + floor (( x_traj ( k ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) j_integral = 1 + floor (( y_traj ( k ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) !Test to see if it is still in the grid if ( i_integral . ge . 1. and . i_integral . le . integral_subgrid_dim ( x_dim_index ). and . j_integral . ge . 1. and . j_integral . le . integral_subgrid_dim ( y_dim_index )) then !Account for at grid value if ( distance_traj ( k ). eq . 0 ) then exit_traj = . true . y_loc = 0. x_loc = 0. valid_traj = . true . endif k = k + 1 x_traj ( k ) = x_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , cos_subgrid_index ) y_traj ( k ) = y_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , sin_subgrid_index ) !distance_traj(k)=sqrt((x_traj(k)-x_r)*(x_traj(k)-x_r)+(y_traj(k)-y_r)*(y_traj(k)-y_r)) distance_traj ( k ) = ( x_traj ( k ) - x_r ) * ( x_traj ( k ) - x_r ) + ( y_traj ( k ) - y_r ) * ( y_traj ( k ) - y_r ) call distrl_sqr ( x_r , y_r , x_traj ( k - 1 ), y_traj ( k - 1 ), x_traj ( k ), y_traj ( k ), x_intercept_traj ( k ), y_intercept_traj ( k ), distance_intercept_traj ( k ), frac_length_traj ( k )) if ( distance_intercept_traj ( k ). lt . distance_traj ( k ). and . distance_intercept_traj ( k ). le . distance_traj ( k - 1 )) then exit_traj = . true . y_loc = distance_intercept_traj ( k ) x_loc = dr_traj * ( k - 2 ) + frac_length_traj ( k ) * dr_traj valid_traj = . true . !elseif (distance_intercept_traj(k).gt.distance_intercept_traj(k-1)) then !    valid_traj=.false. !    exit_traj=.true. !    k=k-1 endif else exit_traj = . true . valid_traj = . false . endif enddo y_loc = sqrt ( y_loc ) end subroutine uEMEP_local_trajectory subroutine uEMEP_calculate_all_trajectory ( x_emis , y_emis , t , traj_max_index , dr_traj , x_traj , y_traj ) use uEMEP_definitions implicit none integer k !integer i_rec,j_rec,i_emis,j_emis integer t , traj_max_index !integer i_source real dr_traj real x_emis , y_emis real x_traj ( traj_max_index ), y_traj ( traj_max_index ) integer i_integral , j_integral logical exit_traj k = 1 !Set the initial trajectory position to the emission source x_traj ( k ) = x_emis y_traj ( k ) = y_emis exit_traj = . false . do while (. not . exit_traj . and . k . lt . traj_max_index ) !Find what meteorological grid the trajectory point is in i_integral = 1 + floor (( x_traj ( k ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) j_integral = 1 + floor (( y_traj ( k ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) !Test to see if it is still in the grid if ( i_integral . ge . 1. and . i_integral . le . integral_subgrid_dim ( x_dim_index ). and . j_integral . ge . 1. and . j_integral . le . integral_subgrid_dim ( y_dim_index )) then k = k + 1 x_traj ( k ) = x_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , cos_subgrid_index ) y_traj ( k ) = y_traj ( k - 1 ) + dr_traj * meteo_subgrid ( i_integral , j_integral , t , sin_subgrid_index ) else exit_traj = . true . endif enddo end subroutine uEMEP_calculate_all_trajectory subroutine uEMEP_minimum_distance_trajectory_fast ( x_r , y_r , traj_max_index_in , dr_traj , x_traj , y_traj , x_loc , y_loc , valid_traj ) use uEMEP_definitions implicit none real , intent ( out ) :: x_loc , y_loc logical , intent ( out ) :: valid_traj real , intent ( in ) :: dr_traj real , intent ( in ) :: x_r , y_r integer , intent ( in ) :: traj_max_index_in !real, intent(in) ::  x_traj(traj_max_index_in),y_traj(traj_max_index_in) real , intent ( in ) :: x_traj ( * ), y_traj ( * ) integer k real distance_traj , distance_intercept_traj real x_intercept_traj , y_intercept_traj , frac_length_traj real distance_intercept_min k = 1 !return !Set the distances for the initial emission grid !distance_traj(k)=sqrt((x_traj(k)-x_r)*(x_traj(k)-x_r)+(y_traj(k)-y_r)*(y_traj(k)-y_r)) distance_traj = ( x_traj ( k ) - x_r ) * ( x_traj ( k ) - x_r ) + ( y_traj ( k ) - y_r ) * ( y_traj ( k ) - y_r ) !Leave the routine because the receptor is the same as the emission grid if ( distance_traj . eq . 0 ) then y_loc = 0. x_loc = 0. valid_traj = . true . return endif !distance_intercept_traj(k)=distance_traj(k) y_loc = 0. x_loc = 0. valid_traj = . false . distance_intercept_min = distance_traj do k = 2 , traj_max_index_in if ( x_traj ( k ). ne . NODATA_value ) then call distrl_sqr ( x_r , y_r , x_traj ( k - 1 ), y_traj ( k - 1 ), x_traj ( k ), y_traj ( k ), x_intercept_traj , y_intercept_traj , distance_intercept_traj , frac_length_traj ) if ( distance_intercept_traj . lt . distance_intercept_min ) then distance_intercept_min = distance_intercept_traj y_loc = distance_intercept_traj x_loc = dr_traj * ( k - 2 ) + frac_length_traj * dr_traj valid_traj = . true . endif endif enddo !Remove most of the results because they are upwind if ( x_loc . eq . 0. and . y_loc . gt . dr_traj ) then valid_traj = . false . endif y_loc = sqrt ( y_loc ) end subroutine uEMEP_minimum_distance_trajectory_fast end module local_trajectory","tags":"","loc":"sourcefile/uemep_local_trajectory.f90.html"},{"title":"uEMEP_time_functions.f90 – uEMEP","text":"Source Code module time_functions !! Various procedures for manipulating time use uemep_constants , only : dp , secphour , secpday implicit none private public :: get_sun_angles , number_to_date , date_to_number , & date_to_datestr_bracket , date_to_datestr_squarebracket , date_to_datestr , & datestr_to_date , day_of_week , summer_time_europe , date_to_julian contains subroutine number_to_date ( date_num , date_array , ref_year ) !! Returns array with date and time from a date number !! !! 'date-num' can be any non-negative number. real ( dp ), intent ( in ) :: date_num !! Date number in seconds since ref_year integer , intent ( out ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer , intent ( in ) :: ref_year !! Reference year ! Local variables integer :: y , m , d real ( dp ) :: day_fraction integer :: day_int integer :: day_count , days_in_year integer :: rest_seconds integer :: daysinmonth ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ! Check that date number if positive if ( date_num < 0 ) then print \"(a)\" , \"ERROR! In number_to_date, 'date_num' must be >= 0.0\" stop 1 end if ! Set day fraction to the nearest second. Avoiding round off errors day_int = idint ( date_num ) day_fraction = date_num - day_int ! Determine hours, minutes and seconds date_array = 0 rest_seconds = int ( day_fraction * 2 4.0 * 360 0.0 + 0.5 ) ! Rounded off date_array ( 4 ) = int ( rest_seconds / 360 0.0 ) date_array ( 5 ) = int (( rest_seconds / 6 0.0 - date_array ( 4 ) * 6 0.0 )) date_array ( 6 ) = int (( rest_seconds - date_array ( 4 ) * 360 0.0 - date_array ( 5 ) * 6 0.0 )) ! Count up days keeping track of the year, month and day of month ! Determine year y = ref_year - 1 day_count = 0 do while ( day_count . le . day_int ) y = y + 1 days_in_year = 365 if ((( mod ( y , 4 ) . eq . 0 ) . and . ( mod ( y , 100 ) . ne . 0 )) . or . ( mod ( y , 400 ) . eq . 0 )) days_in_year = 366 ! Leap year day_count = day_count + days_in_year end do date_array ( 1 ) = y day_count = day_count - days_in_year ! Determine month given the year daysinmonth ( 2 ) = 28 if ((( mod ( date_array ( 1 ), 4 ) . eq . 0 ) . and . ( mod ( date_array ( 1 ), 100 ) . ne . 0 )) . or . ( mod ( date_array ( 1 ), 400 ) . eq . 0 )) daysinmonth ( 2 ) = 29 ! Leap month m = 0 do while ( day_count . le . day_int ) m = m + 1 day_count = day_count + daysinmonth ( m ) end do date_array ( 2 ) = m day_count = day_count - daysinmonth ( m ) ! Determine day d = 0 do while ( day_count . le . day_int ) d = d + 1 day_count = day_count + 1 end do date_array ( 3 ) = d end subroutine number_to_date function date_to_number ( date_array , ref_year ) result ( res ) !! Returns a date number from an array with date and time !! !! Note: Some wrong dates (e.g., 2023-02-29) will still return a number which will be wrong! integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer , intent ( in ) :: ref_year !! Reference year real ( dp ) :: res !! Date number in seconds since ref_year ! Local variables integer :: y , m integer :: daysinmonth ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] res = 0.0 if ( date_array ( 1 ) . gt . ref_year ) then ! Add up days in the year do y = ref_year , date_array ( 1 ) - 1 if ((( mod ( y , 4 ) . eq . 0 ) . and . ( mod ( y , 100 ) . ne . 0 )) . or . ( mod ( y , 400 ) . eq . 0 )) then daysinmonth ( 2 ) = 29 else daysinmonth ( 2 ) = 28 end if do m = 1 , 12 res = res + sngl ( real ( daysinmonth ( m ))) end do end do end if ! Add up days in the remaining months if ((( mod ( date_array ( 1 ), 4 ) . eq . 0 ) . and . ( mod ( date_array ( 1 ), 100 ) . ne . 0 )) . or . ( mod ( date_array ( 1 ), 400 ) . eq . 0 )) then daysinmonth ( 2 ) = 29 else daysinmonth ( 2 ) = 28 end if if ( date_array ( 2 ) . gt . 1 ) then do m = 1 , date_array ( 2 ) - 1 res = res + sngl ( real ( daysinmonth ( m ))) end do end if res = res + sngl ( real ( date_array ( 3 ))) - 1.0 res = res + sngl ( real ( date_array ( 4 ))) / 2 4.0 ! starts at 0 res = res + sngl ( real ( date_array ( 5 ))) / 2 4.0 / 6 0.0 ! starts at 0 res = res + sngl ( real ( date_array ( 6 ))) / 2 4.0 / 6 0.0 / 6 0.0 ! starts at 0 end function date_to_number function date_to_julian ( date_array , ref_year ) result ( res ) !! Returns Julian day from an array with date and time integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer , intent ( in ) :: ref_year !! Reference year integer :: res !! Julian day ! Local variables integer :: b ( 6 ) b ( 1 ) = date_array ( 1 ) b ( 2 ) = 1 b ( 3 ) = 1 b ( 4 ) = 0 b ( 5 ) = 0 b ( 6 ) = 0 res = int ( date_to_number ( date_array , ref_year ) - date_to_number ( b , ref_year ) + 1 ) end function date_to_julian subroutine datestr_to_date ( date_str , format_str , date_array ) !! Converts date string to a date array based on the format string !! !! Example: !!     call datestr_to_date(\"20190429123005\", \"yyyymmdd\", date_array_out) !! Returns: !!     date_arrat_out = [2019, 4, 29, 0, 0, 0] character ( * ), intent ( in ) :: date_str !! Date string [yyyymmddHHMMSS] character ( * ), intent ( in ) :: format_str !! Format string integer , intent ( out ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] ! Local variables integer :: pos ! Extract elements of the date string pos = index ( format_str , 'yyyy' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 3 ), * ) date_array ( 1 ) else date_array ( 1 ) = 0 end if pos = index ( format_str , 'mm' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 2 ) else date_array ( 2 ) = 0 end if pos = index ( format_str , 'dd' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 3 ) else date_array ( 3 ) = 0 end if pos = index ( format_str , 'HH' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 4 ) else date_array ( 4 ) = 0 end if pos = index ( format_str , 'MM' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 5 ) else date_array ( 5 ) = 0 end if pos = index ( format_str , 'SS' ) if ( pos . gt . 0 ) then read ( date_str ( pos : pos + 1 ), * ) date_array ( 6 ) else date_array ( 6 ) = 0 end if end subroutine datestr_to_date subroutine date_to_datestr ( date_array , format_str , date_str ) !! Returns a date string based on (yyyy.mm.dd HH:MM:SS) from a date array !! !! Currently only accepts 'yyyymmddHH', 'yyymmdd' and 'yyyymm' as the format string. !! !! Example: !!     call date_to_datestr([2019, 4, 29, 30, 0, 0], \"yyyymmdd\", date_str) !! Returns: !!     date_str = \"20190429\" integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] character ( len =* ), intent ( in ) :: format_str !! Format string character ( len =* ), intent ( out ) :: date_str !! Date string ! Local variables integer :: pos date_str = format_str ! To avoid just putting in date parts e.g. mm or dd that might occurr in a string then it is required that at least two of the date ! strings are present, i.e. yyyy, mm and dd or HH, MM and SS if (( index ( format_str , 'yyyy' ) . gt . 0 . and . index ( format_str , 'mm' ) . gt . 0 ) . or . ( index ( format_str , 'yyyy' ) . gt . 0 & . and . index ( format_str , 'dd' ) . gt . 0 ) . or . ( index ( format_str , 'dd' ) . gt . 0 . and . index ( format_str , 'mm' ). gt . 0 ) & . or . ( index ( format_str , 'HH' ) . gt . 0 . and . index ( format_str , 'MM' ) . gt . 0 ) . or . ( index ( format_str , 'HH' ) . gt . 0 & . and . index ( format_str , 'SS' ) . gt . 0 ) . or . ( index ( format_str , 'MM' ) . gt . 0 . and . index ( format_str , 'SS' ) . gt . 0 )) then ! Do nothing but continue with routine as this is a valid format for date string substitution else ! Leave the routine return end if ! Now it only accepts the strings 'yyyymmddHH', 'yyyymmdd' and 'yyyymm' for replacement pos = index ( format_str , 'yyyymmddHH' ) if ( pos . gt . 0 ) then write ( date_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) if ( date_array ( 2 ) . gt . 9 ) then write ( date_str ( pos + 4 : pos + 5 ), '(i2)' ) date_array ( 2 ) else write ( date_str ( pos + 4 : pos + 5 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if if ( date_array ( 3 ) . gt . 9 ) then write ( date_str ( pos + 6 : pos + 7 ), '(i2)' ) date_array ( 3 ) else write ( date_str ( pos + 6 : pos + 7 ), '(a1,i1)' ) '0' , date_array ( 3 ) end if if ( date_array ( 4 ) . gt . 9 ) then write ( date_str ( pos + 8 : pos + 9 ), '(i2)' ) date_array ( 4 ) else write ( date_str ( pos + 8 : pos + 9 ), '(a1,i1)' ) '0' , date_array ( 4 ) end if return end if pos = index ( format_str , 'yyyymmdd' ) if ( pos . gt . 0 ) then write ( date_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) if ( date_array ( 2 ) . gt . 9 ) then write ( date_str ( pos + 4 : pos + 5 ), '(i2)' ) date_array ( 2 ) else write ( date_str ( pos + 4 : pos + 5 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if if ( date_array ( 3 ) . gt . 9 ) then write ( date_str ( pos + 6 : pos + 7 ), '(i2)' ) date_array ( 3 ) else write ( date_str ( pos + 6 : pos + 7 ), '(a1,i1)' ) '0' , date_array ( 3 ) end if return end if pos = index ( format_str , 'yyyymm' ) if ( pos . gt . 0 ) then write ( date_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) if ( date_array ( 2 ) . gt . 9 ) then write ( date_str ( pos + 4 : pos + 5 ), '(i2)' ) date_array ( 2 ) else write ( date_str ( pos + 4 : pos + 5 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if return end if end subroutine date_to_datestr subroutine date_to_datestr_new ( date_array , in_format_str , out_a_str ) integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] character ( * ), intent ( in ) :: in_format_str !! Format string character ( * ), intent ( out ) :: out_a_str !! Date string ! Local variables integer :: pos ! Extract elements of the date string pos = index ( in_format_str , 'yyyy' ) if ( pos . gt . 0 ) then write ( out_a_str ( pos : pos + 3 ), '(i4)' ) date_array ( 1 ) end if pos = index ( in_format_str , 'mm' ) if ( pos . gt . 0 ) then if ( date_array ( 2 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 2 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 2 ) end if end if pos = index ( in_format_str , 'dd' ) if ( pos . gt . 0 ) then if ( date_array ( 3 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 3 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 3 ) end if end if pos = index ( in_format_str , 'HH' ) if ( pos . gt . 0 ) then if ( date_array ( 4 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 4 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 4 ) end if end if pos = index ( in_format_str , 'MM' ) if ( pos . gt . 0 ) then if ( date_array ( 5 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 5 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 5 ) end if end if pos = index ( in_format_str , 'SS' ) if ( pos . gt . 0 ) then if ( date_array ( 6 ) . gt . 9 ) then write ( out_a_str ( pos : pos + 1 ), '(i2)' ) date_array ( 6 ) else write ( out_a_str ( pos : pos + 1 ), '(a1,i1)' ) '0' , date_array ( 6 ) end if end if end subroutine date_to_datestr_new subroutine date_to_datestr_bracket ( date_array , in_format_str , out_a_str ) !! Converts a date array to a date string with brackets in format string !! !! format string brackets are '<' and '>'. integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] character ( * ), intent ( in ) :: in_format_str !! Format string character ( * ), intent ( out ) :: out_a_str !! Date string ! Local variables character ( 256 ) :: format_str , a_str integer :: pos1 , pos2 ! Only changes dates when they are inside '<.....>' ! Removes these once changed pos1 = index ( in_format_str , '<' ) pos2 = index ( in_format_str , '>' ) if ( pos1 . le . 0 . or . pos2 . le . 0 . or . pos1 + 1 . gt . pos2 - 1 ) then out_a_str = in_format_str return end if ! Reassign format_str to be just the text between <..> format_str = in_format_str ( pos1 + 1 : pos2 - 1 ) a_str = format_str ! Get the date string call date_to_datestr_new ( date_array , format_str , a_str ) ! Insert the a_str into out_a_str, removing the '<>' text if ( len_trim ( in_format_str ) . gt . pos2 ) then out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) // in_format_str ( pos2 + 1 :) else out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) end if end subroutine date_to_datestr_bracket subroutine date_to_datestr_squarebracket ( date_array , in_format_str , out_a_str ) !! Converts a date array to a date string with brackets in format string !! !! format string brackets are '<' and '>'. integer , intent ( in ) :: date_array ( 6 ) character ( * ), intent ( in ) :: in_format_str character ( * ), intent ( out ) :: out_a_str ! Local variables character ( 256 ) :: format_str , a_str integer :: pos1 , pos2 ! Only changes dates when they are inside '[.....]' ! Removes these once changed pos1 = index ( in_format_str , '[' ) pos2 = index ( in_format_str , ']' ) if ( pos1 . le . 0 . or . pos2 . le . 0 . or . pos1 + 1 . gt . pos2 - 1 ) then out_a_str = in_format_str return end if ! Reassign format_str to be just the text between <..> format_str = in_format_str ( pos1 + 1 : pos2 - 1 ) a_str = format_str ! Get date string call date_to_datestr_new ( date_array , format_str , a_str ) ! Insert the a_str into out_a_str, removing the '[]' text if ( len_trim ( in_format_str ) . gt . pos2 ) then out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) // in_format_str ( pos2 + 1 :) else out_a_str = in_format_str ( 1 : pos1 - 1 ) // trim ( a_str ) end if end subroutine date_to_datestr_squarebracket function day_of_week ( date_array ) result ( res ) !! The subroutine calculates the day of week given current datetime, !! where DAYW = 1 corresponds to Monday and DAYW = 7 to Sunday. The !! algorithm is based on the tables in \"Hvem Hva Hvor 1971\" (p. 121) !! and is valid for all years from 1800 to infinity !! !! Adapted from EPISODE code integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] integer :: res !! Day of week [1-7] ! Local variables integer :: jm ( 12 ) = [ 1 , 5 , 5 , 2 , 7 , 4 , 2 , 6 , 3 , 1 , 5 , 3 ] ! Column number for each month integer :: ir ! Row in HHH table for day of month integer :: jc ! Column in HHH table for month integer :: nt ! Number in HHH table for row ir and column jc integer :: jk ! Column in HHH table for year integer :: j4 , j100 , j400 ! Adjustment values for leap year logical :: leap ! If leap year then true else false integer :: daym , mnth , year ! Extract values from array daym = date_array ( 3 ) mnth = date_array ( 2 ) year = date_array ( 1 ) ! Calculate leap year or not leap = . false . if ( mod ( year , 4 ) . eq . 0 . and . . not . ( mod ( year , 100 ) . eq . 0 . and . mod ( year , 400 ) . ne . 0 )) leap = . true . ! Calculate row number for day of month ir = mod ( daym - 1 , 7 ) + 1 ! Calculate column number for month jc = jm ( mnth ) if ( leap . and . ( mnth . eq . 1 . or . mnth . eq . 2 )) jc = jc + 1 ! Calculate \"number\" in HHH table with row IR and column JC nt = mod ( ir + 7 - jc , 7 ) + 1 ! Calculate column number for year (adjusting for leap years) j4 = ( year - 1800 ) / 4 j100 = ( year - 1800 ) / 100 j400 = ( year - 1600 ) / 400 jk = mod ( year - 1800 + j4 - j100 + j400 + 3 - 1 , 7 ) + 1 ! Calculate day of week res = mod ( jk - 1 + nt - 1 , 7 ) + 1 end function day_of_week function summer_time_europe ( date_array ) result ( summer_time ) !! Returns true if supplied date is during summer time in Europe, else false integer , intent ( in ) :: date_array ( 6 ) !! Datetime [y,m,d,h,m,s] logical :: summer_time !! True if summer time, else false ! Local variables integer :: a ( 6 ), b_start ( 6 ), b_end ( 6 ) integer :: ref_year , year real ( dp ) :: datenum_start , datenum_end , datenum a = date_array ref_year = 2000 b_start = 0 b_end = 0 year = a ( 1 ) b_start ( 1 ) = a ( 1 ) b_start ( 2 ) = 3 b_start ( 3 ) = ( 31 - mod (((( 5 * year ) / 4 ) + 4 ), 7 )) b_start ( 4 ) = 1 b_end ( 1 ) = a ( 1 ) b_end ( 2 ) = 10 b_end ( 3 ) = ( 31 - mod (((( 5 * year ) / 4 ) + 1 ), 7 )) b_end ( 4 ) = 1 datenum_start = date_to_number ( b_start , ref_year ) datenum_end = date_to_number ( b_end , ref_year ) datenum = date_to_number ( a , ref_year ) summer_time = . false . if ( datenum . ge . datenum_start . and . datenum . lt . datenum_end ) summer_time = . true . end function summer_time_europe subroutine get_sun_angles ( lat , lon , date_a , date_num , difutc_h , azimuth_ang , zenith_ang ) !! Returns the azimuth and zenith angles !! !! Routine modified from NORTRIP real , intent ( in ) :: lat real , intent ( in ) :: lon integer , intent ( in ) :: date_a ( 6 ) real ( dp ), intent ( in ) :: date_num real , intent ( in ) :: difutc_h real , intent ( out ) :: azimuth_ang real , intent ( out ) :: zenith_ang ! Local variables real :: julian_day , time_s , dayang , dec , eqtime , solartime , hourang , azt , az real , parameter :: s0 = 136 7.0 real , parameter :: pi = 3.14159 / 18 0.0 integer :: ref_year = 2000 if ( date_a ( 1 ) . eq . 0 ) then julian_day = real ( date_num ) else julian_day = date_to_julian ( date_a , ref_year ) end if time_s = ( julian_day - 1 ) * 2 4.0 * 360 0.0 dayang = 36 0.0 / 36 5.0 * ( julian_day - 1.0 ) dec = 0.396 - 2 2.91 * cos ( pi * dayang ) + 4.025 * sin ( pi * dayang ) eqtime = ( 1.03 + 2 5.7 * cos ( pi * dayang ) - 44 0.0 * sin ( pi * dayang ) - 20 1.0 * cos ( 2.0 * pi * dayang ) - 56 2.0 * sin ( 2.0 * pi * dayang )) / secphour solartime = mod ( time_s + secpday + secphour * ( lon / 1 5.0 + difutc_h + eqtime ), secpday ) hourang = 1 5.0 * ( 1 2.0 - solartime / secphour ) ! Set zenith angle for atmospheric corrections azt = sin ( pi * dec ) * sin ( pi * lat ) + cos ( pi * dec ) * cos ( pi * lat ) * cos ( pi * hourang ) if ( abs ( azt ) . lt . 1.0 ) then az = acos ( azt ) / pi else az = 0.0 end if azimuth_ang = 18 0.0 - hourang zenith_ang = az end subroutine get_sun_angles end module time_functions","tags":"","loc":"sourcefile/uemep_time_functions.f90.html"},{"title":"uEMEP_set_emission_factors.f90 – uEMEP","text":"Source Code module set_emission_factors use uemep_configuration implicit none private public :: uEMEP_set_emission_factors , uEMEP_convert_proxy_to_emissions , & uEMEP_nox_emission_temperature contains !uEMEP_set_emission_factors.f90 subroutine uEMEP_set_emission_factors use uEMEP_definitions implicit none write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Setting emission factors (uEMEP_set_emission_factors)' write ( unit_logfile , '(A)' ) '================================================================' !Converts the emission units of the input data to a standard ug/s/subgrid emission_factor_conversion ( nox_index , traffic_index ,:) = emission_factor ( nox_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( nox_index , shipping_index ,:) = emission_factor ( nox_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) ![tonne/month]*(ug/ton)*(month/sec)=ug/sec. Only valid for the current AIS data which is a total. Should change emission_factor_conversion ( nox_index , heating_index ,:) = emission_factor ( nox_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( no2_index , traffic_index ,:) = emission_factor ( no2_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) emission_factor_conversion ( no2_index , shipping_index ,:) = emission_factor ( no2_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) emission_factor_conversion ( no2_index , heating_index ,:) = emission_factor ( no2_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( pm25_index , traffic_index ,:) = emission_factor ( pm25_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( pm25_index , shipping_index ,:) = emission_factor ( pm25_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) ![tonne/month]*(ug/kg)*(month/sec)=ug/sec emission_factor_conversion ( pm25_index , heating_index ,:) = emission_factor ( pm25_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( pm10_index , traffic_index ,:) = emission_factor ( pm10_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( pm10_index , shipping_index ,:) = emission_factor ( pm10_index , shipping_index ,:) * ( 1.e+12 ) / ( 360 0. * 2 4. * 36 5. / 1 2. ) ![tonne/month]*(ug/kg)*(month/sec)=ug/sec emission_factor_conversion ( pm10_index , heating_index ,:) = emission_factor ( pm10_index , heating_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![dwellings]*(kg/dwelling/year)*(ug/kg)*(year/sec)=ug/sec emission_factor_conversion ( pmex_index , traffic_index ,:) = emission_factor ( pmex_index , traffic_index ,:) * ( 1.e-3 ) * ( 1.e+6 ) / ( 360 0. * 2 4. ) ![veh*m/day]*(g/km/veh)*(km/m)*(ug/g)*(day/sec)=ug/sec emission_factor_conversion ( nh3_index , agriculture_index ,:) = emission_factor ( nh3_index , agriculture_index ,:) * ( 1.e+9 ) / ( 360 0. * 2 4. * 36 5. ) ![kg/yr]*(ug/kg)*(yr/sec)=ug/sec !Test for monthly data !emission_factor_conversion(nh3_index,agriculture_index,:)=emission_factor_conversion(nh3_index,agriculture_index,:)*1.06 if ( read_shipping_from_netcdf_flag ) then emission_factor_conversion (:, shipping_index ,:) = ( 1.e+6 ) / ( 360 0. ) ![g/hr]*(ug/sec)=ug/sec. elseif ( read_weekly_shipping_data_flag . or . read_monthly_and_daily_shipping_data_flag ) then !Convert from g/hour to ug/s emission_factor_conversion (:, shipping_index ,:) = ( 1.e+6 ) / ( 360 0. ) ![g/hr]*(ug/sec)=ug/sec. endif if ( use_RWC_emission_data ) then !Convert from g/h/subgrid to ug/s/subgrid emission_factor_conversion (:, heating_index ,:) = 1.e6 / 360 0. if ( annual_calculations ) then !Convert from g/yr/subgrid to ug/s/subgrid. Temporal profile will be set to 1. !Should also be in shipping. No because the original data is read in as g/hr emission_factor_conversion (:, heating_index ,:) = 1.e6 / 360 0. / 2 4. / 36 5. endif endif !Converts tonne per year to ug/s/subgrid emission_factor_conversion (:, industry_index ,:) = 1.e12 / ( 360 0. * 24 * 36 5. ) !In the case of RIVM data then emissions are already given in ug/s/subgrid if ( read_subgrid_emission_data ) then emission_factor_conversion (:,:,:) = 1.0 endif end subroutine uEMEP_set_emission_factors !uEMEP_convert_proxy_to_emissions subroutine uEMEP_convert_proxy_to_emissions use uEMEP_definitions implicit none integer i_source , i_subsource integer tt real sum_emission_subgrid integer i_pollutant !Do not calculate emissions if EMEP emissions are to be used if ( local_subgrid_method_flag . eq . 3 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Converting proxy data to emissions (uEMEP_convert_proxy_to_emissions)' write ( unit_logfile , '(A)' ) '================================================================' !Set all emissions to the same constant emission value with emissions in ug/sec for all sources do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then i_subsource = 1 do i_pollutant = 1 , n_pollutant_loop !Do not calculate for traffic if use_NORTRIP_emission_data=.true. and  use_NORTRIP_emission_pollutant=.false.). This is done in uEMEP_grid_roads if ( i_source . ne . traffic_index . or . read_subgrid_emission_data & . or .( i_source . eq . traffic_index . and .. not . use_NORTRIP_emission_data ) & . or .( i_source . eq . traffic_index . and . use_NORTRIP_emission_data . and .. not . use_NORTRIP_emission_pollutant ( pollutant_loop_index ( i_pollutant )))) then do tt = 1 , subgrid_dim ( t_dim_index ) emission_subgrid (:,:, tt , i_source , i_pollutant ) = proxy_emission_subgrid (:,:, i_source , i_pollutant ) & * emission_factor_conversion ( pollutant_loop_index ( i_pollutant ), i_source , i_subsource ) & * emission_time_profile_subgrid (:,:, tt , i_source , i_pollutant ) !write(*,*) sum(proxy_emission_subgrid(:,:,i_source,i_subsource)),emission_factor_conversion(compound_index,i_source,i_subsource),sum(emission_time_profile_subgrid(:,:,tt,i_source,i_subsource)) enddo endif sum_emission_subgrid = sum ( emission_subgrid (:,:,:, i_source , i_pollutant )) write ( unit_logfile , '(A,es12.2)' ) 'Sum of emissions for ' // trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ' over period (kg)=' , sum_emission_subgrid * 360 0. / 1.e9 enddo endif enddo !Check NOx shipping !i_source=shipping_index !i_pollutant=pollutant_loop_back_index(nox_nc_index) !do tt=1,subgrid_dim(t_dim_index) !    write(unit_logfile,'(A,es12.2)') 'Sum of emissions per hour '//trim(source_file_str(i_source))//' '//trim(pollutant_file_str(pollutant_loop_index(i_pollutant)))//' over period (kg)=',sum(emission_subgrid(:,:,tt,i_source,i_pollutant))*3600./1.e9 !enddo end subroutine uEMEP_convert_proxy_to_emissions subroutine uEMEP_nox_emission_temperature !Routine for doing the chemistry calculations in uEMEP use uEMEP_definitions implicit none integer t_start , t_end integer i , j , t integer i_cross , j_cross real :: ref_temperature1 =- 1 0. real :: ref_temperature2 = 1 0. real :: ref_scaling1 = 3. real :: ref_scaling2 = 1. real :: emission_scaling real :: temperature real :: emission_scaling_average , temperature_average integer :: emission_scaling_average_count real :: weighting_loop_sum real :: temperature_loop real :: weighting_loop real :: emission_scaling_loop real :: sigma_loop integer :: k !Do not correct if no traffic is to be calculated if (. not . calculate_source ( traffic_index )) then return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Using temperature dependency of NOx traffic emissions (uEMEP_nox_emission_temperature)' write ( unit_logfile , '(A)' ) '================================================================' if ( annual_calculations ) write ( unit_logfile , '(A)' ) 'Using temperature distribution to calculate the emissions scaling.' t_start = 1 t_end = subgrid_dim ( t_dim_index ) ref_temperature1 = traffic_nox_emission_temperature_ref_temperature ( 1 ) ref_temperature2 = traffic_nox_emission_temperature_ref_temperature ( 2 ) ref_scaling1 = traffic_nox_emission_temperature_ref_scaling ( 1 ) ref_scaling2 = traffic_nox_emission_temperature_ref_scaling ( 2 ) !Use the meteo model input from EMEP or alternative directly !This is so it will work for saving emissions for EMEP as well since the meteo and cross reference subgrids are not calculated emission_scaling_average = 0. emission_scaling_average_count = 0 temperature_average = 0 do t = t_start , t_end do j = 1 , emission_subgrid_dim ( y_dim_index , traffic_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , traffic_index ) if ( save_emissions_for_EMEP ( allsource_index )) then if ( allocated ( meteo_var1d_nc )) then !Need to cross reference the meteo grid to the emission grid as this is not done normally i_cross = 1 + floor (( x_emission_subgrid ( i , j , traffic_index ) - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) j_cross = 1 + floor (( y_emission_subgrid ( i , j , traffic_index ) - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) !Because the meteo grid can be smaller than the EMEP grid then need to limit it i_cross = min ( max ( 1 , i_cross ), dim_length_meteo_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_meteo_nc ( y_dim_nc_index )) else write ( unit_logfile , '(a)' ) 'No meteo data available for traffic temperature correction. Stopping.' stop endif else !Use the EMEP meteorology i_cross = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , traffic_index ) j_cross = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , traffic_index ) i_cross = min ( max ( 1 , i_cross ), dim_length_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_nc ( y_dim_nc_index )) endif !i_integral=crossreference_emission_to_integral_subgrid(i,j,x_dim_index,traffic_index) !j_integral=crossreference_emission_to_integral_subgrid(i,j,y_dim_index,traffic_index) if ( use_alternative_meteorology_flag ) then temperature = meteo_var3d_nc ( i_cross , j_cross , t , t2m_nc_index ) - 27 3.14 else temperature = var3d_nc ( i_cross , j_cross , t , t2m_nc_index , allsource_index , meteo_p_loop_index ) - 27 3.14 endif !temperature=meteo_subgrid(i_integral,j_integral,t,t2m_subgrid_index)-273.14 !If annual calculation then use a Gaussian temperature distribution based on Norwegian conditions with a sigma of 7 degrees !This is hardcoded awaiting the proper implementation in NORTRIP if ( annual_calculations ) then sigma_loop = 7. weighting_loop_sum = 0 emission_scaling = 0 do k =- 20 , 20 temperature_loop = temperature + k weighting_loop = exp ( - ( temperature_loop - temperature ) * ( temperature_loop - temperature ) / 2. / ( sigma_loop * sigma_loop )) weighting_loop_sum = weighting_loop_sum + weighting_loop emission_scaling_loop = ref_scaling1 + ( ref_scaling2 - ref_scaling1 ) * ( temperature_loop - ref_temperature1 ) / ( ref_temperature2 - ref_temperature1 ) emission_scaling_loop = max ( min ( emission_scaling_loop , ref_scaling1 ), ref_scaling2 ) emission_scaling = emission_scaling + emission_scaling_loop * weighting_loop !write(*,*) k,temperature_loop,weighting_loop,emission_scaling_loop enddo emission_scaling = emission_scaling / weighting_loop_sum else emission_scaling = ref_scaling1 + ( ref_scaling2 - ref_scaling1 ) * ( temperature - ref_temperature1 ) / ( ref_temperature2 - ref_temperature1 ) emission_scaling = max ( min ( emission_scaling , ref_scaling1 ), ref_scaling2 ) endif emission_scaling_average = emission_scaling_average + emission_scaling temperature_average = temperature_average + temperature emission_scaling_average_count = emission_scaling_average_count + 1 !subgrid(i,j,t,local_subgrid_index,traffic_index,pollutant_loop_back_index(nox_nc_index))=emission_scaling*subgrid(i,j,t,local_subgrid_index,traffic_index,pollutant_loop_back_index(nox_nc_index)) emission_subgrid ( i , j , t , traffic_index , pollutant_loop_back_index ( nox_nc_index )) = emission_scaling * emission_subgrid ( i , j , t , traffic_index , pollutant_loop_back_index ( nox_nc_index )) !write(*,'(3i,2f12.2)') i,j,t,temperature,emission_scaling enddo enddo enddo write ( unit_logfile , '(a,2f12.2)' ) 'Average emissions scaling factor and temperature for traffic NOx: ' , emission_scaling_average / emission_scaling_average_count , temperature_average / emission_scaling_average_count write ( unit_logfile , '(a,4f12.2)' ) 'Parameters ref_temperature1,ref_temperature2,ref_scaling1,ref_scaling2: ' , ref_temperature1 , ref_temperature2 , ref_scaling1 , ref_scaling2 end subroutine uEMEP_nox_emission_temperature end module set_emission_factors","tags":"","loc":"sourcefile/uemep_set_emission_factors.f90.html"},{"title":"uEMEP_read_agriculture_rivm_data.f90 – uEMEP","text":"Source Code module read_agriculture_asi_data use uemep_configuration use mod_lambert_projection , only : lb2lambert2_uEMEP , LL2PS_spherical use mod_area_interpolation , only : area_weighted_extended_interpolation_function implicit none private public :: uEMEP_read_agriculture_rivm_data , uEMEP_read_emission_rivm_data contains !uEMEP_read_agriculture_asi_data.f90 subroutine uEMEP_read_agriculture_rivm_data use uEMEP_definitions use mod_rdm2ll , only : RDM2LL implicit none integer i , j character ( 256 ) temp_str , temp_str1 integer unit_in logical :: exists integer count , index_val real ddlatitude , ddlongitude , totalnh3emission real y_agriculture , x_agriculture integer i_agriculture_index , j_agriculture_index real nh3emission_scale , nh3_gridsize ( 2 ) integer i_range , j_range , i_file integer i_start , i_end , j_start , j_end logical , allocatable :: agriculture_emission_data_available (:,:) integer , allocatable :: agriculture_emission_emep_subgrid_count (:,:) integer iii , jjj integer source_index , subsource_index integer t integer :: io real x_temp ( 3 , 3 ), y_temp ( 3 , 3 ), z_temp ( 3 , 3 ) real temp_emission write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading agriculture rivm nh3 data  (uEMEP_read_agriculture_rivm_data)' write ( unit_logfile , '(A)' ) '================================================================' if (. not . save_emissions_for_EMEP ( agriculture_index )) then projection_type = RDM_projection_index endif source_index = agriculture_index n_subsource ( source_index ) = 1 !unit_conversion(source_index)=1. !Converts kg to mg t = 1 !Internal check allocate ( agriculture_emission_data_available ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) proxy_emission_subgrid (:,:, source_index ,:) = 0. agriculture_emission_data_available = . false . pathfilename_agriculture ( 1 ) = trim ( pathname_agriculture ( 1 )) // trim ( filename_agriculture ( 1 )) pathfilename_agriculture ( 2 ) = trim ( pathname_agriculture ( 2 )) // trim ( filename_agriculture ( 2 )) !Test existence of the agricultural files. If does not exist then stop inquire ( file = trim ( pathfilename_agriculture ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: agriculture file does not exist: ' , trim ( pathfilename_agriculture ( 1 )) stop endif inquire ( file = trim ( pathfilename_agriculture ( 2 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: agriculture file does not exist: ' , trim ( pathfilename_agriculture ( 2 )) stop endif !Open the file for reading do i_file = 1 , 2 unit_in = 20 open ( unit_in , file = pathfilename_agriculture ( i_file ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening agriculture file ' // trim ( pathfilename_agriculture ( i_file )) rewind ( unit_in ) !Read header x,y,emission read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) trim ( temp_str ) count = 0 do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit ddlatitude = 0. ; ddlongitude = 0. ; totalnh3emission = 0. ; !Extract the values in the temp_str index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) x_agriculture !write (*,*) ddlatitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) read ( temp_str1 , * ) y_agriculture !write (*,*) ddlongitude index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :) !write(*,*) index_val,trim(temp_str1),trim(temp_str) !write(*,*) index_val,trim(temp_str) read ( temp_str , * ) totalnh3emission !write (*,*) trim(temp_str1),totalnh3emission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) totalparticulatematteremission !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_int !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:) !if (index_val.gt.1) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !temp_str1=temp_str !if (len(temp_str1).gt.0) read(temp_str1,*) temp_str2 !write (*,*) trim(temp_str1) !write(*,*) count,ddlatitude,ddlongitude,totalnoxemission,totalparticulatematteremission count = count + 1 !Convert lat lon to utm coords call RDM2LL ( y_agriculture , x_agriculture , ddlatitude , ddlongitude ) if ( save_emissions_for_EMEP ( agriculture_index )) then if ( projection_type . eq . LL_projection_index ) then y_agriculture = ddlatitude x_agriculture = ddlongitude elseif ( projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_agriculture , y_agriculture , ddlongitude , ddlatitude , EMEP_projection_attributes ) elseif ( projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_agriculture , y_agriculture , ddlongitude , ddlatitude , EMEP_projection_attributes ) endif endif if ( mod ( count , 10000 ). eq . 0 ) write ( unit_logfile , '(i,5f12.4)' ) count , y_agriculture , x_agriculture , ddlatitude , ddlongitude , totalnh3emission !Find the grid index it belongs to i_agriculture_index = 1 + floor (( x_agriculture - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_agriculture_index = 1 + floor (( y_agriculture - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !Add to subgrid if ( i_file . eq . 1 ) then !Point sources go straight into the emission grid subsource_index = 1 nh3emission_scale = 1. i_start = i_agriculture_index ; i_end = i_agriculture_index ; j_start = j_agriculture_index ; j_end = j_agriculture_index ; proxy_emission_subgrid ( i_agriculture_index , j_agriculture_index , source_index , pollutant_loop_back_index ( nh3_nc_index )) = & proxy_emission_subgrid ( i_agriculture_index , j_agriculture_index , source_index , pollutant_loop_back_index ( nh3_nc_index )) & + totalnh3emission agriculture_emission_data_available ( i_agriculture_index , j_agriculture_index ) = . true . else !Area sources on 1 km grid if ( n_subsource ( source_index ). eq . 2 ) then subsource_index = 2 else subsource_index = 1 endif !h_emis(source_index,subsource_index)=3. nh3_gridsize (:) = 100 0. nh3emission_scale = emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index ) / ( nh3_gridsize ( x_dim_index ) * nh3_gridsize ( y_dim_index )) if ( save_emissions_for_EMEP ( agriculture_index )) then if ( projection_type . eq . LL_projection_index ) then !Approximate grid size in degrees nh3_gridsize ( x_dim_index ) = nh3_gridsize ( x_dim_index ) / 11057 0. / cos ( 3.14159 / 18 0. * y_agriculture ) nh3_gridsize ( y_dim_index ) = nh3_gridsize ( y_dim_index ) / 11057 0. nh3emission_scale = emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index ) & / ( nh3_gridsize ( x_dim_index ) * nh3_gridsize ( y_dim_index )) elseif ( projection_type . eq . LCC_projection_index ) then !Do nothing elseif ( projection_type . eq . PS_projection_index ) then !Do nothing endif endif !Set the loop range to be big enough i_range = floor ( nh3_gridsize ( x_dim_index ) / emission_subgrid_delta ( x_dim_index , source_index ) / 2. ) + 1 j_range = floor ( nh3_gridsize ( y_dim_index ) / emission_subgrid_delta ( y_dim_index , source_index ) / 2. ) + 1 i_start = i_agriculture_index - i_range ; i_end = i_agriculture_index + i_range j_start = j_agriculture_index - j_range ; j_end = j_agriculture_index + j_range !write(*,*) i_range,j_range,nh3_gridsize(x_dim_index),emission_subgrid_delta(x_dim_index,source_index) !write(*,*) i_start,i_end,j_start,j_end !Put emmissions into emission grids !Set up a 3 x 3 grid to interpolate from !write(*,*) count !write(*,*) x_agriculture,y_agriculture,nh3_gridsize(x_dim_index),nh3_gridsize(y_dim_index) !write(*,*) x_emission_subgrid(i_start,j_start,source_index),y_emission_subgrid(i_start,j_start,source_index),emission_subgrid_delta(:,source_index) x_temp ( 1 ,:) = x_agriculture - nh3_gridsize ( x_dim_index ); x_temp ( 2 ,:) = x_agriculture ; x_temp ( 3 ,:) = x_agriculture + nh3_gridsize ( x_dim_index ); y_temp (:, 1 ) = y_agriculture - nh3_gridsize ( y_dim_index ); y_temp (:, 2 ) = y_agriculture ; y_temp (:, 3 ) = y_agriculture + nh3_gridsize ( y_dim_index ); z_temp (:,:) = 0 ; z_temp ( 2 , 2 ) = totalnh3emission do i = i_start , i_end do j = j_start , j_end if ( i . gt . 1. and . i . lt . emission_subgrid_dim ( x_dim_index , source_index ). and . j . gt . 1. and . j . lt . emission_subgrid_dim ( y_dim_index , source_index )) then temp_emission = area_weighted_extended_interpolation_function ( x_temp , y_temp , z_temp , 3 , 3 , & nh3_gridsize , x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), emission_subgrid_delta (:, source_index )) proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_nc_index )) = & proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_nc_index )) + temp_emission * nh3emission_scale if ( proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_nc_index )). gt . 0. ) agriculture_emission_data_available ( i , j ) = . true . !write(*,*)i,j,proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_nc_index)),agriculture_emission_data_available(i,j)!temp_emission*nh3emission_scale/totalnh3emission endif enddo enddo endif enddo write ( unit_logfile , '(A,I)' ) ' Agriculture counts = ' , count close ( unit_in ) enddo !file loop !After populating the grid with emission data (kg/yr) then fill all the other untouched grids with EMEP emission data (mg/m&#94;2/yr) or (mg/m&#94;2/hr). !Doesn't work. Would need to have a Nederlands mask instead of checking if emissions have been written or not. !!Do not use!! if ( 1. eq . 2 ) then if (. not . save_emissions_for_EMEP ( agriculture_index )) then !First find out how many agriculture emission subgrids there are in each EMEP grid allocate ( agriculture_emission_emep_subgrid_count ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) !This loop determines if there is an emep grid associated with an emission grid which should always be true agriculture_emission_emep_subgrid_count = 0 do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) !ii=crossreference_emission_to_target_subgrid(i,j,x_dim_index,source_index) !jj=crossreference_emission_to_target_subgrid(i,j,y_dim_index,source_index) !iii=crossreference_target_to_emep_subgrid(ii,jj,x_dim_index) !jjj=crossreference_target_to_emep_subgrid(ii,jj,y_dim_index) iii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , source_index ) jjj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , source_index ) agriculture_emission_emep_subgrid_count ( iii , jjj ) = agriculture_emission_emep_subgrid_count ( iii , jjj ) + 1 enddo enddo !Note, in current reading we have average emissions from EMEP not total do j = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index ) !write(*,*) i,j,agriculture_emission_data_available(i,j) if (. not . agriculture_emission_data_available ( i , j )) then !ii=crossreference_emission_to_target_subgrid(i,j,x_dim_index,source_index) !jj=crossreference_emission_to_target_subgrid(i,j,y_dim_index,source_index) !iii=crossreference_target_to_emep_subgrid(ii,jj,x_dim_index) !jjj=crossreference_target_to_emep_subgrid(ii,jj,y_dim_index) iii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , source_index ) jjj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , source_index ) if ( agriculture_emission_emep_subgrid_count ( iii , jjj ). ne . 0 ) then !Convert mg/m2/hr to kg/emission subgrid. Need to put in time here for the hourly runs. Need to fix proxy_emission_subgrid ( i , j , source_index , pollutant_loop_back_index ( nh3_index )) = var3d_nc ( iii , jjj , 1 , emis_nc_index , agriculture_nc_index , pollutant_loop_back_index ( nh3_nc_index )) / 1.0e6 & * emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index ) * 2 4. * 36 5. !If hourly data then convert to mean hour emission emissions !if (hourly_calculations) proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_index)) & !    =proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_index))/24./365. !write(*,*) i,j,iii,jjj !write(*,*) pollutant_loop_back_index(nh3_nc_index),proxy_emission_subgrid(i,j,source_index,pollutant_loop_back_index(nh3_index)),var3d_nc(iii,jjj,1,emis_nc_index,agriculture_nc_index,pollutant_loop_back_index(nh3_nc_index)) endif endif !write(*,*) agriculture_emission_emep_subgrid_count(iii,jjj) enddo enddo endif deallocate ( agriculture_emission_data_available ) endif end subroutine uEMEP_read_agriculture_rivm_data subroutine uEMEP_read_emission_rivm_data use uEMEP_definitions implicit none integer i , j character ( 256 ) temp_str integer unit_in logical :: exists integer count real ddlatitude , ddlongitude , totalemission real y_emission , x_emission integer i_emission_index , j_emission_index real emission_scale integer i_file integer source_index character ( 256 ) component_str integer i_source real height integer snap , compound_nc_index integer i_pollutant integer , allocatable :: count_subgrid (:,:,:) real :: height_mean ( n_source_index ) = 0 integer :: count_mean ( n_source_index ) = 0 integer :: io write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading emission rivm data  (uEMEP_read_emission_rivm_data)' write ( unit_logfile , '(A)' ) '================================================================' !Set the projection to the dutch one !Should already have been specified. Not generic enough !projection_type=RDM_projection_index !Set the sources to be downscaled to 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then proxy_emission_subgrid (:,:, i_source ,:) = 0. emission_properties_subgrid (:,:, emission_h_index , i_source ) = 0. endif enddo allocate ( count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) count_subgrid = 0 !Read in as g/s and convert to ug/s which is used in the model emission_scale = 1.0e6 !Set filename, only 1 file used pathfilename_emission_rivm ( 1 ) = trim ( pathname_emission_rivm ( 1 )) // trim ( filename_emission_rivm ( 1 )) !pathfilename_emission_rivm(2)=trim(pathname_emission_rivm(2))//trim(filename_emission_rivm(2)) !Test existence of the emission files. Only one file used. If does not exist then stop inquire ( file = trim ( pathfilename_emission_rivm ( 1 )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: emission RIVM file does not exist: ' , trim ( pathfilename_emission_rivm ( 1 )) stop endif !inquire(file=trim(pathfilename_emission_rivm(2)),exist=exists) !if (.not.exists) then !    write(unit_logfile,'(A,A)') ' ERROR: emission RIVM file does not exist: ', trim(pathfilename_emission_rivm(2)) !    stop !endif !Open the files for reading i_file = 1 unit_in = 20 open ( unit_in , file = pathfilename_emission_rivm ( i_file ), access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening emmision RIVM file ' // trim ( pathfilename_emission_rivm ( i_file )) rewind ( unit_in ) !Read header x,y,emission read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) trim ( temp_str ) count = 0 do !read(unit_in,'(A)') temp_str ddlatitude = 0. ; ddlongitude = 0. ; totalemission = 0. ; height = 0 ; snap = 0 ; component_str = '' ; !read(unit_in,'(2f,e,f,i,a)') x_emission,y_emission,totalemission,height,snap,component_str read ( unit_in , * , iostat = io ) x_emission , y_emission , totalemission , height , snap , component_str if ( io /= 0 ) exit !write(*,'(2f,e,f,i,a)') x_emission,y_emission,totalemission,height,snap,trim(component_str) compound_nc_index = 0 if ( index ( component_str , 'NOx' ). ne . 0 ) compound_nc_index = nox_nc_index if ( index ( component_str , 'PM10' ). ne . 0 ) compound_nc_index = pm10_nc_index if ( index ( component_str , 'NH3' ). ne . 0 ) compound_nc_index = nh3_nc_index if ( index ( component_str , 'PM25' ). ne . 0 ) compound_nc_index = pm25_nc_index !write(*,'(i,a)') compound_nc_index,trim(component_str) !Find the source sector in SNAP source_index = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ). and . uEMEP_to_EMEP_sector ( i_source ). eq . snap ) then source_index = i_source endif enddo !write(*,*) count count = count + 1 !Convert lat lon to utm coords !call RDM2LL(y_emission,x_emission,ddlatitude,ddlongitude) !if (mod(count,100000).eq.0) write(unit_logfile,'(i,2f12.2,e12.2,f12.2,i,2a)') count,x_emission,y_emission,totalemission,height,snap,'  ',trim(component_str) !write(*,*) source_index,compound_nc_index !Assumes the projection for the subgrid and the emissions are the same if ( source_index . gt . 0. and . compound_nc_index . gt . 0 ) then !Find the subgrid index it belongs to i_emission_index = 1 + floor (( x_emission - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_emission_index = 1 + floor (( y_emission - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) !write(*,*) i_emission_index,j_emission_index,emission_subgrid_min(x_dim_index,source_index),emission_subgrid_min(y_dim_index,source_index) !Check that it is valid and add it to the subgrid if ( i_emission_index . ge . 1. and . i_emission_index . le . emission_subgrid_dim ( x_dim_index , source_index ). and . j_emission_index . ge . 1. and . j_emission_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then !Add to subgrid proxy_emission_subgrid ( i_emission_index , j_emission_index , source_index , pollutant_loop_back_index ( compound_nc_index )) = & proxy_emission_subgrid ( i_emission_index , j_emission_index , source_index , pollutant_loop_back_index ( compound_nc_index )) & + totalemission * emission_scale emission_properties_subgrid ( i_emission_index , j_emission_index , emission_h_index , source_index ) = & emission_properties_subgrid ( i_emission_index , j_emission_index , emission_h_index , source_index ) + height !emission_properties_subgrid(i_emission_index,j_emission_index,emission_h_index,source_index)= height count_subgrid ( i_emission_index , j_emission_index , source_index ) = count_subgrid ( i_emission_index , j_emission_index , source_index ) + 1 !write(*,*) count_subgrid(i_emission_index,j_emission_index,source_index) endif endif enddo write ( unit_logfile , '(A,I)' ) ' Emission counts = ' , count close ( unit_in ) !enddo !file loop !Average the emission height sum and check output by looking at means do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) if ( count_subgrid ( i , j , i_source ). gt . 0 ) then emission_properties_subgrid ( i , j , emission_h_index , i_source ) = emission_properties_subgrid ( i , j , emission_h_index , i_source ) / count_subgrid ( i , j , i_source ) height_mean ( i_source ) = emission_properties_subgrid ( i , j , emission_h_index , i_source ) + height_mean ( i_source ) count_mean ( i_source ) = count_mean ( i_source ) + 1 endif enddo enddo endif enddo where ( count_mean . gt . 0 ) height_mean = height_mean / count_mean !Show results do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,A,A,ES10.2,A,f6.2)' ) 'Emission source ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), ': Total RIVM emissions (ug/s)=' , & sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , i_source ), 1 : emission_subgrid_dim ( y_dim_index , i_source ), i_source , i_pollutant )), '  Mean emission height (m)=' , height_mean ( i_source ) enddo endif enddo deallocate ( count_subgrid ) end subroutine uEMEP_read_emission_rivm_data end module read_agriculture_asi_data","tags":"","loc":"sourcefile/uemep_read_agriculture_rivm_data.f90.html"},{"title":"utility_functions.f90 – uEMEP","text":"Source Code module utility_functions use uemep_constants , only : dp implicit none private public :: distrl , distrl_sqr public :: nxtdat public :: ll2utm , ll2ltm public :: utm2ll , ltm2ll real ( dp ), parameter :: pi = 3.141592653589793 contains subroutine distrl ( x0 , y0 , x1 , y1 , x2 , y2 , xm , ym , dm , wm ) !! The subroutine calculates the minimum distance from a given receptor !! point to a given line source. real , intent ( in ) :: x0 !! Receptor point x-coordinate real , intent ( in ) :: y0 !! Receptor point y-coordinate real , intent ( in ) :: x1 !! Line source x-coordinate 1 real , intent ( in ) :: y1 !! Line source y-coordinate 1 real , intent ( in ) :: x2 !! Line source x-coordinate 2 real , intent ( in ) :: y2 !! Line source y-coordinate 2 real , intent ( out ) :: xm !! Minimum distance x-coordinate real , intent ( out ) :: ym !! Minimum distance y-coordinate real , intent ( out ) :: dm !! Minimum distance ! Local variables real :: num , denum , wm if ( x1 == x2 . and . y1 == y2 ) then wm = 0.5 else num = ( x0 - x1 ) * ( x2 - x1 ) + ( y0 - y1 ) * ( y2 - y1 ) denum = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) wm = num / denum end if wm = min ( wm , 1.0 ) wm = max ( wm , 0.0 ) xm = ( 1.0 - wm ) * x1 + wm * x2 ym = ( 1.0 - wm ) * y1 + wm * y2 dm = sqrt (( x0 - xm ) * ( x0 - xm ) + ( y0 - ym ) * ( y0 - ym )) end subroutine distrl subroutine distrl_sqr ( x0 , y0 , x1 , y1 , x2 , y2 , xm , ym , dm_sqr , wm ) real , intent ( in ) :: x0 !! Receptor point x-coordinate real , intent ( in ) :: y0 !! Receptor point y-coordinate real , intent ( in ) :: x1 !! Line source x-coordinate 1 real , intent ( in ) :: y1 !! Line source y-coordinate 1 real , intent ( in ) :: x2 !! Line source x-coordinate 2 real , intent ( in ) :: y2 !! Line source y-coordinate 2 real , intent ( out ) :: xm !! Minimum distance x-coordinate real , intent ( out ) :: ym !! Minimum distance y-coordinate real , intent ( out ) :: dm_sqr !! Minimum distance ! Local variables real :: num , denum , wm if ( x1 == x2 . and . y1 == y2 ) then wm = 0.5 else num = ( x0 - x1 ) * ( x2 - x1 ) + ( y0 - y1 ) * ( y2 - y1 ) denum = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) wm = num / denum end if wm = min ( wm , 1.0 ) wm = max ( wm , 0.0 ) xm = ( 1.0 - wm ) * x1 + wm * x2 ym = ( 1.0 - wm ) * y1 + wm * y2 dm_sqr = ( x0 - xm ) * ( x0 - xm ) + ( y0 - ym ) * ( y0 - ym ) end subroutine distrl_sqr subroutine nxtdat ( un , leof ) !! The subroutine prepares for reading the next uncommented line of data from file integer , intent ( inout ) :: un logical , intent ( out ) :: leof ! Local variables character ( len = 256 ) :: txtstr integer :: io ! If file unit is non-positive then just return if ( un . le . 0 ) return leof = . false . ! Read lines from file do read ( un , \"(a)\" , iostat = io ) txtstr if ( io /= 0 ) then leof = . true . exit else if ( txtstr ( 1 : 1 ) == \"*\" . or . txtstr ( 1 : 1 ) == \"{\" . or . txtstr ( 1 : 1 ) == \"#\" ) then cycle else backspace ( un ) exit end if end if end do end subroutine nxtdat subroutine ll2utm ( iutm , isone_in , lat , lon , utmn , utme ) integer , intent ( in ) :: iutm !! UTM coordinate system indicator integer , intent ( in ) :: isone_in !! UTM zone input? real , intent ( in ) :: lat !! Latitude in decimal degrees real , intent ( in ) :: lon !! Longitude in decimal degress real , intent ( out ) :: utmn !! UTM east-coordinate (y) (meter from west border) real , intent ( out ) :: utme !! UTM north-coordinate (x) (meter from equator) ! Local variables and parameters real :: isone ! UTM zone real ( dp ), parameter :: deast = 50000 0.0 ! East movement UTM real ( dp ), parameter :: scale = 0.9996 ! Scale UTM real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: latv ! Scaled latitude real ( dp ) :: lonv ! Scaled longitude real ( dp ) :: lon0 ! Central meridian of UTM zone real ( dp ) :: b , e , e2 , m , n ! Intermediate values select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! Scale coordinates isone = abs ( isone_in ) latv = lat * pi / 18 0.0 lon0 = real ( isone - 3 0.0 ) * 6.0 - 3.0 lonv = ( lon - lon0 ) * pi / 18 0.0 ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) n = a / dsqrt ( 1.0 - e2 * dsin ( latv ) * dsin ( latv )) e = dsqrt ( e2 * dcos ( latv ) * dcos ( latv ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) b = (( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * latv & - ( 3.0 * f / 4.0 - 3.0 * f * f * f / 12 8.0 ) * dsin ( 2.0 * latv ) & + ( 1 5.0 * f * f / 6 4.0 + 1 5.0 * f * f * f / 12 8.0 ) * dsin ( 4.0 * latv ) & - ( 3 5.0 * f * f * f / 38 4.0 ) * dsin ( 6.0 * latv )) * a ! Calculate UTM north coordinate utmn = ( b + lonv * lonv * n * dsin ( latv ) * dcos ( latv ) / 2.0 & + lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - dtan ( latv ) * dtan ( latv ) + 9.0 * e * e + 4.0 * e * e * e * e ) & / 2 4.0 + lonv * lonv * lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 6 1.0 - 5 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) & / 72 0.0 ) * scale if ( lat < 0.0 ) then utmn = utmn + 1000000 0.0 end if ! Calculate UTM east coordinate utme = ( lonv * n * dcos ( latv ) & + lonv * lonv * lonv * n * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 1.0 - dtan ( latv ) * dtan ( latv ) + e * e ) / 6.0 & + lonv * lonv * lonv * lonv * lonv * n & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - 1 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) / 12 0.0 ) & * scale + deast end subroutine ll2utm subroutine ll2ltm ( iutm , lon0 , lat , lon , utmn , utme ) !! Local lon version (of ll2utm) without zone, so just typical Transverse !! Mecantor (Local Transverse Mecantor) integer , intent ( in ) :: iutm !! UTM coordinate system indicator real , intent ( in ) :: lon0 !! Central meridian of UTM zone real , intent ( in ) :: lat !! Latitude in decimal degrees real , intent ( in ) :: lon !! Longitude in decimal degrees real , intent ( out ) :: utmn !! UTM north-coordinate (x) (meter from equator) real , intent ( out ) :: utme !! UTM  east-coordinate (y) (meter from west border) ! Local variables and paramters real ( dp ), parameter :: deast = 50000 0.0 ! East movement UTM real ( dp ), parameter :: scale = 0.9996 ! Scale UTM real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: latv ! Scaled latitude real ( dp ) :: lonv ! Scaled longitude real ( dp ) :: b , e , e2 , m , n ! Intermediate values select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! Scale coordinates latv = lat * pi / 18 0.0 lonv = ( lon - lon0 ) * pi / 18 0.0 ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) n = a / dsqrt ( 1.0 - e2 * dsin ( latv ) * dsin ( latv )) e = dsqrt ( e2 * dcos ( latv ) * dcos ( latv ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) b = (( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * latv & - ( 3.0 * f / 4.0 - 3.0 * f * f * f / 12 8.0 ) * dsin ( 2.0 * latv ) & + ( 1 5.0 * f * f / 6 4.0 + 1 5.0 * f * f * f / 12 8.0 ) * dsin ( 4.0 * latv ) & - ( 3 5.0 * f * f * f / 38 4.0 ) * dsin ( 6.0 * latv )) * a ! Calculate UTM north coordinate utmn = ( b + lonv * lonv * n * dsin ( latv ) * dcos ( latv ) / 2.0 & + lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - dtan ( latv ) * dtan ( latv ) + 9.0 * e * e + 4.0 * e * e * e * e ) & / 2 4.0 + lonv * lonv * lonv * lonv * lonv * lonv * n * dsin ( latv ) & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 6 1.0 - 5 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) & / 72 0.0 ) * scale if ( lat < 0.0 ) then utmn = utmn + 1000000 0.0 end if ! Calculate UTM east coordinate utme = ( lonv * n * dcos ( latv ) & + lonv * lonv * lonv * n * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 1.0 - dtan ( latv ) * dtan ( latv ) + e * e ) / 6.0 & + lonv * lonv * lonv * lonv * lonv * n & * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) * dcos ( latv ) & * ( 5.0 - 1 8.0 * dtan ( latv ) * dtan ( latv ) & + dtan ( latv ) * dtan ( latv ) * dtan ( latv ) * dtan ( latv )) / 12 0.0 ) & * scale + deast end subroutine ll2ltm subroutine utm2ll ( iutm , isone_in , utmn_in , utme , lat , lon ) !! The subroutine converts UTM north- and east-coordinates to latitude !! and longitude integer , intent ( in ) :: iutm !! UTM coordinate system indicator integer , intent ( in ) :: isone_in !! UTM zone real , intent ( in ) :: utmn_in !! UTM north-coordinate (X) (meter from equator) real , intent ( in ) :: utme !! UTM  east-coordinate (Y) (meter from west border) real , intent ( out ) :: lat !! Latitude in decimal degrees real , intent ( out ) :: lon !! Longitude in decimal degrees ! Local variables and parameters integer :: isone real :: utmn ! UTM north-coordinate real ( dp ), parameter :: deast = 50000 0.0 real ( dp ), parameter :: scale = 0.9996 real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: la0 ! Tangeringsmeridian real ( dp ) :: x ! Scaled north-coordinate real ( dp ) :: y ! Scaled east-coordinate real ( dp ) :: bb0 , e , e2 , fi , m , n ! Intermediate value select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! Adjust for southern hemisphere, specified by negative isone_in if ( isone_in < 0 ) then utmn = utmn_in - 1000000 0.0 else utmn = utmn_in end if isone = abs ( isone_in ) ! Scale coordinates x = utmn / scale y = ( utme - deast ) / scale la0 = real ( isone - 30 ) * 6.0 - 3.0 ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) bb0 = ( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * a fi = x / bb0 & + ( 3.0 * f / 4.0 + 3.0 * f * f / 8.0 + 2 1.0 * f * f * f / 25 6.0 ) * dsin ( 2.0 * x / bb0 ) & + ( 2 1.0 * f * f / 6 4.0 + 2 1.0 * f * f * f / 6 4.0 ) * dsin ( 4.0 * x / bb0 ) & + ( 15 1.0 * f * f * f / 76 8.0 ) * dsin ( 6.0 * x / bb0 ) n = a / dsqrt ( 1.0 - e2 * dsin ( fi ) * dsin ( fi )) e = dsqrt ( e2 * dcos ( fi ) * dcos ( fi ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) ! Calculate latitude and longitude in radians lat = fi - ( y * y * dtan ( fi )) / ( 2.0 * m * n ) & + ( y * y * y * y * dtan ( fi )) / ( 2 4.0 * m * n * n * n ) & * ( 5.0 + 3.0 * dtan ( fi ) * dtan ( fi ) + e * e & - 9.0 * e * e * dtan ( fi ) * dtan ( fi ) - 4.0 * e * e * e * e ) & - ( y * y * y * y * y * y * dtan ( fi )) / ( 72 0.0 * m * n * n * n * n * n ) & * ( 6 1.0 + 9 0.0 * dtan ( fi ) * dtan ( fi ) & + 4 5.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi )) lon = y / ( n * dcos ( fi )) & - ( y * y * y * ( 1.0 + 2.0 * dtan ( fi ) * dtan ( fi ) + e * e )) & / ( 6.0 * n * n * n * dcos ( fi )) & + ( y * y * y * y * y * ( 5.0 + 2 8.0 * dtan ( fi ) * dtan ( fi ) & + 2 4.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi ))) & / ( 12 0.0 * n * n * n * n * n * dcos ( fi )) + la0 * pi / 18 0.0 ! Convert from radians to degrees lat = lat * 18 0.0 / pi lon = lon * 18 0.0 / pi end subroutine utm2ll subroutine ltm2ll ( iutm , isone_in , la0 , utmn_in , utme , lat , lon ) !! Local Transverse Mecantor version of utm2ll integer , intent ( in ) :: iutm !! UTM coordinate system indicator integer , intent ( in ) :: isone_in !! UTM zone real , intent ( in ) :: la0 !! Tangeringsmeridian real , intent ( in ) :: utmn_in !! UTM north-coordinate (X) (meter from equator) real , intent ( in ) :: utme !! UTM  east-coordinate (Y) (meter from west border) real , intent ( out ) :: lat !! Latitude in decimal degrees real , intent ( out ) :: lon !! Longitude in decimal degrees ! Local variables and parameters integer :: isone real :: utmn ! UTM north-coordinate real ( dp ), parameter :: deast = 50000 0.0 real ( dp ), parameter :: scale = 0.9996 real ( dp ) :: a ! Big semiaxis real ( dp ) :: f ! Flattening real ( dp ) :: x ! Scaled north-coordinate real ( dp ) :: y ! Scaled east-coordinate real ( dp ) :: bb0 , e , e2 , fi , m , n ! Intermediate values select case ( iutm ) case ( 1 ) ! UTM WGS84 EUREF 89 (AirQUIS) a = 637813 7.0 f = 1.0 / 29 8.257222101 case ( 2 ) ! UTM WGS84 OLD a = 637813 7.0 f = 1.0 / 29 8.257223563 case ( 3 ) ! UTM ED50 a = 637838 8.0 f = 1.0 / 29 7.0 case default print * , \"ERROR: Unknown UTM coordinate system indictor, iutm: \" , iutm stop 1 end select ! djust for Southern Hemisphere, specified by negative isone_in if ( isone_in < 0 ) then utmn = utmn_in - 1000000 0.0 else utmn = utmn_in end if isone = abs ( isone_in ) ! Scale coordinates x = utmn / scale y = ( utme - deast ) / scale ! Calculate some intermediate quantities e2 = f * ( 2.0 - f ) bb0 = ( 1.0 - f / 2.0 + f * f / 1 6.0 + f * f * f / 3 2.0 ) * a fi = x / bb0 & + ( 3.0 * f / 4.0 + 3.0 * f * f / 8.0 + 2 1.0 * f * f * f / 25 6.0 ) * dsin ( 2.0 * x / bb0 ) & + ( 2 1.0 * f * f / 6 4.0 + 2 1.0 * f * f * f / 6 4.0 ) * dsin ( 4.0 * x / bb0 ) & + ( 15 1.0 * f * f * f / 76 8.0 ) * dsin ( 6.0 * x / bb0 ) n = a / dsqrt ( 1.0 - e2 * dsin ( fi ) * dsin ( fi )) e = dsqrt ( e2 * dcos ( fi ) * dcos ( fi ) / ( 1.0 - e2 )) m = n / ( 1.0 + e * e ) ! Calculate latitude and longitude in radians lat = fi - ( y * y * dtan ( fi )) / ( 2.0 * m * n ) & + ( y * y * y * y * dtan ( fi )) / ( 2 4.0 * m * n * n * n ) & * ( 5.0 + 3.0 * dtan ( fi ) * dtan ( fi ) + e * e & - 9.0 * e * e * dtan ( fi ) * dtan ( fi ) - 4.0 * e * e * e * e ) & - ( y * y * y * y * y * y * dtan ( fi )) / ( 72 0.0 * m * n * n * n * n * n ) & * ( 6 1.0 + 9 0.0 * dtan ( fi ) * dtan ( fi ) & + 4 5.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi )) lon = y / ( n * dcos ( fi )) & - ( y * y * y * ( 1.0 + 2.0 * dtan ( fi ) * dtan ( fi ) + e * e )) & / ( 6.0 * n * n * n * dcos ( fi )) & + ( y * y * y * y * y * ( 5.0 + 2 8.0 * dtan ( fi ) * dtan ( fi ) & + 2 4.0 * dtan ( fi ) * dtan ( fi ) * dtan ( fi ) * dtan ( fi ))) & / ( 12 0.0 * n * n * n * n * n * dcos ( fi )) + la0 * pi / 18 0.0 ! Convert from radians to degrees lat = lat * 18 0.0 / pi lon = lon * 18 0.0 / PI end subroutine ltm2ll end module utility_functions","tags":"","loc":"sourcefile/utility_functions.f90.html"},{"title":"uEMEP_tiling_routines.f90 – uEMEP","text":"Source Code module tiling_routines use uemep_configuration use mod_lambert_projection , only : PROJ2LL implicit none private public :: uEMEP_set_tile_grids , uEMEP_set_region_tile_grids contains !uEMEP_tiling_routines.f90 !Routines for calculating the positions, size and resolution of the tiling regions subroutine uEMEP_set_tile_grids use uEMEP_definitions implicit none integer n_tiles_population_classes , n_tiles_traffic_classes , n_tiles_shipping_classes parameter ( n_tiles_population_classes = 5 , n_tiles_traffic_classes = 5 , n_tiles_shipping_classes = 1 ) real limit_val_tile_population ( n_tiles_population_classes ) ! data limit_val_tile_population /0.,100.,1000.,5000.,10000./ data limit_val_tile_population / 0. , 10 0. , 100 0. , 1000 0. , 10000 0. / integer :: num_tiles_with_population ( n_tiles_population_classes ) = 0 real limit_val_tile_traffic ( n_tiles_traffic_classes ) data limit_val_tile_traffic / 0. , 100 0. , 1000 0. , 10000 0. , 100000 0. / integer :: num_tiles_with_traffic ( n_tiles_traffic_classes ) = 0 real limit_val_tile_shipping ( n_tiles_shipping_classes ) data limit_val_tile_shipping / 0. / integer :: num_tiles_with_shipping ( n_tiles_shipping_classes ) = 0 real tile_subgrid_delta ( n_dim_index ) real tile_subgrid_min ( n_dim_index ) real tile_subgrid_max ( n_dim_index ) integer tile_subgrid_dim ( n_dim_index ) real , allocatable :: tile_subgrid (:,:,:) real , allocatable :: x_tile_subgrid (:,:) real , allocatable :: y_tile_subgrid (:,:) real , allocatable :: lon_tile_subgrid (:,:) real , allocatable :: lat_tile_subgrid (:,:) real , allocatable :: crossreference_emission_to_tile_subgrid (:,:,:,:) real , allocatable :: crossreference_population_to_tile_subgrid (:,:,:) integer , allocatable :: tile_class_subgrid (:,:) integer , allocatable :: tile_municipality_subgrid (:,:) real , allocatable :: aggregated_tile_subgrid (:,:,:) real , allocatable :: aggregated_x_tile_subgrid (:,:,:) real , allocatable :: aggregated_y_tile_subgrid (:,:,:) integer , allocatable :: aggregated_tile_class_subgrid (:,:,:) integer i , j , i_class , i_tile , j_tile , i_source , k , l integer n_tile_index integer tile_population_index !,tile_municipality_index,tile_class_index character ( 256 ) temp_name , temp_str , temp_str1 integer * 8 ssb_id integer municipality_id real x_ssb , f_easting , ssb_dx , y_ssb , ssb_dy integer num_tiles_with_municipality logical exists integer unit_in integer count , index_val integer num_tile_classes ( 10 ) real resolution_tile_classes ( 10 ) character ( 8 ) count_str integer :: unit_tile = 21 real population_tile_scale integer reduce_grid_class real aggregation_tile_scale ( 10 ) integer n_aggregated_tiles !parameter (n_aggregated_tiles=4) !40to5km !parameter (n_aggregated_tiles=5) !160to10km parameter ( n_aggregated_tiles = 1 ) !make_100km_files real aggregated_tile_subgrid_delta ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_min ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_max ( n_dim_index , n_aggregated_tiles ) integer aggregated_tile_subgrid_dim ( n_dim_index , n_aggregated_tiles ) integer count_tile_class ( 4 ) integer i_tile_class ( 4 ) integer j_tile_class ( 4 ) logical :: use_aggregated_tiling = . true . logical :: save_as_seperate_files = . true . integer sum_count , max_count integer count_class ( n_aggregated_tiles , 10 ) logical OK integer max_counter , zero_counter logical :: make_100km_files = . true . integer n_search parameter ( n_search = 5 ) character ( 16 ) search_str ( n_search ) real search_delta ( n_search ) integer temp_search integer :: io data search_str / '1000m' , '500m' , '250m' , '100m' , '50m' / data search_delta / 100 0. , 50 0. , 25 0. , 10 0. , 5 0. / write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating tile distribution and resolution (uEMEP_set_tile_grids)' write ( unit_logfile , '(A)' ) '================================================================' !Set tile index values n_tile_index = n_source_index + 1 tile_population_index = n_source_index + 1 !tile_municipality_index=n_source_index+2 !tile_class_index=n_source_index+3 !Reduce size of grids at and above this value reduce_grid_class = 6 !Set to 6 does not reduce !Specify the tiling region to cover all of Norway population_tile_scale = 1. !For 10 km !population_tile_scale=3. !For 20 km population_tile_scale = 0.625 !For 5 km, to give 250 people /km&#94;2 tile_subgrid_min ( x_dim_index ) =- 7000 0. - 40000 tile_subgrid_min ( y_dim_index ) = 644000 0. - 40000 tile_subgrid_max ( x_dim_index ) = 111000 0. + 4000 0. tile_subgrid_max ( y_dim_index ) = 795000 0. + 4000 0. if ( make_100km_files ) then tile_subgrid_min ( x_dim_index ) =- 7000 0. - 30000 tile_subgrid_max ( x_dim_index ) = 111000 0. + 15000 0. tile_subgrid_min ( y_dim_index ) = 644000 0. - 40000 tile_subgrid_max ( y_dim_index ) = 795000 0. + 5000 0. endif !40to5km tile class population_tile_scale = 0.5 !For 5 km, to give 200 people /km&#94;2 tile_subgrid_delta ( x_dim_index ) = 500 0. tile_subgrid_delta ( y_dim_index ) = 500 0. !160to10 km tile classs population_tile_scale = 1. tile_subgrid_delta ( x_dim_index ) = 1000 0. tile_subgrid_delta ( y_dim_index ) = 1000 0. if ( make_100km_files ) then tile_subgrid_delta ( x_dim_index ) = 10000 0. tile_subgrid_delta ( y_dim_index ) = 10000 0. endif limit_val_tile_population = limit_val_tile_population * population_tile_scale !Set all tile subgrids relative to the target subgrid tile_subgrid_dim ( x_dim_index ) = floor (( tile_subgrid_max ( x_dim_index ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition tile_subgrid_dim ( y_dim_index ) = floor (( tile_subgrid_max ( y_dim_index ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition tile_subgrid_dim ( t_dim_index ) = 1 !Not used !aggregation_tile_scale if ( n_aggregated_tiles . eq . 5 ) then !Not in use aggregation_tile_scale ( 1 ) = 1 6. aggregation_tile_scale ( 2 ) = 8. aggregation_tile_scale ( 3 ) = 4. aggregation_tile_scale ( 4 ) = 2. aggregation_tile_scale ( 5 ) = 1. elseif ( n_aggregated_tiles . eq . 4 ) then aggregation_tile_scale ( 1 ) = 8. aggregation_tile_scale ( 2 ) = 4. aggregation_tile_scale ( 3 ) = 2. aggregation_tile_scale ( 4 ) = 1. elseif ( n_aggregated_tiles . eq . 3 ) then aggregation_tile_scale ( 1 ) = 4. aggregation_tile_scale ( 2 ) = 2. aggregation_tile_scale ( 3 ) = 1. elseif ( n_aggregated_tiles . eq . 1 ) then aggregation_tile_scale ( 1 ) = 1. endif do k = 1 , n_aggregated_tiles aggregated_tile_subgrid_min (:, k ) = tile_subgrid_min (:) aggregated_tile_subgrid_max (:, k ) = tile_subgrid_max (:) aggregated_tile_subgrid_delta (:, k ) = tile_subgrid_delta (:) * aggregation_tile_scale ( k ) aggregated_tile_subgrid_dim ( x_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( x_dim_index , k ) - aggregated_tile_subgrid_min ( x_dim_index , k )) / aggregated_tile_subgrid_delta ( x_dim_index , k )) aggregated_tile_subgrid_dim ( y_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( y_dim_index , k ) - aggregated_tile_subgrid_min ( y_dim_index , k )) / aggregated_tile_subgrid_delta ( y_dim_index , k )) enddo !Allocate tile subgrids if (. not . allocated ( tile_subgrid )) allocate ( tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_tile_index )) if (. not . allocated ( x_tile_subgrid )) allocate ( x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_tile_subgrid )) allocate ( y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_tile_subgrid )) allocate ( lon_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_tile_subgrid )) allocate ( lat_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( crossreference_emission_to_tile_subgrid )) allocate ( crossreference_emission_to_tile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) if (. not . allocated ( crossreference_population_to_tile_subgrid )) allocate ( crossreference_population_to_tile_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ), 2 )) if (. not . allocated ( tile_class_subgrid )) allocate ( tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( tile_municipality_subgrid )) allocate ( tile_municipality_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( aggregated_tile_subgrid )) allocate ( aggregated_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_x_tile_subgrid )) allocate ( aggregated_x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_y_tile_subgrid )) allocate ( aggregated_y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_tile_class_subgrid )) allocate ( aggregated_tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) !Set to 0 all tile values tile_subgrid = 0. tile_municipality_subgrid = 0 tile_class_subgrid = 0 !Read in SSB file containing gridded municipality ids !ssb_dx=1000. !ssb_dy=1000. f_easting = 2.e6 !Search file name to define the grid size ssb_dx = 0. ssb_dy = 0. do k = 1 , n_search temp_search = index ( filename_population ( municipality_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality masking data with resolution ' // trim ( adjustl ( search_str ( k ))) endif enddo if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( municipality_index )) stop else write ( unit_logfile , '(A,2f12.2)' ) 'Setting municipality SSB grid size (x,y) = ' , ssb_dx , ssb_dy endif pathfilename_population ( municipality_index ) = trim ( pathname_population ( municipality_index )) // trim ( filename_population ( municipality_index )) !Test existence of the filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( municipality_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file with municipality IDs does not exist: ' , trim ( pathfilename_population ( municipality_index )) stop endif temp_name = pathfilename_population ( municipality_index ) !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB municipality file ' // trim ( temp_name ) rewind ( unit_in ) !Read header SSBID0250M;kommunenum read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 do ssb_id = 0 ; municipality_id = 0 !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id read ( temp_str , * ) municipality_id count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ssb_id,municipality_id !Convert id to grid centre coordinates that are already in UTM33 for SSB data x_ssb = floor ( ssb_id / 1000000 0. ) - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. !Find the tile this ssb grid is in i_tile = 1 + floor (( x_ssb - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition j_tile = 1 + floor (( y_ssb - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition !Add the municipality id to give the grid a value if ( municipality_id . gt . 0 ) then tile_municipality_subgrid ( i_tile , j_tile ) = tile_municipality_subgrid ( i_tile , j_tile ) + municipality_id endif enddo close ( unit_in ) !Determine tile subgrid do j = 1 , tile_subgrid_dim ( y_dim_index ) do i = 1 , tile_subgrid_dim ( x_dim_index ) x_tile_subgrid ( i , j ) = tile_subgrid_min ( x_dim_index ) + tile_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) !New definition y_tile_subgrid ( i , j ) = tile_subgrid_min ( y_dim_index ) + tile_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !New definition call PROJ2LL ( x_tile_subgrid ( i , j ), y_tile_subgrid ( i , j ), lon_tile_subgrid ( i , j ), lat_tile_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon !if (EMEP_projection_type.eq.LCC_projection_index) then !    call lb2lambert2_uEMEP(xproj_tile_subgrid(i,j),yproj_tile_subgrid(i,j),lon_tile_subgrid(i,j),lat_tile_subgrid(i,j),EMEP_projection_attributes) !else !    xproj_tile_subgrid(i,j)=lon_tile_subgrid(i,j) !    yproj_tile_subgrid(i,j)=lat_tile_subgrid(i,j) !endif enddo enddo !Determine the aggregated tile subgrids, in UTM only do k = 1 , n_aggregated_tiles do j = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) aggregated_x_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( x_dim_index , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) * ( i - 0.5 ) aggregated_y_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( y_dim_index , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) * ( j - 0.5 ) enddo enddo enddo !Create a cross reference grid do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo endif enddo do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_population_subgrid ( i , j ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_population_subgrid ( i , j ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo !Calculate the population within each tile do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) i_tile = crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) j_tile = crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) tile_subgrid ( i_tile , j_tile , tile_population_index ) = tile_subgrid ( i_tile , j_tile , tile_population_index ) + population_subgrid ( i , j , population_data_type ) enddo enddo !Calculate the veh.km within each tile i_source = traffic_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) tile_subgrid ( i_tile , j_tile , traffic_index ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) / 100 0. !ADT*km enddo enddo !Calculate the shipping emissions within each tile i_source = shipping_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) tile_subgrid ( i_tile , j_tile , i_source ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) !emission for the time period enddo enddo !Write summary results num_tiles_with_municipality = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) num_tiles_with_municipality = num_tiles_with_municipality + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'MUNICIPALITY TILE: ' , num_tiles_with_municipality !Write summary results num_tiles_with_population = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_population_classes - 1 if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( i_class + 1 )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo i_class = n_tiles_population_classes if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_population_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' -' , limit_val_tile_population ( i_class + 1 ), num_tiles_with_population ( i_class ) enddo i_class = n_tiles_population_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' <' , ' ' , num_tiles_with_population ( i_class ) !Write summary results num_tiles_with_traffic = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_traffic_classes - 1 if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( i_class + 1 )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo i_class = n_tiles_traffic_classes if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_traffic_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' -' , limit_val_tile_traffic ( i_class + 1 ), num_tiles_with_traffic ( i_class ) enddo i_class = n_tiles_traffic_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' <' , ' ' , num_tiles_with_traffic ( i_class ) !Write summary results num_tiles_with_shipping = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_subgrid ( i_tile , j_tile , shipping_index ). gt . limit_val_tile_shipping ( 1 )) num_tiles_with_shipping ( 1 ) = num_tiles_with_shipping ( 1 ) + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'SHIPPING TILE: ' , num_tiles_with_shipping ( 1 ) num_tile_classes = 0 !Class 1: 500 m. No emissions at all so interpolated, irrespective of population !Class 2: 250 m. Shipping emissions > 0 and Traffic < 1000 (1) or (population < 1000 and Traffic < 10000 (2)) !Class 3: 125 m. Traffic < 10000 (2) or (population > 1000 (2) population < 5000 (2) !Class 4: 50 m. Traffic > 10000 (2) and population > 5000 (3) tile_class_subgrid = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) !Only choose tiles that are part of a municipality if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) then tile_class_subgrid ( i_tile , j_tile ) = 1 if ( tile_subgrid ( i_tile , j_tile , shipping_index ). le . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 1 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 2 )) then tile_class_subgrid ( i_tile , j_tile ) = 1 !No sources and population less than 100 elseif ( tile_subgrid ( i_tile , j_tile , shipping_index ). ge . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). ge . limit_val_tile_population ( 1 )) then tile_class_subgrid ( i_tile , j_tile ) = 2 !Little traffic but any shipping and any population elseif (( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 )). or . & ( tile_subgrid ( i_tile , j_tile , traffic_index ). ge . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 ))) then tile_class_subgrid ( i_tile , j_tile ) = 3 !Population from 1000 to 5000 or road traffic elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 4 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 10000 elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 100000 endif if ( make_100km_files ) then if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) then tile_class_subgrid ( i_tile , j_tile ) = 1 endif endif num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) = num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) + 1 endif enddo enddo write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 1 (500m): ' , num_tile_classes ( 1 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 2 (250m): ' , num_tile_classes ( 2 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 3 (125m): ' , num_tile_classes ( 3 ) if ( reduce_grid_class . eq . 4 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) endif if ( reduce_grid_class . eq . 5 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) endif resolution_tile_classes ( 1 ) = 50 0. resolution_tile_classes ( 2 ) = 25 0. resolution_tile_classes ( 3 ) = 12 5. resolution_tile_classes ( 4 ) = 5 0. resolution_tile_classes ( 5 ) = 2 5. if ( make_100km_files ) then resolution_tile_classes ( 1 ) = 10 0. endif !Preallocate the smallest aggregated tiles with the calculated tile value aggregated_tile_class_subgrid = 0 aggregated_tile_class_subgrid (:,:, n_aggregated_tiles ) = tile_class_subgrid !Aggregate tiles. Using classes of 2, 3 and 4 only do k = n_aggregated_tiles - 1 , 1 , - 1 do j_tile = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i_tile = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) count = 0 do j = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k + 1 ) do i = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k + 1 ) if ( aggregated_x_tile_subgrid ( i , j , k + 1 ). ge . aggregated_x_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. & . and . aggregated_x_tile_subgrid ( i , j , k + 1 ). lt . aggregated_x_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. & . and . aggregated_y_tile_subgrid ( i , j , k + 1 ). ge . aggregated_y_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. & . and . aggregated_y_tile_subgrid ( i , j , k + 1 ). lt . aggregated_y_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. ) then !.and.aggregated_tile_class_subgrid(i,j,k+1).ne.-1) then !This k+1 aggregated tile is within the k tile. Give it a class count = count + 1 count_tile_class ( count ) = aggregated_tile_class_subgrid ( i , j , k + 1 ) i_tile_class ( count ) = i j_tile_class ( count ) = j endif enddo enddo if ( count . eq . 4 ) then !4 x k+1 tiles have been found. Check if they are the same and not equal to the last tile value sum_count = sum ( count_tile_class ( 1 : count )) max_count = maxval ( count_tile_class ( 1 : count )) !if (count_tile_class(1)*count.le.sum_count.and.count_tile_class(2)*count.le.sum_count & !    .and.count_tile_class(3)*count.le.sum_count.and.count_tile_class(4)*count.le.sum_count.and.maxval(count_tile_class).lt.4) then OK = . true . max_counter = 0 zero_counter = 0 do l = 1 , count if ( count_tile_class ( l ). eq . max_count ) max_counter = max_counter + 1 if ( count_tile_class ( l ). eq . 0 ) zero_counter = zero_counter + 1 enddo do l = 1 , count !if (((count_tile_class(l).le.max_count.and.count_tile_class(l).ge.0)).and.OK.and.max_count.lt.4 & !    .and.((max_counter+zero_counter.ge.1.and.k.eq.3).or.(max_counter+zero_counter.ge.1.and.k.eq.2).or.(max_counter+zero_counter.ge.3.and.k.eq.1)) & !    .and..not.(k.eq.1.and.max_count.eq.3)) & !This does not allow 125 m to be the largest size. Removed for 160to10km if ((( count_tile_class ( l ). le . max_count . and . count_tile_class ( l ). ge . 0 )). and . OK . and . max_count . lt . 4 & . and .(( max_counter + zero_counter . ge . 1. and . k . eq . 3 ). or .( max_counter + zero_counter . ge . 1. and . k . eq . 2 ). or .( max_counter + zero_counter . ge . 3. and . k . eq . 1 )) & ) & then OK = . true . else OK = . false . endif enddo if ( OK ) then !if (count_tile_class(1).le.max_count.and.count_tile_class(2).le.max_count & !    .and.count_tile_class(3).le.max_count.and.count_tile_class(4).le.max_count.and.max_count.lt.4) then !Allocate the class to the k tile aggregated_tile_class_subgrid ( i_tile , j_tile , k ) = max_count !sum_count/count !Remove the class from the k+1 tiles do l = 1 , count aggregated_tile_class_subgrid ( i_tile_class ( l ), j_tile_class ( l ), k + 1 ) =- 1 enddo !write(*,*)  'Count is 4 and using' else !write(*,*)  'Count is 4 and not using' aggregated_tile_class_subgrid ( i_tile , j_tile , k ) =- 1 endif else !write(*,*) 'Can not find k+1 tiles',count endif enddo enddo enddo !Save results in a single file if (. not . use_aggregated_tiling ) then temp_name = trim ( pathname_tiles ) // trim ( filename_tiles ) write ( unit_logfile , '(a,2a)' ) 'Saving to: ' , trim ( temp_name ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) count = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )). gt . 0 ) then if ( tile_class_subgrid ( i_tile , j_tile ). lt . reduce_grid_class ) then count = count + 1 !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. else !Divide into 4 lesser grids do j = 0 , 1 do i = 0 , 1 count = count + 1 !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * i write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * j write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * ( i - 1. ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * ( j - 1. ) enddo enddo endif endif enddo enddo close ( unit_tile ) !Save results in multiple files if ( save_as_seperate_files ) then count = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )). gt . 0 ) then if ( tile_class_subgrid ( i_tile , j_tile ). lt . reduce_grid_class ) then count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. close ( unit_tile ) else !Divide into 4 lesser grids do j = 0 , 1 do i = 0 , 1 count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * i write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) - tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * j write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , x_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( x_dim_index ) / 2. + tile_subgrid_delta ( x_dim_index ) / 2. * ( i - 1. ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , y_tile_subgrid ( i_tile , j_tile ) + tile_subgrid_delta ( y_dim_index ) / 2. + tile_subgrid_delta ( y_dim_index ) / 2. * ( j - 1. ) close ( unit_tile ) enddo enddo endif endif enddo enddo endif write ( unit_logfile , '(a,i)' ) 'Tiles before aggregation: ' , count endif if ( use_aggregated_tiling ) then temp_name = trim ( pathname_tiles ) // trim ( filename_tiles ) write ( unit_logfile , '(a,2a)' ) 'Saving to: ' , trim ( temp_name ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) count = 0 do k = 1 , n_aggregated_tiles count_class ( k ,:) = 0 do j_tile = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i_tile = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) !if (num_tile_classes(tile_class_subgrid(i_tile,j_tile)).gt.0) then if ( aggregated_tile_class_subgrid ( i_tile , j_tile , k ). gt . 0 ) then count = count + 1 !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. count_class ( k , aggregated_tile_class_subgrid ( i_tile , j_tile , k )) = count_class ( k , aggregated_tile_class_subgrid ( i_tile , j_tile , k )) + 1 endif !endif enddo enddo write ( unit_logfile , '(a,i,f12.2)' ) 'TILE SIZE: ' , k , aggregated_tile_subgrid_delta ( x_dim_index , k ) / 100 0. write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 1 (500m): ' , count_class ( k , 1 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 2 (250m): ' , count_class ( k , 2 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 3 (125m): ' , count_class ( k , 3 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , count_class ( k , 4 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , count_class ( k , 5 ) enddo close ( unit_tile ) !Save results in multiple files if ( save_as_seperate_files ) then count = 0 do k = 1 , n_aggregated_tiles do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( aggregated_tile_class_subgrid ( i_tile , j_tile , k ). gt . 0 ) then count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , resolution_tile_classes ( aggregated_tile_class_subgrid ( i_tile , j_tile , k )) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) - aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , aggregated_x_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) / 2. write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , aggregated_y_tile_subgrid ( i_tile , j_tile , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) / 2. close ( unit_tile ) endif enddo enddo enddo endif endif write ( unit_logfile , '(a,i)' ) 'Tiles saved: ' , count write ( unit_logfile , '(a)' ) ' Stopping after calculating tiles' stop end subroutine uEMEP_set_tile_grids subroutine uEMEP_set_region_tile_grids !This routine creates the tile files for regions/municipalities !It is based on the variable tile make 'uEMEP_set_tile_grids' so has a lot of unused code in it !It basically reads the masking file, in SSB coordinates, and then finds the extent of this to create municipality tile limits and various resolutions use uEMEP_definitions implicit none integer n_tiles_population_classes , n_tiles_traffic_classes , n_tiles_shipping_classes parameter ( n_tiles_population_classes = 5 , n_tiles_traffic_classes = 5 , n_tiles_shipping_classes = 1 ) real limit_val_tile_population ( n_tiles_population_classes ) data limit_val_tile_population / 0. , 10 0. , 100 0. , 1000 0. , 10000 0. / integer :: num_tiles_with_population ( n_tiles_population_classes ) = 0 real limit_val_tile_traffic ( n_tiles_traffic_classes ) data limit_val_tile_traffic / 0. , 100 0. , 1000 0. , 10000 0. , 100000 0. / integer :: num_tiles_with_traffic ( n_tiles_traffic_classes ) = 0 real limit_val_tile_shipping ( n_tiles_shipping_classes ) data limit_val_tile_shipping / 0. / integer :: num_tiles_with_shipping ( n_tiles_shipping_classes ) = 0 real tile_subgrid_delta ( n_dim_index ) real tile_subgrid_min ( n_dim_index ) real tile_subgrid_max ( n_dim_index ) integer tile_subgrid_dim ( n_dim_index ) real , allocatable :: tile_subgrid (:,:,:) real , allocatable :: x_tile_subgrid (:,:) real , allocatable :: y_tile_subgrid (:,:) real , allocatable :: lon_tile_subgrid (:,:) real , allocatable :: lat_tile_subgrid (:,:) real , allocatable :: crossreference_emission_to_tile_subgrid (:,:,:,:) real , allocatable :: crossreference_population_to_tile_subgrid (:,:,:) integer , allocatable :: tile_class_subgrid (:,:) integer , allocatable :: tile_municipality_subgrid (:,:) real , allocatable :: aggregated_tile_subgrid (:,:,:) real , allocatable :: aggregated_x_tile_subgrid (:,:,:) real , allocatable :: aggregated_y_tile_subgrid (:,:,:) integer , allocatable :: aggregated_tile_class_subgrid (:,:,:) integer i , j , i_class , i_tile , j_tile , i_source , k integer n_tile_index integer tile_population_index !,tile_municipality_index,tile_class_index character ( 256 ) temp_name , temp_str , temp_str1 integer * 8 ssb_id integer municipality_id real x_ssb , f_easting , ssb_dx , y_ssb , ssb_dy integer num_tiles_with_municipality logical exists integer unit_in integer count , index_val integer num_tile_classes ( 10 ) real resolution_tile_classes ( 10 ) character ( 8 ) count_str integer :: unit_tile = 21 real population_tile_scale integer reduce_grid_class real aggregation_tile_scale ( 10 ) integer n_aggregated_tiles parameter ( n_aggregated_tiles = 4 ) !40to5km !parameter (n_aggregated_tiles=5) !160to10km integer dim_region_tiles parameter ( dim_region_tiles = 500 ) integer internal_region_index ( dim_region_tiles ), internal_region_id ( dim_region_tiles ) character ( 256 ) internal_region_name ( dim_region_tiles ) integer n_region_tiles real tile_region_min ( dim_region_tiles , n_dim_index ), tile_region_max ( dim_region_tiles , n_dim_index ) real aggregated_tile_subgrid_delta ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_min ( n_dim_index , n_aggregated_tiles ) real aggregated_tile_subgrid_max ( n_dim_index , n_aggregated_tiles ) integer aggregated_tile_subgrid_dim ( n_dim_index , n_aggregated_tiles ) logical :: save_as_seperate_files = . true . integer n_search parameter ( n_search = 5 ) character ( 16 ) search_str ( n_search ) real search_delta ( n_search ) integer temp_search integer :: io data search_str / '_1000m' , '_500m' , '_250m' , '_100m' , '_50m' / data search_delta / 100 0. , 50 0. , 25 0. , 10 0. , 5 0. / write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating regional tile distribution and resolution (uEMEP_set_region_tile_grids)' write ( unit_logfile , '(A)' ) '================================================================' !Set tile index values n_tile_index = n_source_index + 1 tile_population_index = n_source_index + 1 !tile_municipality_index=n_source_index+2 !tile_class_index=n_source_index+3 !Reduce size of grids at and above this value reduce_grid_class = 6 !Set to 6 does not reduce !Specify the tiling region to cover all of Norway population_tile_scale = 1. !For 10 km !population_tile_scale=3. !For 20 km population_tile_scale = 0.625 !For 5 km, to give 250 people /km&#94;2 tile_subgrid_min ( x_dim_index ) =- 7000 0. - 40000 tile_subgrid_min ( y_dim_index ) = 644000 0. - 40000 tile_subgrid_max ( x_dim_index ) = 111000 0. + 4000 0. tile_subgrid_max ( y_dim_index ) = 795000 0. + 4000 0. !40to5km tile class population_tile_scale = 0.5 !For 5 km, to give 200 people /km&#94;2 tile_subgrid_delta ( x_dim_index ) = 500 0. tile_subgrid_delta ( y_dim_index ) = 500 0. !Municipality tile classs population_tile_scale = 0.01 tile_subgrid_delta ( x_dim_index ) = 100 0. tile_subgrid_delta ( y_dim_index ) = 100 0. limit_val_tile_population = limit_val_tile_population * population_tile_scale !Set all tile subgrids relative to the target subgrid tile_subgrid_dim ( x_dim_index ) = floor (( tile_subgrid_max ( x_dim_index ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition tile_subgrid_dim ( y_dim_index ) = floor (( tile_subgrid_max ( y_dim_index ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition tile_subgrid_dim ( t_dim_index ) = 1 !Not used !aggregation_tile_scale if ( n_aggregated_tiles . eq . 5 ) then !Not in use aggregation_tile_scale ( 1 ) = 1 6. aggregation_tile_scale ( 2 ) = 8. aggregation_tile_scale ( 3 ) = 4. aggregation_tile_scale ( 4 ) = 2. aggregation_tile_scale ( 5 ) = 1. elseif ( n_aggregated_tiles . eq . 4 ) then aggregation_tile_scale ( 1 ) = 8. aggregation_tile_scale ( 2 ) = 4. aggregation_tile_scale ( 3 ) = 2. aggregation_tile_scale ( 4 ) = 1. elseif ( n_aggregated_tiles . eq . 3 ) then aggregation_tile_scale ( 1 ) = 4. aggregation_tile_scale ( 2 ) = 2. aggregation_tile_scale ( 3 ) = 1. endif do k = 1 , n_aggregated_tiles aggregated_tile_subgrid_min (:, k ) = tile_subgrid_min (:) aggregated_tile_subgrid_max (:, k ) = tile_subgrid_max (:) aggregated_tile_subgrid_delta (:, k ) = tile_subgrid_delta (:) * aggregation_tile_scale ( k ) aggregated_tile_subgrid_dim ( x_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( x_dim_index , k ) - aggregated_tile_subgrid_min ( x_dim_index , k )) / aggregated_tile_subgrid_delta ( x_dim_index , k )) aggregated_tile_subgrid_dim ( y_dim_index , k ) = floor (( aggregated_tile_subgrid_max ( y_dim_index , k ) - aggregated_tile_subgrid_min ( y_dim_index , k )) / aggregated_tile_subgrid_delta ( y_dim_index , k )) enddo !Allocate tile subgrids if (. not . allocated ( tile_subgrid )) allocate ( tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_tile_index )) if (. not . allocated ( x_tile_subgrid )) allocate ( x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_tile_subgrid )) allocate ( y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_tile_subgrid )) allocate ( lon_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_tile_subgrid )) allocate ( lat_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( crossreference_emission_to_tile_subgrid )) allocate ( crossreference_emission_to_tile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) if (. not . allocated ( crossreference_population_to_tile_subgrid )) allocate ( crossreference_population_to_tile_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ), 2 )) if (. not . allocated ( tile_class_subgrid )) allocate ( tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( tile_municipality_subgrid )) allocate ( tile_municipality_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ))) if (. not . allocated ( aggregated_tile_subgrid )) allocate ( aggregated_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_x_tile_subgrid )) allocate ( aggregated_x_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_y_tile_subgrid )) allocate ( aggregated_y_tile_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) if (. not . allocated ( aggregated_tile_class_subgrid )) allocate ( aggregated_tile_class_subgrid ( tile_subgrid_dim ( x_dim_index ), tile_subgrid_dim ( y_dim_index ), n_aggregated_tiles )) !Set to 0 all tile values tile_subgrid = 0. tile_municipality_subgrid = 0 tile_class_subgrid = 0 !Read in SSB file containing gridded municipality ids !ssb_dx=1000. !ssb_dy=1000. f_easting = 2.e6 !Search file name to define the grid size ssb_dx = 0. ssb_dy = 0. do k = 1 , n_search temp_search = index ( filename_population ( municipality_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality masking data with resolution ' // trim ( adjustl ( search_str ( k ))) endif enddo if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( municipality_index )) stop else write ( unit_logfile , '(A,2f12.2)' ) 'Setting municipality SSB grid size (x,y) = ' , ssb_dx , ssb_dy endif pathfilename_population ( municipality_index ) = trim ( pathname_population ( municipality_index )) // trim ( filename_population ( municipality_index )) !Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( municipality_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file with municipality IDs does not exist: ' , trim ( pathfilename_population ( municipality_index )) stop endif temp_name = pathfilename_population ( municipality_index ) !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB municipality file ' // trim ( temp_name ) rewind ( unit_in ) !Read header SSBID0250M;kommunenum read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 do ssb_id = 0 ; municipality_id = 0 !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id read ( temp_str , * ) municipality_id count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ssb_id,municipality_id !Convert id to grid centre coordinates that are already in UTM33 for SSB data x_ssb = floor ( ssb_id / 1000000 0. ) - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. !Find the tile this ssb grid is in i_tile = 1 + floor (( x_ssb - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) !New definition j_tile = 1 + floor (( y_ssb - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) !New definition !Add the municipality id to give the grid a value if ( municipality_id . gt . 0 ) then tile_municipality_subgrid ( i_tile , j_tile ) = municipality_id endif enddo close ( unit_in ) !Read municipality ID's and names pathfilename_region_id = trim ( pathname_region_id ) // trim ( filename_region_id ) !Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_region_id ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Region file with municipality IDs does not exist: ' , trim ( pathfilename_region_id ) stop endif temp_name = pathfilename_region_id !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening municipality ID file ' // trim ( temp_name ) rewind ( unit_in ) !Read header index,ID,name read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) count = 0 do count = count + 1 read ( unit_in , * , iostat = io ) internal_region_index ( count ), internal_region_id ( count ), internal_region_name ( count ) if ( io /= 0 ) exit enddo n_region_tiles = count close ( unit_in ) write ( unit_logfile , '(A,i)' ) 'Number of municipalities: ' , n_region_tiles !Determine tile subgrid do j = 1 , tile_subgrid_dim ( y_dim_index ) do i = 1 , tile_subgrid_dim ( x_dim_index ) x_tile_subgrid ( i , j ) = tile_subgrid_min ( x_dim_index ) + tile_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) !New definition y_tile_subgrid ( i , j ) = tile_subgrid_min ( y_dim_index ) + tile_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !New definition call PROJ2LL ( x_tile_subgrid ( i , j ), y_tile_subgrid ( i , j ), lon_tile_subgrid ( i , j ), lat_tile_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_tile_subgrid(i,j),x_tile_subgrid(i,j),lat_tile_subgrid(i,j),lon_tile_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon !if (EMEP_projection_type.eq.LCC_projection_index) then !    call lb2lambert2_uEMEP(xproj_tile_subgrid(i,j),yproj_tile_subgrid(i,j),lon_tile_subgrid(i,j),lat_tile_subgrid(i,j),EMEP_projection_attributes) !else !    xproj_tile_subgrid(i,j)=lon_tile_subgrid(i,j) !    yproj_tile_subgrid(i,j)=lat_tile_subgrid(i,j) !endif enddo enddo !Find grid max and min for each municipality do k = 1 , n_region_tiles tile_region_min ( k , x_dim_index ) = 1e24 tile_region_max ( k , x_dim_index ) =- 1e24 tile_region_min ( k , y_dim_index ) = 1e24 tile_region_max ( k , y_dim_index ) =- 1e24 do j = 1 , tile_subgrid_dim ( y_dim_index ) do i = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i , j ). eq . internal_region_id ( k )) then if ( x_tile_subgrid ( i , j ). lt . tile_region_min ( k , x_dim_index )) tile_region_min ( k , x_dim_index ) = x_tile_subgrid ( i , j ) if ( x_tile_subgrid ( i , j ). gt . tile_region_max ( k , x_dim_index )) tile_region_max ( k , x_dim_index ) = x_tile_subgrid ( i , j ) if ( y_tile_subgrid ( i , j ). lt . tile_region_min ( k , y_dim_index )) tile_region_min ( k , y_dim_index ) = y_tile_subgrid ( i , j ) if ( y_tile_subgrid ( i , j ). gt . tile_region_max ( k , y_dim_index )) tile_region_max ( k , y_dim_index ) = y_tile_subgrid ( i , j ) endif enddo enddo !Add or subtract ssb grid size to allow for the poor resolution and make sure all of the kommune is within the tile tile_region_min ( k , x_dim_index ) = tile_region_min ( k , x_dim_index ) - ssb_dx * 1.5 tile_region_max ( k , x_dim_index ) = tile_region_max ( k , x_dim_index ) + ssb_dx * 1.5 tile_region_min ( k , y_dim_index ) = tile_region_min ( k , y_dim_index ) - ssb_dy * 1.5 tile_region_max ( k , y_dim_index ) = tile_region_max ( k , y_dim_index ) + ssb_dy * 1.5 enddo !Determine the aggregated tile subgrids, in UTM only do k = 1 , n_aggregated_tiles do j = 1 , aggregated_tile_subgrid_dim ( y_dim_index , k ) do i = 1 , aggregated_tile_subgrid_dim ( x_dim_index , k ) aggregated_x_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( x_dim_index , k ) + aggregated_tile_subgrid_delta ( x_dim_index , k ) * ( i - 0.5 ) aggregated_y_tile_subgrid ( i , j , k ) = aggregated_tile_subgrid_min ( y_dim_index , k ) + aggregated_tile_subgrid_delta ( y_dim_index , k ) * ( j - 0.5 ) enddo enddo enddo !Create a cross reference grid do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo endif enddo do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_population_subgrid ( i , j ) - tile_subgrid_min ( x_dim_index )) / tile_subgrid_delta ( x_dim_index )) crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_population_subgrid ( i , j ) - tile_subgrid_min ( y_dim_index )) / tile_subgrid_delta ( y_dim_index )) enddo enddo !Calculate the population within each tile do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) i_tile = crossreference_population_to_tile_subgrid ( i , j , x_dim_index ) j_tile = crossreference_population_to_tile_subgrid ( i , j , y_dim_index ) if ( i_tile . gt . 0. and . j_tile . gt . 0 ) then tile_subgrid ( i_tile , j_tile , tile_population_index ) = tile_subgrid ( i_tile , j_tile , tile_population_index ) + population_subgrid ( i , j , population_data_type ) endif enddo enddo !Calculate the veh.km within each tile i_source = traffic_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) if ( i_tile . gt . 0. and . j_tile . gt . 0 ) then tile_subgrid ( i_tile , j_tile , traffic_index ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) / 100 0. !ADT*km endif enddo enddo !Calculate the shipping emissions within each tile i_source = shipping_index do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) i_tile = crossreference_emission_to_tile_subgrid ( i , j , x_dim_index , i_source ) j_tile = crossreference_emission_to_tile_subgrid ( i , j , y_dim_index , i_source ) if ( i_tile . gt . 0. and . j_tile . gt . 0 ) then tile_subgrid ( i_tile , j_tile , i_source ) = tile_subgrid ( i_tile , j_tile , i_source ) + ( proxy_emission_subgrid ( i , j , i_source , 1 )) !emission for the time period endif enddo enddo !Write summary results num_tiles_with_municipality = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) num_tiles_with_municipality = num_tiles_with_municipality + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'MUNICIPALITY TILE: ' , num_tiles_with_municipality !Write summary results num_tiles_with_population = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_population_classes - 1 if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( i_class + 1 )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo i_class = n_tiles_population_classes if ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( i_class )) num_tiles_with_population ( i_class ) = num_tiles_with_population ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_population_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' -' , limit_val_tile_population ( i_class + 1 ), num_tiles_with_population ( i_class ) enddo i_class = n_tiles_population_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'POPULATION TILE: ' , i_class , limit_val_tile_population ( i_class ), ' <' , ' ' , num_tiles_with_population ( i_class ) !Write summary results num_tiles_with_traffic = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) do i_class = 1 , n_tiles_traffic_classes - 1 if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class ) & . and . tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( i_class + 1 )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo i_class = n_tiles_traffic_classes if ( tile_subgrid ( i_tile , j_tile , traffic_index ). gt . limit_val_tile_traffic ( i_class )) num_tiles_with_traffic ( i_class ) = num_tiles_with_traffic ( i_class ) + 1 enddo enddo do i_class = 1 , n_tiles_traffic_classes - 1 write ( unit_logfile , '(a,i,f12.1,a,f12.1,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' -' , limit_val_tile_traffic ( i_class + 1 ), num_tiles_with_traffic ( i_class ) enddo i_class = n_tiles_traffic_classes write ( unit_logfile , '(a,i,f12.1,a,a12,i)' ) 'TRAFFIC TILE: ' , i_class , limit_val_tile_traffic ( i_class ), ' <' , ' ' , num_tiles_with_traffic ( i_class ) !Write summary results num_tiles_with_shipping = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) if ( tile_subgrid ( i_tile , j_tile , shipping_index ). gt . limit_val_tile_shipping ( 1 )) num_tiles_with_shipping ( 1 ) = num_tiles_with_shipping ( 1 ) + 1 enddo enddo write ( unit_logfile , '(a,i)' ) 'SHIPPING TILE: ' , num_tiles_with_shipping ( 1 ) num_tile_classes = 0 !Class 1: 500 m. No emissions at all so interpolated, irrespective of population !Class 2: 250 m. Shipping emissions > 0 and Traffic < 1000 (1) or (population < 1000 and Traffic < 10000 (2)) !Class 3: 125 m. Traffic < 10000 (2) or (population > 1000 (2) population < 5000 (2) !Class 4: 50 m. Traffic > 10000 (2) and population > 5000 (3) tile_class_subgrid = 0 do j_tile = 1 , tile_subgrid_dim ( y_dim_index ) do i_tile = 1 , tile_subgrid_dim ( x_dim_index ) !Only choose tiles that are part of a municipality if ( tile_municipality_subgrid ( i_tile , j_tile ). gt . 0 ) then tile_class_subgrid ( i_tile , j_tile ) = 1 if ( tile_subgrid ( i_tile , j_tile , shipping_index ). le . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 1 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 2 )) then tile_class_subgrid ( i_tile , j_tile ) = 1 !No sources and population less than 100 elseif ( tile_subgrid ( i_tile , j_tile , shipping_index ). ge . limit_val_tile_shipping ( 1 ). and . & tile_subgrid ( i_tile , j_tile , traffic_index ). le . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). ge . limit_val_tile_population ( 1 )) then tile_class_subgrid ( i_tile , j_tile ) = 2 !Little traffic but any shipping and any population elseif (( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 )). or . & ( tile_subgrid ( i_tile , j_tile , traffic_index ). ge . limit_val_tile_traffic ( 2 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 4 ))) then tile_class_subgrid ( i_tile , j_tile ) = 3 !Population from 1000 to 5000 or road traffic elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 4 ). and . & tile_subgrid ( i_tile , j_tile , tile_population_index ). le . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 10000 elseif ( tile_subgrid ( i_tile , j_tile , tile_population_index ). gt . limit_val_tile_population ( 5 )) then tile_class_subgrid ( i_tile , j_tile ) = 4 !Population > 100000 endif !if (tile_class_subgrid(i_tile,j_tile).eq.2) tile_class_subgrid(i_tile,j_tile)=3 num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) = num_tile_classes ( tile_class_subgrid ( i_tile , j_tile )) + 1 endif enddo enddo write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 1 (500m): ' , num_tile_classes ( 1 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 2 (250m): ' , num_tile_classes ( 2 ) write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 3 (125m): ' , num_tile_classes ( 3 ) if ( reduce_grid_class . eq . 4 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 4 ( 50m): ' , num_tile_classes ( 4 ) endif if ( reduce_grid_class . eq . 5 ) then write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) * 4 else write ( unit_logfile , '(a,i)' ) 'TILES OF CLASS 5 ( 25m): ' , num_tile_classes ( 5 ) endif resolution_tile_classes ( 1 ) = 50 0. resolution_tile_classes ( 2 ) = 25 0. resolution_tile_classes ( 3 ) = 12 5. resolution_tile_classes ( 4 ) = 5 0. resolution_tile_classes ( 5 ) = 2 5. !Save results in a single file temp_name = trim ( pathname_tiles ) // trim ( filename_tiles ) write ( unit_logfile , '(a,2a)' ) 'Saving to: ' , trim ( temp_name ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) count = 0 do k = 1 , n_region_tiles count = count + 1 write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count !write(unit_tile,'(a,i0.5)') 'tile_tag= ',count write ( unit_tile , '(a,a)' ) 'region_name= ' , trim ( internal_region_name ( count )) write ( unit_tile , '(a,i0.5)' ) 'region_id= ' , internal_region_id ( count ) write ( unit_tile , '(a,i0.5)' ) 'region_index= ' , internal_region_index ( count ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , tile_region_min ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , tile_region_min ( k , y_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , tile_region_max ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , tile_region_max ( k , y_dim_index ) enddo close ( unit_tile ) !Save results in multiple files if ( save_as_seperate_files ) then count = 0 do k = 1 , n_region_tiles count = count + 1 write ( count_str , '(i8)' ) count temp_name = trim ( pathname_tiles ) // trim ( ADJUSTL ( count_str )) // '_' // trim ( filename_tiles ) open ( unit_tile , file = temp_name , access = 'sequential' , status = 'unknown' ) write ( unit_tile , '(a,i0.5)' ) 'tile_tag= ' // trim ( save_tile_tag ) // '_' , count write ( unit_tile , '(a,a)' ) 'region_name= ' , trim ( internal_region_name ( count )) write ( unit_tile , '(a,i0.5)' ) 'region_id= ' , internal_region_id ( count ) write ( unit_tile , '(a,i0.5)' ) 'region_index= ' , internal_region_index ( count ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(x_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_delta(y_dim_index)=' , region_subgrid_delta write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(x_dim_index)=' , tile_region_min ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_min(y_dim_index)=' , tile_region_min ( k , y_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(x_dim_index)=' , tile_region_max ( k , x_dim_index ) write ( unit_tile , '(a,f12.2)' ) 'subgrid_max(y_dim_index)=' , tile_region_max ( k , y_dim_index ) close ( unit_tile ) enddo write ( unit_logfile , '(a,i)' ) 'Number of region tiles: ' , count endif write ( unit_logfile , '(a)' ) ' Stopping after calculating tiles' stop end subroutine uEMEP_set_region_tile_grids end module tiling_routines","tags":"","loc":"sourcefile/uemep_tiling_routines.f90.html"},{"title":"uEMEP_subgrid_deposition.f90 – uEMEP","text":"Source Code module subgrid_deposition use uemep_configuration use set_dispersion_parameters , only : delta_wind_direction , & uEMEP_set_dispersion_sigma_PG , uEMEP_set_dispersion_sigma_simple , & uEMEP_set_dispersion_params_PG , uEMEP_set_dispersion_params_simple use local_trajectory , only : uEMEP_calculate_all_trajectory , & uEMEP_minimum_distance_trajectory_fast use dispersion_functions , only : gauss_plume_cartesian_sigma_integral_func , & gauss_plume_cartesian_sigma_func use kz_functions , only : z_centremass_gauss_func , u_profile_neutral_val_func , & uEMEP_set_dispersion_sigma_Kz use mod_area_interpolation , only : area_weighted_interpolation_function , & area_weighted_extended_interpolation_function use mod_rargsort , only : rargsort implicit none private public :: uEMEP_subgrid_deposition contains ! uEMEP_subgrid_deposition.f90 !Calculations the dry deposition and source depletion of a plume subroutine uEMEP_subgrid_deposition ( source_index ) use uEMEP_definitions implicit none integer source_index integer i , j , ii , jj , tt , k integer i_pollutant !Define the target subgrid to be the same as the emission subgrid real , allocatable :: target_subgrid (:,:,:) real , allocatable :: target_deposition_subgrid (:,:,:,:) real , allocatable :: x_target_subgrid (:,:) real , allocatable :: y_target_subgrid (:,:) real , allocatable :: traveltime_target_subgrid (:,:,:,:) real :: target_subgrid_delta ( 2 ) integer target_subgrid_dim ( n_dim_index ) !define the temporary arrays for meteo real , allocatable :: temp_FF_subgrid (:,:) real , allocatable :: temp_FF_integral_subgrid (:,:) real , allocatable :: trajectory_vector (:,:) real , allocatable :: angle_diff (:,:) real temp_sum_subgrid ( n_pollutant_loop ) integer traj_max_index logical valid_traj real traj_step_size , x_loc , y_loc , FFgrid_loc , logz0_loc , u_star0_loc , FF10_loc , zc_loc , invL_loc real ay_loc , by_loc , az_loc , bz_loc , sig_y_0_loc , sig_z_0_loc , sig_y_00_loc , sig_z_00_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc real FF_loc , FF_zc_loc , precip_loc real FF_integral_loc integer n_plume_subgrid_max parameter ( n_plume_subgrid_max = 100000 ) integer plume_crossreference ( n_plume_subgrid_max , 2 ) real plume_distance ( n_plume_subgrid_max , 2 ) real temp_plume_distance ( n_plume_subgrid_max ) integer sorted_plume_index ( n_plume_subgrid_max ) real plume_source ( n_pollutant_loop ) integer plume_count , max_plume_count real xpos_limit , ypos_limit real distance_subgrid , distance_subgrid_min , distance_emission_subgrid_min integer i_target_start , i_target_end , j_target_start , j_target_end integer t_start , t_end integer i_cross , j_cross integer i_cross_integral , j_cross_integral integer i_cross_deposition , j_cross_deposition integer i_cross_target_integral , j_cross_target_integral integer subsource_index real subgrid_internal , subgrid_internal_integral real subgrid_internal_pollutant ( n_pollutant_loop ), drydepo_internal_pollutant ( n_pollutant_loop ), wetdepo_internal_pollutant ( n_pollutant_loop ) real drydepo_internal_integral real vertical_integral_internal , wetdepo_internal , wetdepo_internal_integral real xpos_emission_subgrid , ypos_emission_subgrid real xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min real xpos_target_subgrid , ypos_target_subgrid integer target_subgrid_dim_min ( 2 ), target_subgrid_dim_max ( 2 ) real plume_vertical_integral ( n_integral_subgrid_index ) real plume_vertical_integral_pollutant ( n_integral_subgrid_index ) real , allocatable :: target_vertical_integral_subgrid (:,:,:) integer i_integral integer count !Functions !integer rargsort(n_plume_subgrid_max) write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating deposition and dispersion (uEMEP_subgrid_deposition)' write ( unit_logfile , '(A)' ) '================================================================' !Set up the target subgrid to be the same as the emission subgrid for that source. target_subgrid_dim (:) = emission_subgrid_dim (:, source_index ) target_subgrid_delta (:) = emission_subgrid_delta (:, source_index ) !Deposition and plume depletion must be calculated also in the buffer zone if ( calculate_source_depletion_flag ) then !Need to calculate on all the grids to get the depletion target_subgrid_dim_min (:) = 1 ; target_subgrid_dim_max (:) = target_subgrid_dim ( 1 : 2 ) else !Limit the target grid to slightly larger than concentration grid target_subgrid_dim_min ( x_dim_index ) =- 1 + 1 + floor (( subgrid_min ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) target_subgrid_dim_min ( y_dim_index ) =- 1 + 1 + floor (( subgrid_min ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) target_subgrid_dim_max ( x_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( x_dim_index ) - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) target_subgrid_dim_max ( y_dim_index ) =+ 1 + 1 + ceiling (( subgrid_max ( y_dim_index ) - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) endif !Allocate the target subgrid to be the same as the emission subgrid but no time dimension if ( allocated ( target_subgrid )) deallocate ( target_subgrid ) if ( allocated ( target_deposition_subgrid )) deallocate ( target_deposition_subgrid ) if ( allocated ( x_target_subgrid )) deallocate ( x_target_subgrid ) if ( allocated ( y_target_subgrid )) deallocate ( y_target_subgrid ) if ( allocated ( traveltime_target_subgrid )) deallocate ( traveltime_target_subgrid ) if (. not . allocated ( target_subgrid )) allocate ( target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), n_pollutant_loop )) if (. not . allocated ( target_deposition_subgrid )) allocate ( target_deposition_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), n_deposition_index , n_pollutant_loop )) if (. not . allocated ( x_target_subgrid )) allocate ( x_target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_target_subgrid )) allocate ( y_target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ))) if (. not . allocated ( traveltime_target_subgrid )) allocate ( traveltime_target_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), 2 , n_pollutant_loop )) if ( adjust_wetdepo_integral_to_lowest_layer_flag . or . local_subgrid_method_flag . eq . 1 ) then if ( allocated ( target_vertical_integral_subgrid )) deallocate ( target_vertical_integral_subgrid ) if (. not . allocated ( target_vertical_integral_subgrid )) allocate ( target_vertical_integral_subgrid ( target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), 3 )) endif x_target_subgrid (:,:) = x_emission_subgrid (:,:, source_index ) y_target_subgrid (:,:) = y_emission_subgrid (:,:, source_index ) !Allocate temporary wind speed subgrid allocate ( temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( temp_FF_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) allocate ( angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) !Set the x and y position limits to coincide to half the EMEP grid (refered here as lon and lat but can be also LCC projection) times the number of grids xpos_limit = dgrid_nc ( lon_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling ypos_limit = dgrid_nc ( lat_nc_index ) / 2. * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling !Minimum distance for travel time calculation set to half of a grid diagonal weighted so the circle has the same area as the square with that diagonal distance_subgrid_min = sqrt ( subgrid_delta ( x_dim_index ) * subgrid_delta ( x_dim_index ) + subgrid_delta ( y_dim_index ) * subgrid_delta ( y_dim_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 !Minimum distance for dispersion set to  half of an emission grid diagonal weighted so the circle has the same area as the square with that diagonal distance_emission_subgrid_min = sqrt ( emission_subgrid_delta ( x_dim_index , source_index ) * emission_subgrid_delta ( x_dim_index , source_index ) & + emission_subgrid_delta ( y_dim_index , source_index ) * emission_subgrid_delta ( y_dim_index , source_index )) / 2. / sqrt ( 2. ) * 4. / 3.14159 !Set the subsource_index to 1 so no additional subsources in these routines subsource_index = 1 !Set local dispersion parameters to be used only in the annual calculation, overwritten in the hourly files !if (annual_calculations) then call uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) sig_y_00_loc = sig_y_00 ( source_index , subsource_index ) sig_z_00_loc = sig_z_00 ( source_index , subsource_index ) h_emis_loc = h_emis ( source_index , subsource_index ) z_rec_loc = z_rec ( source_index , subsource_index ) !endif write ( unit_logfile , '(a,i3)' ) 'Calculating deposition and dispersion data for ' // trim ( source_file_str ( source_index )) !Set the target grid loop variables j_target_start = 1 ; j_target_end = target_subgrid_dim ( y_dim_index ) i_target_start = 1 ; i_target_end = target_subgrid_dim ( x_dim_index ) j_target_start = target_subgrid_dim_min ( y_dim_index ); j_target_end = target_subgrid_dim_max ( y_dim_index ) i_target_start = target_subgrid_dim_min ( x_dim_index ); i_target_end = target_subgrid_dim_max ( x_dim_index ) !write(*,*) j_target_start,j_target_end,i_target_start,i_target_end !stop !Set the start and end times of the loop t_start = 1 ; t_end = subgrid_dim ( t_dim_index ) !Loop through the time do tt = t_start , t_end !Initialise the final grid to 0 subgrid (:,:, tt , proxy_subgrid_index , source_index ,:) = 0. subgrid (:,:, tt , drydepo_local_subgrid_index , source_index ,:) = 0. subgrid (:,:, tt , wetdepo_local_subgrid_index , source_index ,:) = 0. integral_subgrid (:,:, tt ,:, source_index ,:) = 0. !deposition_subgrid(:,:,tt,:,:)=0. !Initialise the target grid to 0 target_subgrid = 0. target_deposition_subgrid = 0. target_vertical_integral_subgrid = 0. !Set the last meteo data subgrid in the case when the internal time loop is used if (. not . use_single_time_loop_flag ) then if ( tt . gt . t_start ) then last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt - 1 ,:) else last_meteo_subgrid (:,:,:) = meteo_subgrid (:,:, tt ,:) endif endif !Finds the angle difference between the current and last meteo field for dispersion and implements meandering if selected do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) if ( hourly_calculations ) then call delta_wind_direction ( i_cross , j_cross , tt , meteo_subgrid ( i_cross , j_cross , tt , FF10_subgrid_index ), angle_diff ( i_cross , j_cross )) else angle_diff ( i_cross , j_cross ) = 0. endif enddo enddo !Create a temporary wind speed subgrid for each hour call uEMEP_create_wind_field ( temp_FF_subgrid , angle_diff , wind_level_flag , source_index , subsource_index , tt ) !Create an integral wind speed subgrid call uEMEP_create_wind_field ( temp_FF_integral_subgrid , angle_diff , wind_level_integral_flag , source_index , subsource_index , tt ) !Define the trajectory and its length !Maxium number of trajectory steps and size of steps based on the integral (meteorology) loop size if ( use_trajectory_flag ( source_index )) then traj_step_size = min ( integral_subgrid_delta ( x_dim_index ), integral_subgrid_delta ( y_dim_index )) * traj_step_scale traj_max_index = floor ( max ( integral_subgrid_loop_index ( x_dim_index ), integral_subgrid_loop_index ( y_dim_index )) / traj_step_scale ) if ( tt . eq . t_start ) write ( unit_logfile , '(a,f12.1,i)' ) 'Trajectory step (m) and dimensions: ' , traj_step_size , traj_max_index if (. not . allocated ( trajectory_vector )) allocate ( trajectory_vector ( traj_max_index , 2 )) endif max_plume_count = 0 !Set up the deposition target subgrid based on the emission subgrid. !This works when the deposition subgrid is larger than the target emission subgrid !When the deposition subgrid is smaller than the target then we need to take the average of the grids !This should be area weighted but is not if ( calculate_deposition_flag ) then if ( deposition_subgrid_delta ( x_dim_index ). lt . target_subgrid_delta ( x_dim_index )) then do jj = j_target_start , j_target_end do ii = i_target_start , i_target_end i_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , y_dim_index , source_index ) !i_loop_deposition=floor(target_subgrid_delta(x_dim_index)/deposition_subgrid_delta(x_dim_index)/2.) !target_deposition_subgrid(ii,jj,:,:)=target_deposition_subgrid(ii,jj,:,:)+deposition_subgrid(i_cross_deposition,j_cross_deposition,tt,:,:) !write(*,*) deposition_subgrid(i_cross_deposition,j_cross_deposition,tt,:,:) do i_pollutant = 1 , n_pollutant_loop target_deposition_subgrid ( ii , jj , vd_index , i_pollutant ) = target_deposition_subgrid ( ii , jj , vd_index , i_pollutant ) + & area_weighted_extended_interpolation_function ( x_deposition_subgrid , y_deposition_subgrid , deposition_subgrid (:,:, tt , vd_index , i_pollutant ) & , deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), deposition_subgrid_delta (:), x_target_subgrid ( ii , jj ), y_target_subgrid ( ii , jj ), target_subgrid_delta ) enddo enddo enddo else do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) i_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_deposition = crossreference_emission_to_deposition_subgrid ( ii , jj , y_dim_index , source_index ) target_deposition_subgrid ( ii , jj ,:,:) = deposition_subgrid ( i_cross_deposition , j_cross_deposition , tt ,:,:) !write(*,*) deposition_subgrid(i_cross_deposition,j_cross_deposition,tt,:,:) enddo enddo endif endif !Loop through all the emission subgrids do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index ) !Allocate temporary emission (plume source) for this grid and time plume_source (:) = emission_subgrid ( ii , jj , tt , source_index ,:) !Only calculate if there is an emissions if ( sum ( plume_source (:)). ne . 0 ) then !Calculate the trajectory for this emission source if ( use_trajectory_flag ( source_index )) then trajectory_vector = NODATA_value !Calculate the trajectory for this emission grid call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( ii , jj , source_index ), y_emission_subgrid ( ii , jj , source_index ), tt , & traj_max_index , traj_step_size , trajectory_vector (:, x_dim_index ), trajectory_vector (:, y_dim_index )) else !Create an artificial trajectory here for the straight line case by making the trajectory step size half the size of the integral grid !Not working!!!! traj_step_size = min ( integral_subgrid_max ( x_dim_index ) - integral_subgrid_min ( x_dim_index ), integral_subgrid_max ( y_dim_index ) - integral_subgrid_min ( y_dim_index )) / 2. call uEMEP_calculate_all_trajectory ( x_emission_subgrid ( ii , jj , source_index ), y_emission_subgrid ( ii , jj , source_index ), tt , & traj_max_index , traj_step_size , trajectory_vector (:, x_dim_index ), trajectory_vector (:, y_dim_index )) endif !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index ) i_cross_integral = min ( max ( 1 , i_cross_integral ), integral_subgrid_dim ( x_dim_index )) j_cross_integral = min ( max ( 1 , j_cross_integral ), integral_subgrid_dim ( y_dim_index )) !Set the local wind speed and other parameters at emission position FF_loc = temp_FF_subgrid ( i_cross_integral , j_cross_integral ) FF_integral_loc = temp_FF_integral_subgrid ( i_cross_integral , j_cross_integral ) !L_loc=1./meteo_subgrid(i_cross_integral,j_cross_integral,tt,invL_subgrid_index) invL_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , invL_subgrid_index ) FFgrid_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FFgrid_subgrid_index ) logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , logz0_subgrid_index ) u_star0_loc = max ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , ustar_subgrid_index ), ustar_min ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index ) !MORE COMPLICATED BECAUSE THE PLUME DEPLETION MUST ALSO BE CALCULATED OUTSIDE THE TARGET REGION!! !SO THE LOOP NEEDS TO BE THE EMISSION LOOP NOT JUST THE TARGET LOOP !Loop through the target grids and find the distance of each target grid along the plume centre line if ( calculate_deposition_flag . and . calculate_source_depletion_flag ) then !Set the size of the loop region around the emission cell to be up to emission_subgrid_loop_index i_target_start = max ( 1 , ii - emission_subgrid_loop_index ( x_dim_index , source_index )) i_target_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), ii + emission_subgrid_loop_index ( x_dim_index , source_index )) j_target_start = max ( 1 , jj - emission_subgrid_loop_index ( y_dim_index , source_index )) j_target_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), jj + emission_subgrid_loop_index ( y_dim_index , source_index )) else !Usea smaller area i_target_start = max ( 1 , ii - emission_subgrid_loop_index ( x_dim_index , source_index )) i_target_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), ii + emission_subgrid_loop_index ( x_dim_index , source_index )) j_target_start = max ( 1 , jj - emission_subgrid_loop_index ( y_dim_index , source_index )) j_target_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), jj + emission_subgrid_loop_index ( y_dim_index , source_index )) endif !Set the emission limits (EMEP projection ) surrounding the target grid xpos_emission_subgrid = xproj_emission_subgrid ( ii , jj , source_index ) ypos_emission_subgrid = yproj_emission_subgrid ( ii , jj , source_index ) xpos_area_max = xpos_emission_subgrid + xpos_limit xpos_area_min = xpos_emission_subgrid - xpos_limit ypos_area_max = ypos_emission_subgrid + ypos_limit ypos_area_min = ypos_emission_subgrid - ypos_limit plume_count = 0 plume_crossreference = 0 plume_distance = 0 !write(*,*) i_target_end-i_target_start,j_target_end-j_target_start do j = j_target_start , j_target_end do i = i_target_start , i_target_end !Only calculate if it is within the local region distance !Set the EMEP projection position of the emission grid. This guarantees that it extentds to the right distance xpos_target_subgrid = xproj_emission_subgrid ( i , j , source_index ) ypos_target_subgrid = yproj_emission_subgrid ( i , j , source_index ) !Select only target grids within the predefined region if ( xpos_target_subgrid . ge . xpos_area_min . and . xpos_target_subgrid . le . xpos_area_max & . and . ypos_target_subgrid . ge . ypos_area_min . and . ypos_target_subgrid . le . ypos_area_max ) then !Find the integral index for the target grid i_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , source_index ) j_cross_target_integral = crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , source_index ) i_cross_target_integral = min ( max ( 1 , i_cross_target_integral ), integral_subgrid_dim ( x_dim_index )) j_cross_target_integral = min ( max ( 1 , j_cross_target_integral ), integral_subgrid_dim ( y_dim_index )) !Set the mixing height at the average of the emission and target position h_mix_loc = ( meteo_subgrid ( i_cross_integral , j_cross_integral , tt , hmix_subgrid_index ) + meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , hmix_subgrid_index )) / 2. !Set the precipitation at the receptor grid precip_loc = meteo_subgrid ( i_cross_target_integral , j_cross_target_integral , tt , precip_subgrid_index ) !Find the minimum distance to the trajectory and check it is valid (downwind) call uEMEP_minimum_distance_trajectory_fast ( x_target_subgrid ( i , j ), y_target_subgrid ( i , j ), & traj_max_index , traj_step_size , trajectory_vector (:, x_dim_index ), trajectory_vector (:, y_dim_index ), x_loc , y_loc , valid_traj ) !valid_traj=.false. if ( valid_traj ) then !Check if y_loc is within 4*sigma region based on the PG stability functions at emission position call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Put the plume in the plume vector for later use if ( abs ( y_loc ). lt . 3. * sig_y_loc ) then plume_count = plume_count + 1 !Check number of subgrids in plume does not exceed allowable if ( plume_count . gt . n_plume_subgrid_max ) then write ( unit_logfile , '(a,i)' ) 'WARNING: Number of subgrids for a plume exceeds the maximum value of: ' , n_plume_subgrid_max write ( unit_logfile , '(a)' ) '         Exiting the plume but will continue calculating' goto 10 else plume_crossreference ( plume_count , x_dim_index ) = i plume_crossreference ( plume_count , y_dim_index ) = j plume_distance ( plume_count , x_dim_index ) = x_loc plume_distance ( plume_count , y_dim_index ) = y_loc endif endif endif endif enddo enddo max_plume_count = max ( max_plume_count , plume_count ) !Sort the target grids from closest to furthest creating a crossreference index !write(*,*) 'IN: ',plume_distance(1:plume_count,x_dim_index) 10 temp_plume_distance ( 1 : plume_count ) = plume_distance ( 1 : plume_count , x_dim_index ) call rargsort ( temp_plume_distance ( 1 : plume_count ), sorted_plume_index ( 1 : plume_count ), plume_count ) !write(*,*) 'OUT:',sorted_plume_index(1:plume_count) !Set the plume source that will be depleted with deposition plume_source = emission_subgrid ( ii , jj , tt , source_index ,:) !Loop through the sorted array starting at the closest (which should always be the emission grid) !write(*,*) ii,jj,plume_count do k = 1 , plume_count x_loc = plume_distance ( sorted_plume_index ( k ), x_dim_index ) y_loc = plume_distance ( sorted_plume_index ( k ), y_dim_index ) i = plume_crossreference ( sorted_plume_index ( k ), x_dim_index ) j = plume_crossreference ( sorted_plume_index ( k ), y_dim_index ) !write(*,*) x_loc,y_loc !Select method for assigning sigma if ( stability_scheme_flag . eq . 1 ) then call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 2 ) then call uEMEP_set_dispersion_params_PG ( invL_loc , source_index , subsource_index ) ay_loc = ay ( source_index , subsource_index ) by_loc = by ( source_index , subsource_index ) az_loc = az ( source_index , subsource_index ) bz_loc = bz ( source_index , subsource_index ) call uEMEP_set_dispersion_sigma_PG ( invL_loc , logz0_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) endif if ( stability_scheme_flag . eq . 3 ) then !Set initial values for sigma. Initial sig_y is set here as well but is overridden by Kz dispersion call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) call uEMEP_set_dispersion_sigma_Kz ( Kz_scheme , x_loc , sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , sig_z_loc , h_emis_loc , h_mix_loc , invL_loc , FF10_loc , 1 0. , logz0_loc , emission_subgrid_delta (:, source_index ), u_star0_loc , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z_loc , sig_y_loc , FF_zc_loc ) !Add the meandering and change in wind angle to the plume since not included in Kz calculation sig_y_loc = sig_y_loc + x_loc * angle_diff ( i_cross_integral , j_cross_integral ) !Use the average of the emision height and zc to determine wind speed. Is set to true if wind_level_flag=6 !CHECK THIS if ( wind_level_flag . eq . 6. or . wind_level_zc_flag ) then !Set the minimum wind speed FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif if ( wind_level_integral_flag . eq . 6 ) then !Set the minimum wind speed FF_integral_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif endif if ( stability_scheme_flag . eq . 4 ) then write ( unit_logfile , '(a,i)' ) 'Stability_scheme_flag=4 (Kz emulator) no longer an option. Stopping' stop !call uEMEP_set_dispersion_sigma_Kz_emulator(h_emis_loc,invL_loc,logz0_loc,h_mix_loc,sig_z_00_loc,sig_y_00_loc,sigy_0_subgid_width_scale,emission_subgrid_delta(:,source_index),angle_diff(i_cross_integral,j_cross_integral),x_loc,sig_z_loc,sig_y_loc,sig_z_0_loc,sig_y_0_loc) endif !Adjust the height of the wind to the average of the emission and plume centre of mass height. !This is already the case in the Kz calculation so not repeated here. if ( wind_level_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then !if (wind_level_flag.eq.6) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif if ( wind_level_integral_flag . eq . 6. and . stability_scheme_flag . ne . 3 ) then !if (wind_level_flag.eq.6) then call z_centremass_gauss_func ( sig_z_loc , h_emis_loc , h_mix_loc , zc_loc ) zc_loc = ( h_emis_loc + zc_loc ) / 2. call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_zc_loc , u_star0_loc ) FF_integral_loc = sqrt ( FF_zc_loc * FF_zc_loc + FF_min_dispersion * FF_min_dispersion ) endif !Calculate the dispersion based on the derived sigmas subgrid_internal = gauss_plume_cartesian_sigma_func ( x_loc , y_loc , h_emis_loc , z_rec_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc ) !write(*,'(9es12.2)') x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,subgrid_internal !Only use half of the source grid for deposition and depletion if ( k . gt . 1 ) then !s/m3 *m2=s/m subgrid_internal_integral = ( subgrid_internal ) * target_subgrid_delta ( x_dim_index ) * target_subgrid_delta ( y_dim_index ) else subgrid_internal_integral = ( subgrid_internal ) * target_subgrid_delta ( x_dim_index ) * 0.5 * target_subgrid_delta ( y_dim_index ) !Half the grid endif !Calculate the vertically integrated mass of the plume (s/m2) up to the lowest level and up to the mixing height if ( adjust_wetdepo_integral_to_lowest_layer_flag . and . calculate_deposition_flag ) then plume_vertical_integral ( hsurf_integral_subgrid_index ) = gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc , 0. , H_emep ) * H_emep plume_vertical_integral ( hmix_integral_subgrid_index ) = gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_loc , 0. , h_mix_loc ) * h_mix_loc !write(*,*) h_mix_loc,x_loc,sig_z_loc,vertical_integral_internal/(sig_z_loc*sqrt(2.*3.14159)/(2.*3.14159*sig_y_loc*sig_z_loc)*exp(-0.5*(y_loc*y_loc)/(sig_y_loc*sig_y_loc))/FF_loc*plume_source(i_pollutant) ) !write(*,*) plume_vertical_integral(1)/plume_vertical_integral(2),H_emep/h_mix_loc,H_emep/h_mix_loc/(plume_vertical_integral(1)/plume_vertical_integral(2)) !Calculate the average concentration in the lowest layer !These two give the same results but the second is quicker. Can put it in a seperate subroutine !vertical_integral_internal=gauss_plume_cartesian_sigma_integral_func(x_loc,y_loc,h_emis_loc,z_rec_loc,sig_z_loc,sig_y_loc,h_mix_loc,FF_loc,0.,h_mix_loc)*h_mix_loc*plume_source(i_pollutant) vertical_integral_internal = exp ( - 0.5 * ( y_loc * y_loc ) / ( sig_y_loc * sig_y_loc )) / FF_loc / ( sqrt ( 2. * 3.14159 ) * sig_y_loc ) !write(*,*) h_mix_loc,x_loc,sig_z_loc,vertical_integral_internal/(exp(-0.5*(y_loc*y_loc)/(sig_y_loc*sig_y_loc))/FF_loc/(sqrt(2.*3.14159)*sig_y_loc)*plume_source(i_pollutant)) endif if ( local_subgrid_method_flag . eq . 1 ) then plume_vertical_integral ( hsurf_average_subgrid_index ) = gauss_plume_cartesian_sigma_integral_func ( x_loc , y_loc , h_emis_loc , sig_z_loc , sig_y_loc , h_mix_loc , FF_integral_loc , 0. , H_emep ) endif if ( subgrid_internal_integral . gt . 0 ) then if ( calculate_deposition_flag ) then do i_pollutant = 1 , n_pollutant_loop !Multiply by the emissions to get the concentration prior to depletion (ug/m3) subgrid_internal_pollutant ( i_pollutant ) = subgrid_internal * plume_source ( i_pollutant ) !Calculate the dry deposition flux (ug/m3 *m/s=ug/s/m2) drydepo_internal_pollutant ( i_pollutant ) = subgrid_internal_pollutant ( i_pollutant ) * target_deposition_subgrid ( i , j , vd_index , i_pollutant ) !Calculate the dimensionless integral for plume depletion (s/m *m/s=1) drydepo_internal_integral = subgrid_internal_integral * target_deposition_subgrid ( i , j , vd_index , i_pollutant ) !Set the scavenging (s/m2 /m *m/s = /m2). 1e-3/3600 converts mm/hr to m/s wetdepo_internal = vertical_integral_internal * wetdepo_scavanging_rate ( pollutant_loop_index ( i_pollutant )) * ( precip_loc / 100 0. / 360 0. ) !Calculate the wet deposition flux ( /m2 ug/s = ug/m2/s) wetdepo_internal_pollutant ( i_pollutant ) = wetdepo_internal * plume_source ( i_pollutant ) !Calculate the dimensionless integral for plume depletion (/m2 * m2 = 1) wetdepo_internal_integral = wetdepo_internal * target_subgrid_delta ( x_dim_index ) * target_subgrid_delta ( y_dim_index ) !Make integrated concentration values plume_vertical_integral_pollutant (:) = plume_vertical_integral (:) * plume_source ( i_pollutant ) !Calculate the plume depletion by dry and wet deposition (ug/s) if ( calculate_source_depletion_flag ) then plume_source ( i_pollutant ) = plume_source ( i_pollutant ) * exp ( - drydepo_internal_integral - wetdepo_internal_integral ) endif !write(*,'(f12.2,4es12.2,f12.3)') x_loc,subgrid_internal_pollutant(i_pollutant),subgrid_internal,plume_source(i_pollutant),drydepo_internal_pollutant(i_pollutant)*target_subgrid_delta(x_dim_index)*target_subgrid_delta(y_dim_index),plume_source(i_pollutant)/emission_subgrid(ii,jj,tt,source_index,i_pollutant) !Add to the dry deposition target grid target_deposition_subgrid ( i , j , drydepo_index , i_pollutant ) = target_deposition_subgrid ( i , j , drydepo_index , i_pollutant ) + drydepo_internal_pollutant ( i_pollutant ) !Add to the wet deposition target grid target_deposition_subgrid ( i , j , wetdepo_index , i_pollutant ) = target_deposition_subgrid ( i , j , wetdepo_index , i_pollutant ) + wetdepo_internal_pollutant ( i_pollutant ) !Add to the target concentration subgrid position target_subgrid ( i , j , i_pollutant ) = target_subgrid ( i , j , i_pollutant ) + subgrid_internal_pollutant ( i_pollutant ) enddo else !No deposition do i_pollutant = 1 , n_pollutant_loop !Multiply by the emissions to get the concentration prior to depletion (ug/m3) subgrid_internal_pollutant ( i_pollutant ) = subgrid_internal * plume_source ( i_pollutant ) !Add to the target concentration subgrid position target_subgrid ( i , j , i_pollutant ) = target_subgrid ( i , j , i_pollutant ) + subgrid_internal_pollutant ( i_pollutant ) !Make integrated concentration values plume_vertical_integral_pollutant (:) = plume_vertical_integral (:) * plume_source ( i_pollutant ) enddo endif !Determine the distance for the travel time calculation distance_subgrid = sqrt ( x_loc * x_loc + y_loc * y_loc ) distance_subgrid = max ( distance_subgrid , distance_subgrid_min ) !Add to the travel time array traveltime_target_subgrid ( i , j , 1 ,:) = traveltime_target_subgrid ( i , j , 1 ,:) + distance_subgrid / FF_loc * subgrid_internal_pollutant traveltime_target_subgrid ( i , j , 2 ,:) = traveltime_target_subgrid ( i , j , 2 ,:) + subgrid_internal_pollutant !Calculate the vertically integrated mass of the plume (s/m2) up to the lowest level and up to the mixing height if (( calculate_deposition_flag . and . adjust_wetdepo_integral_to_lowest_layer_flag ). or . local_subgrid_method_flag . eq . 1 ) then target_vertical_integral_subgrid ( i , j ,:) = target_vertical_integral_subgrid ( i , j ,:) + plume_vertical_integral_pollutant (:) !write(*,'(2i,4es12.2)') i,j,plume_vertical_integral(1),target_vertical_integral_subgrid(i,j,1),plume_vertical_integral(2),target_vertical_integral_subgrid(i,j,2) endif endif enddo !plume loop endif !end if emission not 0 enddo !End of emission loop enddo write ( unit_logfile , '(a,i)' ) 'Maximum number of subgrids per plume in this period and region = ' , max_plume_count !This ratio should be 1 in a well mixed layer. It can be used to estimate the average column concentration based on the surface layer concentration !target_vertical_integral_subgrid(:,:,4)=target_vertical_integral_subgrid(:,:,1)/target_vertical_integral_subgrid(:,:,2) !Interpolate target grid to the concentration subgrid do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then do i_pollutant = 1 , n_pollutant_loop if ( calculate_deposition_flag ) then subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , drydepo_local_subgrid_index , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_deposition_subgrid (:,:, drydepo_index , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , wetdepo_local_subgrid_index , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_deposition_subgrid (:,:, wetdepo_index , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) endif subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) = subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_subgrid (:,:, i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 1 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_target_subgrid (:,:, 1 , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) = traveltime_subgrid ( i , j , tt , 2 , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , traveltime_target_subgrid (:,:, 2 , i_pollutant ) & , target_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_subgrid ( i , j ), y_subgrid ( i , j )) enddo else subgrid ( i , j , tt , proxy_subgrid_index , source_index ,:) = NODATA_value traveltime_subgrid ( i , j , tt ,:,:) = NODATA_value endif enddo enddo !Determine the final travel time traveltime_subgrid (:,:, tt , 3 ,:) = traveltime_subgrid (:,:, tt , 1 ,:) / traveltime_subgrid (:,:, tt , 2 ,:) where ( traveltime_subgrid (:,:, tt , 2 ,:). eq . 0 ) traveltime_subgrid (:,:, tt , 3 ,:) = 360 0. * 1 2. !Place the vertically integrated values in the integral subgrid from the target grid, that is the same as the emission grid !write(*,*) 'Interpolating vertically integrated values to the integral grid' if (( calculate_deposition_flag . and . adjust_wetdepo_integral_to_lowest_layer_flag ). or . local_subgrid_method_flag . eq . 1 ) then do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) !i_cross_integral=crossreference_integral_to_emission_subgrid(i,j,x_dim_index,source_index) !j_cross_integral=crossreference_integral_to_emission_subgrid(i,j,y_dim_index,source_index) !i_cross_integral=max(1,i_cross_integral);i_cross_integral=min(integral_subgrid_dim(x_dim_index),i_cross_integral) !j_cross_integral=max(1,j_cross_integral);j_cross_integral=min(integral_subgrid_dim(y_dim_index),j_cross_integral) do i_integral = 1 , n_integral_subgrid_index do i_pollutant = 1 , n_pollutant_loop integral_subgrid ( i , j , tt , i_integral , source_index , i_pollutant ) = integral_subgrid ( i , j , tt , i_integral , source_index , i_pollutant ) & + area_weighted_interpolation_function ( x_target_subgrid , y_target_subgrid , target_vertical_integral_subgrid (:,:, i_integral ) & , target_subgrid_dim ( x_dim_index ), target_subgrid_dim ( y_dim_index ), target_subgrid_delta (:), x_integral_subgrid ( i , j ), y_integral_subgrid ( i , j )) !write(*,*) i,j,i_integral,integral_subgrid(i,j,tt,i_integral,source_index,i_pollutant) enddo enddo enddo enddo !Add to allsource do i_integral = 1 , n_integral_subgrid_index integral_subgrid (:,:, tt , i_integral , allsource_index ,:) = integral_subgrid (:,:, tt , i_integral , allsource_index ,:) + integral_subgrid (:,:, tt , i_integral , source_index ,:) enddo endif !Show mean outputs for checking do i_pollutant = 1 , n_pollutant_loop temp_sum_subgrid ( i_pollutant ) = 0. count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , source_index )) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) + subgrid ( i , j , tt , proxy_subgrid_index , source_index , i_pollutant ) count = count + 1 endif enddo enddo if ( count . gt . 0 ) then temp_sum_subgrid ( i_pollutant ) = temp_sum_subgrid ( i_pollutant ) / count else temp_sum_subgrid ( i_pollutant ) = 0 endif write ( unit_logfile , '(a,3f12.3)' ) 'Mean concentration ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , temp_sum_subgrid ( i_pollutant ) enddo enddo !End time loop if ( allocated ( trajectory_vector )) deallocate ( trajectory_vector ) if ( allocated ( target_subgrid )) deallocate ( target_subgrid ) if ( allocated ( target_deposition_subgrid )) deallocate ( target_deposition_subgrid ) if ( allocated ( temp_FF_subgrid )) deallocate ( temp_FF_subgrid ) if ( allocated ( temp_FF_integral_subgrid )) deallocate ( temp_FF_integral_subgrid ) if ( allocated ( traveltime_target_subgrid )) deallocate ( traveltime_target_subgrid ) if ( allocated ( target_vertical_integral_subgrid )) deallocate ( target_vertical_integral_subgrid ) end subroutine uEMEP_subgrid_deposition subroutine uEMEP_create_wind_field ( temp_FF_subgrid , angle_diff , wind_level_flag_in , source_index_in , subsource_index_in , tt_in ) use uEMEP_definitions implicit none integer , intent ( in ) :: wind_level_flag_in , tt_in , source_index_in , subsource_index_in integer j_cross , i_cross integer i_cross_integral , j_cross_integral integer ii , jj real z0_temp , h_temp real sig_y_00_loc , h_emis_loc , h_mix_loc , FF10_loc , x_loc , sig_z_loc , sig_y_loc , ff_loc , logz0_loc real sig_z_00_loc , sig_y_0_loc , sig_z_0_loc , zc_loc , u_star0_loc !define the temporary arrays for meteo real , intent ( out ) :: temp_FF_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index )) real , intent ( in ) :: angle_diff ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index )) temp_FF_subgrid = 0. if ( wind_level_flag_in . ne . 5 ) then do j_cross = 1 , integral_subgrid_dim ( y_dim_index ) do i_cross = 1 , integral_subgrid_dim ( x_dim_index ) z0_temp = exp ( meteo_subgrid ( i_cross , j_cross , tt_in , logz0_subgrid_index )) h_temp = h_emis ( source_index_in , subsource_index_in ) if ( annual_calculations . and . wind_level_flag_in . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FFgrid_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag_in . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( annual_calculations . and . wind_level_flag_in . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FF10_subgrid_index ) elseif ( annual_calculations . and . wind_level_flag_in . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. / meteo_subgrid ( i_cross , j_cross , tt_in , inv_FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 1 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FFgrid_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 2 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FFgrid_subgrid_index ) * ( 1. - ( log (( H_meteo + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( H_meteo + z0_temp ) / z0_temp )) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 3 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FF10_subgrid_index ) elseif ( hourly_calculations . and . wind_level_flag_in . eq . 4 ) then temp_FF_subgrid ( i_cross , j_cross ) = meteo_subgrid ( i_cross , j_cross , tt_in , FF10_subgrid_index ) * ( 1. - ( log (( 1 0. + z0_temp ) / z0_temp ) - log (( h_temp + z0_temp ) / z0_temp )) / log (( 1 0. + z0_temp ) / z0_temp )) elseif ( wind_level_flag_in . eq . 0 ) then temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag_in . eq . 5 ) then !Will set based on sigma z centre of mass temp_FF_subgrid ( i_cross , j_cross ) = 1. elseif ( wind_level_flag_in . eq . 6 ) then !Will set based on sigma z centre of mass and emission height temp_FF_subgrid ( i_cross , j_cross ) = 1. else write ( unit_logfile , '(a)' ) 'No valid wind_level_flag_in selected. Stopping (uEMEP_subgrid_dispersion)' stop endif !Setting a minimum value for wind for dispersion purposes (cannot be zero) temp_FF_subgrid ( i_cross , j_cross ) = sqrt ( temp_FF_subgrid ( i_cross , j_cross ) * temp_FF_subgrid ( i_cross , j_cross ) + FF_min_dispersion * FF_min_dispersion ) if ( temp_FF_subgrid ( i_cross , j_cross ). eq . 0 ) then write ( unit_logfile , '(a,2i)' ) 'Zero wind speed at integral grid (stopping): ' , i_cross , j_cross stop endif enddo enddo endif !If wind level flag is set to 5, use of initial plume centre of mass, then set wind speed for each non-zero emission grid if ( wind_level_flag_in . eq . 5 ) then temp_FF_subgrid = 0. do jj = 1 , emission_subgrid_dim ( y_dim_index , source_index_in ) do ii = 1 , emission_subgrid_dim ( x_dim_index , source_index_in ) if ( sum ( emission_subgrid ( ii , jj , tt_in , source_index_in ,:)). ne . 0 ) then !Set the integral meteorological grid position for the emission position i_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , x_dim_index , source_index_in ) j_cross_integral = crossreference_emission_to_integral_subgrid ( ii , jj , y_dim_index , source_index_in ) !Set the local variables logz0_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , logz0_subgrid_index ) FF10_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , FF10_subgrid_index ) sig_y_00_loc = emission_properties_subgrid ( ii , jj , emission_sigy00_index , source_index_in ) sig_z_00_loc = emission_properties_subgrid ( ii , jj , emission_sigz00_index , source_index_in ) h_emis_loc = emission_properties_subgrid ( ii , jj , emission_h_index , source_index_in ) h_mix_loc = meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , hmix_subgrid_index ) if ( annual_calculations ) then FF10_loc = 1. / meteo_subgrid ( i_cross_integral , j_cross_integral , tt_in , inv_FF10_subgrid_index ) endif !Set sig_0's at the emission position x_loc = 0. call uEMEP_set_dispersion_sigma_simple ( sig_z_00_loc , sig_y_00_loc , sigy_0_subgid_width_scale , emission_subgrid_delta (:, source_index_in ), angle_diff ( i_cross_integral , j_cross_integral ), x_loc , sig_z_loc , sig_y_loc , sig_z_0_loc , sig_y_0_loc ) !Use the initial plume centre of mass to determine wind advection height call z_centremass_gauss_func ( sig_z_0_loc , h_emis_loc , h_mix_loc , zc_loc ) call u_profile_neutral_val_func ( zc_loc , FF10_loc , 1 0. , h_mix_loc , exp ( logz0_loc ), FF_loc , u_star0_loc ) !Set the minimum wind speed FF_loc = sqrt ( FF_loc * FF_loc + FF_min_dispersion * FF_min_dispersion ) temp_FF_subgrid ( ii , jj ) = FF_loc !write(*,*) FF10_loc,FF_loc,zc_loc,sig_z_0_loc endif enddo enddo endif end subroutine uEMEP_create_wind_field end module subgrid_deposition","tags":"","loc":"sourcefile/uemep_subgrid_deposition.f90.html"},{"title":"uEMEP_Kz_functions.f90 – uEMEP","text":"Source Code module kz_functions use uemep_constants , only : epsilon0 implicit none private public :: TROENKz_invL_from_phi , z_centremass_gauss_func , & u_profile_neutral_val_func , uEMEP_set_dispersion_sigma_Kz contains !   Functions for calculating dispersion from Kz and wind profiles !========================================================================== !   uEMEP_calculate_dispersion_Kz !   Kz_func !   z_centremass_gauss_func !   phi_func !   u_profile_val_func ! !   Calculates dispersion based on Kz and wind profiles !========================================================================== subroutine uEMEP_set_dispersion_sigma_Kz ( Kz_scheme_in , x_in , sig_z00 , sig_y00 , sigy_0_subgid_width_scale , sig_z_in , z_emis_loc , h_mix_loc , invL , u_val , z_val , logz0 , subgrid_delta , u_star0_in , average_zc_h_in_Kz_flag , n_kz_iterations , sig_y_scaling_factor , sig_z , sig_y , u_zc ) implicit none real , intent ( in ) :: x_in , sig_z00 , sig_y00 , sigy_0_subgid_width_scale , sig_z_in , z_emis_loc , h_mix_loc , invL , u_val , z_val , logz0 , subgrid_delta ( 2 ), u_star0_in , sig_y_scaling_factor integer , intent ( in ) :: Kz_scheme_in , n_kz_iterations logical , intent ( in ) :: average_zc_h_in_Kz_flag real , intent ( out ) :: sig_z , sig_y , u_zc integer n_loop , j real K_z , L real :: z_tau_min = 2. , z_tau_max = 10 0. real z0 , zc real :: K_min = 0.001 real l_t , f_t real u_star0 , u_star0_val , tau real min_xy , x real phih_temp n_loop = n_kz_iterations !Limit stable L to this positive L value !L=1.e6 !L=lowest_stable_L !if (abs(invL).gt.1./L) L=1./invL L = 1. / invL !Why does it not explode? when invL=0? if ( abs ( invL ) < epsilon0 ) L = 1.0e6 z0 = exp ( logz0 ) min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. !min_x=1. !x=max(x_in,min_xy) !Set x to this value because it simulates that it has already travelled half a grid to get this sig_z0 !Which is why sg_z is added only to sig_z00 x = x_in + min_xy !Initialise sig_z sig_z = sig_z_in !If the emission is above the boundary layer height then set the initial plume guess to its low turbulence form !Same values used in the emulator (1/1000 slender plume) if ( z_emis_loc / h_mix_loc . ge . 1.0 ) sig_z = sig_z00 + 0.001 * exp ( 1.0 * log ( x )) !Set ustar0 for K_z to the value from EMEP u_star0 = u_star0_in zc = z_emis_loc !Set zc and K_z at start of plume based on sig_z0 !call z_centremass_gauss_func(sig_z0,z_emis_loc,h_mix_loc,zc_start) !call Kz_func(h_mix_loc,L,u_star0,zc_start,K_min,K_z_start) !call u_profile_val_func(zc_start,L,u_val,z_val,h_mix_loc,z0,u_zc_start,u_star0,u_hmix) !Put bug back in u_zc = u_val !Calculate the Lagrangian time scale before the iteration loop using a minimum distance for this to make it non zero on the grid !l_t=max(x,min_xy)/u_zc tau = 0.6 * max ( min ( z_tau_max , z_emis_loc ), z_tau_min ) / u_star0 !f_t=1.+tau/l_t*(exp(-l_t/tau)-1.) !if (x.lt.200) then !write(*,'(a,i,5f)') 'S: ',j,tau,l_t,f_t,u_zc,sig_z !write(*,'(a,5f)') 'S: ',tau,u_star0,z_tau_max,z_emis_loc,z_tau_min !endif !All functions commented out 4 secs !All functions included 15 secs !Without u_profile 11 secs !Commenting out all functions below gives 7 secs do j = 1 , n_loop !Calculate centre of mass for the emission height. call z_centremass_gauss_func ( sig_z , z_emis_loc , h_mix_loc , zc ) !4.5 sec if ( average_zc_h_in_Kz_flag ) zc = ( z_emis_loc + zc ) / 2. !write(*,'(i,4f)') j,sig_z,z_emis_loc,h_mix_loc,zc !Calculate the wind profile !call u_profile_val_func(zc,L,u_val,z_val,h_mix_loc,z0,u_zc,u_star0_val,u_hmix) !7secs. Without phim_func calls 5 secs call u_profile_neutral_val_func ( zc , u_val , z_val , h_mix_loc , z0 , u_zc , u_star0_val ) !write(*,'(i,9f)') j,zc,L,u_val,z_val,h_mix_loc,z0,u_zc,u_star0,u_hmix !u_zc=(u_zc+u_zc_start)/2. !write(*,'(i,8f)') j,x,u_star0_in,u_star0,zc,z_val,u_zc,u_zc_start,u_val !Use the calculated u_star for the dispersion, not the EMEP input !u_star0=u_star0_val !Calculate K_z at the centre of mass if ( Kz_scheme_in . eq . 2 ) then call TROENKz ( zc , h_mix_loc , u_star0 , invL , K_min , K_z , phih_temp ) else call Kz_func ( h_mix_loc , L , u_star0 , zc , K_min , K_z ) !5.5 secs endIf !write(*,'(i,1f)') j,K_z !Take average of K_z_start(x=0) and K_z(x) !K_z=(K_z+K_z_start)/2. !calculate l_t based on the centre of mass wind speed l_t = max ( x , min_xy ) / u_zc f_t = 1. + tau / l_t * ( exp ( - l_t / tau ) - 1. ) !Calculate sig_z for the next iteration, using the sig_z0 from the neutral plume approximation sig_z = sig_z00 + sqrt ( 2. * K_z * l_t * f_t ) !write(*,'(i,1f)') j,sig_z !write(*,*) K_z,l_t,f_t,sig_z,u_zc !write(*,*) j,z_emis_loc,zc,h_mix_loc*0.25,sig_z !if (x.lt.200) then !write(*,'(a,i,5f)') 'S: ',j,tau,l_t,f_t,u_zc,sig_z !endif enddo !Calculate sigma_y at the maximum K, around the average of the emission height and 0.25 of the boundary layer height !THis is new 27.10.2018 and not tested. It will reduce sig_y which is OK !h_y=(h_mix_loc*0.25+z_emis_loc)/2. !call Kz_func(h_mix_loc,L,u_star0,h_y,K_min,K_y) !sig_y=sig_y00+min_xy*sigy_0_subgid_width_scale+sqrt(2.*K_y*l_t*f_t) !Should change this to what is documented, i.e. 2*sig_z. Need to test sig_y = sig_y00 + min_xy * sigy_0_subgid_width_scale + ( sig_z - sig_z00 ) * sig_y_scaling_factor end subroutine uEMEP_set_dispersion_sigma_Kz subroutine Kz_func ( z_pbl , L , u_star0_in , z , K_min , K_z ) implicit none real , intent ( in ) :: z_pbl , L , u_star0_in , z , K_min real , intent ( out ) :: K_z real kappa parameter ( kappa = 0.4 ) real phih , phih_i real phih_hs , phih_i_hs real phih_hs_p1 , phih_i_hs_p1 real K_zpbl , K_zhs , h_s , delta_K_zhs , u_star0 h_s = 0.04 * z_pbl !ustar0 cannot be 0. Set to a low value !u_star0=max(u_star0_in,0.01) u_star0 = u_star0_in call phih_func ( z , L , phih , phih_i ) K_zpbl = K_min K_z = K_min if ( L . ge . 0 ) then !K_z=0.39*u_star0*z*exp(-0.5*(z/0.21/z_pbl)*(z/0.21/z_pbl))  !As in EMEP !K_z=0.39*u_star0*z*exp(-0.5*(z/0.32/z_pbl)*(z/0.32/z_pbl)) !Adjusted to match under neutral conditions K_z = 0.39 * u_star0 * z / phih * exp ( - 0.5 * ( z / 0.32 / z_pbl ) * ( z / 0.32 / z_pbl )) !Adjusted but with stability added else call phih_func ( h_s , L , phih_hs , phih_i_hs ) call phih_func ( h_s + 1. , L , phih_hs_p1 , phih_i_hs_p1 ) K_zhs = u_star0 * kappa * h_s / phih_hs delta_K_zhs = u_star0 * kappa * (( h_s + 1. ) / phih_hs_p1 - ( h_s ) / phih_hs ) if ( z . le . h_s ) K_z = u_star0 * kappa * z / phih if ( z . gt . h_s . and . z . le . z_pbl ) K_z = K_zpbl + (( z_pbl - z ) / ( z_pbl - h_s )) * (( z_pbl - z ) / ( z_pbl - h_s )) * ( K_zhs - K_zpbl + ( z - h_s ) * ( delta_K_zhs + 2. * ( K_zhs - K_zpbl ) / ( z_pbl - h_s ))) endif K_z = max ( K_z , K_min ) end subroutine Kz_func subroutine TROENKz ( z , h , ustar , invL , Kdef , Kz , phih ) !Vertical dispersion routine as described in: !Troen, I., & Mahrt, L. (1986). A Simple Model of the Atmospheric Boundary !Layer: !Sensitivity to Surface Evaporation. Boundary-Layer Meteorology, 37, 129-148. !https://doi.org/10.1007/BF00122760 implicit none real , intent ( in ) :: z ! height real , intent ( in ) :: h ! Boundary layer depth real , intent ( in ) :: ustar , invL , Kdef !  u*, 1/L, default Kz real , intent ( out ) :: Kz , phih real :: ws real :: kappa = 0.4 real :: zsurf !Height of the surface layer. Stability function for unstable calculated !here for z>zsurf zsurf = 0.1 * h if ( z < h ) then if ( invL < 0 ) then !phih=(1-7.*min(z,zsurf)*invL)**(-1./3.) !Original in !Troen and Mahrt for phim, so no Prandtl number !phih=(1-16.*min(z,zsurf)*invL)**(-1./2.) !As in Garratt and Obrien for phih, so with Prandtl number phih = ( 1 - 1 6. * z * invL ) ** ( - 1. / 2. ) !As in Garratt and Obrien for phih, so with Prandtl number else phih = 1 + 5. * z * invL !As in Garratt, Prandtl number is 1 in stable boundary layer endif ws = ustar / phih Kz = kappa * ws * z * ( 1. - z / h ) ** 2 else Kz = Kdef endif end subroutine TROENKz subroutine TROENKz_invL_from_phi ( z , phih , invL ) implicit none real , intent ( in ) :: z ! height real , intent ( in ) :: phih real , intent ( out ) :: invL !1/L if ( phih < 1 ) then !phih=(1-16.*min(z,zsurf)*invL)**(-1./2.) !As in Garratt and Obrien for phih, so with Prandtl number invL = ( phih **- 2. - 1 ) / ( - 1 6. * z ) else !phih=1+5.*z*invL !As in Garratt, Prandtl number is 1 in stable boundary layer invL = ( phih - 1 ) / 5. / z endif end subroutine TROENKz_invL_from_phi subroutine z_centremass_gauss_func ( sigma , h , z_pbl , z_c ) implicit none real , intent ( in ) :: sigma , h , z_pbl real , intent ( out ) :: z_c real z_loop ( 5 ) real H_c integer i_loop , i real sqrt_2pi , sqrt_2 real pi parameter ( pi = 3.141592653589793 ) sqrt_2pi = sqrt ( 2. * pi ) sqrt_2 = sqrt ( 2. ) i_loop = 5 z_loop ( 1 ) = h ; z_loop ( 2 ) =- h ; z_loop ( 3 ) = 2. * z_pbl - h ; z_loop ( 4 ) = 2. * z_pbl + h ; z_loop ( 5 ) =- 2. * z_pbl + h z_c = 0. !c_z=0.;c_av=0. H_c = z_pbl !If the emission height h is greater than the boundary layer height then only allow reflection from the surface !and set the top of the integration H_c to infinity if ( h . gt . z_pbl ) then H_c = 1.e16 i_loop = 2 endif !Reduce the loop size when the reflection from the boundary layer is not important if ( sigma + h . lt . z_pbl / 3. ) then i_loop = 2 endif !Remove this after finished testing !i_loop=5 do i = 1 , i_loop z_c = z_c + sigma / sqrt_2pi * ( exp ( - 0.5 * ( z_loop ( i ) / sigma ) * ( z_loop ( i ) / sigma )) - exp ( - 0.5 * (( H_c - z_loop ( i )) / sigma ) * (( H_c - z_loop ( i )) / sigma ))) & + z_loop ( i ) / 2 * ( erf (( H_c - z_loop ( i )) / sqrt_2 / sigma ) + erf (( z_loop ( i )) / sqrt_2 / sigma )) !c_av=c_av+0.5*(erf((z_pbl-z_loop(i))/sqrt_2/sigma)+erf((z_loop(i))/sqrt_2/sigma))/z_pbl !c_z=c_z+1./sigma/sqrt_2pi*exp(-0.5*((z-z_loop(i))/sigma)*((z-z_loop(i))/sigma)) enddo !if (sigma.gt.0.9*z_pbl) then !c_z=1./z_pbl !c_av=1./z_pbl !endif end subroutine z_centremass_gauss_func subroutine u_profile_val_func ( z , L , u_val , z_val_in , z_pbl , z0 , u , u_star0 , u_pbl ) implicit none real , intent ( in ) :: z , L , u_val , z_val_in , z_pbl , z0 real , intent ( out ) :: u , u_star0 , u_pbl real a , b , p , kappa parameter ( a = 1 6. , b = 5. , p =- 0.25 , kappa = 0.4 ) real z_l , z_val real phim , phim_i real phim_val , phim_i_val !real phim_pbl,phih_pbl,phim_i_pbl,phih_i_pbl !If the input height is above the boundary layer then set the height to pbl height and calculate z_val = z_val_in if ( z_val . ge . z_pbl ) z_val = z_pbl z_l = 0.4 * z_pbl call phim_func ( z , L , phim , phim_i ) call phim_func ( z_val , L , phim_val , phim_i_val ) !call phi_func(z_pbl,L,phim_pbl,phih_pbl,phim_i_pbl,phih_i_pbl) if ( L . ge . 0. ) then u_star0 = u_val * kappa / ( log ( z_val / z0 ) - phim_i_val + kappa * z_val / z_l * ( 1 - z_val / 2. / z_pbl ) - z_val / z_pbl * ( 1 + b * z_val / 2. / L )) !u_pbl=u_star0/kappa*(log(z_pbl/z0)-phim_i_pbl+kappa*z_pbl/z_l*(1-z_pbl/2./z_pbl)-z_pbl/z_pbl*(1+b*z_pbl/2./L)) u = u_star0 / kappa * ( log ( z / z0 ) - phim_i + kappa * z / z_l * ( 1 - z / 2. / z_pbl ) - z / z_pbl * ( 1 + b * z / 2. / L )) else u_star0 = u_val * kappa / ( log ( z_val / z0 ) - phim_i_val + kappa * z_val / z_l * ( 1 - z_val / 2. / z_pbl ) - 1. / z_pbl * (( a * z_val - L ) * phim_val + L ) / a / ( p + 1 )) !u_pbl=u_star0/kappa*(log(z_pbl/z0)-phim_i_pbl+kappa*z_pbl/z_l*(1-z_pbl/2./z_pbl)-1./z_pbl*((a*z_pbl-L)*phim_pbl+L)/a/(p+1)) u = u_star0 / kappa * ( log ( z / z0 ) - phim_i + kappa * z / z_l * ( 1 - z / 2. / z_pbl ) - 1. / z_pbl * (( a * z - L ) * phim + L ) / a / ( p + 1 )) endif !u_pbl not used and so not calculated here u_pbl = u if ( z . ge . z_pbl ) then u = u_pbl endif end subroutine u_profile_val_func subroutine u_profile_neutral_val_func ( z , u_val , z_val_in , z_pbl , z0 , u , u_star0 ) implicit none real , intent ( in ) :: z , u_val , z_val_in , z_pbl , z0 real , intent ( out ) :: u , u_star0 real kappa parameter ( kappa = 0.4 ) real z_l , z_val !If the input height is above the boundary layer then set the height to pbl height and calculate z_val = min ( z_val_in , z_pbl ) z_l = 0.4 * z_pbl u_star0 = u_val * kappa / ( log ( z_val / z0 ) + kappa * z_val / z_l * ( 1 - z_val / 2. / z_pbl ) - z_val / z_pbl ) u = u_star0 / kappa * ( log ( z / z0 ) + kappa * z / z_l * ( 1 - z / 2. / z_pbl ) - z / z_pbl ) end subroutine u_profile_neutral_val_func subroutine phi_func ( z , L , phim , phih , phim_i , phih_i ) implicit none real , intent ( in ) :: z , L real , intent ( out ) :: phim , phih , phim_i , phih_i real a , b , p , q , pi parameter ( a = 1 6. , b = 5. , p =- 0.25 , q =- 0.5 , pi = 3.141592653589793 ) real eps eps = z / L if ( eps . ge . 0 ) then phim = 1. + b * eps phim_i =- b * eps phih = phim phih_i = phim_i else phim = exp ( p * log (( 1. - a * eps ))) phih = exp ( q * log (( 1. - a * eps ))) phim_i = 2. * log (( 1. + 1. / phim ) / 2. ) + log (( 1. + 1. / ( phim * phim )) / 2. ) - 2. * atan ( 1. / phim ) + pi / 2. phih_i = 2. * log (( 1. + 1. / phih ) / 2. ) endif end subroutine phi_func subroutine phim_func ( z , L , phim , phim_i ) implicit none real , intent ( in ) :: z , L real , intent ( out ) :: phim , phim_i real a , b , p , pi parameter ( a = 1 6. , b = 5. , p =- 0.25 , pi = 3.141592653589793 ) real eps eps = z / L if ( eps . ge . 0 ) then phim = 1. + b * eps phim_i =- b * eps else phim = exp ( p * log (( 1. - a * eps ))) phim_i = 2. * log (( 1. + 1. / phim ) / 2. ) + log (( 1. + 1. / ( phim * phim )) / 2. ) - 2. * atan ( 1. / phim ) + pi / 2. endif end subroutine phim_func subroutine phih_func ( z , L , phih , phih_i ) implicit none real , intent ( in ) :: z , L real , intent ( out ) :: phih , phih_i real a , b , q parameter ( a = 1 6. , b = 5. , q =- 0.5 ) real eps eps = z / L if ( eps . ge . 0 ) then phih = 1. + b * eps phih_i =- b * eps else phih = exp ( q * log (( 1. - a * eps ))) phih_i = 2. * log (( 1. + 1. / phih ) / 2. ) endif end subroutine phih_func subroutine z_centremass_gauss_array_func ( sig_norm , h_norm , n_array , zc_array ) implicit none real , intent ( in ) :: sig_norm , h_norm , n_array real , intent ( out ) :: zc_array ( int ( n_array )) real z_loop ( 5 ) real H_c real z_c integer i_loop , i , k real sqrt_2pi , sqrt_2 real pi parameter ( pi = 3.141592653589793 ) sqrt_2pi = sqrt ( 2. * pi ) sqrt_2 = sqrt ( 2. ) i_loop = 5 z_loop ( 1 ) = h_norm ; z_loop ( 2 ) =- h_norm ; z_loop ( 3 ) = 2. - h_norm ; z_loop ( 4 ) = 2. + h_norm ; z_loop ( 5 ) =- 2. + h_norm H_c = 1. !If the emission height h is greater than the boundary layer height then only allow reflection from the surface !and set the top of the integration H_c to infinity if ( h_norm . gt . 1. ) then H_c = 1.e4 i_loop = 2 endif !Reduce the loop size when the reflection from the boundary layer is not important !if (sig_norm+h_norm.lt.1./3.) then !    i_loop=2 !endif !Remove this after finished testing i_loop = 5 do k = 1 , int ( n_array ) z_c = 0. do i = 1 , i_loop z_c = z_c + sig_norm / sqrt_2pi * ( exp ( - 0.5 * ( z_loop ( i ) / sig_norm ) * ( z_loop ( i ) / sig_norm )) - exp ( - 0.5 * (( H_c - z_loop ( i )) / sig_norm ) * (( H_c - z_loop ( i )) / sig_norm ))) & + z_loop ( i ) / 2. * ( erf (( H_c - z_loop ( i )) / sqrt_2 / sig_norm ) + erf (( z_loop ( i )) / sqrt_2 / sig_norm )) enddo zc_array ( k ) = z_c enddo end subroutine z_centremass_gauss_array_func end module kz_functions","tags":"","loc":"sourcefile/uemep_kz_functions.f90.html"},{"title":"uEMEP_dispersion_functions.f90 – uEMEP","text":"Source Code module dispersion_functions implicit none private public :: gauss_plume_cartesian_sigma_func , gauss_plume_cartesian_sigma_integral_func , & gauss_plume_second_order_rotated_reflected_func , & gauss_plume_second_order_rotated_reflected_integral_func , & gauss_plume_second_order_rotated_integral_func contains !========================================================================== !   uEMEP model gauss_plume_second_order_rotated_reflected_func !   Rotationally symetric Gaussian plume function to second order !========================================================================== function gauss_plume_second_order_rotated_reflected_func ( r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl ) implicit none real r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl real gauss_plume_second_order_rotated_reflected_func real sig_th , sig_z , B , c real order_1 , order_2 real z_loop ( 6 ) integer n_loop , k real :: correction = 2. real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 r = max ( 1. , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) !write(*,*) sig_z,sig_th*r,sig_z_0,sig_y_0 B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) !write(*,*) B if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif if ( sig_z . gt . 0.9 * z_pbl ) then if ( B . gt . - 1. ) then !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) c = 1. / ( z_pbl * 2. * pi * r * sqrt ( 1. + B )) * erf ( correction * pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B )) else c = correction / ( 2. * sqrt ( 2 * pi ) * sig_th * r ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) endif else c = 0. do k = 1 , n_loop if ( B . gt . - 1. ) then !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) c = c + 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( correction * pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B )) * ( exp (( - ( z - z_loop ( k )) ** 2 ) / 2. / sig_z ** 2 )) else c = c + correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) * ( exp (( - ( z - z_loop ( k )) ** 2 ) / 2. / sig_z ** 2 )) !Perhaps also a correction in the higher orders but must calculate that again endif !if (r.eq.1.) write(*,*) k,r,c,1./(4.*pi*sig_y_0*sig_z_0) enddo endif !write(*,*) c,z_pbl !Original ! if (B.gt.-1.) then !    !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) !    c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*erf(pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) !else !    c=1./(4.*pi*sig_th*r*sig_z)*(1-order_1*pi**2*(1.+B)/(24*sig_th**2)+order_2*pi**4*((1.+B**2)/(640.*sig_th**4)))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) !endif gauss_plume_second_order_rotated_reflected_func = c end function gauss_plume_second_order_rotated_reflected_func !========================================================================== !   uEMEP model gauss_plume_second_order_rotated_func !   Rotationally symetric Gaussian plume function to second order with boundary layer reflection !========================================================================== function gauss_plume_second_order_rotated_func ( r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , h ) implicit none real r , z , ay , by , az , bz , sig_y_0 , sig_z_0 , h real gauss_plume_second_order_rotated_func real sig_th , sig_z , B , c real order_1 , order_2 real :: correction = 2. real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 r = max ( 0.001 , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) !write(*,*) sig_z,sig_th*r,sig_z_0,sig_y_0 B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) !write(*,*) B if ( B . gt . - 1. ) then !c=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B))*(exp((-(z-h)**2)/2./sig_z**2)+exp((-(z+h)**2)/2./sig_z**2)) c = 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B ) * correction ) * ( exp (( - ( z - h ) ** 2 ) / 2. / sig_z ** 2 ) + exp (( - ( z + h ) ** 2 ) / 2. / sig_z ** 2 )) else c = correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) * ( exp (( - ( z - h ) ** 2 ) / 2. / sig_z ** 2 ) + exp (( - ( z + h ) ** 2 ) / 2. / sig_z ** 2 )) endif gauss_plume_second_order_rotated_func = c end function gauss_plume_second_order_rotated_func !========================================================================== !   uEMEP model gauss_plume_second_order_rotated_integral_func !   Rotationally symetric Gaussian plume function to second order vertically integrated from H1 to H2 !========================================================================== function gauss_plume_second_order_rotated_integral_func ( r , ay , by , az , bz , sig_y_0 , sig_z_0 , h , H1 , H2 ) implicit none real r , ay , by , az , bz , sig_y_0 , sig_z_0 , h , H1 , H2 real gauss_plume_second_order_rotated_integral_func real sig_th , sig_z , B , c_y_int , c_z_int real order_1 , order_2 real :: correction = 2. real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 !Still need to implement reflections r = max ( 0.001 , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) c_z_int = sqrt ( pi / 2. ) * sig_z * ( erf (( H2 - h ) / sqrt ( 2. ) / sig_z ) - erf (( H1 - h ) / sqrt ( 2. ) / sig_z ) + erf (( H2 + h ) / sqrt ( 2. ) / sig_z ) - erf (( H1 + h ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) if ( B . gt . - 1. ) then !c_int=1./(2.*pi*sqrt(2.*pi)*r*sig_z*sqrt(1.+B))*tanh(2/sqrt(pi)*pi/(2.*sqrt(2.))/sig_th*sqrt(1.+B)) c_y_int = 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B ) * correction ) else c_y_int = correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) endif gauss_plume_second_order_rotated_integral_func = c_y_int * c_z_int end function gauss_plume_second_order_rotated_integral_func !========================================================================== !   uEMEP model gauss_plume_second_order_rotated_reflected_integral_func !   Rotationally symetric Gaussian plume function to second order vertically integrated from H1 to H2 !========================================================================== function gauss_plume_second_order_rotated_reflected_integral_func ( r , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl , H1 , H2 ) implicit none real r , ay , by , az , bz , sig_y_0 , sig_z_0 , z_s , z_pbl , H1 , H2 real gauss_plume_second_order_rotated_reflected_integral_func real sig_th , sig_z , B , c_y_int , c_z_int real order_1 , order_2 real :: correction = 2. integer k , n_loop real z_loop ( 6 ) real pi parameter ( pi = 3.141592 ) !Corrected for the B**2 falut in the taylor expansion and for the fact that the integral was only half a circle. 20.08.2019 !Still need to implement reflections r = max ( 0.001 , r ) order_1 = 1. order_2 = 1. sig_th = ( sig_y_0 + ay * ( exp ( by * log ( r )))) / r sig_z = sig_z_0 + az * ( exp ( bz * log ( r ))) B =- ( sig_th ** 2 ) * ( bz * ( sig_z - sig_z_0 ) / r / sig_th + by * ( r * sig_th - sig_y_0 ) / sig_z ) if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif if ( sig_z . gt . 0.9 * z_pbl ) then c_z_int = 1. / z_pbl else c_z_int = 0. do k = 1 , n_loop c_z_int = c_z_int + sqrt ( pi / 2. ) * sig_z * ( erf (( H2 - z_loop ( k )) / sqrt ( 2. ) / sig_z ) - erf (( H1 - z_loop ( k )) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) enddo endif if ( B . gt . - 1. ) then c_y_int = 1. / ( 2. * pi * sqrt ( 2. * pi ) * r * sig_z * sqrt ( 1. + B )) * erf ( pi / ( 2. * sqrt ( 2. )) / sig_th * sqrt ( 1. + B ) * correction ) else c_y_int = correction / ( 4. * pi * sig_th * r * sig_z ) * ( 1 - order_1 * pi ** 2 * ( 1. + B ) * correction ** 2 / ( 24 * sig_th ** 2 ) + order_2 * pi ** 4 * (( 1. + B ) ** 2 * correction ** 4 / ( 64 0. * sig_th ** 4 ))) endif !write(*,*) c_y_int,c_z_int gauss_plume_second_order_rotated_reflected_integral_func = c_y_int * c_z_int end function gauss_plume_second_order_rotated_reflected_integral_func !========================================================================== !   uEMEP model gauss_plume_cartesian_func !   Cartesian Gaussian plume function !========================================================================== function gauss_plume_cartesian_func ( x_s , y_s , z_s , cos_val , sin_val , x_r , y_r , z_r , ay , by , az , bz , sig_y_0 , sig_z_0 , delta ) implicit none real x_s , y_s , z_s , x_r , y_r , z_r real ay , by , az , bz , sig_y_0 , sig_z_0 , delta real gauss_plume_cartesian_func real sig_y , sig_z , x , y real cos_val , sin_val real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) x = ( x_r - x_s ) * cos_val + ( y_r - y_s ) * sin_val y =- ( x_r - x_s ) * sin_val + ( y_r - y_s ) * cos_val gauss_plume_cartesian_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) !write(*,*)sig_y_0,sig_y,sig_z_0,sig_z !gauss_plume_cartesian_func=1./(2.*pi*sig_y*sig_z)*exp((-y**2)/2./sig_y**2) & !    *(exp((-(z_r-z_s)**2)/2./sig_z**2)+exp((-(z_r+z_s)**2)/2./sig_z**2)) gauss_plume_cartesian_func = 1. / ( 2. * pi * sig_y * sig_z ) * exp ( - y * y / 2. / sig_y / sig_y ) & * ( exp ( - ( z_r - z_s ) * ( z_r - z_s ) / 2. / sig_z / sig_z ) + exp ( - ( z_r + z_s ) * ( z_r + z_s ) / 2. / sig_z / sig_z )) endif end function gauss_plume_cartesian_func !========================================================================== !   uEMEP model gauss_plume_cartesian_integral_func !   Cartesian Gaussian plume function !========================================================================== function gauss_plume_cartesian_integral_func ( x_s , y_s , z_s , cos_val , sin_val , x_r , y_r , ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta ) implicit none real x_s , y_s , z_s , x_r , y_r real ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta real gauss_plume_cartesian_integral_func real sig_y , sig_z , x , y real cos_val , sin_val real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) x = ( x_r - x_s ) * cos_val + ( y_r - y_s ) * sin_val y =- ( x_r - x_s ) * sin_val + ( y_r - y_s ) * cos_val gauss_plume_cartesian_integral_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) !gauss_plume_cartesian_integral_func=1./(2.*pi*sig_y)*exp((-y**2)/2./sig_y**2) & !    *sqrt(pi/2.)*(erf((z_s-H1)/sqrt(2.)/sig_z)-erf((z_s-H2)/sqrt(2.)/sig_z)+erf((z_s+H2)/sqrt(2.)/sig_z)-erf((z_s+H1)/sqrt(2.)/sig_z))/(H2-H1) gauss_plume_cartesian_integral_func = 1. / ( 2. * pi * sig_y ) * exp (( - y * y ) / 2. / ( sig_y * sig_y )) & * sqrt ( pi / 2. ) * ( erf (( z_s - H1 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s - H2 ) / sqrt ( 2. ) / sig_z ) + erf (( z_s + H2 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s + H1 ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) endif end function gauss_plume_cartesian_integral_func !========================================================================== !   uEMEP model gauss_plume_cartesian_trajectory_func !   Cartesian Gaussian plume function that does not calculate direction but uses distance x and perpendicular distance y as input. !   These are precalculated !========================================================================== !function gauss_plume_cartesian_func(x_s,y_s,z_s,u_s,v_s,x_r,y_r,z_r,ay,by,az,bz,sig_y_0,sig_z_0) function gauss_plume_cartesian_trajectory_func ( x , y , z_s , z_r , ay , by , az , bz , sig_y_0 , sig_z_0 , delta ) implicit none real x , y , z_s , z_r real ay , by , az , bz , sig_y_0 , sig_z_0 , delta real gauss_plume_cartesian_trajectory_func real sig_y , sig_z real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) !x=(x_r-x_s)*cos_val+(y_r-y_s)*sin_val !y=-(x_r-x_s)*sin_val+(y_r-y_s)*cos_val gauss_plume_cartesian_trajectory_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) gauss_plume_cartesian_trajectory_func = 1. / ( 2. * pi * sig_y * sig_z ) * exp (( - y * y ) / 2. / ( sig_y * sig_y )) & * ( exp (( - ( z_r - z_s ) * ( z_r - z_s )) / 2. / ( sig_z * sig_z )) + exp (( - ( z_r + z_s ) * ( z_r + z_s )) / 2. / ( sig_z * sig_z ))) endif end function gauss_plume_cartesian_trajectory_func !========================================================================== !   uEMEP model gauss_plume_cartesian_trajectory_integral_func !   Cartesian Gaussian plume function !========================================================================== function gauss_plume_cartesian_trajectory_integral_func ( x , y , z_s , ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta ) implicit none real x , y , z_s real ay , by , az , bz , sig_y_0 , sig_z_0 , H1 , H2 , delta real gauss_plume_cartesian_trajectory_integral_func real sig_y , sig_z real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) !r=sqrt((x_s-x_r)**2+(y_s-y_r)**2) !if (abs(u_s).lt.001) u_s=0.001 !th=atan(v_s/u_s) !if (u_s.lt.0) th=th+pi !cos_val=cos(th) !sin_val=sin(th) !x=(x_r-x_s)*cos_val+(y_r-y_s)*sin_val !y=-(x_r-x_s)*sin_val+(y_r-y_s)*cos_val gauss_plume_cartesian_trajectory_integral_func = 0. sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta ) if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then sig_z = sig_z_0 + az * exp ( bz * log ( x )) !gauss_plume_cartesian_integral_func=1./(2.*pi*sig_y)*exp((-y**2)/2./sig_y**2) & !    *sqrt(pi/2.)*(erf((z_s-H1)/sqrt(2.)/sig_z)-erf((z_s-H2)/sqrt(2.)/sig_z)+erf((z_s+H2)/sqrt(2.)/sig_z)-erf((z_s+H1)/sqrt(2.)/sig_z))/(H2-H1) gauss_plume_cartesian_trajectory_integral_func = 1. / ( 2. * pi * sig_y ) * exp (( - y * y ) / 2. / ( sig_y * sig_y )) & * sqrt ( pi / 2. ) * ( erf (( z_s - H1 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s - H2 ) / sqrt ( 2. ) / sig_z ) + erf (( z_s + H2 ) / sqrt ( 2. ) / sig_z ) - erf (( z_s + H1 ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) endif end function gauss_plume_cartesian_trajectory_integral_func function gauss_plume_cartesian_sigma_func ( x , y , z_s , z_r , sig_z , sig_y , z_pbl , FF ) implicit none real , intent ( in ) :: x , y , z_s , z_r , sig_y , sig_z , z_pbl , FF real gauss_plume_cartesian_sigma_func real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) real z_loop ( 5 ) real c_z integer k , n_loop gauss_plume_cartesian_sigma_func = 0. if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then !write(*,*) 'here' !If the emission height z_s is greater than the boundary layer height z_pbl then only allow reflection from the surface !Also if z_r+z_s<z_pbl/3 then only use surface reflections since the pbl reflection counts for so little !Otherwise allow reflection from surface and boundary layer if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif !For large sigmaz set the plume to be evenly distributed in the boundary layer !A value of 0.9 is used as this is the correct value for surface level releases and within 2% for high level releases !Should not be used for above boundary layer releases but is not accounted for if ( sig_z . gt . 0.9 * z_pbl ) then c_z = 1. / z_pbl gauss_plume_cartesian_sigma_func = c_z / ( sqrt ( 2. * pi ) * sig_y ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF else c_z = 0. do k = 1 , n_loop c_z = c_z + exp ( - 0.5 * (( z_r - z_loop ( k )) / sig_z ) * (( z_r - z_loop ( k )) / sig_z )) enddo gauss_plume_cartesian_sigma_func = c_z / ( 2. * pi * sig_y * sig_z ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF endif !if (x.eq.0) then !    write(*,*) gauss_plume_cartesian_sigma_func*FF,1./(2.*pi*sig_y*sig_z) !endif endif end function gauss_plume_cartesian_sigma_func function gauss_plume_cartesian_sigma_integral_func ( x , y , z_s , sig_z , sig_y , z_pbl , FF , H1 , H2 ) implicit none real , intent ( in ) :: x , y , z_s , sig_y , sig_z , z_pbl , FF , H1 , H2 real gauss_plume_cartesian_sigma_integral_func real pi , sig_limit parameter ( pi = 3.141592 , sig_limit = 3. ) real z_loop ( 5 ) real c_z integer k , n_loop gauss_plume_cartesian_sigma_integral_func = 0. if ( x . ge . 0. and . abs ( y ). lt . sig_y * sig_limit ) then !If the emission height z_s is greater than the boundary layer height z_pbl then only allow reflection from the surface !Also if z_r+z_s<z_pbl/3 then only use surface reflections since the pbl reflection counts for so little !Otherwise allow reflection from surface and boundary layer if ( z_s . gt . z_pbl . or . z_s + sig_z . lt . z_pbl / 3. ) then n_loop = 2 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s else n_loop = 5 z_loop ( 1 ) = z_s ; z_loop ( 2 ) =- z_s ; z_loop ( 3 ) = 2. * z_pbl - z_s ; z_loop ( 4 ) = 2. * z_pbl + z_s ; z_loop ( 5 ) =- 2. * z_pbl + z_s endif !For large sigmaz set the plume to be evenly distributed in the boundary layer !A value of 0.9 is used as this is the correct value for surface level releases and within 2% for high level releases !Should not be used for above boundary layer releases but is not accounted for if ( sig_z . gt . 0.9 * z_pbl ) then c_z = 1. / z_pbl gauss_plume_cartesian_sigma_integral_func = c_z / ( sqrt ( 2. * pi ) * sig_y ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF else c_z = 0. do k = 1 , n_loop !c_z=c_z+exp(-0.5*((z_r-z_loop(k))/sig_z)*((z_r-z_loop(k))/sig_z)) c_z = c_z + sqrt ( pi / 2. ) * sig_z * ( erf (( z_loop ( k ) - H1 ) / sqrt ( 2. ) / sig_z ) - erf (( z_loop ( k ) - H2 ) / sqrt ( 2. ) / sig_z )) / ( H2 - H1 ) enddo gauss_plume_cartesian_sigma_integral_func = c_z / ( 2. * pi * sig_y * sig_z ) * exp ( - 0.5 * ( y * y ) / ( sig_y * sig_y )) / FF endif !gauss_plume_cartesian_integral_func=1./(2.*pi*sig_y)*exp((-y*y)/2./(sig_y*sig_y)) & !    *sqrt(pi/2.)*(erf((z_s-H1)/sqrt(2.)/sig_z)-erf((z_s-H2)/sqrt(2.)/sig_z)+erf((z_s+H2)/sqrt(2.)/sig_z)-erf((z_s+H1)/sqrt(2.)/sig_z))/(H2-H1) endif end function gauss_plume_cartesian_sigma_integral_func end module dispersion_functions","tags":"","loc":"sourcefile/uemep_dispersion_functions.f90.html"},{"title":"uEMEP_read_SSB_data.f90 – uEMEP","text":"Source Code module read_ssb_data use uemep_configuration use utility_functions , only : ll2utm , ll2ltm use mod_lambert_projection , only : LL2LAEA , PROJ2LL use mod_area_interpolation , only : area_weighted_extended_vectorgrid_interpolation_function implicit none private public :: uEMEP_read_netcdf_population , uEMEP_read_SSB_data , uEMEP_read_netcdf_population_latlon contains !uEMEP_read_SSB_data.f90 subroutine uEMEP_read_SSB_data use uEMEP_definitions implicit none integer i , j , k character ( 256 ) temp_name character ( 256 ) temp_str , temp_str1 , temp_str2 integer unit_in logical :: exists integer count , index_val integer temp_int integer * 8 ssb_id real dwe_todw , dwe_mult real pop_tot , emp_tot integer i_ssb_index , j_ssb_index integer source_index , subsource_index integer t integer , allocatable :: count_subgrid (:,:) real , allocatable :: temp1_subgrid (:,:), temp2_subgrid (:,:), temp3_subgrid (:,:) real x_ssb , y_ssb real :: f_easting = 2.e6 integer SSB_file_index real :: ssb_dx = 25 0. , ssb_dy = 25 0. real heating_proxy integer :: use_region = 0 character ( 256 ) region_number_str integer n_search parameter ( n_search = 5 ) character ( 16 ) search_str ( n_search ) real search_delta ( n_search ) integer temp_search integer :: io data search_str / '1000m' , '500m' , '250m' , '100m' , '50m' / data search_delta / 100 0. , 50 0. , 25 0. , 10 0. , 5 0. / write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading SSB data  (uEMEP_read_SSB_data)' write ( unit_logfile , '(A)' ) '================================================================' source_index = heating_index n_subsource ( source_index ) = 1 t = 1 !Initialise the use_grid array to false if population is to be used for the auto subgridding if ( use_population_positions_for_auto_subgrid_flag ) then use_subgrid = . false . endif !If dwellings are read then allocate the emission heating arrays. Otherwise allocate the population arrays if ( SSB_data_type . eq . dwelling_index ) then proxy_emission_subgrid (:,:, source_index ,:) = 0. allocate ( count_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp1_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp2_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) allocate ( temp3_subgrid ( emission_subgrid_dim ( x_dim_index , source_index ), emission_subgrid_dim ( y_dim_index , source_index ))) else allocate ( count_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) allocate ( temp1_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) allocate ( temp2_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) allocate ( temp3_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) endif count_subgrid = 0 SSB_file_index = SSB_data_type if ( SSB_data_type . eq . dwelling_index ) then pathfilename_heating ( SSB_file_index ) = trim ( pathname_heating ( SSB_file_index )) // trim ( filename_heating ( SSB_file_index )) !Test existence of the heating filename. If does not exist then stop inquire ( file = trim ( pathfilename_heating ( SSB_file_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file does not exist: ' , trim ( pathfilename_heating ( SSB_file_index )) stop endif temp_name = pathfilename_heating ( SSB_file_index ) elseif (. not . use_region_select_and_mask_flag ) then pathfilename_population ( SSB_file_index ) = trim ( pathname_population ( SSB_file_index )) // trim ( filename_population ( SSB_file_index )) !Test existence of the heating filename. If does not exist then stop inquire ( file = trim ( pathfilename_population ( SSB_file_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file does not exist: ' , trim ( pathfilename_population ( SSB_file_index )) stop endif temp_name = pathfilename_population ( SSB_file_index ) elseif ( use_region_select_and_mask_flag . and . SSB_data_type . eq . population_index ) then region_number_str = '' write ( region_number_str , * ) region_index region_number_str = trim ( region_number_str ) // '_' pathfilename_population ( SSB_file_index ) = trim ( pathname_population ( SSB_file_index )) // trim ( adjustl ( region_number_str )) // trim ( filename_population ( SSB_file_index )) !Test existence of the heating filename. If does not exist then use default inquire ( file = trim ( pathfilename_population ( SSB_file_index )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: SSB file does not exist: ' , trim ( pathfilename_population ( SSB_file_index )) stop endif temp_name = pathfilename_population ( SSB_file_index ) end if ! Determine grid resolution of population file ! NB: should this also be done for dwelling_index and establishement_index? if ( SSB_data_type . eq . population_index ) then !Search file name to define the grid size ssb_dx = 0. ; ssb_dy = 0. do k = 1 , n_search temp_search = index ( filename_population ( SSB_file_index ), trim ( adjustl ( search_str ( k )))) if ( temp_search . ne . 0 ) then ssb_dx = search_delta ( k ) ssb_dy = search_delta ( k ) write ( unit_logfile , '(i,A)' ) temp_search , ' Reading municipality population data with resolution ' // trim ( adjustl ( search_str ( k ))) ! No point changing 'limit_population_delta' here, since it has already been used (uEMEP_set_subgrids) !limit_population_delta=search_delta(k) endif enddo if ( ssb_dx . eq . 0 ) then write ( unit_logfile , '(A)' ) 'Cannot find a valid SSB grid size. Stopping. ' // trim ( filename_population ( SSB_file_index )) stop endif endif !Open the file for reading unit_in = 20 open ( unit_in , file = temp_name , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening SSB file ' // trim ( temp_name ) rewind ( unit_in ) subsource_index = 1 !Read header SSBID0250M;dwe_todw;dwe_det;dwe_2dw;dwe_row;dwe_mult;dwe_com;dwe_oth;dwe_area read ( unit_in , '(A)' ) temp_str write ( unit_logfile , '(A)' ) 'Header: ' // trim ( temp_str ) !read(unit_in,'(A)') temp_str !write(*,*) trim(temp_str) count = 0 do ssb_id = 0 ; dwe_todw = 0 ; dwe_mult = 0 ; pop_tot = 0 ; emp_tot = 0 if ( SSB_data_type . eq . dwelling_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !Extract the ssb id for the coordinates index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id !Extract the total number of dwellings index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) dwe_todw !Skip over some values not to be used index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int !Extract the multiple dwellings number index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) dwe_mult endif if ( SSB_data_type . eq . population_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,*) trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id !write(*,*) trim(temp_str) !index_val=index(temp_str,';',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:);if (index_val.gt.1) read(temp_str1,*) pop_tot read ( temp_str , * ) pop_tot !write (*,*) ssb_id,pop_tot,index_val endif if ( SSB_data_type . eq . establishment_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,*) trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) ssb_id !write(*,*) trim(temp_str) index_val = index ( temp_str , ';' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int read ( temp_str , * ) pop_tot !write (*,*) ssb_id,pop_tot,index_val endif if ( SSB_data_type . eq . kindergaten_index . or . SSB_data_type . eq . school_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,'(a)') trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) x_ssb index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) y_ssb index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_str2 index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_int !write(*,'(a)') trim(temp_str) index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) pop_tot !read(temp_str,*) pop_tot !write (*,*) x_ssb,y_ssb,pop_tot endif if ( SSB_data_type . eq . home_index ) then !Read in file string read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) exit !write(*,'(a)') trim(temp_str) !Extract the ssb id for the coordinates index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) temp_str2 index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) y_ssb index_val = index ( temp_str , ',' , back = . false .); temp_str1 = temp_str ( 1 : index_val - 1 ); temp_str = temp_str ( index_val + 1 :); if ( index_val . gt . 1 ) read ( temp_str1 , * ) x_ssb !index_val=index(temp_str,',',back=.false.);temp_str1=temp_str(1:index_val-1);temp_str=temp_str(index_val+1:);if (index_val.gt.1) read(temp_str1,*) pop_tot read ( temp_str , * ) pop_tot !write (*,*) trim(temp_str2),y_32,x_32,pop_tot !Convert from UTM32 to 33 !call UTM2LL(utm_zone-1,y_32,x_32,lat_32,lon_32) !write(*,*) lat_32,lon_32 !call ll2utm_modern(1,utm_zone,lat_32,lon_32,y_ssb,x_ssb) !write(*,*) y_ssb,x_ssb endif count = count + 1 !if (mod(count,100000).eq.0) write(*,*) count,ssb_id,dwe_todw,dwe_mult,pop_tot if ( dwe_todw . gt . 0. or . pop_tot . gt . 0 ) then !Convert id to grid centre coordinates that are already in UTM33 for SSB data if ( SSB_data_type . eq . dwelling_index . or . SSB_data_type . eq . establishment_index . or . SSB_data_type . eq . population_index ) then x_ssb = ssb_id / 10000000 - f_easting + ssb_dx / 2. y_ssb = mod ( ssb_id , 10000000 ) + ssb_dy / 2. endif !Convert lat lon to utm coords !call ll2utm_modern(1,utm_zone,ddlatitude,ddlongitude,y_ship,x_ship) !Add to heating emission proxy subgrid if ( SSB_data_type . eq . dwelling_index ) then !Find the grid index it belongs to i_ssb_index = 1 + floor (( x_ssb - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ssb_index = 1 + floor (( y_ssb - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then !write(*,*) x_ssb,y_ssb,emission_subgrid_delta(x_dim_index,source_index),i_ssb_index,j_ssb_index !Reduce the number of dwellings when they are in a multiple dwelling by factor of 5. i.e. the proxy is reduced in blocks with the assumption that only 1 in 5 use their wood heater heating_proxy = dwe_todw heating_proxy = max ( 0. , dwe_todw - dwe_mult ) + dwe_mult / 5. proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) + heating_proxy count_subgrid ( i_ssb_index , j_ssb_index ) = count_subgrid ( i_ssb_index , j_ssb_index ) + 1 !write(*,*) count,proxy_emission_subgrid(i_ssb_index,j_ssb_index,source_index,subsource_index) endif else !Find the grid index it belongs to in the population grid i_ssb_index = 1 + floor (( x_ssb - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) j_ssb_index = 1 + floor (( y_ssb - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . population_subgrid_dim ( x_dim_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . population_subgrid_dim ( y_dim_index ). and . pop_tot . gt . 0 ) then population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) = population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) + pop_tot count_subgrid ( i_ssb_index , j_ssb_index ) = count_subgrid ( i_ssb_index , j_ssb_index ) + 1 !write(*,*) count,proxy_emission_subgrid(i_ssb_index,j_ssb_index,source_index,subsource_index) endif if ( use_population_positions_for_auto_subgrid_flag ) then !Cover the grids when target grids are smaller than population grids if ( SSB_data_type . eq . population_index ) then use_region = floor ( population_subgrid_delta ( x_dim_index ) / subgrid_delta ( x_dim_index ) / 2. ) endif !Find the grid index it belongs to in the target grid i_ssb_index = 1 + floor (( x_ssb - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) j_ssb_index = 1 + floor (( y_ssb - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) if ( i_ssb_index - use_region . ge . 1. and . i_ssb_index + use_region . le . subgrid_dim ( x_dim_index ) & . and . j_ssb_index - use_region . ge . 1. and . j_ssb_index + use_region . le . subgrid_dim ( y_dim_index ). and . pop_tot . gt . 0 ) then use_subgrid ( i_ssb_index - use_region : i_ssb_index + use_region , j_ssb_index - use_region : j_ssb_index + use_region ,:) = . true . endif endif endif endif enddo if ( SSB_data_type . eq . dwelling_index ) then write ( unit_logfile , '(A,I)' ) 'Dwelling counts = ' , count write ( unit_logfile , '(A,es12.3)' ) 'Total dwellings = ' , sum ( proxy_emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ), source_index , 1 )) write ( unit_logfile , '(A,I,a,i,a)' ) 'Number of grid placements = ' , sum ( count_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , source_index ), 1 : emission_subgrid_dim ( y_dim_index , source_index ))), ' of ' , emission_subgrid_dim ( x_dim_index , source_index ) * emission_subgrid_dim ( y_dim_index , source_index ), ' grids' else write ( unit_logfile , '(A,I)' ) 'Population type index = ' , SSB_data_type write ( unit_logfile , '(A,I)' ) 'Population counts = ' , count write ( unit_logfile , '(A,es12.3)' ) 'Total population = ' , sum ( population_subgrid (:,:, SSB_data_type )) write ( unit_logfile , '(A,I,a,i,a)' ) 'Number of grid placements = ' , sum ( count_subgrid ), ' of ' , subgrid_dim ( x_dim_index ) * subgrid_dim ( y_dim_index ), ' grids' endif close ( unit_in ) deallocate ( count_subgrid ) !Find the number of subgrids to be used if ( use_population_positions_for_auto_subgrid_flag . and . SSB_data_type . ne . dwelling_index ) then count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) count = count + 1 enddo enddo write ( unit_logfile , '(a,i,a,i)' ) ' Using population for subgrids. Number of subgrids to be calculated based on population = ' , count , ' of ' , subgrid_dim ( y_dim_index ) * subgrid_dim ( x_dim_index ) endif deallocate ( temp1_subgrid , temp2_subgrid , temp3_subgrid ) end subroutine uEMEP_read_SSB_data !Read in the population data in netcdf format !This is particularly used for reading in the global population dataset !This is not used any longer, replaced by uEMEP_read_netcdf_population_latlon !Attempt to read in local but still not working subroutine uEMEP_read_netcdf_population use uEMEP_definitions use netcdf implicit none integer status_nc integer i_split , j_split , n_delta_split integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc , var_id_nc_temp real x_ssb , y_ssb integer i_ssb_index , j_ssb_index real delta_pop_nc ( num_dims_population_nc ) integer dim_id_nc ( num_dims_population_nc ) integer dim_length_population_nc ( num_dims_population_nc ) real y_pop , x_pop integer source_index logical :: exists !Temporary reading rvariables real , allocatable :: population_nc_dp (:,:,:) double precision , allocatable :: var2d_nc_dp (:,:) !If the data type is dwelling then this means it is for heating if ( SSB_data_type . eq . dwelling_index ) source_index = heating_index !Set the filename pathfilename_population ( SSB_data_type ) = trim ( pathname_population ( SSB_data_type )) // trim ( filename_population ( SSB_data_type )) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_population ( SSB_data_type )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_population ( SSB_data_type )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_population ( SSB_data_type )) status_nc = NF90_OPEN ( pathfilename_population ( SSB_data_type ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the projection. If no projection then in lat lon coordinates !status_nc = NF90_INQ_VARID (id_nc,'projection_lambert',var_id_nc) !status_nc = NF90_INQ_VARID (id_nc,'mollweide',var_id_nc_temp) !if (status_nc.eq.NF90_NOERR) then !    population_nc_projection_type=mollweide_projection_index !    var_id_nc=var_id_nc_temp !endif status_nc = NF90_INQ_VARID ( id_nc , 'transverse_mercator' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = UTM_projection_index var_id_nc = var_id_nc_temp endif status_nc = NF90_INQ_VARID ( id_nc , 'projection_utm' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = UTM_projection_index var_id_nc = var_id_nc_temp endif status_nc = NF90_INQ_VARID ( id_nc , 'projection_lambert' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = LCC_projection_index var_id_nc = var_id_nc_temp endif status_nc = NF90_INQ_VARID ( id_nc , 'projection_ETRS89_LAEA' , var_id_nc_temp ) if ( status_nc . eq . NF90_NOERR ) then population_nc_projection_type = LAEA_projection_index var_id_nc = var_id_nc_temp endif if ( population_nc_projection_type . ne . LL_projection_index ) then !If there is a projection then read in the attributes. All these are doubles !status_nc = nf90_inquire_variable(id_nc, var_id_nc, natts = numAtts_projection) status_nc = nf90_get_att ( id_nc , var_id_nc , 'Central_Meridian' , population_nc_projection_attributes ( 1 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'False_Easting' , population_nc_projection_attributes ( 2 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'False_Northing' , population_nc_projection_attributes ( 3 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'longitude_of_prime_meridian' , population_nc_projection_attributes ( 4 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'semi_major_axis' , population_nc_projection_attributes ( 5 )) status_nc = nf90_get_att ( id_nc , var_id_nc , 'inverse_flattening' , population_nc_projection_attributes ( 6 )) write ( unit_logfile , '(A,4i,6f12.2)' ) 'Reading projection (index, params) ' , population_nc_projection_type , population_nc_projection_attributes ( 1 : 6 ) endif !Even if projection is Mollweide still use the lat lon positions !population_nc_projection_type=LL_projection_index !Find the (x,y) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_population_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_population_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_population_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_population_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_population_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of population dimensions (x,y): ' , dim_length_population_nc !Allocate the temporary arrays for lat,lon and population if (. not . allocated ( population_nc_dp )) allocate ( population_nc_dp ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ), num_var_population_nc )) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index )), num_dims_population_nc )) !x and y !Read the x and y values to get the delta do i = 1 , num_dims_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_population_nc ( i ), i ), start = ( / 1 / ), count = ( / dim_length_population_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_pop_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.2)' ) 'Population grid delta (m): ' , delta_pop_nc do i = 1 , num_var_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , population_nc_dp (:,:, i ), start = ( / 1 , 1 / ), count = ( / dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Population variable min and max: ' , trim ( var_name_nc_temp ), minval ( population_nc_dp (:,:, i )), maxval ( population_nc_dp (:,:, i )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo !Loop through the population data and put it in the population grid !Converting from lat lon to the subgrid coordinates and then finding the nearest neighbour !If population_subgrid_delta<delta_pop_nc then split the input grid into subgrids that are smaller than subgrid !Split any way into four even if they are the same grids for better interpolation n_delta_split = floor ( sqrt ( delta_pop_nc ( x_dim_nc_index ) ** 2 + delta_pop_nc ( y_dim_nc_index ) ** 2 ) / sqrt ( population_subgrid_delta ( x_dim_index ) ** 2 + population_subgrid_delta ( y_dim_index ) ** 2 ) + . 001 ) n_delta_split = 10 * max ( n_delta_split , 1 ) write ( unit_logfile , '(A,i)' ) 'Population grids split into this many segments for numerical nearest neighbour interpolation: ' , n_delta_split !Already defined as 0. Do it again population_subgrid (:,:, SSB_data_type ) = 0 do j = 1 , dim_length_population_nc ( y_dim_nc_index ) do i = 1 , dim_length_population_nc ( x_dim_nc_index ) if ( population_nc_dp ( i , j , population_nc_index ). gt . 0 ) then if ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , population_nc_dp ( i , j , lat_nc_index ), population_nc_dp ( i , j , lon_nc_index ), y_pop , x_pop ) !write(*,*) population_nc_dp(i,j,lat_nc_index),population_nc_dp(i,j,lon_nc_index),y_pop,x_pop elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , population_nc_dp ( i , j , lat_nc_index ), population_nc_dp ( i , j , lon_nc_index ), y_pop , x_pop ) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_pop , y_pop , population_nc_dp ( i , j , lon_nc_index ), population_nc_dp ( i , j , lat_nc_index ), projection_attributes ) !call LAEA2LL(x_pop,y_pop,x_ssb,y_ssb,projection_attributes) !write(*,*) population_nc_dp(i,j,lon_nc_index)-x_ssb,population_nc_dp(i,j,lat_nc_index)-y_ssb else write ( unit_logfile , '(A)' ) 'No supported projection available for population. Stopping ' stop endif !Loop through the n_delta_split do i_split = 1 , n_delta_split do j_split = 1 , n_delta_split x_ssb = x_pop - delta_pop_nc ( x_dim_nc_index ) * 0.5 + ( i_split - 0.5 ) * delta_pop_nc ( x_dim_nc_index ) / n_delta_split y_ssb = y_pop - delta_pop_nc ( y_dim_nc_index ) * 0.5 + ( j_split - 0.5 ) * delta_pop_nc ( y_dim_nc_index ) / n_delta_split if ( SSB_data_type . eq . population_index ) then i_ssb_index = 1 + floor (( x_ssb - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) j_ssb_index = 1 + floor (( y_ssb - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . population_subgrid_dim ( x_dim_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . population_subgrid_dim ( y_dim_index )) then population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) = population_subgrid ( i_ssb_index , j_ssb_index , SSB_data_type ) & + population_nc_dp ( i , j , population_nc_index ) / ( n_delta_split ** 2 ) !write(*,'(2i,6f12.1)') i_split,j_split,x_pop,y_pop,x_ssb,y_ssb,(i_split-0.5)*delta_pop_nc(x_dim_nc_index)/n_delta_split,(j_split-0.5)*delta_pop_nc(y_dim_nc_index)/n_delta_split !write(*,*) i_split,j_split,i_ssb_index,j_ssb_index !write(*,*) i_ssb_index,j_ssb_index,SSB_data_type,population_subgrid(i_ssb_index,j_ssb_index,SSB_data_type) endif endif if ( SSB_data_type . eq . dwelling_index ) then i_ssb_index = 1 + floor (( x_ssb - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_ssb_index = 1 + floor (( y_ssb - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if ( i_ssb_index . ge . 1. and . i_ssb_index . le . emission_subgrid_dim ( x_dim_index , source_index ) & . and . j_ssb_index . ge . 1. and . j_ssb_index . le . emission_subgrid_dim ( y_dim_index , source_index )) then proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) = proxy_emission_subgrid ( i_ssb_index , j_ssb_index , source_index ,:) & + population_nc_dp ( i , j , population_nc_index ) / ( n_delta_split ** 2 ) endif endif enddo enddo endif enddo enddo if ( allocated ( population_nc_dp )) deallocate ( population_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) end subroutine uEMEP_read_netcdf_population !Read in the population data in netcdf format in latlon grid !This is particularly used for reading in the global population dataset subroutine uEMEP_read_netcdf_population_latlon use uEMEP_definitions use netcdf implicit none integer status_nc integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc real delta_pop_nc ( num_dims_population_nc ) integer dim_id_nc ( num_dims_population_nc ) integer dim_length_population_nc ( num_dims_population_nc ) integer dim_start_population_nc ( num_dims_population_nc ) integer source_index logical reduce_population_region_flag real temp_lon ( 4 ), temp_lat ( 4 ), temp_x ( 4 ), temp_y ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max real temp_delta ( num_dims_population_nc ) real correct_lon ( 2 ) real temp_scale integer :: name_index = 0 logical :: exists !Temporary reading rvariables real , allocatable :: population_nc_dp (:,:,:) !double precision, allocatable :: population_nc_dp(:,:,:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: temp_var2d_nc_dp (:,:) !If the data type is dwelling then this means it is for heating !Always set to this since emissions will be the largest domain, when reducing the reading domain !source_index=heating_index if ( SSB_data_type . eq . dwelling_index ) source_index = heating_index if ( SSB_data_type . eq . dwelling_index ) name_index = dwelling_nc_index if ( SSB_data_type . eq . population_index ) name_index = population_nc_index !Set the filename pathfilename_population ( SSB_data_type ) = trim ( pathname_population ( SSB_data_type )) // trim ( filename_population ( SSB_data_type )) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_population ( SSB_data_type )), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_population ( SSB_data_type )) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_population ( SSB_data_type )) status_nc = NF90_OPEN ( pathfilename_population ( SSB_data_type ), nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the (lon,lat) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_population_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_population_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_population_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_population_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_population_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of population dimensions (lon,lat): ' , dim_length_population_nc !Reduce the size of the grid to the heating emission grid size reduce_population_region_flag = . true . if ( reduce_population_region_flag ) then write ( unit_logfile , '(A)' ) 'Reducing population domain for reading' !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon if ( SSB_data_type . eq . dwelling_index ) then call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_min ( x_dim_index , source_index ), emission_subgrid_max ( y_dim_index , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( emission_subgrid_max ( x_dim_index , source_index ), emission_subgrid_min ( y_dim_index , source_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) endif if ( SSB_data_type . eq . population_index ) then call PROJ2LL ( population_subgrid_min ( x_dim_index ), population_subgrid_min ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( population_subgrid_max ( x_dim_index ), population_subgrid_max ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( population_subgrid_min ( x_dim_index ), population_subgrid_max ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( population_subgrid_max ( x_dim_index ), population_subgrid_min ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) endif temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 temp_x = temp_lon ; temp_y = temp_lat do i = 1 , 4 !write(*,*) i,temp_x(i),temp_y(i) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo write ( unit_logfile , '(A,2f12.2)' ) 'Min: ' , temp_x_min , temp_y_min write ( unit_logfile , '(A,2f12.2)' ) 'Max: ' , temp_x_max , temp_y_max !Read the lon and lat values to get the delta and size. Put in temporary array !Allocate the temporary arrays for lat,lon and population if (. not . allocated ( temp_var2d_nc_dp )) allocate ( temp_var2d_nc_dp ( max ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index )), num_dims_population_nc )) !x and y dim_start_population_nc = 1 do i = 1 , num_dims_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var2d_nc_dp ( 1 : dim_length_population_nc ( i ), i ), start = ( / dim_start_population_nc ( i ) / ), count = ( / dim_length_population_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_pop_nc = temp_var2d_nc_dp ( 2 ,:) - temp_var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Population grid delta (degrees): ' , delta_pop_nc !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = delta_pop_nc ( 1 ) temp_delta ( 2 ) = delta_pop_nc ( 2 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max !Increase the region by 5 grids to be certain i_temp_min = max ( 1 , i_temp_min - 5 ) i_temp_max = min ( dim_length_population_nc ( x_dim_nc_index ), i_temp_max + 5 ) j_temp_min = max ( 1 , j_temp_min - 5 ) j_temp_max = min ( dim_length_population_nc ( y_dim_nc_index ), j_temp_max + 5 ) dim_length_population_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_population_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_population_nc ( x_dim_nc_index ) = i_temp_min dim_start_population_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading population i grids: ' , i_temp_min , i_temp_max , dim_length_population_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading population j grids: ' , j_temp_min , j_temp_max , dim_length_population_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading population lon grids (min,max): ' , temp_var2d_nc_dp ( i_temp_min , x_dim_nc_index ), temp_var2d_nc_dp ( i_temp_max , x_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading population lat grids (min,max): ' , temp_var2d_nc_dp ( j_temp_min , y_dim_nc_index ), temp_var2d_nc_dp ( j_temp_max , y_dim_nc_index ) !endif endif if ( i_temp_min . ge . i_temp_max . or . j_temp_min . ge . j_temp_max ) then !No population data available write ( unit_logfile , '(A)' ) ' WARNING: No population data available in this region. Setting to 0' proxy_emission_subgrid (:,:, source_index ,:) = 0. population_subgrid (:,:, SSB_data_type ) = 0 else if (. not . allocated ( population_nc_dp )) allocate ( population_nc_dp ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ), num_var_population_nc )) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index )), num_dims_population_nc )) !x and y !Read the lon and lat values to get the delta do i = 1 , num_dims_population_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_population_nc ( i ), i ), start = ( / dim_start_population_nc ( i ) / ), count = ( / dim_length_population_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_pop_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Population grid delta (degrees): ' , delta_pop_nc !write(*,*) var2d_nc_dp(1,1),var2d_nc_dp(dim_length_population_nc(x_dim_nc_index),1) !write(*,*) var2d_nc_dp(1,2),var2d_nc_dp(dim_length_population_nc(y_dim_nc_index),2) !Read the population data !write(*,*) 'Reading population data' !do i=1,num_var_population_nc i = name_index !Uses the population_nc_index as index, =1, but not logical !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_population_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , population_nc_dp (:,:, population_nc_index ), start = ( / dim_start_population_nc ( x_dim_nc_index ), dim_start_population_nc ( y_dim_nc_index ) / ), count = ( / dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Population variable min and max: ' , trim ( var_name_nc_temp ), minval ( population_nc_dp (:,:, population_nc_index )), maxval ( population_nc_dp (:,:, population_nc_index )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif !enddo !write(*,*) 'Finished reading population data' !Loop through the population data and put it in the population grid !Converting from lat lon to the subgrid coordinates and then finding the nearest neighbour !Interpolate to the population grid in lat lon coordinates population_subgrid (:,:, SSB_data_type ) = 0. !where (population_nc_dp.lt.0.0D00) population_nc_dp=0.0D00 where ( population_nc_dp . lt . 0.0 ) population_nc_dp = 0.0 write ( unit_logfile , '(2a,2f12.2)' ) 'Population min and max: ' , trim ( var_name_nc_temp ), minval ( population_nc_dp (:,:, population_nc_index )), maxval ( population_nc_dp (:,:, population_nc_index )) !stop if ( SSB_data_type . eq . population_index ) then do j = 1 , population_subgrid_dim ( y_dim_nc_index ) do i = 1 , population_subgrid_dim ( x_dim_nc_index ) !Project the centre position to lat lon call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_population_subgrid ( i , j ) - population_subgrid_delta ( x_dim_index ) / 2. , y_population_subgrid ( i , j ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_population_subgrid ( i , j ) + population_subgrid_delta ( x_dim_index ) / 2. , y_population_subgrid ( i , j ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ) - population_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ) + population_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !write(*,*) correct_lon ! population_subgrid(i,j,SSB_data_type)=area_weighted_extended_vectorgrid_interpolation_function( & !     real(var2d_nc_dp(1:dim_length_population_nc(x_dim_nc_index),x_dim_nc_index))*correct_lon(1),real(var2d_nc_dp(1:dim_length_population_nc(y_dim_nc_index),y_dim_nc_index)) & !     ,population_nc_dp(:,:,population_nc_index),dim_length_population_nc(x_dim_nc_index),dim_length_population_nc(y_dim_nc_index) & !     ,delta_pop_nc*correct_lon,temp_lon(1)*correct_lon(1),temp_lat(1),temp_delta*correct_lon) ! write(*,*) temp_lon(1),temp_lat(1),var2d_nc_dp(int(dim_length_population_nc(x_dim_nc_index)/2),x_dim_nc_index),var2d_nc_dp(int(dim_length_population_nc(y_dim_nc_index)/2),y_dim_nc_index),population_subgrid(i,j,SSB_data_type) !Take the nearest instead for a check !i_ssb_index=1+floor((temp_lon(1)-var2d_nc_dp(1,x_dim_nc_index))/delta_pop_nc(1)+0.5) !j_ssb_index=1+floor((temp_lat(1)-var2d_nc_dp(1,y_dim_nc_index))/delta_pop_nc(2)+0.5) !population_subgrid(i,j,SSB_data_type)=population_nc_dp(i_ssb_index,j_ssb_index,population_nc_index) !Do the interpolation on the same grid then scale afterwards. Equivalent to interpolating density then rescaling with grid size population_subgrid ( i , j , SSB_data_type ) = area_weighted_extended_vectorgrid_interpolation_function ( & real ( var2d_nc_dp ( 1 : dim_length_population_nc ( x_dim_nc_index ), x_dim_nc_index )) * correct_lon ( 1 ), real ( var2d_nc_dp ( 1 : dim_length_population_nc ( y_dim_nc_index ), y_dim_nc_index )) & , population_nc_dp (:,:, population_nc_index ), dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) & , delta_pop_nc * correct_lon , temp_lon ( 1 ) * correct_lon ( 1 ), temp_lat ( 1 ), delta_pop_nc * correct_lon ) temp_scale = ( temp_delta ( 1 ) * correct_lon ( 1 ) * temp_delta ( 2 ) * correct_lon ( 2 )) / ( delta_pop_nc ( 1 ) * correct_lon ( 1 ) * delta_pop_nc ( 2 ) * correct_lon ( 2 )) !write(*,*) temp_scale population_subgrid ( i , j , SSB_data_type ) = population_subgrid ( i , j , SSB_data_type ) * temp_scale if ( isnan ( population_subgrid ( i , j , SSB_data_type ))) then write ( * , * ) 'Stopping, nan in population_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif if ( population_subgrid ( i , j , SSB_data_type ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in population_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif enddo enddo write ( unit_logfile , '(A,f12.2)' ) 'Total population in read domain: ' , sum ( population_nc_dp (:,:, population_nc_index )) write ( unit_logfile , '(A,f12.2)' ) 'Total population in subgrid domain: ' , sum ( population_subgrid (:,:, SSB_data_type )) endif if ( SSB_data_type . eq . dwelling_index ) then proxy_emission_subgrid (:,:, source_index ,:) = 0. do j = 1 , emission_subgrid_dim ( y_dim_nc_index , source_index ) do i = 1 , emission_subgrid_dim ( x_dim_nc_index , source_index ) !Project the centre position to lat lon call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( x_dim_index , source_index ) / 2. , y_emission_subgrid ( i , j , source_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_emission_subgrid ( i , j , source_index ), y_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( y_dim_index , source_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !Interpolate on same grid then scale, equivalent to interpolating density and then recalculating proxy_emission_subgrid ( i , j , source_index ,:) = area_weighted_extended_vectorgrid_interpolation_function ( & real ( var2d_nc_dp ( 1 : dim_length_population_nc ( x_dim_nc_index ), x_dim_nc_index )) * correct_lon ( 1 ), real ( var2d_nc_dp ( 1 : dim_length_population_nc ( y_dim_nc_index ), y_dim_nc_index )) & , population_nc_dp (:,:, population_nc_index ), dim_length_population_nc ( x_dim_nc_index ), dim_length_population_nc ( y_dim_nc_index ) & , delta_pop_nc * correct_lon , temp_lon ( 1 ) * correct_lon ( 1 ), temp_lat ( 1 ), delta_pop_nc * correct_lon ) temp_scale = ( temp_delta ( 1 ) * correct_lon ( 1 ) * temp_delta ( 2 ) * correct_lon ( 2 )) / ( delta_pop_nc ( 1 ) * correct_lon ( 1 ) * delta_pop_nc ( 2 ) * correct_lon ( 2 )) proxy_emission_subgrid ( i , j , source_index ,:) = proxy_emission_subgrid ( i , j , source_index ,:) * temp_scale if ( isnan ( proxy_emission_subgrid ( i , j , source_index , 1 ))) then write ( * , * ) 'Stopping, nan in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif if ( proxy_emission_subgrid ( i , j , source_index , 1 ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in proxy_emission_subgrid' write ( * , * ) temp_scale , correct_lon , delta_pop_nc , temp_delta , temp_lon stop endif enddo enddo !Apply the power law scaling for population to reduce the distribution in higher population areas write ( unit_logfile , '(A,f12.2)' ) 'Power scaling of population using: ' , population_power_scale proxy_emission_subgrid (:,:, source_index ,:) = proxy_emission_subgrid (:,:, source_index ,:) ** population_power_scale endif endif !No population available if ( allocated ( population_nc_dp )) deallocate ( population_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_var2d_nc_dp )) deallocate ( temp_var2d_nc_dp ) end subroutine uEMEP_read_netcdf_population_latlon end module read_ssb_data","tags":"","loc":"sourcefile/uemep_read_ssb_data.f90.html"},{"title":"uEMEP_define_subgrid.f90 – uEMEP","text":"Source Code module define_subgrid use uemep_constants , only : pi use uemep_configuration use mod_lambert_projection , only : PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: uEMEP_define_subgrid , uEMEP_define_subgrid_extent contains !uEMEP_define_subgrid.f90 subroutine uEMEP_define_subgrid_extent use uEMEP_definitions implicit none integer i_source !integer ii,jj real dx_temp , dy_temp real lon_temp , lat_temp write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Define subgrid extent and buffer zones (uEMEP_define_subgrid_extent)' write ( unit_logfile , '(A)' ) '================================================================' !If annual calculations then always set time start and stop to 1 if ( annual_calculations ) then start_time_nc_index = 1 end_time_nc_index = 1 start_time_meteo_nc_index = 1 end_time_meteo_nc_index = 1 endif !Set the time index to be the same as the EMEP time dimensions emission_subgrid_dim ( t_dim_index ,:) = subgrid_dim ( t_dim_index ) init_emission_subgrid_dim ( t_dim_index ,:) = subgrid_dim ( t_dim_index ) integral_subgrid_dim ( t_dim_index ) = subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,I6)' ) 'Number of external time steps:' , end_time_loop_index - start_time_loop_index + 1 write ( unit_logfile , '(A,I6)' ) 'Number of internal time steps:' , subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A,2I6)' ) 'Number of target grids:' , subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Number of integral grids:' , integral_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Max number of emission grids:' , emission_max_subgrid_dim ( 1 : 2 ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I6)' ) 'Number of emission grids: ' , trim ( source_file_str ( i_source )), emission_subgrid_dim ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2I8)' ) 'Number of initial emission grids: ' , trim ( source_file_str ( i_source )), init_emission_subgrid_dim ( 1 : 2 , i_source ) endif enddo !Allocate buffers and adjust the dimensions appropriately !Calculate the max loop size to cover the nearest EMEP grids. This avoids looping through all the grids !loop_index_scale=1.2*EMEP_grid_interpolation_size/2.*local_fraction_grid_size_scaling !Was 1.5 loop_index_scale = 1.2 * EMEP_grid_interpolation_size / 2. * local_fraction_grid_size_scaling !Was 1.5 !Define the centre of the subgrid !ii=int(subgrid_dim(x_dim_index)/2) !jj=int(subgrid_dim(y_dim_index)/2) call PROJ2LL (( subgrid_min ( x_dim_index ) + subgrid_max ( x_dim_index )) / 2. ,( subgrid_min ( y_dim_index ) + subgrid_max ( y_dim_index )) / 2. , lon_temp , lat_temp , projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL((subgrid_min(y_dim_index)+subgrid_max(y_dim_index))/2.,(subgrid_min(x_dim_index)+subgrid_max(x_dim_index))/2.,lat_temp,lon_temp) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,(subgrid_min(y_dim_index)+subgrid_max(y_dim_index))/2.,(subgrid_min(x_dim_index)+subgrid_max(x_dim_index))/2.,lat_temp,lon_temp) !endif if ( EMEP_projection_type . eq . LL_projection_index ) then dx_temp = 11100 0. * dgrid_nc ( lon_nc_index ) * cos ( lat_temp * pi / 18 0. ) dy_temp = 11100 0. * dgrid_nc ( lat_nc_index ) else !Assumed LCC or PS dx_temp = dgrid_nc ( lon_nc_index ) dy_temp = dgrid_nc ( lat_nc_index ) endif subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / subgrid_delta ( x_dim_index ) * loop_index_scale ) subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / subgrid_delta ( y_dim_index ) * loop_index_scale ) integral_subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / integral_subgrid_delta ( x_dim_index ) * loop_index_scale ) integral_subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / integral_subgrid_delta ( y_dim_index ) * loop_index_scale ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid_loop_index ( x_dim_index , i_source ) = floor ( dx_temp / emission_subgrid_delta ( x_dim_index , i_source ) * loop_index_scale ) emission_subgrid_loop_index ( y_dim_index , i_source ) = floor ( dy_temp / emission_subgrid_delta ( y_dim_index , i_source ) * loop_index_scale ) endif enddo do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then init_emission_subgrid_loop_index ( x_dim_index , i_source ) = floor ( dx_temp / init_emission_subgrid_delta ( x_dim_index , i_source ) * loop_index_scale ) init_emission_subgrid_loop_index ( y_dim_index , i_source ) = floor ( dy_temp / init_emission_subgrid_delta ( y_dim_index , i_source ) * loop_index_scale ) endif enddo if ( calculate_deposition_flag ) then deposition_subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / deposition_subgrid_delta ( x_dim_index ) * loop_index_scale ) deposition_subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / deposition_subgrid_delta ( y_dim_index ) * loop_index_scale ) endif if ( read_landuse_flag ) then landuse_subgrid_loop_index ( x_dim_index ) = floor ( dx_temp / landuse_subgrid_delta ( x_dim_index ) * loop_index_scale ) landuse_subgrid_loop_index ( y_dim_index ) = floor ( dy_temp / landuse_subgrid_delta ( y_dim_index ) * loop_index_scale ) endif !Set the buffer sizes according to these loops for emissions only !This will remove edge effects for dispersion but will only remove edge effects for moving window only when emissions are used for redistribution buffer_index_scale = loop_index_scale !if (use_downwind_position_flag) buffer_index_scale=buffer_index_scale*2. if ( use_buffer_zone ) then buffer_index ( x_dim_index ) = floor ( dx_temp / subgrid_delta ( x_dim_index ) * buffer_index_scale ) buffer_index ( y_dim_index ) = floor ( dy_temp / subgrid_delta ( y_dim_index ) * buffer_index_scale ) integral_buffer_index ( x_dim_index ) = floor ( dx_temp / integral_subgrid_delta ( x_dim_index ) * buffer_index_scale ) integral_buffer_index ( y_dim_index ) = floor ( dy_temp / integral_subgrid_delta ( y_dim_index ) * buffer_index_scale ) !Buffer index for emissions a half grid larger because of the possible use of the integral do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) if ( local_subgrid_method_flag . eq . 3 ) then !Extend the emission buffer zone 0.5 EMEP grids when redistributing emissions to gurantee all emissions are accounted for emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) endif endif enddo do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then init_emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / init_emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) init_emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / init_emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 0.5 )) if ( local_subgrid_method_flag . eq . 3 ) then !Extend the emission buffer zone 0.5 EMEP grids when redistributing emissions to gurantee all emissions are accounted for init_emission_buffer_index ( x_dim_index , i_source ) = floor ( dx_temp / init_emission_subgrid_delta ( x_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) init_emission_buffer_index ( y_dim_index , i_source ) = floor ( dy_temp / init_emission_subgrid_delta ( y_dim_index , i_source ) * ( buffer_index_scale + 1.0 )) endif endif enddo if ( calculate_deposition_flag ) then deposition_buffer_index ( x_dim_index ) = floor ( dx_temp / deposition_subgrid_delta ( x_dim_index ) * buffer_index_scale ) deposition_buffer_index ( y_dim_index ) = floor ( dy_temp / deposition_subgrid_delta ( y_dim_index ) * buffer_index_scale ) endif !Make sure the landuse bufferzone is the same as the emissions in case it is used as a proxy if ( read_landuse_flag ) then landuse_buffer_index ( x_dim_index ) = floor ( dx_temp / landuse_subgrid_delta ( x_dim_index ) * ( buffer_index_scale + 0.5 )) landuse_buffer_index ( y_dim_index ) = floor ( dy_temp / landuse_subgrid_delta ( y_dim_index ) * ( buffer_index_scale + 0.5 )) if ( local_subgrid_method_flag . eq . 3 ) then landuse_buffer_index ( x_dim_index ) = floor ( dx_temp / landuse_subgrid_delta ( x_dim_index ) * ( buffer_index_scale + 1.0 )) landuse_buffer_index ( y_dim_index ) = floor ( dy_temp / landuse_subgrid_delta ( y_dim_index ) * ( buffer_index_scale + 1.0 )) endif endif else buffer_index = 0 emission_buffer_index = 0 init_emission_buffer_index = 0 integral_buffer_index = 0 deposition_buffer_index = 0 landuse_buffer_index = 0 endif buffer_size = buffer_index * subgrid_delta emission_buffer_size = emission_buffer_index * emission_subgrid_delta init_emission_buffer_size = emission_buffer_index * init_emission_subgrid_delta integral_buffer_size = integral_buffer_index * integral_subgrid_delta if ( calculate_deposition_flag ) then deposition_buffer_size = deposition_buffer_index * deposition_subgrid_delta endif if ( read_landuse_flag ) then landuse_buffer_size = landuse_buffer_index * landuse_subgrid_delta endif do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid_dim ( 1 : 2 , i_source ) = emission_subgrid_dim ( 1 : 2 , i_source ) + emission_buffer_index ( 1 : 2 , i_source ) * 2 emission_subgrid_min ( 1 : 2 , i_source ) = emission_subgrid_min ( 1 : 2 , i_source ) - emission_buffer_size ( 1 : 2 , i_source ) emission_subgrid_max ( 1 : 2 , i_source ) = emission_subgrid_max ( 1 : 2 , i_source ) + emission_buffer_size ( 1 : 2 , i_source ) endif enddo !emission_max_subgrid_dim(1:2)=emission_max_subgrid_dim(1:2)+buffer_index(1:2)*2 emission_max_subgrid_dim ( 1 : 2 ) = maxval ( emission_subgrid_dim ( 1 : 2 ,:), 2 ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then init_emission_subgrid_dim ( 1 : 2 , i_source ) = init_emission_subgrid_dim ( 1 : 2 , i_source ) + init_emission_buffer_index ( 1 : 2 , i_source ) * 2 init_emission_subgrid_min ( 1 : 2 , i_source ) = init_emission_subgrid_min ( 1 : 2 , i_source ) - init_emission_buffer_size ( 1 : 2 , i_source ) init_emission_subgrid_max ( 1 : 2 , i_source ) = init_emission_subgrid_max ( 1 : 2 , i_source ) + init_emission_buffer_size ( 1 : 2 , i_source ) endif enddo integral_subgrid_dim ( 1 : 2 ) = integral_subgrid_dim ( 1 : 2 ) + integral_buffer_index ( 1 : 2 ) * 2 integral_subgrid_min ( 1 : 2 ) = integral_subgrid_min ( 1 : 2 ) - integral_buffer_size ( 1 : 2 ) integral_subgrid_max ( 1 : 2 ) = integral_subgrid_max ( 1 : 2 ) + integral_buffer_size ( 1 : 2 ) if ( calculate_deposition_flag ) then deposition_subgrid_dim ( 1 : 2 ) = deposition_subgrid_dim ( 1 : 2 ) + deposition_buffer_index ( 1 : 2 ) * 2 deposition_subgrid_min ( 1 : 2 ) = deposition_subgrid_min ( 1 : 2 ) - deposition_buffer_size ( 1 : 2 ) deposition_subgrid_max ( 1 : 2 ) = deposition_subgrid_max ( 1 : 2 ) + deposition_buffer_size ( 1 : 2 ) endif if ( read_landuse_flag ) then landuse_subgrid_dim ( 1 : 2 ) = landuse_subgrid_dim ( 1 : 2 ) + landuse_buffer_index ( 1 : 2 ) * 2 landuse_subgrid_min ( 1 : 2 ) = landuse_subgrid_min ( 1 : 2 ) - landuse_buffer_size ( 1 : 2 ) landuse_subgrid_max ( 1 : 2 ) = landuse_subgrid_max ( 1 : 2 ) + landuse_buffer_size ( 1 : 2 ) endif write ( unit_logfile , '(A,2I5)' ) 'Number of target grids to be looped for each EMEP grid:' , subgrid_loop_index ( 1 : 2 ) write ( unit_logfile , '(A,2I5)' ) 'Number of integral grids to be looped for each EMEP grid:' , integral_subgrid_loop_index ( 1 : 2 ) write ( unit_logfile , '(A,2I5)' ) 'Size of integral grid buffer zone:' , integral_buffer_index ( 1 : 2 ) if ( calculate_deposition_flag ) then write ( unit_logfile , '(A,2I5)' ) 'Size of deposition grid buffer zone:' , deposition_buffer_index ( 1 : 2 ) endif if ( read_landuse_flag ) then write ( unit_logfile , '(A,2I5)' ) 'Size of landuse grid buffer zone:' , landuse_buffer_index ( 1 : 2 ) endif do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I5)' ) 'Size of emission grid buffer zone: ' , trim ( source_file_str ( i_source )), emission_buffer_index ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2I5)' ) 'Size of initial emission grid buffer zone: ' , trim ( source_file_str ( i_source )), emission_buffer_index ( 1 : 2 , i_source ) endif enddo write ( unit_logfile , '(A,2I6)' ) 'Number of target grids:' , subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Number of integral grids:' , integral_subgrid_dim ( 1 : 2 ) write ( unit_logfile , '(A,2I6)' ) 'Number of integral grids:' , integral_subgrid_dim ( 1 : 2 ) if ( calculate_deposition_flag ) then write ( unit_logfile , '(A,2I6)' ) 'Number of deposition grids:' , deposition_subgrid_dim ( 1 : 2 ) endif write ( unit_logfile , '(A,2I6)' ) 'Max number of emission grids:' , emission_max_subgrid_dim ( 1 : 2 ) do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I6)' ) 'Number of emission grids:' , trim ( source_file_str ( i_source )), emission_subgrid_dim ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Min of emission grids:   ' , trim ( source_file_str ( i_source )), emission_subgrid_min ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Max of emission grids:   ' , trim ( source_file_str ( i_source )), emission_subgrid_max ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Delta of emission grids: ' , trim ( source_file_str ( i_source )), emission_subgrid_delta ( 1 : 2 , i_source ) endif if ( calculate_source ( i_source )) then write ( unit_logfile , '(A,A,2I8)' ) 'Number of initial emission grids:' , trim ( source_file_str ( i_source )), init_emission_subgrid_dim ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Min of initial emission grids:   ' , trim ( source_file_str ( i_source )), init_emission_subgrid_min ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Max of initial emission grids:   ' , trim ( source_file_str ( i_source )), init_emission_subgrid_max ( 1 : 2 , i_source ) write ( unit_logfile , '(A,A,2f12.1)' ) 'Delta of initial emission grids: ' , trim ( source_file_str ( i_source )), init_emission_subgrid_delta ( 1 : 2 , i_source ) endif enddo end subroutine uEMEP_define_subgrid_extent subroutine uEMEP_define_subgrid use uEMEP_definitions implicit none integer i , j integer i_source !integer ii,jj integer :: subsource_index = 1 write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Define subgrid arrays (uEMEP_define_subgrid)' write ( unit_logfile , '(A)' ) '================================================================' !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( subgrid )) deallocate ( subgrid ) if ( allocated ( x_subgrid )) deallocate ( x_subgrid ) if ( allocated ( y_subgrid )) deallocate ( y_subgrid ) if ( allocated ( lon_subgrid )) deallocate ( lon_subgrid ) if ( allocated ( lat_subgrid )) deallocate ( lat_subgrid ) if ( allocated ( xproj_subgrid )) deallocate ( xproj_subgrid ) if ( allocated ( yproj_subgrid )) deallocate ( yproj_subgrid ) if ( allocated ( traveltime_subgrid )) deallocate ( traveltime_subgrid ) !Define target grid if (. not . allocated ( subgrid )) allocate ( subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_subgrid_index , n_source_index , n_pollutant_loop )) if (. not . allocated ( x_subgrid )) allocate ( x_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_subgrid )) allocate ( y_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_subgrid )) allocate ( lon_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_subgrid )) allocate ( lat_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_subgrid )) allocate ( xproj_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_subgrid )) allocate ( yproj_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ))) if (. not . allocated ( traveltime_subgrid )) allocate ( traveltime_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), 3 , n_pollutant_loop )) !Last index 1 for weighted time, 2 for sum of weights, 3 for final time traveltime_subgrid = 0. ! Allocate in-region arrays for downscaled in-region contributions if ( trace_emissions_from_in_region ) then if ( allocated ( subgrid_proxy_from_in_region )) deallocate ( subgrid_proxy_from_in_region ) if ( allocated ( subgrid_local_from_in_region )) deallocate ( subgrid_local_from_in_region ) allocate ( subgrid_proxy_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) allocate ( subgrid_local_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) subgrid_proxy_from_in_region = 0.0 subgrid_local_from_in_region = 0.0 end if !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( comp_subgrid )) deallocate ( comp_subgrid ) if ( allocated ( comp_EMEP_subgrid )) deallocate ( comp_EMEP_subgrid ) if ( allocated ( orig_EMEP_subgrid )) deallocate ( orig_EMEP_subgrid ) if ( allocated ( species_EMEP_subgrid )) deallocate ( species_EMEP_subgrid ) !Define compound subgrid. Same as target in dimensions if (. not . allocated ( comp_subgrid )) then allocate ( comp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) comp_subgrid = 0. endif if (. not . allocated ( comp_EMEP_subgrid )) then allocate ( comp_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) comp_EMEP_subgrid = 0. endif if (. not . allocated ( orig_EMEP_subgrid )) then allocate ( orig_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index )) orig_EMEP_subgrid = 0. endif if (. not . allocated ( species_EMEP_subgrid ). and .( save_emep_species . or . save_seasalt )) then allocate ( species_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_pmxx_sp_index , n_species_loop_index )) species_EMEP_subgrid = 0. endif do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) x_subgrid ( i , j ) = subgrid_min ( x_dim_index ) + subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_subgrid ( i , j ) = subgrid_min ( y_dim_index ) + subgrid_delta ( y_dim_index ) * ( j - 0.5 ) call PROJ2LL ( x_subgrid ( i , j ), y_subgrid ( i , j ), lon_subgrid ( i , j ), lat_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_subgrid(i,j),x_subgrid(i,j),lat_subgrid(i,j),lon_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_subgrid(i,j),x_subgrid(i,j),lat_subgrid(i,j),lon_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_subgrid ( i , j ), yproj_subgrid ( i , j ), lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_subgrid ( i , j ), yproj_subgrid ( i , j ), lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_subgrid ( i , j ) = lon_subgrid ( i , j ) yproj_subgrid ( i , j ) = lat_subgrid ( i , j ) endif enddo enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( integral_subgrid )) deallocate ( integral_subgrid ) if ( allocated ( x_integral_subgrid )) deallocate ( x_integral_subgrid ) if ( allocated ( y_integral_subgrid )) deallocate ( y_integral_subgrid ) if ( allocated ( lon_integral_subgrid )) deallocate ( lon_integral_subgrid ) if ( allocated ( lat_integral_subgrid )) deallocate ( lat_integral_subgrid ) if ( allocated ( xproj_integral_subgrid )) deallocate ( xproj_integral_subgrid ) if ( allocated ( yproj_integral_subgrid )) deallocate ( yproj_integral_subgrid ) if ( allocated ( meteo_nc_xproj_integral_subgrid )) deallocate ( meteo_nc_xproj_integral_subgrid ) if ( allocated ( meteo_nc_yproj_integral_subgrid )) deallocate ( meteo_nc_yproj_integral_subgrid ) !Define integral grid if (. not . allocated ( integral_subgrid )) allocate ( integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_dim ( t_dim_index ), n_integral_subgrid_index , n_source_index , n_pollutant_loop )) if (. not . allocated ( x_integral_subgrid )) allocate ( x_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_integral_subgrid )) allocate ( y_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_integral_subgrid )) allocate ( lon_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_integral_subgrid )) allocate ( lat_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_integral_subgrid )) allocate ( xproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_integral_subgrid )) allocate ( yproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if ( use_alternative_meteorology_flag ) then if (. not . allocated ( meteo_nc_xproj_integral_subgrid )) allocate ( meteo_nc_xproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) if (. not . allocated ( meteo_nc_yproj_integral_subgrid )) allocate ( meteo_nc_yproj_integral_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ))) endif integral_subgrid = 0. do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) x_integral_subgrid ( i , j ) = integral_subgrid_min ( x_dim_index ) + integral_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_integral_subgrid ( i , j ) = integral_subgrid_min ( y_dim_index ) + integral_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) call PROJ2LL ( x_integral_subgrid ( i , j ), y_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_integral_subgrid(i,j),x_integral_subgrid(i,j),lat_integral_subgrid(i,j),lon_integral_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_integral_subgrid(i,j),x_integral_subgrid(i,j),lat_integral_subgrid(i,j),lon_integral_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_integral_subgrid ( i , j ), yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_integral_subgrid ( i , j ), yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_integral_subgrid ( i , j ) = lon_integral_subgrid ( i , j ) yproj_integral_subgrid ( i , j ) = lat_integral_subgrid ( i , j ) endif if ( use_alternative_meteorology_flag ) then if ( meteo_nc_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( meteo_nc_xproj_integral_subgrid ( i , j ), meteo_nc_yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) elseif ( meteo_nc_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( meteo_nc_xproj_integral_subgrid ( i , j ), meteo_nc_yproj_integral_subgrid ( i , j ), lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) else meteo_nc_xproj_integral_subgrid ( i , j ) = lon_integral_subgrid ( i , j ) meteo_nc_yproj_integral_subgrid ( i , j ) = lat_integral_subgrid ( i , j ) endif endif enddo enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( meteo_subgrid )) deallocate ( meteo_subgrid ) if ( allocated ( last_meteo_subgrid )) deallocate ( last_meteo_subgrid ) !Define meteo grid, same positional coordinates as the integral grid (lower resolution) if (. not . allocated ( meteo_subgrid )) allocate ( meteo_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_dim ( t_dim_index ), n_meteo_subgrid_index )) if (. not . allocated ( last_meteo_subgrid )) allocate ( last_meteo_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), n_meteo_subgrid_index )) !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( use_subgrid )) deallocate ( use_subgrid ) !if (allocated(use_subgrid_val)) deallocate (use_subgrid_val) if ( allocated ( use_subgrid_interpolation_index )) deallocate ( use_subgrid_interpolation_index ) !Allocate the use_subgrid array and set to true for all subgrids if (. not . allocated ( use_subgrid )) allocate ( use_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_source_index )) !if (.not.allocated(use_subgrid_val)) allocate (use_subgrid_val(subgrid_dim(x_dim_index),subgrid_dim(y_dim_index),n_source_index)) if (. not . allocated ( use_subgrid_interpolation_index )) allocate ( use_subgrid_interpolation_index ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), n_source_index )) use_subgrid = . true . !use_subgrid_val=1 !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( proxy_emission_subgrid )) deallocate ( proxy_emission_subgrid ) if ( allocated ( emission_subgrid )) deallocate ( emission_subgrid ) if ( allocated ( x_emission_subgrid )) deallocate ( x_emission_subgrid ) if ( allocated ( y_emission_subgrid )) deallocate ( y_emission_subgrid ) if ( allocated ( lon_emission_subgrid )) deallocate ( lon_emission_subgrid ) if ( allocated ( lat_emission_subgrid )) deallocate ( lat_emission_subgrid ) if ( allocated ( xproj_emission_subgrid )) deallocate ( xproj_emission_subgrid ) if ( allocated ( yproj_emission_subgrid )) deallocate ( yproj_emission_subgrid ) if ( allocated ( emission_time_profile_subgrid )) deallocate ( emission_time_profile_subgrid ) if ( allocated ( emission_properties_subgrid )) deallocate ( emission_properties_subgrid ) !Allocate emission grids with same dimensions as the maximum emission subgrid if (. not . allocated ( proxy_emission_subgrid )) allocate ( proxy_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( emission_subgrid )) allocate ( emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( x_emission_subgrid )) allocate ( x_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( y_emission_subgrid )) allocate ( y_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lon_emission_subgrid )) allocate ( lon_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( lat_emission_subgrid )) allocate ( lat_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( emission_time_profile_subgrid )) allocate ( emission_time_profile_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) if (. not . allocated ( xproj_emission_subgrid )) allocate ( xproj_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( yproj_emission_subgrid )) allocate ( yproj_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index )) if (. not . allocated ( emission_properties_subgrid )) allocate ( emission_properties_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_emission_index , n_source_index )) emission_time_profile_subgrid = 1. proxy_emission_subgrid = 0. emission_subgrid = 0. emission_properties_subgrid = 0. !Define emission grids do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) x_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( x_dim_index , i_source ) + emission_subgrid_delta ( x_dim_index , i_source ) * ( i - 0.5 ) y_emission_subgrid ( i , j , i_source ) = emission_subgrid_min ( y_dim_index , i_source ) + emission_subgrid_delta ( y_dim_index , i_source ) * ( j - 0.5 ) call PROJ2LL ( x_emission_subgrid ( i , j , i_source ), y_emission_subgrid ( i , j , i_source ), lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), projection_attributes , projection_type ) !if (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_emission_subgrid(i,j,i_source),x_emission_subgrid(i,j,i_source), & !    lat_emission_subgrid(i,j,i_source),lon_emission_subgrid(i,j,i_source)) !elseif (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_emission_subgrid(i,j,i_source),x_emission_subgrid(i,j,i_source), & !    lat_emission_subgrid(i,j,i_source),lon_emission_subgrid(i,j,i_source)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_emission_subgrid ( i , j , i_source ), yproj_emission_subgrid ( i , j , i_source ), lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_emission_subgrid ( i , j , i_source ), yproj_emission_subgrid ( i , j , i_source ), lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) else xproj_emission_subgrid ( i , j , i_source ) = lon_emission_subgrid ( i , j , i_source ) yproj_emission_subgrid ( i , j , i_source ) = lat_emission_subgrid ( i , j , i_source ) endif enddo enddo endif enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( population_subgrid )) deallocate ( population_subgrid ) if ( allocated ( x_population_subgrid )) deallocate ( x_population_subgrid ) if ( allocated ( y_population_subgrid )) deallocate ( y_population_subgrid ) if ( allocated ( lon_population_subgrid )) deallocate ( lon_population_subgrid ) if ( allocated ( lat_population_subgrid )) deallocate ( lat_population_subgrid ) if ( allocated ( xproj_population_subgrid )) deallocate ( xproj_population_subgrid ) if ( allocated ( yproj_population_subgrid )) deallocate ( yproj_population_subgrid ) !Define population grid if (. not . allocated ( population_subgrid )) allocate ( population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ), n_population_index )) if (. not . allocated ( x_population_subgrid )) allocate ( x_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_population_subgrid )) allocate ( y_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_population_subgrid )) allocate ( lon_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_population_subgrid )) allocate ( lat_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_population_subgrid )) allocate ( xproj_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_population_subgrid )) allocate ( yproj_population_subgrid ( population_subgrid_dim ( x_dim_index ), population_subgrid_dim ( y_dim_index ))) population_subgrid = 0 do j = 1 , population_subgrid_dim ( y_dim_index ) do i = 1 , population_subgrid_dim ( x_dim_index ) x_population_subgrid ( i , j ) = population_subgrid_min ( x_dim_index ) + population_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_population_subgrid ( i , j ) = population_subgrid_min ( y_dim_index ) + population_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the population call PROJ2LL ( x_population_subgrid ( i , j ), y_population_subgrid ( i , j ), lon_population_subgrid ( i , j ), lat_population_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_population_subgrid(i,j),x_population_subgrid(i,j),lat_population_subgrid(i,j),lon_population_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_population_subgrid(i,j),x_population_subgrid(i,j),lat_population_subgrid(i,j),lon_population_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_population_subgrid ( i , j ), yproj_population_subgrid ( i , j ), lon_population_subgrid ( i , j ), lat_population_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_population_subgrid ( i , j ), yproj_population_subgrid ( i , j ), lon_population_subgrid ( i , j ), lat_population_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_population_subgrid ( i , j ) = lon_population_subgrid ( i , j ) yproj_population_subgrid ( i , j ) = lat_population_subgrid ( i , j ) endif enddo enddo !Place some properties in the emission properties subgrid do j = 1 , emission_max_subgrid_dim ( y_dim_index ) do i = 1 , emission_max_subgrid_dim ( x_dim_index ) emission_properties_subgrid ( i , j , emission_h_index ,:) = h_emis (:, subsource_index ) emission_properties_subgrid ( i , j , emission_sigz00_index ,:) = sig_z_00 (:, subsource_index ) emission_properties_subgrid ( i , j , emission_sigy00_index ,:) = sig_y_00 (:, subsource_index ) enddo enddo !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( calculate_deposition_flag ) then if ( allocated ( orig_EMEP_deposition_subgrid )) deallocate ( orig_EMEP_deposition_subgrid ) if ( allocated ( deposition_subgrid )) deallocate ( deposition_subgrid ) if ( allocated ( x_deposition_subgrid )) deallocate ( x_deposition_subgrid ) if ( allocated ( y_deposition_subgrid )) deallocate ( y_deposition_subgrid ) if ( allocated ( lon_deposition_subgrid )) deallocate ( lon_deposition_subgrid ) if ( allocated ( lat_deposition_subgrid )) deallocate ( lat_deposition_subgrid ) if ( allocated ( xproj_deposition_subgrid )) deallocate ( xproj_deposition_subgrid ) if ( allocated ( yproj_deposition_subgrid )) deallocate ( yproj_deposition_subgrid ) !Define deposition grid if (. not . allocated ( orig_EMEP_deposition_subgrid )) allocate ( orig_EMEP_deposition_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_deposition_index , n_compound_index )) if (. not . allocated ( deposition_subgrid )) allocate ( deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), deposition_subgrid_dim ( t_dim_index ), n_deposition_index , n_pollutant_loop )) if (. not . allocated ( x_deposition_subgrid )) allocate ( x_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_deposition_subgrid )) allocate ( y_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_deposition_subgrid )) allocate ( lon_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_deposition_subgrid )) allocate ( lat_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_deposition_subgrid )) allocate ( xproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_deposition_subgrid )) allocate ( yproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) orig_EMEP_deposition_subgrid = 0 deposition_subgrid = 0 do j = 1 , deposition_subgrid_dim ( y_dim_index ) do i = 1 , deposition_subgrid_dim ( x_dim_index ) x_deposition_subgrid ( i , j ) = deposition_subgrid_min ( x_dim_index ) + deposition_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_deposition_subgrid ( i , j ) = deposition_subgrid_min ( y_dim_index ) + deposition_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the deposition call PROJ2LL ( x_deposition_subgrid ( i , j ), y_deposition_subgrid ( i , j ), lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_deposition_subgrid(i,j),x_deposition_subgrid(i,j),lat_deposition_subgrid(i,j),lon_deposition_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_deposition_subgrid(i,j),x_deposition_subgrid(i,j),lat_deposition_subgrid(i,j),lon_deposition_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_deposition_subgrid ( i , j ), yproj_deposition_subgrid ( i , j ), lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_deposition_subgrid ( i , j ), yproj_deposition_subgrid ( i , j ), lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_deposition_subgrid ( i , j ) = lon_deposition_subgrid ( i , j ) yproj_deposition_subgrid ( i , j ) = lat_deposition_subgrid ( i , j ) endif enddo enddo endif if ( read_landuse_flag ) then !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( landuse_subgrid )) deallocate ( landuse_subgrid ) if ( allocated ( x_landuse_subgrid )) deallocate ( x_landuse_subgrid ) if ( allocated ( y_landuse_subgrid )) deallocate ( y_landuse_subgrid ) if ( allocated ( lon_landuse_subgrid )) deallocate ( lon_landuse_subgrid ) if ( allocated ( lat_landuse_subgrid )) deallocate ( lat_landuse_subgrid ) if ( allocated ( xproj_landuse_subgrid )) deallocate ( xproj_landuse_subgrid ) if ( allocated ( yproj_landuse_subgrid )) deallocate ( yproj_landuse_subgrid ) !Define landuse grid if (. not . allocated ( landuse_subgrid )) allocate ( landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ), n_landuse_index )) if (. not . allocated ( x_landuse_subgrid )) allocate ( x_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_landuse_subgrid )) allocate ( y_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_landuse_subgrid )) allocate ( lon_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_landuse_subgrid )) allocate ( lat_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_landuse_subgrid )) allocate ( xproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_landuse_subgrid )) allocate ( yproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) landuse_subgrid = 0 do j = 1 , landuse_subgrid_dim ( y_dim_index ) do i = 1 , landuse_subgrid_dim ( x_dim_index ) x_landuse_subgrid ( i , j ) = landuse_subgrid_min ( x_dim_index ) + landuse_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_landuse_subgrid ( i , j ) = landuse_subgrid_min ( y_dim_index ) + landuse_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the landuse call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_landuse_subgrid ( i , j ) = lon_landuse_subgrid ( i , j ) yproj_landuse_subgrid ( i , j ) = lat_landuse_subgrid ( i , j ) endif enddo enddo endif !Deallocate grids if they are already allocated. This will be in the case of the use_multiple_receptor_grids_flag=.true. if ( allocated ( exposure_subgrid )) deallocate ( exposure_subgrid ) !Define exposure subgrid if (. not . allocated ( exposure_subgrid )) allocate ( exposure_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop )) end subroutine uEMEP_define_subgrid end module define_subgrid","tags":"","loc":"sourcefile/uemep_define_subgrid.f90.html"},{"title":"uEMEP_calculate_exposure.f90 – uEMEP","text":"Source Code module calculate_exposure use uemep_configuration use uEMEP_definitions implicit none private public :: uEMEP_calculate_exposure contains subroutine uEMEP_calculate_exposure () integer :: i , j integer :: i_source integer :: i_cross , j_cross real :: weighted_concentration ( n_source_index , n_pollutant_loop ) real :: subgrid_area_scaling real :: population_total ( n_pollutant_loop ) real :: max_val ( n_pollutant_loop ) integer :: i_max ( n_pollutant_loop ), j_max ( n_pollutant_loop ), i_cross_max ( n_pollutant_loop ), j_cross_max ( n_pollutant_loop ) real :: val_limit ( n_compound_nc_index ) real :: pop_over_limit ( subgrid_dim ( t_dim_index ), n_pollutant_loop ) real :: grids_over_limit ( subgrid_dim ( t_dim_index ), n_pollutant_loop ) integer :: t integer :: i_pollutant write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating exposure (uEMEP_calculate_exposure)' write ( unit_logfile , '(A)' ) '================================================================' ! Loop through target grid and find the population exposure_subgrid = 0.0 subgrid_area_scaling = 1.0 ! Scale population due to difference in grid size sizes only when population grid is used ! Only works when the target subgrid is smaller than the population subgrid if ( population_index . eq . 2 ) then ! This does not work when target grid is larger than the population grid subgrid_area_scaling = ( subgrid_delta ( x_dim_index ) * subgrid_delta ( y_dim_index )) / ( population_subgrid_delta ( x_dim_index ) * population_subgrid_delta ( y_dim_index )) end if population_total = 0 max_val = - 1.0 pop_over_limit = 0.0 grids_over_limit = 0.0 val_limit ( no2_index ) = 10 0.0 ! TODO: Need to fix this later val_limit ( pm10_index ) = 5 0.0 ! TODO: Need to fix this later val_limit ( pm25_index ) = 3 0.0 ! TODO: Need to fix this later i_max = 0 ; j_max = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) i_cross = crossreference_target_to_population_subgrid ( i , j , x_dim_index ) j_cross = crossreference_target_to_population_subgrid ( i , j , y_dim_index ) do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . and . use_subgrid ( i , j , i_source )) then exposure_subgrid ( i , j ,:, i_source ,:) = subgrid ( i , j ,:, local_subgrid_index , i_source ,:) * population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling end if end do ! Calculate number over limit. Does not work for hourly data properly yet i_source = allsource_index do i_pollutant = 1 , n_pollutant_loop do t = 1 , subgrid_dim ( t_dim_index ) if ( use_subgrid ( i , j , i_source )) then if ( pollutant_loop_index ( i_pollutant ) . eq . no2_nc_index ) then if ( comp_subgrid ( i , j , t , pollutant_loop_index ( i_pollutant )) . gt . val_limit ( pollutant_loop_index ( i_pollutant ))) then pop_over_limit ( t , i_pollutant ) = pop_over_limit ( t , i_pollutant ) + population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling grids_over_limit ( t , i_pollutant ) = grids_over_limit ( t , i_pollutant ) + 1 end if end if end if end do if ( use_subgrid ( i , j , allsource_index )) then exposure_subgrid ( i , j ,:, allsource_index , i_pollutant ) = subgrid ( i , j ,:, total_subgrid_index , allsource_index , i_pollutant ) * population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling population_total ( i_pollutant ) = population_total ( i_pollutant ) + population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling if ( sum ( subgrid ( i , j ,:, total_subgrid_index , allsource_index , i_pollutant )) / subgrid_dim ( t_dim_index ) . gt . max_val ( i_pollutant )) then max_val ( i_pollutant ) = sum ( subgrid ( i , j ,:, total_subgrid_index , allsource_index , i_pollutant )) / subgrid_dim ( t_dim_index ) i_max ( i_pollutant ) = i j_max ( i_pollutant ) = j end if i_cross_max ( i_pollutant ) = crossreference_target_to_population_subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ), x_dim_index ) j_cross_max ( i_pollutant ) = crossreference_target_to_population_subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ), y_dim_index ) end if end do end do end do do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A)' ) 'Population weighted concentration and max time average concentration (with population) by source per period for ' // trim ( input_comp_name ) weighted_concentration ( allsource_index , i_pollutant ) = sum ( exposure_subgrid (:,:,:, allsource_index , i_pollutant )) / population_total ( i_pollutant ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,2f12.2,2f12.0)' ) 'Total ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))) // ': ' , weighted_concentration ( allsource_index , i_pollutant ), max_val ( i_pollutant ), population_total ( i_pollutant ), population_subgrid ( i_cross_max ( i_pollutant ), j_cross_max ( i_pollutant ), population_data_type ) ! Calculate population weighted values for each source do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then weighted_concentration ( i_source , i_pollutant ) = sum ( exposure_subgrid (:,:,:, i_source , i_pollutant )) / population_total ( i_pollutant ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,2f12.2)' ) trim ( source_file_str ( i_source )) // ': ' , weighted_concentration ( i_source , i_pollutant ), sum ( subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, local_subgrid_index , i_source , i_pollutant )) / subgrid_dim ( t_dim_index ) end if end do write ( unit_logfile , '(A24,2f12.2)' ) 'nonlocal: ' , weighted_concentration ( allsource_index , i_pollutant ) - sum ( weighted_concentration (:, i_pollutant )) + weighted_concentration ( allsource_index , i_pollutant ), & 2 * sum ( subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, total_subgrid_index , allsource_index , i_pollutant )) / subgrid_dim ( t_dim_index ) - sum ( subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, local_subgrid_index ,:, i_pollutant )) / subgrid_dim ( t_dim_index ) ! In case of no2 recalculate the total and present it again as no2 and not nox if ( pollutant_loop_index ( i_pollutant ) . eq . nox_nc_index ) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) i_cross = crossreference_target_to_population_subgrid ( i , j , x_dim_index ) j_cross = crossreference_target_to_population_subgrid ( i , j , y_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then exposure_subgrid ( i , j ,:, allsource_index , i_pollutant ) = comp_subgrid ( i , j ,:, no2_nc_index ) * population_subgrid ( i_cross , j_cross , population_data_type ) * subgrid_area_scaling end if end do end do weighted_concentration ( allsource_index , i_pollutant ) = sum ( exposure_subgrid (:,:,:, allsource_index , i_pollutant )) / population_total ( i_pollutant ) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,2f12.2)' ) 'Total no2: ' , weighted_concentration ( allsource_index , i_pollutant ), sum ( comp_subgrid ( i_max ( i_pollutant ), j_max ( i_pollutant ),:, no2_nc_index )) / subgrid_dim ( t_dim_index ) write ( unit_logfile , '(A24,f12.2)' ) 'Population over limit: ' , maxval ( pop_over_limit ) write ( unit_logfile , '(A24,f12.2)' ) 'Grids over limit: ' , maxval ( grids_over_limit ) end if end do !pollutant loop end subroutine uEMEP_calculate_exposure end module calculate_exposure","tags":"","loc":"sourcefile/uemep_calculate_exposure.f90.html"},{"title":"Area_weighted_interpolation_function.f90 – uEMEP","text":"Source Code module mod_area_interpolation implicit none private public :: area_weighted_interpolation_function , & area_weighted_extended_interpolation_function , & area_weighted_extended_vectorgrid_interpolation_function contains function area_weighted_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval ) result ( res ) !! Returns the area weight value for a a point at position xval, yval from the grid values xgrid,ygrid,zgrid integer , intent ( in ) :: xdim , ydim real , intent ( in ) :: delta ( 2 ) real , intent ( in ) :: xgrid ( xdim , ydim ), ygrid ( xdim , ydim ), zgrid ( xdim , ydim ) real , intent ( in ) :: xval , yval real :: res ! Local variables real :: zval real :: sum_weight real :: weighting integer :: i , j , ii , jj real :: xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min real :: xpos_max , xpos_min , ypos_max , ypos_min ! If only on grid available then return the value of that grid if ( xdim . eq . 1 . and . ydim . eq . 1 ) then res = zgrid ( xdim , ydim ) return endif ! Find grid index for position val i = 1 + floor (( xval - xgrid ( 1 , 1 )) / delta ( 1 ) + 0.5 ) j = 1 + floor (( yval - ygrid ( 1 , 1 )) / delta ( 2 ) + 0.5 ) i = max ( 1 , i ); i = min ( xdim , i ) j = max ( 1 , j ); j = min ( ydim , j ) if ( i . lt . 1 . or . j . lt . 1 . or . i . gt . xdim . or . j . gt . ydim ) then write ( * , '(A,4i6)' ) 'Interpolation out of range in area_weighted_interpolation_function. Stopping. (i,j,xdim,ydim)' , i , j , xdim , ydim write ( * , '(4f12.2)' ) xval , yval , xgrid ( 1 , 1 ), ygrid ( 1 , 1 ) stop 1 else xpos_area_max = xval + delta ( 1 ) / 2.0 xpos_area_min = xval - delta ( 1 ) / 2.0 ypos_area_max = yval + delta ( 2 ) / 2.0 ypos_area_min = yval - delta ( 2 ) / 2.0 zval = 0.0 sum_weight = 0.0 do jj = j - 1 , j + 1 do ii = i - 1 , i + 1 xpos_min = max ( xpos_area_min , xgrid ( ii , jj ) - delta ( 1 ) / 2.0 ) xpos_max = min ( xpos_area_max , xgrid ( ii , jj ) + delta ( 1 ) / 2.0 ) ypos_min = max ( ypos_area_min , ygrid ( ii , jj ) - delta ( 2 ) / 2.0 ) ypos_max = min ( ypos_area_max , ygrid ( ii , jj ) + delta ( 2 ) / 2.0 ) if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / delta ( 1 ) / delta ( 2 ) else weighting = 0.0 endif zval = zval + zgrid ( ii , jj ) * weighting sum_weight = sum_weight + weighting enddo enddo endif res = zval end function area_weighted_interpolation_function function area_weighted_extended_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval , delta_val ) result ( res ) !! Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid !! Delta_val can be any size integer , intent ( in ) :: xdim , ydim real , intent ( in ) :: delta ( 2 ) real , intent ( in ) :: delta_val ( 2 ) real , intent ( in ) :: xgrid ( xdim , ydim ), ygrid ( xdim , ydim ), zgrid ( xdim , ydim ) real , intent ( in ) :: xval , yval real :: res ! Local variables real :: zval , sum_weight , weighting real :: xpos_max , xpos_min , ypos_max , ypos_min real :: xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min integer :: i , j , ii , jj , iii , jjj integer :: ii_delta , jj_delta ! If only on grid available then return the value of that grid if ( xdim . eq . 1 . and . ydim . eq . 1 ) then res = zgrid ( xdim , ydim ) return endif ! Find grid index for position val i = 1 + floor (( xval - xgrid ( 1 , 1 )) / delta ( 1 ) + 0.5 ) j = 1 + floor (( yval - ygrid ( 1 , 1 )) / delta ( 2 ) + 0.5 ) i = max ( 1 , i ); i = min ( xdim , i ) j = max ( 1 , j ); j = min ( ydim , j ) if ( i . lt . 1 . or . j . lt . 1 . or . i . gt . xdim . or . j . gt . ydim ) then write ( * , '(A,4i6)' ) 'Interpolation out of range in area_weighted_extended_interpolation_function. Stopping. (i,j,xdim,ydim)' , i , j , xdim , ydim write ( * , '(4f12.2)' ) xval , yval , xgrid ( 1 , 1 ), ygrid ( 1 , 1 ) stop else xpos_area_max = xval + delta_val ( 1 ) / 2.0 xpos_area_min = xval - delta_val ( 1 ) / 2.0 ypos_area_max = yval + delta_val ( 2 ) / 2.0 ypos_area_min = yval - delta_val ( 2 ) / 2.0 jj_delta = 1 + floor ( 0.5 * ( delta_val ( 2 ) / delta ( 2 ) - 1.0 )) ii_delta = 1 + floor ( 0.5 * ( delta_val ( 1 ) / delta ( 1 ) - 1.0 )) zval = 0.0 sum_weight = 0.0 do jjj = j - jj_delta , j + jj_delta do iii = i - ii_delta , i + ii_delta jj = max ( jjj , 1 ); jj = min ( jj , ydim ) ii = max ( iii , 1 ); ii = min ( ii , xdim ) xpos_min = max ( xpos_area_min , xgrid ( ii , jj ) - delta ( 1 ) / 2.0 ) xpos_max = min ( xpos_area_max , xgrid ( ii , jj ) + delta ( 1 ) / 2.0 ) ypos_min = max ( ypos_area_min , ygrid ( ii , jj ) - delta ( 2 ) / 2.0 ) ypos_max = min ( ypos_area_max , ygrid ( ii , jj ) + delta ( 2 ) / 2.0 ) if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / delta_val ( 1 ) / delta_val ( 2 ) else weighting = 0.0 endif zval = zval + zgrid ( ii , jj ) * weighting sum_weight = sum_weight + weighting enddo enddo endif res = zval end function area_weighted_extended_interpolation_function function area_weighted_extended_vectorgrid_interpolation_function ( xgrid , ygrid , zgrid , xdim , ydim , delta , xval , yval , delta_val ) result ( res ) !! Returns the area weighted value for rectangle of size delta_val at position xval, yval from the grid values xgrid,ygrid,zgrid !! Delta_val can be any size !! vectorgrid means the grid positions only have one dimension integer , intent ( in ) :: xdim , ydim real , intent ( in ) :: delta ( 2 ) real , intent ( in ) :: delta_val ( 2 ) real , intent ( in ) :: xgrid ( xdim ), ygrid ( ydim ), zgrid ( xdim , ydim ) real , intent ( in ) :: xval , yval real :: res ! Local variables real :: zval , sum_weight , weighting real :: xpos_area_max , xpos_area_min , ypos_area_max , ypos_area_min real :: xpos_max , xpos_min , ypos_max , ypos_min integer :: i , j , ii , jj , iii , jjj integer :: ii_delta , jj_delta ! If only on grid available then return the value of that grid if ( xdim . eq . 1 . and . ydim . eq . 1 ) then res = zgrid ( xdim , ydim ) return endif ! Find grid index for position val i = 1 + floor (( xval - xgrid ( 1 )) / delta ( 1 ) + 0.5 ) j = 1 + floor (( yval - ygrid ( 1 )) / delta ( 2 ) + 0.5 ) i = max ( 1 , i ); i = min ( xdim , i ) j = max ( 1 , j ); j = min ( ydim , j ) if ( i . lt . 1 . or . j . lt . 1 . or . i . gt . xdim . or . j . gt . ydim ) then write ( * , '(A,4i6)' ) 'Interpolation out of range in area_weighted_extended_interpolation_function. Stopping. (i,j,xdim,ydim)' , i , j , xdim , ydim write ( * , '(4f12.2)' ) xval , yval , xgrid ( 1 ), ygrid ( 1 ) stop else xpos_area_max = xval + delta_val ( 1 ) / 2.0 xpos_area_min = xval - delta_val ( 1 ) / 2.0 ypos_area_max = yval + delta_val ( 2 ) / 2.0 ypos_area_min = yval - delta_val ( 2 ) / 2.0 jj_delta = 1 + floor ( 0.5 * ( delta_val ( 2 ) / delta ( 2 ) - 1.0 )) ii_delta = 1 + floor ( 0.5 * ( delta_val ( 1 ) / delta ( 1 ) - 1.0 )) zval = 0.0 sum_weight = 0.0 do jjj = j - jj_delta , j + jj_delta do iii = i - ii_delta , i + ii_delta jj = max ( jjj , 1 ); jj = min ( jj , ydim ) ii = max ( iii , 1 ); ii = min ( ii , xdim ) xpos_min = max ( xpos_area_min , xgrid ( ii ) - delta ( 1 ) / 2.0 ) xpos_max = min ( xpos_area_max , xgrid ( ii ) + delta ( 1 ) / 2.0 ) ypos_min = max ( ypos_area_min , ygrid ( jj ) - delta ( 2 ) / 2.0 ) ypos_max = min ( ypos_area_max , ygrid ( jj ) + delta ( 2 ) / 2.0 ) if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / delta_val ( 1 ) / delta_val ( 2 ) else weighting = 0.0 endif zval = zval + zgrid ( ii , jj ) * weighting sum_weight = sum_weight + weighting enddo enddo endif res = zval end function area_weighted_extended_vectorgrid_interpolation_function end module mod_area_interpolation","tags":"","loc":"sourcefile/area_weighted_interpolation_function.f90.html"},{"title":"uEMEP_set_constants.f90 – uEMEP","text":"Source Code module set_constants use uemep_configuration implicit none private public :: uEMEP_set_constants , uEMEP_set_pollutant_loop , & uEMEP_reset_constants , uEMEP_set_species_loop contains subroutine uEMEP_set_constants use uEMEP_definitions implicit none integer i , j integer count character ( 256 ) deposition_str !Initialise some array flags replace_EMEP_local_with_subgrid_local = . false . calculate_source = . false . calculate_EMEP_source = . false . !Initialise the number of variables read in EMEP num_lc_var_nc = num_lc_var_nc_start frac_nc_index = num_var_nc_start + 1 local_nc_index = num_var_nc_start + 2 num_var_nc = num_var_nc_start + 2 frac_nc_loop_index = frac_nc_index local_nc_loop_index = local_nc_index lc_frac_nc_loop_index = lc_frac_nc_index lc_local_nc_loop_index = lc_local_nc_index min_frac_nc_loop_index = minval ( frac_nc_loop_index ) max_frac_nc_loop_index = maxval ( frac_nc_loop_index ) min_lc_frac_nc_loop_index = minval ( lc_frac_nc_loop_index ) max_lc_frac_nc_loop_index = maxval ( lc_frac_nc_loop_index ) !convert_local_to_fraction_loop_index(lc_local_nc_loop_index)=lc_frac_nc_loop_index dim_name_nc ( x_dim_nc_index ) = 'lon' dim_name_nc ( y_dim_nc_index ) = 'lat' dim_name_nc ( z_dim_nc_index ) = 'lev' dim_name_nc ( time_dim_nc_index ) = 'time' dim_name_nc ( xdist_dim_nc_index ) = 'x_dist' dim_name_nc ( ydist_dim_nc_index ) = 'y_dist' !Sectors. Default are SNAP sectors before reading config files uEMEP_to_EMEP_sector = 0 uEMEP_to_EMEP_sector ( traffic_index ) = 7 uEMEP_to_EMEP_sector ( shipping_index ) = 8 uEMEP_to_EMEP_sector ( agriculture_index ) = 10 uEMEP_to_EMEP_sector ( heating_index ) = 2 uEMEP_to_EMEP_sector ( industry_index ) = 3 !Used to be 4??? Changed when including the rest !Set replace value to -1 as flag uEMEP_to_EMEP_replace_sector =- 1 uEMEP_to_EMEP_sector ( publicpower_index ) = 1 uEMEP_to_EMEP_sector ( fugitive_index ) = 4 uEMEP_to_EMEP_sector ( solvents_index ) = 6 uEMEP_to_EMEP_sector ( aviation_index ) = 8 uEMEP_to_EMEP_sector ( offroad_index ) = 8 uEMEP_to_EMEP_sector ( waste_index ) = 9 uEMEP_to_EMEP_sector ( livestock_index ) = 10 uEMEP_to_EMEP_sector ( other_index ) = 5 uEMEP_to_EMEP_sector_str ( traffic_index ) = '07' uEMEP_to_EMEP_sector_str ( shipping_index ) = '08' uEMEP_to_EMEP_sector_str ( agriculture_index ) = '10' uEMEP_to_EMEP_sector_str ( heating_index ) = '02' uEMEP_to_EMEP_sector_str ( industry_index ) = '03' uEMEP_to_EMEP_sector_str ( publicpower_nc_index ) = '01' uEMEP_to_EMEP_sector_str ( fugitive_nc_index ) = '04' uEMEP_to_EMEP_sector_str ( solvents_nc_index ) = '06' uEMEP_to_EMEP_sector_str ( aviation_nc_index ) = '08' uEMEP_to_EMEP_sector_str ( offroad_nc_index ) = '08' uEMEP_to_EMEP_sector_str ( waste_nc_index ) = '09' uEMEP_to_EMEP_sector_str ( livestock_nc_index ) = '10' uEMEP_to_EMEP_sector_str ( other_nc_index ) = '05' !Concentrations var_name_nc = '' var_name_nc ( conc_nc_index , o3_nc_index , allsource_nc_index ) = 'o3' var_name_nc ( conc_nc_index , no2_nc_index , allsource_nc_index ) = 'no2' var_name_nc ( conc_nc_index , nox_nc_index , allsource_nc_index ) = 'nox' var_name_nc ( conc_nc_index , nh3_nc_index , allsource_nc_index ) = 'nh3' var_name_nc ( conc_nc_index , nh4_nc_index , allsource_nc_index ) = 'nh4' var_name_nc ( conc_nc_index , pm25_nc_index , allsource_nc_index ) = 'pm25' var_name_nc ( conc_nc_index , pm10_nc_index , allsource_nc_index ) = 'pm10' var_name_nc ( conc_nc_index , pmco_nc_index , allsource_nc_index ) = 'pmco' var_name_nc ( conc_nc_index , pmex_nc_index , allsource_nc_index ) = 'pmex' var_name_nc ( conc_nc_index , so2_nc_index , allsource_nc_index ) = 'so2' var_name_nc ( conc_nc_index , pm_nc_index , allsource_nc_index ) = 'pm' var_name_nc ( conc_nc_index , all_nc_index , allsource_nc_index ) = 'all' var_name_nc ( conc_nc_index , all_sand_nc_index , allsource_nc_index ) = 'all_sand' var_name_nc ( conc_nc_index , all_sand_salt_nc_index , allsource_nc_index ) = 'all_sand_salt' var_name_nc ( conc_nc_index , all_salt_nc_index , allsource_nc_index ) = 'all_salt' var_name_nc ( conc_nc_index , all_totals_nc_index , allsource_nc_index ) = 'all_totals' var_name_nc ( conc_nc_index , aaqd_totals_nc_index , allsource_nc_index ) = 'aaqd_totals' var_name_nc ( conc_nc_index , gp_totals_nc_index , allsource_nc_index ) = 'gp_totals' var_name_nc ( conc_nc_index , op_totals_nc_index , allsource_nc_index ) = 'op_totals' var_name_nc ( conc_nc_index , pm25_sand_nc_index , allsource_nc_index ) = 'pm25_sand' var_name_nc ( conc_nc_index , pm10_sand_nc_index , allsource_nc_index ) = 'pm10_sand' var_name_nc ( conc_nc_index , pm25_salt_nc_index , allsource_nc_index ) = 'pm25_salt' var_name_nc ( conc_nc_index , pm10_salt_nc_index , allsource_nc_index ) = 'pm10_salt' var_name_nc ( conc_nc_index , bap_nc_index , allsource_nc_index ) = 'bap' var_name_nc ( conc_nc_index , co_nc_index , allsource_nc_index ) = 'co' var_name_nc ( conc_nc_index , c6h6_nc_index , allsource_nc_index ) = 'benzene' var_name_nc ( conc_nc_index , somo35_nc_index , allsource_nc_index ) = 'somo35' var_name_nc ( conc_nc_index , comax_nc_index , allsource_nc_index ) = 'maxco' var_name_nc ( conc_nc_index , o3max_nc_index , allsource_nc_index ) = 'maxo3' var_name_nc ( conc_nc_index , o3_26th_nc_index , allsource_nc_index ) = '26th_o3' !Special extrasource file. Will be used if called with. use_alternative_ppm_variable_for_lf var_name_nc ( conc_nc_index , pm25_nc_index , extrasource_nc_index ) = 'D3_ug_PPM25' var_name_nc ( conc_nc_index , pmco_nc_index , extrasource_nc_index ) = 'D3_ug_PPM_C' !Local fractions var_name_nc ( frac_nc_index , nox_nc_index , traffic_nc_index ) = 'nox_sec07_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , traffic_nc_index ) = 'pmco_sec07_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , traffic_nc_index ) = 'pm25_sec07_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , shipping_nc_index ) = 'nox_sec08_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , shipping_nc_index ) = 'pm25_sec08_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , shipping_nc_index ) = 'pmco_sec08_local_fraction' var_name_nc ( frac_nc_index , nh3_nc_index , agriculture_nc_index ) = 'nh3_sec10_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , heating_nc_index ) = 'nox_sec02_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , heating_nc_index ) = 'pm25_sec02_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , heating_nc_index ) = 'pmco_sec02_local_fraction' !SNAP 1 is energy, SNAP 3 is combustion in manufacturing and SNAP 4 is process, all should be used but in Norway it is mostly process??? var_name_nc ( frac_nc_index , nox_nc_index , industry_nc_index ) = 'nox_sec04_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , industry_nc_index ) = 'pm25_sec04_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , industry_nc_index ) = 'pmco_sec04_local_fraction' !Total emissions. These arer reset later var_name_nc ( emis_nc_index , nh3_nc_index , allsource_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , allsource_nc_index ) = 'Emis_mgm2_nox' var_name_nc ( emis_nc_index , pmco_nc_index , allsource_nc_index ) = 'Emis_mgm2_pmco' var_name_nc ( emis_nc_index , pm25_nc_index , allsource_nc_index ) = 'Emis_mgm2_pm25' !Sector emissions var_name_nc ( emis_nc_index , nh3_nc_index , agriculture_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec7nox' var_name_nc ( emis_nc_index , pm25_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec7pm25' var_name_nc ( emis_nc_index , pmco_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec7pmco' var_name_nc ( emis_nc_index , nox_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec8nox' var_name_nc ( emis_nc_index , pm25_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec8pm25' var_name_nc ( emis_nc_index , pmco_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec8pmco' var_name_nc ( emis_nc_index , nox_nc_index , heating_nc_index ) = 'Emis_mgm2_sec2nox' var_name_nc ( emis_nc_index , pm25_nc_index , heating_nc_index ) = 'Emis_mgm2_sec2pm25' var_name_nc ( emis_nc_index , pmco_nc_index , heating_nc_index ) = 'Emis_mgm2_sec2pmco' var_name_nc ( emis_nc_index , nox_nc_index , industry_nc_index ) = 'Emis_mgm2_sec4nox' var_name_nc ( emis_nc_index , pm25_nc_index , industry_nc_index ) = 'Emis_mgm2_sec4pm25' var_name_nc ( emis_nc_index , pmco_nc_index , industry_nc_index ) = 'Emis_mgm2_sec4pmco' !Meteorology var_name_nc ( ugrid_nc_index , all_nc_index , allsource_nc_index ) = 'u_wind' var_name_nc ( vgrid_nc_index , all_nc_index , allsource_nc_index ) = 'v_wind' var_name_nc ( u10_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_u10' var_name_nc ( v10_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_v10' var_name_nc ( FFgrid_nc_index , all_nc_index , allsource_nc_index ) = 'wind_speed' var_name_nc ( FF10_nc_index , all_nc_index , allsource_nc_index ) = 'ws10m' var_name_nc ( inv_FFgrid_nc_index , all_nc_index , allsource_nc_index ) = 'inv_wind_speed' var_name_nc ( inv_FF10_nc_index , all_nc_index , allsource_nc_index ) = 'inv_ws10m' var_name_nc ( hmix_nc_index , all_nc_index , allsource_nc_index ) = 'HMIX' var_name_nc ( kz_nc_index , all_nc_index , allsource_nc_index ) = 'Kz' var_name_nc ( ustar_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_ustar_nwp' var_name_nc ( logz0_nc_index , all_nc_index , allsource_nc_index ) = 'av_logz0' var_name_nc ( invL_nc_index , all_nc_index , allsource_nc_index ) = 'inv_L' var_name_nc ( J_nc_index , all_nc_index , allsource_nc_index ) = 'J(NO2)' var_name_nc ( ZTOP_nc_index , all_nc_index , allsource_nc_index ) = 'Z_TOP' var_name_nc ( t2m_nc_index , all_nc_index , allsource_nc_index ) = 'met2d_t2m' var_name_nc ( precip_nc_index , all_nc_index , allsource_nc_index ) = 'WDEP_PREC' !'precipitations' var_name_nc ( phi_nc_index , all_nc_index , allsource_nc_index ) = 'phi_nwp' surface_level_nc = 7 !Will be reset as length of 'lev' dimension !Alternative meteorology. dim_name_meteo_nc ( x_dim_nc_index ) = 'x' dim_name_meteo_nc ( y_dim_nc_index ) = 'y' dim_name_meteo_nc ( z_dim_nc_index ) = 'height3' dim_name_meteo_nc ( time_dim_nc_index ) = 'time' !Landuse dim_name_landuse_nc ( x_dim_nc_index ) = 'lon' dim_name_landuse_nc ( y_dim_nc_index ) = 'lat' var_name_landuse_nc = 'Band1' var_name_meteo_nc = '' !Depends which file you read unfortunately. My files lat, MEPS latitude WHY? !Put these in the config file !var_name_meteo_nc(lon_nc_index)='lon' !var_name_meteo_nc(lat_nc_index)='lat' var_name_meteo_nc ( lon_nc_index ) = 'longitude' var_name_meteo_nc ( lat_nc_index ) = 'latitude' var_name_meteo_nc ( ugrid_nc_index ) = 'u_wind' !!Doesn't exist but name is used var_name_meteo_nc ( vgrid_nc_index ) = 'v_wind' !!Doesn't exist but name is used var_name_meteo_nc ( FFgrid_nc_index ) = 'FF_wind' !Doesn't exist but name is used var_name_meteo_nc ( FF10_nc_index ) = 'wind_speed' var_name_meteo_nc ( inv_FFgrid_nc_index ) = '' var_name_meteo_nc ( inv_FF10_nc_index ) = '' var_name_meteo_nc ( hmix_nc_index ) = 'atmosphere_boundary_layer_thickness' var_name_meteo_nc ( kz_nc_index ) = '' var_name_meteo_nc ( ustar_nc_index ) = 'ustar' !Doesn't exist but name is used var_name_meteo_nc ( logz0_nc_index ) = 'Z0' !Needs to be converted to log(Z0) var_name_meteo_nc ( invL_nc_index ) = 'invL' !!Doesn't exist but name is used. Will be calculated var_name_meteo_nc ( J_nc_index ) = '' var_name_meteo_nc ( ZTOP_nc_index ) = '' var_name_meteo_nc ( t2m_nc_index ) = 'air_temperature_2m' var_name_meteo_nc ( precip_nc_index ) = 'precipitation_amount_acc' var_name_meteo_nc ( phi_nc_index ) = 'phi_nwp' !Additional     parameter (u10_nc_subgrid_index=22,v10_nc_subgrid_index=23,uw_nc_subgrid_index=24,vw_nc_subgrid_index=25,Hflux_nc_subgrid_index=26) var_name_meteo_nc ( u10_nc_index ) = 'x_wind_10m' !10 m wind not grid. Replaces ugrid. Used for direction var_name_meteo_nc ( v10_nc_index ) = 'y_wind_10m' !10 m wind not grid. Replaces vgrid. Used for direction var_name_meteo_nc ( uw_nc_index ) = 'downward_eastward_momentum_flux_in_air' !Will be used to determine ustar var_name_meteo_nc ( vw_nc_index ) = 'downward_northward_momentum_flux_in_air' !Will be used to determine ustar var_name_meteo_nc ( Hflux_nc_index ) = 'integral_of_surface_downward_sensible_heat_flux_wrt_time' !var_name_meteo_nc(rh2m_nc_index)='relative_humidity_2m' !var_name_meteo_nc(t0m_nc_index)='air_temperature_0m' !var_name_meteo_nc(t12m_nc_index)='air_temperature_ml' !This is at level 0 !var_name_meteo_nc(t100m_nc_index)='air_temperature_ml' !This is at model level 4 (0-4) !var_name_meteo_nc(SWflux_nc_index)='integral_of_surface_downwelling_shortwave_flux_in_air_wrt_time' !var_name_meteo_nc(LWflux_nc_index)='integral_of_surface_downwelling_longwave_flux_in_air_wrt_time' !var_name_meteo_nc(cloudcover_nc_index)='cloud_area_fraction' !var_name_meteo_nc(rain_nc_index)='precipitation_amount_acc' !var_name_meteo_nc(snow_nc_index)='snowfall_amount_acc' !var_name_meteo_nc(pressure_nc_index)='surface_air_pressure' !dim_name_population_nc(x_dim_nc_index)='x' !dim_name_population_nc(y_dim_nc_index)='y' dim_name_population_nc ( x_dim_nc_index ) = 'lon' dim_name_population_nc ( y_dim_nc_index ) = 'lat' !var_name_population_nc(lon_nc_index)='lon' !var_name_population_nc(lat_nc_index)='lat' var_name_population_nc ( population_nc_index ) = 'Band1' var_name_population_nc ( dwelling_nc_index ) = 'Band1' dim_name_shipping_nc ( x_dim_nc_index ) = 'lon' dim_name_shipping_nc ( y_dim_nc_index ) = 'lat' var_name_shipping_nc ( population_nc_index ) = 'nox' !Additional compounds for chemistry and totals comp_name_nc = '' comp_name_nc ( o3_nc_index ) = 'D3_ug_O3' comp_name_nc ( no2_nc_index ) = 'D3_ug_NO2' comp_name_nc ( nox_nc_index ) = 'D3_ugN_NOX' comp_name_nc ( nh3_nc_index ) = 'D3_ug_NH3' !comp_name_nc(nh3_nc_index)='nh3' comp_name_nc ( nh4_nc_index ) = 'D3_ug_NH4_F' !comp_name_nc(pm25_nc_index)='pm25' !comp_name_nc(pmco_nc_index)='D3_ug_PMCO' comp_name_nc ( pm10_nc_index ) = 'D3_ug_PM10' comp_name_nc ( pm25_nc_index ) = 'D3_ug_PM25' comp_name_nc ( pmex_nc_index ) = 'Exhaust' !comp_name_nc(pm25_nc_index)='SURF_ug_PM25_rh50' comp_name_nc ( co_nc_index ) = 'D3_ug_CO' comp_name_nc ( bap_nc_index ) = 'D3_ug_BAP' comp_name_nc ( c6h6_nc_index ) = 'D3_ug_BENZENE' comp_name_nc ( somo35_nc_index ) = 'SOMO35' comp_name_nc ( comax_nc_index ) = 'MaxD8M_CO' comp_name_nc ( o3max_nc_index ) = 'MaxD8M_O3' comp_name_nc ( o3_26th_nc_index ) = 'MaxD8M_O3_26th' comp_name_nc ( so2_nc_index ) = 'D3_ug_SO2' comp_name_nc ( pm25_sand_nc_index ) = 'PM25_sand' comp_name_nc ( pm10_sand_nc_index ) = 'PM10_sand' comp_name_nc ( pm25_salt_nc_index ) = 'PM25_salt' comp_name_nc ( pm10_salt_nc_index ) = 'PM10_salt' !Additional speciation of PM from EMEP species_name_nc = '' species_name_nc ( pm10_sp_index , sp_soa_index ) = 'pm10_EMEP_soa' species_name_nc ( pm25_sp_index , sp_soa_index ) = 'pm25_EMEP_soa' species_name_nc ( pm10_sp_index , sp_asoa_index ) = 'pm10_EMEP_asoa' species_name_nc ( pm25_sp_index , sp_asoa_index ) = 'pm25_EMEP_asoa' species_name_nc ( pm10_sp_index , sp_bsoa_index ) = 'pm10_EMEP_bsoa' species_name_nc ( pm25_sp_index , sp_bsoa_index ) = 'pm25_EMEP_bsoa' !species_name_nc(pm25_sp_index,sp_asoa_in_index)='SURF_ug_ASOA' !species_name_nc(pm25_sp_index,sp_bsoa_in_index)='SURF_ug_BSOA' species_name_nc ( pm25_sp_index , sp_asoa_in_index ) = 'SURF_ug_PM_ASOA' species_name_nc ( pm25_sp_index , sp_bsoa_in_index ) = 'SURF_ug_PM_BSOA' species_name_nc ( pm10_sp_index , sp_sia_index ) = 'pm10_EMEP_sia' species_name_nc ( pm25_sp_index , sp_sia_index ) = 'pm25_EMEP_sia' species_name_nc ( pm10_sp_index , sp_sia_in_index ) = 'SURF_ug_SIA' species_name_nc ( pm25_sp_index , sp_no3_index ) = 'SURF_ug_NO3_F' species_name_nc ( pm25_sp_index , sp_so4_index ) = 'SURF_ug_SO4' species_name_nc ( pm25_sp_index , sp_nh4_index ) = 'SURF_ug_NH4_F' species_name_nc ( pmco_sp_index , sp_no3_index ) = 'SURF_ug_NO3_C' species_name_nc ( pm10_sp_index , sp_dust_index ) = 'pm10_EMEP_dust' species_name_nc ( pm25_sp_index , sp_dust_index ) = 'pm25_EMEP_dust' species_name_nc ( pmco_sp_index , sp_dust_index ) = 'pmco_EMEP_dust' species_name_nc ( pmco_sp_index , sp_dust_sah_index ) = 'SURF_ug_DUST_SAH_C' species_name_nc ( pm25_sp_index , sp_dust_sah_index ) = 'SURF_ug_DUST_SAH_F' species_name_nc ( pmco_sp_index , sp_dust_wb_index ) = 'SURF_ug_DUST_WB_C' species_name_nc ( pm25_sp_index , sp_dust_wb_index ) = 'SURF_ug_DUST_WB_F' species_name_nc ( pm25_sp_index , sp_seasalt_index ) = 'pm25_EMEP_seasalt' species_name_nc ( pm10_sp_index , sp_seasalt_index ) = 'pm10_EMEP_seasalt' species_name_nc ( pm25_sp_index , sp_seasalt_in_index ) = 'SURF_ug_SEASALT_F' species_name_nc ( pmco_sp_index , sp_seasalt_in_index ) = 'SURF_ug_SEASALT_C' species_name_nc ( pm10_sp_index , sp_ffire_index ) = 'pm10_EMEP_fire' species_name_nc ( pm25_sp_index , sp_ffire_index ) = 'pm25_EMEP_fire' species_name_nc ( pm25_sp_index , sp_ffire_bc_index ) = 'SURF_ug_FFIRE_BC' species_name_nc ( pm25_sp_index , sp_ffire_rem_index ) = 'SURF_ug_FFIRE_REMPPM25' species_name_nc ( pm10_sp_index , sp_ppm_index ) = 'pm10_EMEP_ppm' species_name_nc ( pm25_sp_index , sp_ppm_index ) = 'pm25_EMEP_ppm' species_name_nc ( pm10_sp_index , sp_ppm_in_index ) = 'SURF_ug_PPM10' species_name_nc ( pm25_sp_index , sp_ppm_in_index ) = 'SURF_ug_PPM25' species_name_nc ( pmco_sp_index , sp_ppm_in_index ) = 'SURF_ug_PPM_C' species_name_nc ( pm10_sp_index , sp_pm_index ) = 'pm10_EMEP_total' species_name_nc ( pm25_sp_index , sp_pm_index ) = 'pm25_EMEP_total' species_name_nc ( pm10_sp_index , sp_pm_in_index ) = 'SURF_ug_PM10' species_name_nc ( pm25_sp_index , sp_pm_in_index ) = 'SURF_ug_PMFINE' !This must be set to FINE if SOA is to be derived by subtracting the other species !species_name_nc(pm25_sp_index,sp_pm_in_index)='SURF_ug_PM25' species_name_nc ( pmco_sp_index , sp_pm_in_index ) = 'SURF_ug_PMCO' species_name_nc ( pm10_sp_index , sp_water_index ) = 'pm10_EMEP_water' species_name_nc ( pm25_sp_index , sp_water_index ) = 'pm25_EMEP_water' species_name_nc ( pm10_sp_index , sp_water_in_index ) = '' !species_name_nc(pm25_sp_index,sp_pm_in_index)='SURF_ug_PMFINE' species_name_nc ( pm25_sp_index , sp_water_in_index ) = 'SURF_PM25water' !Additional compounds for OP calculations. From Willem !aSOA = ['SURF_ug_PM_ASOA'] !bSOA = ['SURF_ug_PM_BSOA'] !# BBOA: the POA from biomass burning (and other residential heating sources such as coal) !BBOA_f = ['SURF_ug_POM_F_RES', !                  'SURF_ug_EC_F_RES_NEW', !                  'SURF_ug_EC_F_RES_AGE', !                  'SURF_ug_REMPPM25_RES', !                  'SURF_ug_FFIRE_OM', !                  'SURF_ug_FFIRE_BC', !                  'SURF_ug_FFIRE_REMPPM25'] species_name_nc ( pm10_sp_index , sp_BBOA_index ) = 'pm10_EMEP_BBOA' species_name_nc ( pm25_sp_index , sp_BBOA_index ) = 'pm25_EMEP_BBOA' species_name_nc ( pmco_sp_index , sp_BBOA_index ) = 'pmco_EMEP_BBOA' species_name_nc ( pm10_sp_index , sp_BBOA_RES_index ) = 'pm10_EMEP_BBOA_RES' species_name_nc ( pm25_sp_index , sp_BBOA_RES_index ) = 'pm25_EMEP_BBOA_RES' species_name_nc ( pmco_sp_index , sp_BBOA_RES_index ) = 'pmco_EMEP_BBOA_RES' species_name_nc ( pm25_sp_index , sp_POM_RES_in_index ) = 'SURF_ug_POM_F_RES' species_name_nc ( pm25_sp_index , sp_EC_RES_NEW_in_index ) = 'SURF_ug_EC_F_RES_NEW' species_name_nc ( pm25_sp_index , sp_EC_RES_AGE_in_index ) = 'SURF_ug_EC_F_RES_AGE' species_name_nc ( pm25_sp_index , sp_REM_RES_in_index ) = 'SURF_ug_REMPPM25_RES' species_name_nc ( pm25_sp_index , sp_FFIRE_OM_in_index ) = 'SURF_ug_FFIRE_OM' species_name_nc ( pm25_sp_index , sp_FFIRE_BC_in_index ) = 'SURF_ug_FFIRE_BC' species_name_nc ( pm25_sp_index , sp_FFIRE_REM_in_index ) = 'SURF_ug_FFIRE_REMPPM25' !BBOA_c = ['SURF_ug_EC_C_RES', !                  'SURF_ug_POM_C_RES', !                   'SURF_ug_REMPPM_C_RES', !                   'SURF_ug_FFIRE_C'] species_name_nc ( pmco_sp_index , sp_EC_RES_in_index ) = 'SURF_ug_EC_C_RES' species_name_nc ( pmco_sp_index , sp_POM_RES_in_index ) = 'SURF_ug_POM_C_RES' species_name_nc ( pmco_sp_index , sp_REM_RES_in_index ) = 'SURF_ug_REMPPM_C_RES' species_name_nc ( pmco_sp_index , sp_FFIRE_in_index ) = 'SURF_ug_FFIRE_C' !OP_aSOA = 0.44 # nmol min-1 ug-1; multiply with the ug/m3 concs to get OP !OP_bSOA = 0.15 !OP_BBOA = 0.08 !----------------------------------------------------------- !And then for the non-exhaust and exhaust (HOA) contributions I combine the LFs with the LF pm25 and pmco fields, and multiply by: !OP_HOA = 0.94 # nmol min-1 ug-1 !OP_nonexh = 3.51 !Deposition names deposition_name_nc = '' i = nh3_nc_index if ( i . eq . nh3_nc_index ) deposition_str = 'NH3' deposition_name_nc ( temp_conif_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_CF' deposition_name_nc ( temp_decid_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_DF' deposition_name_nc ( med_needle_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_NF' deposition_name_nc ( med_broadleaf_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_BF' deposition_name_nc ( temp_crop_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_TC' deposition_name_nc ( med_crop_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_MC' deposition_name_nc ( root_crop_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_RC' deposition_name_nc ( moorland_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_SNL' deposition_name_nc ( grass_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_GR' deposition_name_nc ( medscrub_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_MS' deposition_name_nc ( wetlands_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_WE' deposition_name_nc ( tundra_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_TU' deposition_name_nc ( desert_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_DE' deposition_name_nc ( water_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_W' deposition_name_nc ( ice_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_ICE' deposition_name_nc ( urban_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_U' deposition_name_nc ( grid_index , i ) = 'MSC_VG_' // trim ( deposition_str ) // '_Grid' var_name_nc ( wetdepo_nc_index , i , allsource_nc_index ) = 'WDEP_' // trim ( deposition_str ) var_name_nc ( drydepo_nc_index , i , allsource_nc_index ) = 'DDEP_' // trim ( deposition_str ) // '_m2Grid' comp_scale_nc (:) = 1. comp_scale_nc ( nox_nc_index ) = ( 1 4. + 2. * 1 6. ) / 1 4. !Value read in is in ugN converted to nh3 depo_scale_nc (:) = 1. depo_scale_nc ( nh3_nc_index ) = ( 1 4. + 3. * 1. ) / 1 4. !Value read in is in ugN converted to nh3 !Names for the OP calculations !Allocate the indexes for specifying compound and sources together. Never used and not correct either!!! count = 0 do i = 1 , size ( compound_source_index , 1 ) do j = 1 , size ( compound_source_index , 2 ) count = count + 1 compound_source_index ( i , j ) = count enddo enddo !Allocate source strings for writing to files source_file_str ( allsource_index ) = 'allsources' source_file_str ( traffic_index ) = 'traffic' source_file_str ( shipping_index ) = 'shipping' source_file_str ( agriculture_index ) = 'agriculture' source_file_str ( heating_index ) = 'heating' source_file_str ( industry_index ) = 'industry' source_file_str ( publicpower_index ) = 'publicpower' source_file_str ( fugitive_index ) = 'fugitive' source_file_str ( solvents_index ) = 'solvents' source_file_str ( aviation_index ) = 'aviation' source_file_str ( offroad_index ) = 'offroad' source_file_str ( waste_index ) = 'waste' source_file_str ( livestock_index ) = 'livestock' source_file_str ( other_index ) = 'other' source_file_str ( traffic_exhaust_index ) = 'traffic_exhaust' source_file_str ( traffic_nonexhaust_index ) = 'traffic_nonexhaust' do i = 1 , n_pollutant_nc_index pollutant_file_str ( i ) = var_name_nc ( conc_nc_index , i , allsource_nc_index ) enddo !do i=1,n_possible_subsource !    write(str_temp,'(i1)') i !    subsource_str(i)='_'//trim(str_temp) !enddo !Set filename indexes for grids generated by uEMEP j = 0 do i = 1 , n_source_index j = j + 1 ; proxy_emission_file_index ( i ) = j j = j + 1 ; emission_file_index ( i ) = j j = j + 1 ; proxy_file_index ( i ) = j j = j + 1 ; proxy_integral_file_index ( i ) = j j = j + 1 ; emep_subgrid_file_index ( i ) = j j = j + 1 ; emep_subgrid_nonlocal_file_index ( i ) = j j = j + 1 ; emep_subgrid_local_file_index ( i ) = j j = j + 1 ; emep_additional_subgrid_nonlocal_file_index ( i ) = j j = j + 1 ; emep_additional_subgrid_local_file_index ( i ) = j j = j + 1 ; emep_subgrid_semilocal_file_index ( i ) = j j = j + 1 ; subgrid_sourcetotal_inregion_file_index ( i ) = j j = j + 1 ; subgrid_sourcetotal_file_index ( i ) = j j = j + 1 ; emep_subgrid_frac_file_index ( i ) = j j = j + 1 ; subgrid_local_file_index ( i ) = j j = j + 1 ; subgrid_total_file_index ( i ) = j j = j + 1 ; use_subgrid_file_index ( i ) = j j = j + 1 ; emep_emission_subgrid_file_index ( i ) = j enddo do i = 1 , n_population_index j = j + 1 ; population_file_index ( i ) = j enddo j = j + 1 ; subgrid_ugrid_file_index = j j = j + 1 ; subgrid_vgrid_file_index = j j = j + 1 ; subgrid_u10_file_index = j j = j + 1 ; subgrid_v10_file_index = j j = j + 1 ; subgrid_hmix_file_index = j j = j + 1 ; subgrid_kz_file_index = j j = j + 1 ; subgrid_logz0_file_index = j j = j + 1 ; subgrid_invL_file_index = j j = j + 1 ; subgrid_FFgrid_file_index = j j = j + 1 ; subgrid_FF10_file_index = j j = j + 1 ; subgrid_DDgrid_file_index = j j = j + 1 ; subgrid_DD10_file_index = j j = j + 1 ; subgrid_invFFgrid_file_index = j j = j + 1 ; subgrid_invFF10_file_index = j j = j + 1 ; subgrid_ustar_file_index = j j = j + 1 ; subgrid_t2m_file_index = j j = j + 1 ; subgrid_J_file_index = j j = j + 1 ; subgrid_meteo_file_index = j !Set initial values  for the dispersion parameters sig_y_00 = 1 0. sig_z_00 = 1 0. h_emis = 1 5. z_rec = 2. h_emis ( traffic_index ,:) = 2. h_emis ( shipping_index ,:) = 7 0. h_emis ( heating_index ,:) = 1 5. h_emis ( agriculture_index ,:) = 1. h_emis ( industry_index ,:) = 10 0. h_emis ( aviation_index ,:) = 1 0. h_emis ( fugitive_index ,:) = 5. h_emis ( livestock_index ,:) = 5. h_emis ( solvents_index ,:) = 1 5. h_emis ( offroad_index ,:) = 5. h_emis ( waste_index ,:) = 1 5. sig_y_00 ( shipping_index ,:) = 5. sig_y_00 ( traffic_index ,:) = 1. sig_y_00 ( heating_index ,:) = 5. sig_y_00 ( agriculture_index ,:) = 5. sig_y_00 ( industry_index ,:) = 5. sig_y_00 ( aviation_index ,:) = 2 5. sig_z_00 ( shipping_index ,:) = 5. sig_z_00 ( traffic_index ,:) = 1. sig_z_00 ( heating_index ,:) = 1 0. sig_z_00 ( agriculture_index ,:) = 1 0. sig_z_00 ( industry_index ,:) = 1 0. sig_z_00 ( aviation_index ,:) = 1 0. !Set all emission factors to unity emission_factor = 1. !Set all no2, relative to nox, to 0.1. emission_factor ( no2_index ,:,:) = 0.1 !Preset all initial emission factors emission_factor ( nox_index , traffic_index ,:) = 0.4 !(g/km/veh) emission_factor ( nox_index , shipping_index ,:) = 1. !Shipping data is in emissions [tonne/month] emission_factor ( nox_index , heating_index ,:) = 3. / 1 5. !(kg/dwelling/year) Estimate only emission_factor ( nox_index , industry_index ,:) = 1. !Industry data is in emissions [tonne/year] emission_factor ( no2_index , traffic_index ,:) = 0.15 * emission_factor ( nox_index , traffic_index ,:) emission_factor ( no2_index , shipping_index ,:) = 0.10 * emission_factor ( nox_index , shipping_index ,:) emission_factor ( no2_index , heating_index ,:) = 0.1 * emission_factor ( nox_index , heating_index ,:) !(kg/dwelling/year) Estimate only emission_factor ( no2_index , industry_index ,:) = 0.10 * emission_factor ( nox_index , shipping_index ,:) emission_factor ( pm25_index , traffic_index ,:) = 0.01 !(g/km/veh) emission_factor ( pm25_index , shipping_index ,:) = 1. !Shipping data is in emissions [tonne/month] emission_factor ( pm25_index , heating_index ,:) = 3. !(kg/dwelling/year) SSB number is 6 emission_factor ( pm25_index , industry_index ,:) = 1. emission_factor ( pm10_index , traffic_index ,:) = 0.01 !(g/km/veh) emission_factor ( pm10_index , shipping_index ,:) = 1. !Shipping data is in emissions [tonne/month] emission_factor ( pm10_index , heating_index ,:) = 3. !(kg/dwelling/year) SSB number is 6 emission_factor ( pm10_index , industry_index ,:) = 1. emission_factor ( pmex_index , traffic_index ,:) = 0.01 !(g/km/veh) emission_factor ( nh3_index , agriculture_index ,:) = 1. !Agriculture data is in emissions [kg/yr] emission_factor ( nh4_index , agriculture_index ,:) = 1. !Agriculture data is in emissions [kg/yr] ratio_truck_car_emission ( nox_index ) = 1 2.5 !4.86/.318 !From excel sheet for NOx. 12.5 matches the values used in NORTRIP ratio_truck_car_emission ( no2_index ) = 1 2.5 !4.86/.318 !Should perhaps be different but ratio_truck_car_emission ( pm25_index ) = 1 0. ratio_truck_car_emission ( pm10_index ) = 1 0. ratio_truck_car_emission ( pmex_index ) = 1 0. !Set AQI thresholds aqi_hourly_limits ( no2_index , 1 ) = 10 0. ; aqi_hourly_limits ( no2_index , 2 ) = 20 0. ; aqi_hourly_limits ( no2_index , 3 ) = 40 0. ; !aqi_hourly_limits(pm10_index,1)=50.;aqi_hourly_limits(pm10_index,2)=80.;aqi_hourly_limits(pm10_index,3)=400.; !aqi_hourly_limits(pm25_index,1)=25.;aqi_hourly_limits(pm25_index,2)=40.;aqi_hourly_limits(pm25_index,3)=150.; aqi_hourly_limits ( pm10_index , 1 ) = 6 0. ; aqi_hourly_limits ( pm10_index , 2 ) = 12 0. ; aqi_hourly_limits ( pm10_index , 3 ) = 40 0. ; aqi_hourly_limits ( pm25_index , 1 ) = 3 0. ; aqi_hourly_limits ( pm25_index , 2 ) = 5 0. ; aqi_hourly_limits ( pm25_index , 3 ) = 15 0. ; aqi_hourly_limits ( o3_index , 1 ) = 10 0. ; aqi_hourly_limits ( o3_index , 2 ) = 18 0. ; aqi_hourly_limits ( o3_index , 3 ) = 24 0. ; aqi_daily_limits ( pm10_index , 1 ) = 3 0. ; aqi_daily_limits ( pm10_index , 2 ) = 5 0. ; aqi_daily_limits ( pm10_index , 3 ) = 15 0. ; aqi_daily_limits ( pm25_index , 1 ) = 1 5. ; aqi_daily_limits ( pm25_index , 2 ) = 2 5. ; aqi_daily_limits ( pm25_index , 3 ) = 7 5. ; !Not properly defined aqi_annual_limits ( no2_index , 1 ) = 0. ; aqi_annual_limits ( no2_index , 2 ) = 4 0. ; aqi_annual_limits ( no2_index , 3 ) = 4 0. ; aqi_annual_limits ( pm10_index , 1 ) = 0. ; aqi_annual_limits ( pm10_index , 2 ) = 2 5. ; aqi_annual_limits ( pm10_index , 3 ) = 3 5. ; aqi_annual_limits ( pm25_index , 1 ) = 0. ; aqi_annual_limits ( pm25_index , 2 ) = 1 5. ; aqi_annual_limits ( pm25_index , 3 ) = 2 5. ; !For temperature scaling traffic_nox_emission_temperature_ref_temperature ( 1 ) =- 1 5. traffic_nox_emission_temperature_ref_temperature ( 2 ) = 5. traffic_nox_emission_temperature_ref_scaling ( 1 ) = 3. traffic_nox_emission_temperature_ref_scaling ( 2 ) = 1. !EMEP projection default (LCC) !Pre feb 2020 values EMEP_projection_type = LCC_projection_index EMEP_projection_attributes ( 1 ) = 6 3.0 !Standard parallel 1 EMEP_projection_attributes ( 2 ) = 6 3.0 !Standard parallel 2 EMEP_projection_attributes ( 3 ) = 1 5.0 !lon0 EMEP_projection_attributes ( 4 ) = 6 3.0 !lat0 EMEP_projection_attributes ( 5 ) = 637100 0.0 !earth_radius EMEP_projection_attributes ( 6 ) = 1.e12 !flattening spherical earth. Never used? !uEMEP projection default (UTM) projection_type = UTM_projection_index projection_attributes ( 1 ) = utm_zone projection_attributes ( 2 ) = utm_lon0 !uEMEP projection alternative (LAEA) for European modelling. Can copy to config file if it is to be used !projection_type=LAEA_projection_index !projection_attributes(1) = 10.  !lon0 !projection_attributes(2) = 52.  !lat0 !projection_attributes(3) = 4321000.  !false_easting !projection_attributes(4) = 3210000.  !false_northing !projection_attributes(5) = 6370000.0  !earth_radius !These are used for landuse sector conversion only. They are already specified in uEMEP_to_EMEP_sector convert_GNFR_to_uEMEP_sector_index ( 1 ) = publicpower_nc_index convert_GNFR_to_uEMEP_sector_index ( 2 ) = industry_nc_index convert_GNFR_to_uEMEP_sector_index ( 3 ) = heating_nc_index convert_GNFR_to_uEMEP_sector_index ( 4 ) = fugitive_nc_index convert_GNFR_to_uEMEP_sector_index ( 5 ) = solvents_nc_index convert_GNFR_to_uEMEP_sector_index ( 6 ) = traffic_nc_index convert_GNFR_to_uEMEP_sector_index ( 7 ) = shipping_nc_index convert_GNFR_to_uEMEP_sector_index ( 8 ) = aviation_nc_index convert_GNFR_to_uEMEP_sector_index ( 9 ) = offroad_nc_index convert_GNFR_to_uEMEP_sector_index ( 10 ) = waste_nc_index convert_GNFR_to_uEMEP_sector_index ( 11 ) = livestock_nc_index convert_GNFR_to_uEMEP_sector_index ( 12 ) = agriculture_nc_index convert_GNFR_to_uEMEP_sector_index ( 13 ) = other_nc_index convert_uEMEP_to_GNFR_sector_index ( publicpower_nc_index ) = 1 convert_uEMEP_to_GNFR_sector_index ( industry_nc_index ) = 2 convert_uEMEP_to_GNFR_sector_index ( heating_nc_index ) = 3 convert_uEMEP_to_GNFR_sector_index ( fugitive_nc_index ) = 4 convert_uEMEP_to_GNFR_sector_index ( solvents_nc_index ) = 5 convert_uEMEP_to_GNFR_sector_index ( traffic_nc_index ) = 6 convert_uEMEP_to_GNFR_sector_index ( shipping_nc_index ) = 7 convert_uEMEP_to_GNFR_sector_index ( aviation_nc_index ) = 8 convert_uEMEP_to_GNFR_sector_index ( offroad_nc_index ) = 9 convert_uEMEP_to_GNFR_sector_index ( waste_nc_index ) = 10 convert_uEMEP_to_GNFR_sector_index ( livestock_nc_index ) = 11 convert_uEMEP_to_GNFR_sector_index ( agriculture_nc_index ) = 12 convert_uEMEP_to_GNFR_sector_index ( other_nc_index ) = 13 end subroutine uEMEP_set_constants subroutine uEMEP_set_pollutant_loop use uEMEP_definitions implicit none integer p_loop !Set the pollutant index loops after reading in pollutant_index !Remove the sand and salt PM2.5, not necessary. Fixed ratio if needed n_pollutant_loop=6 if ( pollutant_index . eq . all_sand_salt_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 6 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_index ( 5 ) = pm10_sand_nc_index pollutant_loop_index ( 6 ) = pm10_salt_nc_index pollutant_loop_index ( 7 ) = pm25_sand_nc_index pollutant_loop_index ( 8 ) = pm25_salt_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 pollutant_loop_back_index ( pm10_sand_nc_index ) = 5 pollutant_loop_back_index ( pm10_salt_nc_index ) = 6 pollutant_loop_back_index ( pm25_sand_nc_index ) = 7 pollutant_loop_back_index ( pm25_salt_nc_index ) = 8 elseif ( pollutant_index . eq . all_salt_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 5 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_index ( 5 ) = pm10_salt_nc_index pollutant_loop_index ( 6 ) = pm25_salt_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 pollutant_loop_back_index ( pm10_salt_nc_index ) = 5 pollutant_loop_back_index ( pm25_salt_nc_index ) = 6 elseif ( pollutant_index . eq . all_sand_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 5 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_index ( 5 ) = pm10_sand_nc_index pollutant_loop_index ( 6 ) = pm25_sand_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 pollutant_loop_back_index ( pm10_sand_nc_index ) = 5 pollutant_loop_back_index ( pm25_sand_nc_index ) = 6 elseif ( pollutant_index . eq . all_nc_index ) then n_emep_pollutant_loop = 3 !if (use_GNFR19_emissions_from_EMEP_flag) n_emep_pollutant_loop=4 !Include exhaust n_pollutant_loop = 4 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = pmex_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( pmex_nc_index ) = 4 elseif ( pollutant_index . eq . all_totals_nc_index ) then n_emep_pollutant_loop = 3 n_pollutant_loop = 3 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 elseif ( pollutant_index . eq . aaqd_totals_nc_index ) then n_emep_pollutant_loop = 6 n_pollutant_loop = 6 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = co_nc_index pollutant_loop_index ( 5 ) = bap_nc_index pollutant_loop_index ( 6 ) = c6h6_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( co_nc_index ) = 4 pollutant_loop_back_index ( bap_nc_index ) = 5 pollutant_loop_back_index ( c6h6_nc_index ) = 6 extract_benzene_from_voc_emissions = . true . elseif ( pollutant_index . eq . gp_totals_nc_index ) then n_emep_pollutant_loop = 4 n_pollutant_loop = 4 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_index ( 4 ) = co_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 pollutant_loop_back_index ( co_nc_index ) = 4 elseif ( pollutant_index . eq . op_totals_nc_index ) then n_emep_pollutant_loop = 3 n_pollutant_loop = 3 pollutant_loop_index ( 1 ) = nox_nc_index pollutant_loop_index ( 2 ) = pm25_nc_index pollutant_loop_index ( 3 ) = pm10_nc_index pollutant_loop_back_index ( nox_nc_index ) = 1 pollutant_loop_back_index ( pm25_nc_index ) = 2 pollutant_loop_back_index ( pm10_nc_index ) = 3 elseif ( pollutant_index . eq . pm_nc_index ) then n_emep_pollutant_loop = 2 n_pollutant_loop = 3 pollutant_loop_index ( 1 ) = pm25_nc_index pollutant_loop_index ( 2 ) = pm10_nc_index pollutant_loop_index ( 3 ) = pmex_nc_index pollutant_loop_back_index ( pm25_nc_index ) = 1 pollutant_loop_back_index ( pm10_nc_index ) = 2 pollutant_loop_back_index ( pmex_nc_index ) = 3 elseif ( pollutant_index . eq . nh3_nc_index ) then n_emep_pollutant_loop = 1 n_pollutant_loop = 1 pollutant_loop_index ( 1 ) = nh3_nc_index pollutant_loop_index ( 2 ) = nh4_nc_index pollutant_loop_back_index ( nh3_nc_index ) = 1 pollutant_loop_back_index ( nh4_nc_index ) = 2 else n_emep_pollutant_loop = 1 n_pollutant_loop = 1 pollutant_loop_index ( 1 ) = pollutant_index pollutant_loop_back_index ( pollutant_index ) = 1 !write(*,*) pollutant_loop_index(1),pollutant_index endif !Set indexing for additional compounds. Only used when reading in EMEP data do p_loop = 1 , n_pollutant_loop if ( pollutant_loop_index ( p_loop ). eq . nox_nc_index ) then n_pollutant_compound_loop ( p_loop ) = 3 pollutant_compound_loop_index ( p_loop , 1 ) = nox_nc_index pollutant_compound_loop_index ( p_loop , 2 ) = no2_nc_index pollutant_compound_loop_index ( p_loop , 3 ) = o3_nc_index !Add addition values to be read and saved if ( save_EMEP_somo35 ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = somo35_nc_index endif if ( save_EMEP_o3max ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = o3max_nc_index endif if ( save_EMEP_o3_26th ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = o3_26th_nc_index endif if ( save_EMEP_so2 ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = so2_nc_index endif elseif ( pollutant_loop_index ( p_loop ). eq . nh3_nc_index ) then n_pollutant_compound_loop ( p_loop ) = 2 pollutant_compound_loop_index ( p_loop , 1 ) = nh3_nc_index pollutant_compound_loop_index ( p_loop , 2 ) = nh4_nc_index elseif ( pollutant_loop_index ( p_loop ). eq . co_nc_index ) then n_pollutant_compound_loop ( p_loop ) = 1 pollutant_compound_loop_index ( p_loop , 1 ) = co_nc_index if ( save_EMEP_comax ) then n_pollutant_compound_loop ( p_loop ) = n_pollutant_compound_loop ( p_loop ) + 1 pollutant_compound_loop_index ( p_loop , n_pollutant_compound_loop ( p_loop )) = comax_nc_index endif else n_pollutant_compound_loop ( p_loop ) = 1 pollutant_compound_loop_index ( p_loop , 1 ) = pollutant_loop_index ( p_loop ) endif enddo write ( unit_logfile , '(a,i)' ) 'Number of pollutants=' , n_pollutant_loop write ( unit_logfile , '(a,i)' ) 'Number of EMEP pollutants=' , n_emep_pollutant_loop end subroutine uEMEP_set_pollutant_loop subroutine uEMEP_set_species_loop use uEMEP_definitions implicit none integer s_loop !Set the pollutant index loops after reading in pollutant_index !Remove the sand and salt PM2.5, not necessary. Fixed ratio if needed n_pollutant_loop=6 if ( save_emep_species ) then n_species_loop_index = n_sp_index do s_loop = 1 , n_species_loop_index species_loop_index ( s_loop ) = s_loop enddo elseif ( save_seasalt ) then n_species_loop_index = 1 species_loop_index ( 1 ) = sp_seasalt_index else !No species will be read or chosen. Set to 0 to make sure it fails if they are n_species_loop_index = 1 species_loop_index ( 1 ) = 0 endif !Override the save_emep_species to include the OP species if ( save_emep_OP_species ) then n_species_loop_index = n_sp_OP_index do s_loop = 1 , n_species_loop_index species_loop_index ( s_loop ) = s_loop enddo endif write ( unit_logfile , '(a,i)' ) 'Number of species=' , n_species_loop_index !write(*,*) '####0: ',n_species_loop_index end subroutine uEMEP_set_species_loop subroutine uEMEP_reset_constants !Reset some constants based on the configuration file input use uEMEP_definitions implicit none integer index_start character ( 256 ) prefix_str , postfix_str integer i , j character ( 8 ) sector_str_lf , sector_str_emis integer sector_index character ( 256 ) temp_str integer i_comp , i_source , p_loop character ( 256 ) local_fraction_naming_template_str_temp , local_fraction_grid_size_str if ( index ( alternative_meteorology_type , 'nortrip' ). gt . 0 ) then var_name_meteo_nc ( lon_nc_index ) = 'lon' var_name_meteo_nc ( lat_nc_index ) = 'lat' endif !Reset meteorological names if ( index ( alternative_meteorology_type , 'nbv' ). gt . 0 ) then dim_name_meteo_nc ( z_dim_nc_index ) = 'height4' var_name_meteo_nc ( lon_nc_index ) = 'lon' var_name_meteo_nc ( lat_nc_index ) = 'lat' var_name_meteo_nc ( hmix_nc_index ) = 'boundary_layer_height' var_name_meteo_nc ( logz0_nc_index ) = 'surface_roughness_momentum' !Needs to be converted to log(Z0) var_name_meteo_nc ( Hflux_nc_index ) = 'surface_upward_sensible_heat_flux' !Note this is upward not downward so must have a negative when read var_name_meteo_nc ( precip_nc_index ) = 'precipitation_amount' endif if ( use_EMEP_surface_ozone_flag ) then comp_name_nc ( o3_nc_index ) = 'SURF_ug_O3' endif !If GNFR19 emissions are true then so are the GNFR13 emissions if ( use_GNFR19_emissions_from_EMEP_flag ) use_GNFR_emissions_from_EMEP_flag = . true . !Set the emission sector index to be read to standard GNFR. !Not actually used now but could be used in the loop below if ( use_GNFR_emissions_from_EMEP_flag ) then uEMEP_to_EMEP_sector ( allsource_index ) = 0 uEMEP_to_EMEP_sector ( traffic_index ) = 6 uEMEP_to_EMEP_sector ( shipping_index ) = 7 uEMEP_to_EMEP_sector ( agriculture_index ) = 12 uEMEP_to_EMEP_sector ( heating_index ) = 3 uEMEP_to_EMEP_sector ( industry_index ) = 2 uEMEP_to_EMEP_sector ( publicpower_nc_index ) = 1 uEMEP_to_EMEP_sector ( fugitive_nc_index ) = 4 uEMEP_to_EMEP_sector ( solvents_nc_index ) = 5 uEMEP_to_EMEP_sector ( aviation_nc_index ) = 8 uEMEP_to_EMEP_sector ( offroad_nc_index ) = 9 uEMEP_to_EMEP_sector ( waste_nc_index ) = 10 uEMEP_to_EMEP_sector ( livestock_nc_index ) = 11 uEMEP_to_EMEP_sector ( other_nc_index ) = 13 uEMEP_to_EMEP_sector ( publicpower_point_nc_index ) = 14 uEMEP_to_EMEP_sector ( publicpower_area_nc_index ) = 15 uEMEP_to_EMEP_sector ( traffic_gasoline_nc_index ) = 16 uEMEP_to_EMEP_sector ( traffic_diesel_nc_index ) = 17 uEMEP_to_EMEP_sector ( traffic_gas_nc_index ) = 18 uEMEP_to_EMEP_sector ( traffic_nonexhaust_nc_index ) = 19 endif !Create the sector strings, different for emissions to the local fraction strings, no leading 0's do i_source = 1 , n_source_nc_index write ( temp_str , '(i2)' ) uEMEP_to_EMEP_sector ( i_source ) if ( uEMEP_to_EMEP_sector ( i_source ). lt . 10 ) then uEMEP_to_EMEP_sector_str ( i_source ) = '0' // trim ( adjustl ( temp_str )) else uEMEP_to_EMEP_sector_str ( i_source ) = trim ( temp_str ) endif write ( uEMEP_to_EMEP_emis_sector_str ( i_source ), '(i2)' ) uEMEP_to_EMEP_sector ( i_source ) uEMEP_to_EMEP_emis_sector_str ( i_source ) = adjustl ( uEMEP_to_EMEP_emis_sector_str ( i_source )) if ( i_source . eq . allsource_nc_index ) then uEMEP_to_EMEP_emis_sector_str ( i_source ) = '' uEMEP_to_EMEP_sector_str ( i_source ) = '' endif !write(*,*) i_source,uEMEP_to_EMEP_sector_str(i_source),' ',uEMEP_to_EMEP_emis_sector_str(i_source) enddo if ( use_alphabetic_GNFR_emissions_from_EMEP_flag ) then uEMEP_to_EMEP_emis_sector_str ( allsource_index ) = '' uEMEP_to_EMEP_emis_sector_str ( traffic_index ) = 'F' uEMEP_to_EMEP_emis_sector_str ( shipping_index ) = 'G' uEMEP_to_EMEP_emis_sector_str ( agriculture_index ) = 'L' uEMEP_to_EMEP_emis_sector_str ( heating_index ) = 'C' uEMEP_to_EMEP_emis_sector_str ( industry_index ) = 'B' uEMEP_to_EMEP_emis_sector_str ( publicpower_nc_index ) = 'A' uEMEP_to_EMEP_emis_sector_str ( fugitive_nc_index ) = 'D' uEMEP_to_EMEP_emis_sector_str ( solvents_nc_index ) = 'E' uEMEP_to_EMEP_emis_sector_str ( aviation_nc_index ) = 'H' uEMEP_to_EMEP_emis_sector_str ( offroad_nc_index ) = 'I' uEMEP_to_EMEP_emis_sector_str ( waste_nc_index ) = 'J' uEMEP_to_EMEP_emis_sector_str ( livestock_nc_index ) = 'K' uEMEP_to_EMEP_emis_sector_str ( other_nc_index ) = 'M' uEMEP_to_EMEP_emis_sector_str ( traffic_gasoline_nc_index ) = 'F1' uEMEP_to_EMEP_emis_sector_str ( traffic_diesel_nc_index ) = 'F2' uEMEP_to_EMEP_emis_sector_str ( traffic_gas_nc_index ) = 'F3' uEMEP_to_EMEP_emis_sector_str ( traffic_nonexhaust_nc_index ) = 'F4' uEMEP_to_EMEP_emis_sector_str ( publicpower_point_nc_index ) = 'A1' uEMEP_to_EMEP_emis_sector_str ( publicpower_area_nc_index ) = 'A2' uEMEP_to_EMEP_emis_sector_str ( traffic_exhaust_nc_index ) = 'F1-3' !Not read endif save_EMEP_source = calculate_EMEP_source !Automatically set these extra files to be read !Of these only the traffic exhaust and nonexhaust will be saved if ( use_GNFR19_emissions_from_EMEP_flag ) then calculate_EMEP_source ( traffic_gasoline_nc_index ) = . true . calculate_EMEP_source ( traffic_diesel_nc_index ) = . true . calculate_EMEP_source ( traffic_gas_nc_index ) = . true . calculate_EMEP_source ( publicpower_point_nc_index ) = . true . calculate_EMEP_source ( publicpower_area_nc_index ) = . true . calculate_EMEP_source ( traffic_exhaust_nc_index ) = . true . calculate_EMEP_source ( traffic_nonexhaust_nc_index ) = . true . !We do not want to add these since they are already in traffic but we do want to save them calculate_EMEP_source ( traffic_exhaust_nc_index ) = . false . calculate_EMEP_source ( traffic_nonexhaust_nc_index ) = . false . save_EMEP_source ( traffic_exhaust_nc_index ) = . true . save_EMEP_source ( traffic_nonexhaust_nc_index ) = . true . endif !integer GNFR_index(n_source_nc_index) !A 1 �PublicPower� (1) !B 2 �Industry� (3) !C 3 �OtherStationaryComb� (2) !D 4 �Fugitive� (4) !E 5 �Solvents� (6) !F 6 �RoadTransport� (7) !G 7 �Shipping� (8) !H 8 �Aviation� (8) !I 9 �Offroad� (8) !J 10 �Waste� (9) !K 11 �AgriLivestock� (10) !L 12 �AgriOther� (10) !M 13 �Other� (5) !These are for the previous EMEP version before 4.3.3 if ( use_GNFR_emissions_from_EMEP_flag ) then !Local fractions var_name_nc ( frac_nc_index , nox_nc_index , traffic_nc_index ) = 'nox_sec06_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , traffic_nc_index ) = 'pmco_sec06_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , traffic_nc_index ) = 'pm25_sec06_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , shipping_nc_index ) = 'nox_sec07_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , shipping_nc_index ) = 'pm25_sec07_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , shipping_nc_index ) = 'pmco_sec07_local_fraction' !var_name_nc(frac_nc_index,nh3_nc_index,agriculture_nc_index)='nh3_sec11_local_fraction' !var_name_nc(frac_nc_index,nh3_nc_index,agriculture_nc_index)='nh3_sec12_local_fraction' !Read as total for the time being as these have become two sectors now var_name_nc ( frac_nc_index , nh3_nc_index , agriculture_nc_index ) = 'nh3_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , heating_nc_index ) = 'nox_sec03_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , heating_nc_index ) = 'pm25_sec03_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , heating_nc_index ) = 'pmco_sec03_local_fraction' var_name_nc ( frac_nc_index , nox_nc_index , industry_nc_index ) = 'nox_sec02_local_fraction' var_name_nc ( frac_nc_index , pm25_nc_index , industry_nc_index ) = 'pm25_sec02_local_fraction' var_name_nc ( frac_nc_index , pmco_nc_index , industry_nc_index ) = 'pmco_sec02_local_fraction' !Total emissions remain the same var_name_nc ( emis_nc_index , nh3_nc_index , allsource_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , allsource_nc_index ) = 'Emis_mgm2_nox' var_name_nc ( emis_nc_index , pmco_nc_index , allsource_nc_index ) = 'Emis_mgm2_pmco' var_name_nc ( emis_nc_index , pm25_nc_index , allsource_nc_index ) = 'Emis_mgm2_pm25' !Sector emissions read as total var_name_nc ( emis_nc_index , nh3_nc_index , agriculture_nc_index ) = 'Emis_mgm2_nh3' var_name_nc ( emis_nc_index , nox_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec6nox' var_name_nc ( emis_nc_index , pm25_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec6pm25' var_name_nc ( emis_nc_index , pmco_nc_index , traffic_nc_index ) = 'Emis_mgm2_sec6pmco' var_name_nc ( emis_nc_index , nox_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec7nox' var_name_nc ( emis_nc_index , pm25_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec7pm25' var_name_nc ( emis_nc_index , pmco_nc_index , shipping_nc_index ) = 'Emis_mgm2_sec7pmco' var_name_nc ( emis_nc_index , nox_nc_index , heating_nc_index ) = 'Emis_mgm2_sec3nox' var_name_nc ( emis_nc_index , pm25_nc_index , heating_nc_index ) = 'Emis_mgm2_sec3pm25' var_name_nc ( emis_nc_index , pmco_nc_index , heating_nc_index ) = 'Emis_mgm2_sec3pmco' var_name_nc ( emis_nc_index , nox_nc_index , industry_nc_index ) = 'Emis_mgm2_sec2nox' var_name_nc ( emis_nc_index , pm25_nc_index , industry_nc_index ) = 'Emis_mgm2_sec2pm25' var_name_nc ( emis_nc_index , pmco_nc_index , industry_nc_index ) = 'Emis_mgm2_sec2pmco' endif !General setting of names. Overrides all other presets do i_comp = 1 , n_pollutant_nc_index do i_source = 1 , n_source_nc_index var_name_nc ( frac_nc_index , i_comp , i_source ) = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_nc_index )) // '_sec' // trim ( uEMEP_to_EMEP_sector_str ( i_source )) // '_local_fraction' var_name_nc ( emis_nc_index , i_comp , i_source ) = 'Emis_mgm2_sec' // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // var_name_nc ( conc_nc_index , i_comp , allsource_nc_index ) if ( i_source . eq . allsource_nc_index ) then var_name_nc ( frac_nc_index , i_comp , i_source ) = trim ( var_name_nc ( conc_nc_index , i_comp , allsource_nc_index )) // '_local_fraction' var_name_nc ( emis_nc_index , i_comp , i_source ) = 'Emis_mgm2_' // var_name_nc ( conc_nc_index , i_comp , allsource_nc_index ) endif if ( extract_benzene_from_voc_emissions . and . i_comp . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i_comp , i_source ) = 'Emis_mgm2_sec' // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // 'voc' endif !write(*,*) i_comp,i_source,trim(var_name_nc(frac_nc_index,i_comp,i_source)),trim(var_name_nc(emis_nc_index,i_comp,i_source)) enddo enddo if ( use_emission_naming_template_flag ) then !Set the prefix and postfix part of the emission name string based on the template !Assumes compound is added at the end index_start = INDEX ( emission_naming_template_str , '<n>' ) if ( index_start . eq . 0 ) then prefix_str = '' else prefix_str = emission_naming_template_str ( 1 : index_start - 1 ) endif if ( index_start + 3. gt . len_trim ( emission_naming_template_str )) then postfix_str = '' else postfix_str = emission_naming_template_str ( index_start + 3 :) endif !write(*,*) index_start,index_start+3,len_trim(emission_naming_template_str) if ( use_GNFR_emissions_from_EMEP_flag . or . use_alphabetic_GNFR_emissions_from_EMEP_flag ) then write ( unit_logfile , '(a)' ) 'Using emission name template for GNFR sectors: ' // trim ( emission_naming_template_str ) do i = 1 , n_pollutant_nc_index do i_source = 1 , n_source_nc_index var_name_nc ( emis_nc_index , i , i_source ) = trim ( prefix_str ) // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , i_source ) = trim ( prefix_str ) // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // trim ( postfix_str ) // 'voc' endif if ( i_source . eq . allsource_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // 'voc' endif if ( use_alphabetic_GNFR_emissions_from_EMEP_flag ) then !Remove any leading '_' in the postfix_str index_start = INDEX ( postfix_str , '_' ) if ( index_start . eq . 1 ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ( 2 :)) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ( 2 :)) // 'voc' endif else var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( postfix_str ) // 'voc' endif endif endif endif !write(*,*) i,i_source,trim(var_name_nc(emis_nc_index,i,i_source)) enddo enddo else write ( unit_logfile , '(a)' ) 'Using emission name template for SNAP sectors: ' // trim ( emission_naming_template_str ) do i = 1 , n_pollutant_nc_index do i_source = 1 , n_source_nc_index var_name_nc ( emis_nc_index , i , i_source ) = trim ( prefix_str ) // trim ( uEMEP_to_EMEP_emis_sector_str ( i_source )) // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( i_source . eq . allsource_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) if ( extract_benzene_from_voc_emissions . and . i . eq . c6h6_nc_index ) then var_name_nc ( emis_nc_index , i , allsource_nc_index ) = trim ( prefix_str ) // '' // trim ( postfix_str ) // 'voc' endif endif enddo enddo endif endif !Set the indexes for the local fraction data and increase the number of variables appropriately !Include a conversion array between the local and fraction arrays if ( use_local_fraction_naming_template_flag ) then i = 0 do j = 1 , n_local_fraction_grids i = i + 1 ; lc_frac_nc_loop_index ( j ) = i enddo do j = 1 , n_local_fraction_grids i = i + 1 ; lc_local_nc_loop_index ( j ) = i !convert_local_to_fraction_loop_index(lc_local_nc_loop_index(j))=lc_frac_nc_loop_index(j) enddo !do j=1,n_local_fraction_grids !    convert_fraction_to_local_loop_index(lc_fraction_nc_loop_index(j))=lc_local_nc_loop_index(j) !enddo num_lc_var_nc = i write ( unit_logfile , '(a,i)' ) 'New number of num_lc_var_nc variables with additional LF EMEP: ' , num_lc_var_nc min_lc_frac_nc_loop_index = minval ( lc_frac_nc_loop_index ) max_lc_frac_nc_loop_index = maxval ( lc_frac_nc_loop_index ) i = num_var_nc_start do j = 1 , n_local_fraction_grids i = i + 1 ; frac_nc_loop_index ( j ) = i convert_frac_to_lc_frac_loop_index ( frac_nc_loop_index ( j )) = lc_frac_nc_loop_index ( j ) !write(*,*) i,j,frac_nc_loop_index(j),convert_frac_to_lc_frac_loop_index(frac_nc_loop_index(j)) enddo do j = 1 , n_local_fraction_grids i = i + 1 ; local_nc_loop_index ( j ) = i enddo num_var_nc = i write ( unit_logfile , '(a,i)' ) 'New number of num_var_nc variables with additional LF EMEP: ' , num_var_nc min_frac_nc_loop_index = minval ( frac_nc_loop_index ) max_frac_nc_loop_index = maxval ( frac_nc_loop_index ) endif if ( use_local_fraction_naming_template_flag ) then !Set the prefix and postfix part of the emission name string based on the template !Assumes compound is added at the end do j = 1 , n_local_fraction_grids local_fraction_naming_template_str_temp = local_fraction_naming_template_str index_start = INDEX ( local_fraction_naming_template_str_temp , '<n>' ) if ( index_start . eq . 0 ) then prefix_str = '' else prefix_str = local_fraction_naming_template_str_temp ( 1 : index_start - 1 ) endif if ( index_start + 3. gt . len_trim ( local_fraction_naming_template_str_temp )) then postfix_str = '' else postfix_str = local_fraction_naming_template_str_temp ( index_start + 3 :) endif !Create the local fraction grid size for appending to the variable name write ( temp_str , '(i2)' ) local_fraction_grid_size ( j ) local_fraction_grid_size_str = '_' // trim ( adjustl ( temp_str )) // 'x' // trim ( adjustl ( temp_str )) if (. not . use_local_fraction_grid_size_in_template_flag ) then local_fraction_grid_size_str = '' endif !write(*,*) index_start,index_start+3,len_trim(emission_naming_template_str) write ( unit_logfile , '(a,i)' ) 'Using local fraction name template: ' // trim ( local_fraction_naming_template_str_temp ) // ' for lf grid = ' , j !do i=1,n_pollutant_nc_index do p_loop = 1 , n_emep_pollutant_loop + 1 if ( p_loop . le . n_emep_pollutant_loop ) then i = pollutant_loop_index ( p_loop ) else i = pmco_nc_index !Necessary to include this endif do i_source = 1 , n_source_nc_index if ( calculate_source ( i_source ). or . calculate_EMEP_source ( i_source ). or . save_EMEP_source ( i_source ). or . i_source . eq . allsource_nc_index ) then var_name_nc ( frac_nc_loop_index ( j ), i , i_source ) = trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) // '_' // trim ( prefix_str ) // trim ( uEMEP_to_EMEP_sector_str ( i_source )) // trim ( postfix_str ) // trim ( local_fraction_grid_size_str ) if ( i_source . eq . allsource_nc_index ) then var_name_nc ( frac_nc_loop_index ( j ), i , allsource_nc_index ) = trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) // trim ( postfix_str ) // trim ( local_fraction_grid_size_str ) endif write ( unit_logfile , '(2i6,2a)' ) i , i_source , '  ' , trim ( var_name_nc ( frac_nc_loop_index ( j ), i , i_source )) endif enddo enddo enddo endif !Only works on the old sectors and lf names if ( use_user_specified_sectors_flag ) then write ( unit_logfile , '(a)' ) 'Replacing sector index in EMEP (sector,pollutant,lf_name,emis_name)' do sector_index = 0 , n_source_nc_index if ( calculate_source ( sector_index ). and . uEMEP_to_EMEP_replace_sector ( sector_index ). ge . 0 ) then !sector_index=traffic_nc_index write ( sector_str_lf , '(i0.2)' ) uEMEP_to_EMEP_replace_sector ( sector_index ) write ( sector_str_emis , '(i0.1)' ) uEMEP_to_EMEP_replace_sector ( sector_index ) if ( uEMEP_to_EMEP_replace_sector ( sector_index ). ne . 0 ) then sector_str_lf = '_sec' // trim ( sector_str_lf ) sector_str_emis = trim ( sector_str_emis ) else sector_str_lf = '' sector_str_emis = '' endif do i = 1 , n_pollutant_nc_index !Can fix the above problem here if ( use_local_fraction_naming_template_flag ) then var_name_nc ( frac_nc_index , i , sector_index ) = trim ( prefix_str ) // trim ( sector_str_lf ) // trim ( postfix_str ) else var_name_nc ( frac_nc_index , i , sector_index ) = trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) // trim ( sector_str_lf ) // '_local_fraction' endif !var_name_nc(frac_nc_index,pmco_nc_index,sector_index)='pmco'//trim(sector_str)//'_local_fraction' !var_name_nc(frac_nc_index,pm25_nc_index,sector_index)='pm25'//trim(sector_str)//'_local_fraction' if ( use_emission_naming_template_flag ) then var_name_nc ( emis_nc_index , i , sector_index ) = trim ( prefix_str ) // trim ( sector_str_emis ) // trim ( postfix_str ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) else var_name_nc ( emis_nc_index , i , sector_index ) = 'Emis_mgm2_sec' // trim ( sector_str_emis ) // trim ( var_name_nc ( conc_nc_index , i , allsource_nc_index )) endif write ( unit_logfile , '(2i8,a6,i2,a4,i2,a3,2a48)' ) sector_index , i , ' from ' , uEMEP_to_EMEP_sector ( sector_index ), ' to ' , uEMEP_to_EMEP_replace_sector ( sector_index ), ' : ' , trim ( var_name_nc ( frac_nc_index , i , sector_index )), trim ( var_name_nc ( emis_nc_index , i , sector_index )) enddo endif enddo endif !stop !write(unit_tile,'(a,i0.5)') 'tile_tag= '//trim(save_tile_tag)//'_',count if ( use_EMEP_surface_compounds_flag ) then write ( unit_logfile , '(a)' ) 'Using EMEP surface compounds instead of gridded' comp_name_nc ( o3_nc_index ) = 'SURF_ug_O3' comp_name_nc ( no2_nc_index ) = 'SURF_ug_NO2' comp_name_nc ( nox_nc_index ) = 'SURF_ugN_NOX' !Not used comp_name_nc ( nh3_nc_index ) = 'SURF_ug_NH3' !comp_name_nc(nh3_nc_index)='nh3' comp_name_nc ( nh4_nc_index ) = 'SURF_ug_NH4_F' !comp_name_nc(pm25_nc_index)='pm25' !comp_name_nc(pmco_nc_index)='SURF_ug_PMCO' comp_name_nc ( pm10_nc_index ) = 'SURF_ug_PM10' comp_name_nc ( pm25_nc_index ) = 'SURF_ug_PM25' comp_name_nc ( co_nc_index ) = 'SURF_ug_CO' comp_name_nc ( bap_nc_index ) = 'SURF_ug_BAP' comp_name_nc ( c6h6_nc_index ) = 'SURF_ug_BENZENE' comp_name_nc ( so2_nc_index ) = 'SURF_ug_SO2' endif if ( use_water_in_EMEP_surface_pm_flag ) then write ( unit_logfile , '(a)' ) 'Using EMEP surface PM including water (RH50)' comp_name_nc ( pm10_nc_index ) = 'SURF_ug_PM10_rh50' comp_name_nc ( pm25_nc_index ) = 'SURF_ug_PM25_rh50' endif !Reset emission names so they will not be read if they are not used if ( make_EMEP_grid_emission_data ( allsource_index ). or . local_subgrid_method_flag . ne . 2. or . save_emissions_for_EMEP ( allsource_index ). or . save_emissions ) then else var_name_nc ( emis_nc_index ,:,:) = '' write ( unit_logfile , '(a,i)' ) 'Will not read or write any EMEP emission data' endif !If utm zones set the projection parameters to these values if ( projection_type . eq . UTM_projection_index ) then projection_attributes ( 1 ) = utm_zone projection_attributes ( 2 ) = utm_lon0 endif if ( projection_type . eq . LTM_projection_index ) then projection_attributes ( 1 ) = utm_zone projection_attributes ( 2 ) = ltm_lon0 endif !Reset the EMEP grid region based on the size of the selected local fraction local_fraction_grid_size_scaling = real ( local_fraction_grid_size ( local_fraction_grid_for_EMEP_grid_interpolation )) EMEP_grid_interpolation_size_original = EMEP_grid_interpolation_size !EMEP_grid_interpolation_size=EMEP_grid_interpolation_size_original*local_fraction_grid_size_scaling local_fraction_additional_grid_size_scaling = real ( local_fraction_grid_size ( local_fraction_grid_for_EMEP_additional_grid_interpolation )) EMEP_additional_grid_interpolation_size_original = EMEP_additional_grid_interpolation_size !EMEP_additional_grid_interpolation_size=EMEP_additional_grid_interpolation_size_original*local_fraction_additional_grid_size_scaling !Definitions of the emission saving grid. These are the pre February 2020 values !save_emission_subgrid_min(x_dim_index)=-6.498834E+05 !save_emission_subgrid_delta(x_dim_index)=2500. !save_emission_subgrid_dim(x_dim_index)=531 !save_emission_subgrid_min(y_dim_index)=-6.567275E+05 !save_emission_subgrid_delta(y_dim_index)=2500. !save_emission_subgrid_dim(y_dim_index)=671 end subroutine uEMEP_reset_constants end module set_constants","tags":"","loc":"sourcefile/uemep_set_constants.f90.html"},{"title":"uEMEP_read_namefile_routines.f90 – uEMEP","text":"Source Code module read_namefile_routines !! Subroutines and functions for reading in name files use uemep_constants , only : dp implicit none private public :: read_name_char , read_name_logical , read_name_integer , & read_name_real , read_name_double interface read_name module procedure read_name_real module procedure read_name_double module procedure read_name_integer module procedure read_name_char module procedure read_name_logical end interface read_name contains function read_name_real ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads single precision value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file real , intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit real :: res !! Value found in name file (or default value) ! Local variables integer :: i , index_val , io character ( len = 256 ) :: temp_str , temp_str1 , temp_str2 ! Initially, set to default value res = default_val rewind ( unit_in ) do read ( unit_in , \"(a)\" , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' ! If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,es12.4)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_real function read_name_double ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads double precision value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file real ( dp ), intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit real ( dp ) :: res !! Value found in name file (or default value) ! Local variables integer :: i , index_val , io character ( len = 256 ) :: temp_str , temp_str1 , temp_str2 ! Initiallly set to default value res = default_val rewind ( unit_in ) !do while (.not.eof(unit_in)) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' ! If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,es12.4)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_double function read_name_integer ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads integer value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file integer , intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit integer :: res !! Value found in name file (or default value) ! Local variables integer :: i , index_val , io character ( 256 ) temp_str , temp_str1 , temp_str2 ! Initially set return value to default value res = default_val rewind ( unit_in ) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' !If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,i12)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_integer function read_name_char ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads string from name file !! !! Skips comments (!) and returns default string if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of string in name file character ( len =* ), intent ( in ) :: default_val !! Default string integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit character ( len = :), allocatable :: res !! String found in name file (or default string) ! Local variables integer :: i , index_val , io character ( 256 ) :: temp_str , temp_str1 , temp_str2 character ( 256 ) :: call_str = 'read_name_char' ! Initially set default string as return string res = default_val rewind ( unit_in ) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' !If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then !Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then !Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then ! Special for characters so it doesn't read it's own call if ( trim ( temp_str2 ( 1 : min ( len ( trim ( temp_str2 )), len ( trim ( call_str ))))) . ne . trim ( call_str )) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if res = adjustl ( res ) write ( unit_out , '(A,A)' ) 'Setting: ' // trim ( name_str ) // ' = ' , trim ( res ) end if end if end if end if end if end do end function read_name_char function read_name_logical ( name_str , default_val , unit_in , unit_out ) result ( res ) !! Reads boolean value from name file !! !! Skips comments (!) and returns default value if name is not present in name file character ( len =* ), intent ( in ) :: name_str !! Name of value in name file logical , intent ( in ) :: default_val !! Default value integer , intent ( in ) :: unit_in !! Name file unit integer , intent ( in ) :: unit_out !! Log file unit logical :: res ! Local variables integer :: i , index_val , io character ( len = 256 ) :: temp_str , temp_str1 , temp_str2 ! Initially set return value as default res = default_val rewind ( unit_in ) do read ( unit_in , '(A)' , iostat = io ) temp_str if ( io /= 0 ) then exit end if ! Remove tabs index_val = 0 do i = 1 , len ( temp_str ) if ( ichar ( temp_str ( i : i )) . ne . 9 ) then index_val = index_val + 1 temp_str1 ( index_val : index_val ) = temp_str ( i : i ) end if end do temp_str = ADJUSTL ( temp_str1 ) temp_str1 = '' ! If not a comment if ( trim ( temp_str ( 1 : 1 )) . ne . '!' ) then ! Find the position of the equals sign if there is one index_val = index ( temp_str , '=' , back = . false .) if ( index_val . gt . 1 ) then ! Create the string before the equals sign temp_str1 = trim ( temp_str ( 1 : index_val - 1 )) ! Check to see if it is a matching string if ( trim ( temp_str1 ) . eq . trim ( name_str )) then ! Create the string after the equals sign temp_str2 = temp_str ( index_val + 1 :) temp_str2 = adjustl ( temp_str2 ) if ( len ( trim ( temp_str2 )) . ge . 1 ) then read ( temp_str2 , * , iostat = io ) res if ( io /= 0 ) then cycle end if write ( unit_out , '(A,L)' ) 'Setting: ' // trim ( name_str ) // ' = ' , res end if end if end if end if end do end function read_name_logical end module read_namefile_routines","tags":"","loc":"sourcefile/uemep_read_namefile_routines.f90.html"},{"title":"uEMEP_subgrid_deposition_EMEP.f90 – uEMEP","text":"Source Code module subgrid_deposition_emep use uemep_configuration use mod_area_interpolation , only : area_weighted_extended_interpolation_function implicit none private public :: uEMEP_set_deposition_velocities , uEMEP_subgrid_deposition_EMEP , & uEMEP_calculate_deposition contains !uEMEP_read_deposition_EMEP.f90 subroutine uEMEP_subgrid_deposition_EMEP use uEMEP_definitions implicit none integer i_source , i_pollutant integer i , j real xpos_min , xpos_max , ypos_min , ypos_max real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_limit , ypos_limit integer i_nc , j_nc integer ii , jj real weighting_nc ( - 1 : 1 , - 1 : 1 ) integer i_meteo , j_meteo real h_mix_loc ( subgrid_dim ( t_dim_index )) real ratio ( subgrid_dim ( t_dim_index ), n_source_index , n_pollutant_loop ) real delta_area ( 2 ) real temp ( subgrid_dim ( t_dim_index ), 2 ) integer tt real ratio_interp ( subgrid_dim ( t_dim_index ), 2 ) write ( unit_logfile , '(A)' ) 'Distributing deposition to the subgrid' !Place the EMEP deposition velocities in the deposition subgrid, no interpolation. Now done using area interpolation do i_pollutant = 1 , n_emep_pollutant_loop !do j=1,deposition_subgrid_dim(y_dim_index) !do i=1,deposition_subgrid_dim(x_dim_index) !i_cross_emep=crossreference_deposition_to_emep_subgrid(i,j,x_dim_index) !j_cross_emep=crossreference_deposition_to_emep_subgrid(i,j,y_dim_index) !deposition_subgrid(i,j,:,vd_index,i_pollutant)=depo_var3d_nc(i_cross_emep,j_cross_emep,:,grid_index,i_pollutant) !write(*,*) i,j,deposition_subgrid(i,j,:,vd_index,i_pollutant) !enddo !enddo !Place the EMEP depositions in the concentration subgrid, no interpolation do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) ii = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) jj = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) !Nearest neighbour interpolate the EMEP compounds to subgrid !do i_loop=1,n_pollutant_compound_loop(i_pollutant) !do i_depo=1,n_deposition_index !orig_EMEP_deposition_subgrid(i,j,:,i_depo,i_pollutant)=depo_var3d_nc(ii,jj,:,i_depo,pollutant_compound_loop_index(i_pollutant,i_loop)) orig_EMEP_deposition_subgrid ( i , j ,:, drydepo_index , i_pollutant ) = var3d_nc ( ii , jj ,:, drydepo_nc_index , allsource_index , i_pollutant ) orig_EMEP_deposition_subgrid ( i , j ,:, wetdepo_index , i_pollutant ) = var3d_nc ( ii , jj ,:, wetdepo_nc_index , allsource_index , i_pollutant ) !enddo !enddo !This is overwritten in the weighted interpolation !write(*,*)sum(subgrid(i,j,:,emep_nonlocal_subgrid_index,:,:)),sum(subgrid(i,j,:,emep_subgrid_index,:,:)) subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index ,:,:) = var3d_nc ( ii , jj ,:, drydepo_nc_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index ,:,:) = var3d_nc ( ii , jj ,:, wetdepo_nc_index ,:,:) & * subgrid ( i , j ,:, emep_nonlocal_subgrid_index ,:,:) / subgrid ( i , j ,:, emep_subgrid_index ,:,:) enddo enddo enddo !Place the EMEP nonlocal deposition velocities in the subgrid, area weighted interpolation subgrid (:,:,:, drydepo_nonlocal_subgrid_index ,:,:) = 0. subgrid (:,:,:, wetdepo_nonlocal_subgrid_index ,:,:) = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. ypos_limit = dgrid_nc ( lat_nc_index ) / 2. ! write(*,*) integral_subgrid(:,:,1,hmix_integral_subgrid_index,allsource_index,i_pollutant) do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !Assumes it is never on the edge of the EMEP grid, not limitted i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then delta_area ( 1 ) = xpos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling * 11057 0. * cos ( 3.14159 / 18 0. * var1d_nc ( j_nc , lat_nc_index )) delta_area ( 2 ) = ypos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling * 11057 0. elseif ( EMEP_projection_type . eq . LCC_projection_index . or . EMEP_projection_type . eq . PS_projection_index ) then delta_area ( 1 ) = xpos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling delta_area ( 2 ) = ypos_limit * EMEP_grid_interpolation_size * local_fraction_grid_size_scaling endif !write(*,*) delta_area !The adjustment for the vertical profile is done here for wet deposition !The integral subgrid values are placed onto the target subgrid using the area weighted average over the lcoal region (xpos_limit*EMEP_grid_interpolation_size) if ( adjust_wetdepo_integral_to_lowest_layer_flag ) then i_meteo = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_meteo = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) h_mix_loc (:) = meteo_subgrid ( i_meteo , j_meteo ,:, hmix_subgrid_index ) i_source = allsource_index do i_pollutant = 1 , n_pollutant_loop do tt = 1 , subgrid_dim ( t_dim_index ) temp ( tt , 2 ) = area_weighted_extended_interpolation_function ( x_integral_subgrid , y_integral_subgrid , integral_subgrid (:,:, tt , hmix_integral_subgrid_index , i_source , i_pollutant ) & , integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_delta ( x_dim_index ), x_subgrid ( i , j ), y_subgrid ( i , j ), delta_area ) temp ( tt , 1 ) = area_weighted_extended_interpolation_function ( x_integral_subgrid , y_integral_subgrid , integral_subgrid (:,:, tt , hsurf_integral_subgrid_index , i_source , i_pollutant ) & , integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), integral_subgrid_delta ( x_dim_index ), x_subgrid ( i , j ), y_subgrid ( i , j ), delta_area ) !ratio(tt,i_source,i_pollutant)=temp(tt,2)/temp(tt,1)*H_emep/h_mix_loc(tt) ratio ( tt , i_source , i_pollutant ) = temp ( tt , 2 ) / temp ( tt , 1 ) * H_emep / h_mix_loc ( tt ) !write(*,*) h_mix_loc(tt)/H_emep,temp(tt,2),temp(tt,1),ratio(tt,i_source,i_pollutant) !Division by 0 traps if ( temp ( tt , 1 ). eq . 0 ) ratio ( tt , i_source , i_pollutant ) = 0. if ( h_mix_loc ( tt ). eq . 0 ) ratio ( tt , i_source , i_pollutant ) = 0. ratio ( tt , i_source , i_pollutant ) = max ( 0. , ratio ( tt , i_source , i_pollutant )) ratio ( tt , i_source , i_pollutant ) = min ( 1. , ratio ( tt , i_source , i_pollutant )) !write(*,'(2i,3es12.2)') i,j,temp(tt,1),temp(tt,2),ratio(tt,i_source,i_pollutant) enddo enddo else ratio = 1. endif xpos_area_max = xproj_subgrid ( i , j ) + xpos_limit xpos_area_min = xproj_subgrid ( i , j ) - xpos_limit ypos_area_max = yproj_subgrid ( i , j ) + ypos_limit ypos_area_min = yproj_subgrid ( i , j ) - ypos_limit do jj = j_nc - 1 , j_nc + 1 do ii = i_nc - 1 , i_nc + 1 xpos_min = max ( xpos_area_min , var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max = min ( xpos_area_max , var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min = max ( ypos_area_min , var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max = min ( ypos_area_max , var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Determine the area intersection of the EMEP grid and an EMEP grid size centred on the integral subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii - i_nc , jj - j_nc ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii - i_nc , jj - j_nc ) = 0. endif i_source = allsource_index do i_pollutant = 1 , n_emep_pollutant_loop !Division by 0 traps ratio_interp (:, 1 ) = subgrid ( i , j ,:, emep_nonlocal_subgrid_index , allsource_index , i_pollutant ) / subgrid ( i , j ,:, emep_subgrid_index , allsource_index , i_pollutant ) where ( ratio_interp (:, 1 ). gt . 1. ) ratio_interp (:, 1 ) = 1. where ( ratio_interp (:, 1 ). lt . 0. ) ratio_interp (:, 1 ) = 0. where ( subgrid ( i , j ,:, emep_subgrid_index , allsource_index , i_pollutant ). eq . 0. ) ratio_interp (:, 1 ) = 0. ratio_interp (:, 2 ) = subgrid ( i , j ,:, emep_local_subgrid_index , allsource_index , i_pollutant ) / subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source , i_pollutant ) * ratio (:, i_source , i_pollutant ) !where (ratio_interp(:,2).gt.1.) ratio_interp(:,2)=1. where ( ratio_interp (:, 2 ). lt . 0. ) ratio_interp (:, 2 ) = 0. where ( subgrid ( i , j ,:, emep_nonlocal_subgrid_index , i_source , i_pollutant ). eq . 0. ) ratio_interp (:, 2 ) = 0. subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid ( i , j ,:, drydepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + var3d_nc ( ii , jj ,:, drydepo_nc_index , i_source , i_pollutant ) & * ratio_interp (:, 1 ) & * weighting_nc ( ii - i_nc , jj - j_nc ) !subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,i_pollutant)=subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,i_pollutant) & !        +var3d_nc(ii,jj,:,wetdepo_nc_index,i_source,i_pollutant) & !        *(1.-subgrid(i,j,:,emep_local_subgrid_index,allsource_index,i_pollutant)/subgrid(i,j,:,emep_subgrid_index,i_source,i_pollutant)*ratio(:,i_source,i_pollutant)) & !        *weighting_nc(ii-i_nc,jj-j_nc) subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) = subgrid ( i , j ,:, wetdepo_nonlocal_subgrid_index , allsource_index , i_pollutant ) & + var3d_nc ( ii , jj ,:, wetdepo_nc_index , i_source , i_pollutant ) & / ( 1. + ratio_interp (:, 2 )) & * weighting_nc ( ii - i_nc , jj - j_nc ) !write(*,*) ratio(:,i_source,i_pollutant),subgrid(i,j,:,emep_local_subgrid_index,allsource_index,i_pollutant)/subgrid(i,j,:,emep_nonlocal_subgrid_index,allsource_index,i_pollutant) enddo enddo enddo !write(*,*) i,j,ratio,subgrid(i,j,:,emep_local_subgrid_index,i_source,:)/subgrid(i,j,:,emep_subgrid_index,i_source,:) !write(*,*) i,j,deposition_subgrid(i,j,:,vd_index,:),depo_var3d_nc(i_nc,j_nc,:,grid_index,:) enddo enddo end subroutine uEMEP_subgrid_deposition_EMEP subroutine uEMEP_calculate_deposition use uEMEP_definitions implicit none integer source_index integer i , j !real sum_temp(subgrid_dim(x_dim_index),subgrid_dim(y_dim_index),subgrid_dim(t_dim_index)) write ( unit_logfile , '(A)' ) 'Combining local deposition sources' !Calculate redistributed subgrid allsource deposition ! subgrid (:,:,:, drydepo_local_subgrid_index , allsource_index ,:) = 0. !subgrid(:,:,:,drydepo_nonlocal_subgrid_index,allsource_index,:)=0. subgrid (:,:,:, wetdepo_local_subgrid_index , allsource_index ,:) = 0. !subgrid(:,:,:,wetdepo_nonlocal_subgrid_index,allsource_index,:)=0. do source_index = 1 , n_source_index if ( calculate_source ( source_index )) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) !i_cross_deposition=crossreference_target_to_deposition_subgrid(i,j,x_dim_index) !j_cross_deposition=crossreference_target_to_deposition_subgrid(i,j,y_dim_index) !subgrid(i,j,:,drydepo_nonlocal_subgrid_index,source_index,:)=subgrid(i,j,:,emep_nonlocal_subgrid_index,source_index,:) & !     *deposition_subgrid(i_cross_deposition,j_cross_deposition,:,vd_index,:) !subgrid(i,j,:,drydepo_nonlocal_subgrid_index,allsource_index,:)=subgrid(i,j,:,drydepo_nonlocal_subgrid_index,allsource_index,:)+subgrid(i,j,:,drydepo_nonlocal_subgrid_index,source_index,:) subgrid ( i , j ,:, drydepo_local_subgrid_index , allsource_index ,:) = subgrid ( i , j ,:, drydepo_local_subgrid_index , allsource_index ,:) + subgrid ( i , j ,:, drydepo_local_subgrid_index , source_index ,:) !write(*,*) subgrid(i,j,:,emep_nonlocal_subgrid_index,source_index,1),deposition_subgrid(i_cross_deposition,j_cross_deposition,:,vd_index,1) !subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,:)=subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,allsource_index,:)+subgrid(i,j,:,wetdepo_nonlocal_subgrid_index,source_index,:) subgrid ( i , j ,:, wetdepo_local_subgrid_index , allsource_index ,:) = subgrid ( i , j ,:, wetdepo_local_subgrid_index , allsource_index ,:) + subgrid ( i , j ,:, wetdepo_local_subgrid_index , source_index ,:) enddo enddo endif enddo !Convert the nonlocal depositions from mg/m2/hr to ug/m2/sec for compatability with local calculations subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index ,:) = subgrid (:,:,:, drydepo_nonlocal_subgrid_index , allsource_index ,:) * 100 0. / 360 0. subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index ,:) = subgrid (:,:,:, wetdepo_nonlocal_subgrid_index , allsource_index ,:) * 100 0. / 360 0. end subroutine uEMEP_calculate_deposition subroutine uEMEP_set_deposition_velocities use uEMEP_definitions implicit none integer i_pollutant integer i , j real xpos_min , xpos_max , ypos_min , ypos_max real xpos_area_min , xpos_area_max , ypos_area_min , ypos_area_max real xpos_limit , ypos_limit integer i_nc , j_nc integer ii , jj real weighting_nc ( - 1 : 1 , - 1 : 1 ) integer i_landuse write ( unit_logfile , '(A)' ) 'Placing EMEP deposition velocities on the deposition subgrid' !Fill in with a default value deposition_subgrid (:,:,:,:, 1 : n_pollutant_loop ) = 0. !write(*,*) size(deposition_subgrid) drydepo_vd_default ( 1 : n_compound_index ) = 0.0 !Positive value in m/s drydepo_vd_default ( nh3_index ) = 0.03 !Positive value in m/s wetdepo_scavanging_rate ( 1 : n_compound_index ) = 0.0 !Positive value in m/s wetdepo_scavanging_rate ( nh3_index ) = 0.5 * 1.e6 / 100 0. !Dimensions of m-1 W/h do i_pollutant = 1 , n_pollutant_loop deposition_subgrid (:,:,:, vd_index , i_pollutant ) = drydepo_vd_default ( pollutant_loop_index ( i_pollutant )) !write(*,*) i_source,i_pollutant,sum(deposition_subgrid(:,:,:,vd_index,i_pollutant)),drydepo_vd_default(i_pollutant) enddo !stop !Place the EMEP deposition velocities in the deposition subgrid, area weighted interpolation deposition_subgrid (:,:,:, vd_index ,:) = 0. xpos_limit = dgrid_nc ( lon_nc_index ) / 2. ypos_limit = dgrid_nc ( lat_nc_index ) / 2. do j = 1 , deposition_subgrid_dim ( y_dim_index ) do i = 1 , deposition_subgrid_dim ( x_dim_index ) !Cross reference EMEP grid with limits i_nc = crossreference_deposition_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_deposition_to_emep_subgrid ( i , j , y_dim_index ) i_nc = min ( max ( 2 , i_nc ), dim_length_nc ( x_dim_nc_index ) - 1 ) j_nc = min ( max ( 2 , j_nc ), dim_length_nc ( y_dim_nc_index ) - 1 ) !write(*,*) i,j,i_nc,j_nc xpos_area_max = xproj_deposition_subgrid ( i , j ) + xpos_limit xpos_area_min = xproj_deposition_subgrid ( i , j ) - xpos_limit ypos_area_max = yproj_deposition_subgrid ( i , j ) + ypos_limit ypos_area_min = yproj_deposition_subgrid ( i , j ) - ypos_limit do jj = j_nc - 1 , j_nc + 1 do ii = i_nc - 1 , i_nc + 1 xpos_min = max ( xpos_area_min , var1d_nc ( ii , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) xpos_max = min ( xpos_area_max , var1d_nc ( ii , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) ypos_min = max ( ypos_area_min , var1d_nc ( jj , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) ypos_max = min ( ypos_area_max , var1d_nc ( jj , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) !Determine the area intersection of the EMEP grid and an EMEP grid size centred on the deposition subgrid if ( xpos_max . gt . xpos_min . and . ypos_max . gt . ypos_min ) then weighting_nc ( ii - i_nc , jj - j_nc ) = ( ypos_max - ypos_min ) * ( xpos_max - xpos_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii - i_nc , jj - j_nc ) = 0. endif if ( read_landuse_flag ) then do i_landuse = 1 , n_landuse_index - 1 deposition_subgrid ( i , j ,:, vd_index ,:) = deposition_subgrid ( i , j ,:, vd_index ,:) + depo_var3d_nc ( ii , jj ,:, i_landuse ,:) * landuse_subgrid ( i , j , i_landuse ) * weighting_nc ( ii - i_nc , jj - j_nc ) enddo else deposition_subgrid ( i , j ,:, vd_index ,:) = deposition_subgrid ( i , j ,:, vd_index ,:) + depo_var3d_nc ( ii , jj ,:, grid_index ,:) * weighting_nc ( ii - i_nc , jj - j_nc ) endif enddo enddo !Fill in zeros with the nearest EMEP value. 0 can appear because of non overlapping EMEP and landuse grids, I think where ( deposition_subgrid ( i , j ,:, vd_index ,:). eq . 0 ) deposition_subgrid ( i , j ,:, vd_index ,:) = depo_var3d_nc ( i_nc , j_nc ,:, grid_index ,:) !write(*,'(2i,23es12.2,f)') i,j,deposition_subgrid(i,j,:,vd_index,:),depo_var3d_nc(i_nc,j_nc,:,grid_index,:),sum(depo_var3d_nc(ii,jj,:,1:n_landuse_index-1,:)),sum(landuse_subgrid(i,j,1:n_landuse_index-1)) enddo enddo end subroutine uEMEP_set_deposition_velocities end module subgrid_deposition_emep","tags":"","loc":"sourcefile/uemep_subgrid_deposition_emep.f90.html"},{"title":"uemep_constants.f90 – uEMEP","text":"Source Code module uemep_constants implicit none ! Type constants integer , parameter , public :: dp = selected_real_kind ( 15 , 307 ) ! Mathematical constants real , parameter :: pi = 3.14159265358979323 ! Time constants real , parameter , public :: secphour = 360 0.0 real , parameter , public :: secpday = 8640 0.0 ! Other constants real , parameter :: NODATA_value = - 12 8.0 real , parameter :: epsilon0 = 1.0e-6 end module uemep_constants","tags":"","loc":"sourcefile/uemep_constants.f90.html"},{"title":"uEMEP_subgrid_emission_EMEP.f90 – uEMEP","text":"Source Code module subgrid_emission_emep use uemep_configuration use mod_lambert_projection , only : lb2lambert2_uEMEP , LL2PS_spherical , lb2lambert_uEMEP implicit none private public :: uEMEP_subgrid_emission_EMEP contains !========================================================================== !   uEMEP model subgrid_emission_EMEP !========================================================================== subroutine uEMEP_subgrid_emission_EMEP use uEMEP_definitions implicit none integer i , j integer ii , jj , tt , t real , allocatable :: weighting_nc (:,:), weighting_subgrid (:,:,:) real , allocatable :: total_weighting_nc (:,:,:), proxy_weighting_nc (:,:,:) real , allocatable :: total_proxy_emission_subgrid (:,:,:,:) real , allocatable :: total_proxy_subgrid_emission_in_EMEP_grid (:,:,:,:) integer , allocatable :: subgrid_count_nc (:,:) integer , allocatable :: subgrid_count_subgrid (:,:,:) integer i_nc_start , i_nc_end , j_nc_start , j_nc_end integer i_start , i_end , j_start , j_end , t_start , t_end real lon_min , lon_max , lat_min , lat_max integer i_nc , j_nc integer i_source integer ii_nc , jj_nc , ii_w , jj_w integer :: n_weight = 3 integer weighting_subgrid_dim ( 2 , n_source_index ) integer i_cross , j_cross !integer, allocatable :: crossreference_weighting_to_emep_subgrid(:,:,:,:) integer i_w_c , j_w_c integer i_nc_c , j_nc_c real sum_temp ( n_pollutant_loop ) real xpos_subgrid , ypos_subgrid real xpos_subgrid2 , ypos_subgrid2 integer i_pollutant !functions !Set the scaling factor for EMEP emissions depending on whether they are total emissions or average emissions !EMEP_emission_aggregation_period=365.*24.   !For aggregation over a year !EMEP_emission_aggregation_period=1.         !For hourly average if ( local_subgrid_method_flag . ne . 3. and . local_subgrid_method_flag . ne . 4 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Distributing EMEP emission to subgrids (uEMEP_subgrid_emission_EMEP)' write ( unit_logfile , '(A)' ) '================================================================' !Allocate and save the existing emission subgrid data allocate ( total_proxy_emission_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_source_index , n_pollutant_loop )) !There are no subsources in EMEP so this index is set to 1 and the subsource emissions are transferred to the proxy emission subgrid !subsource_index=1 !do i_source=1,n_source_index !if (calculate_source(i_source)) then !    temp_proxy_emission_subgrid(:,:,i_source,:)=sum(proxy_emission_subgrid(:,:,i_source,:),3) !endif !enddo !Set the start and end times of the loop t_start = 1 t_end = subgrid_dim ( t_dim_index ) tt = 1 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_pollutant = 1 , n_pollutant_loop !write(*,*) trim(source_file_str(i_source)) !write(*,*) trim(var_name_nc(conc_nc_index,pollutant_loop_index(i_pollutant),allsource_nc_index)) !trim(pollutant_file_str(pollutant_loop_index(i_pollutant))) !write(*,*) sum(emission_subgrid(1:emission_subgrid_dim(x_dim_index,i_source),1:emission_subgrid_dim(y_dim_index,i_source),:,i_source,i_pollutant)) !write(*,*) (t_end-t_start+1) !write(unit_logfile,'(A,A,A,A,ES10.2)') 'Emission source ',trim(source_file_str(i_source))//' ',trim(var_name_nc(conc_nc_index,pollutant_loop_index(i_pollutant),allsource_nc_index)),': Total hourly average emissions before use of EMEP (ug/s)=', & !    sum(emission_subgrid(1:emission_subgrid_dim(x_dim_index,i_source),1:emission_subgrid_dim(y_dim_index,i_source),:,i_source,i_pollutant))/(t_end-t_start+1) enddo endif enddo !Distribute the EMEP emissions evenly over the subgrids within an EMEP grid if ( EMEP_emission_grid_interpolation_flag . eq . 0. or . local_subgrid_method_flag . eq . 4 ) then !if (EMEP_emission_grid_interpolation_flag.eq.0) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to all subgrids within an EMEP grid' tt = 1 allocate ( total_proxy_subgrid_emission_in_EMEP_grid ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_source_index , n_pollutant_loop )) allocate ( subgrid_count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) allocate ( subgrid_count_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ))) !emission_subgrid=0. total_proxy_subgrid_emission_in_EMEP_grid = 0. total_proxy_emission_subgrid = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid (:,:,:, i_source ,:) = 0. subgrid_count_subgrid = 0 subgrid_count_nc = 0 !Calculate total subgrid emissions and number of subgrids in each EMEP grid do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) ii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) jj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) ii = max ( min ( ii , dim_length_nc ( x_dim_nc_index )), 1 ) jj = max ( min ( jj , dim_length_nc ( y_dim_nc_index )), 1 ) subgrid_count_nc ( ii , jj ) = subgrid_count_nc ( ii , jj ) + 1 total_proxy_subgrid_emission_in_EMEP_grid ( ii , jj , i_source ,:) = total_proxy_subgrid_emission_in_EMEP_grid ( ii , jj , i_source ,:) + proxy_emission_subgrid ( i , j , i_source ,:) emission_subgrid ( i , j ,:, i_source ,:) = var3d_nc ( ii , jj ,:, emis_nc_index , i_source ,:) enddo enddo !Transfer the total emissions in the EMEP grid to each subgrid within that grid !if (subgrid_emission_distribution_flag) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) ii = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) jj = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) ii = max ( min ( ii , dim_length_nc ( x_dim_nc_index )), 1 ) jj = max ( min ( jj , dim_length_nc ( y_dim_nc_index )), 1 ) total_proxy_emission_subgrid ( i , j , i_source ,:) = total_proxy_subgrid_emission_in_EMEP_grid ( ii , jj , i_source ,:) subgrid_count_subgrid ( i , j ,:) = subgrid_count_nc ( ii , jj ) !write(*,*) subgrid_count_nc(ii,jj) !Converts from mg/m2/hour(year) to ug/s/subgrid assuming the original EMEP emissions are in mg/m2/hour(year) if ( hourly_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) & * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. if ( annual_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) & * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. / EMEP_emission_aggregation_period !write(*,*) emission_subgrid(i,j,1,i_source,subsource_index),var3d_nc(ii,jj,1,emis_nc_index,i_source)*emission_subgrid_delta(x_dim_index,i_source)*emission_subgrid_delta(y_dim_index,i_source)*1000./3600. enddo enddo !endif !Determine subgrid normalised time profile per hour from EMEP grid emissions (average hourly emission conversion) !This is not quite right because the entire emission time profile is not available in a short period !Minimum of a day is needed, with the assumption that all days are the same if ( local_subgrid_method_flag . eq . 4 ) then write ( unit_logfile , '(A)' ) 'Calculating EMEP emission time profile' do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) if ( hourly_calculations ) then sum_temp (:) = sum ( emission_subgrid ( i , j ,:, i_source ,:), 1 ) do i_pollutant = 1 , n_pollutant_loop emission_time_profile_subgrid ( i , j ,:, i_source , i_pollutant ) = emission_subgrid ( i , j ,:, i_source , i_pollutant ) / sum_temp ( i_pollutant ) * emission_subgrid_dim ( t_dim_index , i_source ) if ( sum_temp ( i_pollutant ). eq . 0. ) emission_time_profile_subgrid ( i , j ,:, i_source , i_pollutant ) = 0. enddo else emission_time_profile_subgrid ( i , j ,:, i_source ,:) = 1. endif !write(*,'(<emission_subgrid_dim(t_dim_index,i_source)>f6.2)') emission_time_profile_subgrid(i,j,:,i_source,subsource_index) !write(*,*) i,j,subgrid_count_subgrid(i,j,1,i_source),total_proxy_emission_subgrid(i,j,1,i_source,subsource_index),emission_subgrid(i,j,1,i_source,subsource_index) !Set emissions to 0 in the case when local_subgrid_method_flag.eq.4 since these are set later !This way of doing things is not logical as it fills the grid unnecessarilly. Should be fixed and made logical emission_subgrid ( i , j ,:, i_source ,:) = 0. enddo enddo endif !Distribute EMEP emissions to existing proxy subgrid emissions if ( subgrid_emission_distribution_flag . and . local_subgrid_method_flag . ne . 4 ) then if ( local_subgrid_method_flag . eq . 2 ) write ( unit_logfile , '(2A)' ) 'Distributing local emission data to subgrid emissions for: ' , trim ( source_file_str ( i_source )) if ( local_subgrid_method_flag . eq . 3 ) write ( unit_logfile , '(2A)' ) 'Distributing EMEP emissions to proxy subgrid emissions, no weighting used, for: ' , trim ( source_file_str ( i_source )) do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * subgrid_count_subgrid (:,:,:) * proxy_emission_subgrid (:,:, i_source ,:) / total_proxy_emission_subgrid (:,:, i_source ,:) where ( total_proxy_emission_subgrid (:,:, i_source ,:). eq . 0. ) emission_subgrid (:,:, t , i_source ,:) = 0. enddo !Fix round off negatives where ( emission_subgrid (:,:,:, i_source ,:). lt . 0 ) emission_subgrid (:,:,:, i_source ,:) = 0. !write(*,*) sum(emission_subgrid(:,:,:,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(emission_subgrid(:,:,:,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !write(*,*) sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pmex_nc_index))),sum(var3d_nc(:,:,:,emis_nc_index,traffic_index,pollutant_loop_back_index(pm25_nc_index))) !write(*,*) pmex_index,pmex_nc_index !stop endif endif enddo endif !Quick calculation of area weighting, no edge effects. Does not need to change with time !This is done also if there is moving window weighting later as it is used for the nonlocal contribution if ( EMEP_emission_grid_interpolation_flag . eq . 1. and . local_subgrid_method_flag . ne . 4 ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to proxy emission subgrids using area weighting of the EMEP grid' tt = 1 !tt=dim_length_nc(time_dim_nc_index) allocate ( weighting_nc ( n_weight , n_weight )) !EMEP grid weighting for interpolation. Does not need a source index for area weighting !allocate (subgrid_count_nc(dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),tt,n_source_index)) allocate ( subgrid_count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) !allocate (emission_subgrid(emission_max_subgrid_dim(x_dim_index),emission_max_subgrid_dim(y_dim_index),subgrid_dim(t_dim_index),n_source_index,n_pollutant_loop)) total_proxy_emission_subgrid = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid (:,:,:, i_source ,:) = 0. subgrid_count_subgrid = 0 do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) !Only calculate for valid emission subgrids when using the proxy emissions for distribution if (. not . subgrid_emission_distribution_flag . or . sum ( proxy_emission_subgrid ( i , j , i_source ,:)). ne . 0 ) then !Assumes it is never on the edge of the EMEP grid i_nc = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) weighting_nc = 0. if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid = lon_emission_subgrid ( i , j , i_source ) ypos_subgrid = lat_emission_subgrid ( i , j , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid,ypos_subgrid,lon_emission_subgrid(i,j,i_source),lat_emission_subgrid(i,j,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) endif !Calculate the area weighted EMEP grid emissions at each subgrid do jj =- 1 , + 1 do ii =- 1 , + 1 ii_nc = ii + i_nc jj_nc = jj + j_nc ii_w = ii + 2 jj_w = jj + 2 lon_min = max ( xpos_subgrid - dgrid_nc ( lon_nc_index ) / 2. , var1d_nc ( ii_nc , lon_nc_index ) - dgrid_nc ( lon_nc_index ) / 2. ) lon_max = min ( xpos_subgrid + dgrid_nc ( lon_nc_index ) / 2. , var1d_nc ( ii_nc , lon_nc_index ) + dgrid_nc ( lon_nc_index ) / 2. ) lat_min = max ( ypos_subgrid - dgrid_nc ( lat_nc_index ) / 2. , var1d_nc ( jj_nc , lat_nc_index ) - dgrid_nc ( lat_nc_index ) / 2. ) lat_max = min ( ypos_subgrid + dgrid_nc ( lat_nc_index ) / 2. , var1d_nc ( jj_nc , lat_nc_index ) + dgrid_nc ( lat_nc_index ) / 2. ) if ( lon_max . gt . lon_min . and . lat_max . gt . lat_min ) then weighting_nc ( ii_w , jj_w ) = ( lat_max - lat_min ) * ( lon_max - lon_min ) / dgrid_nc ( lon_nc_index ) / dgrid_nc ( lat_nc_index ) else weighting_nc ( ii_w , jj_w ) = 0. endif emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) + var3d_nc ( ii_nc , jj_nc ,:, emis_nc_index , i_source ,:) * weighting_nc ( ii_w , jj_w ) enddo enddo !write(*,*) sum(weighting_nc) !This is OK !Calculate the total subgrid emissions in the EMEP grid region surrounding the subgrid i_start = max ( 1 , i - emission_subgrid_loop_index ( x_dim_index , i_source )) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i + emission_subgrid_loop_index ( x_dim_index , i_source )) j_start = max ( 1 , j - emission_subgrid_loop_index ( y_dim_index , i_source )) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j + emission_subgrid_loop_index ( y_dim_index , i_source )) do jj = j_start , j_end do ii = i_start , i_end if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid2 = lon_emission_subgrid ( ii , jj , i_source ) ypos_subgrid2 = lat_emission_subgrid ( ii , jj , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid2,ypos_subgrid2,lon_emission_subgrid(ii,jj,i_source),lat_emission_subgrid(ii,jj,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) endif if ( abs ( xpos_subgrid - xpos_subgrid2 ). le . dgrid_nc ( lon_nc_index ) / 2. & . and . abs ( ypos_subgrid - ypos_subgrid2 ). le . dgrid_nc ( lat_nc_index ) / 2. ) then total_proxy_emission_subgrid ( i , j , i_source ,:) = total_proxy_emission_subgrid ( i , j , i_source ,:) + proxy_emission_subgrid ( ii , jj , i_source ,:) subgrid_count_subgrid ( i , j ,:) = subgrid_count_subgrid ( i , j ,:) + 1 endif enddo enddo !Converts from mg/subgrid to ug/s/subgrid assuming the original EMEP emissions are in mg/m2/hour if ( hourly_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. if ( annual_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. / EMEP_emission_aggregation_period endif !If valid emission point enddo if ( mod ( j , 100 ). eq . 0 ) write ( * , '(A,A,A,i4,A,i4)' ) 'Subgrid emission EMEP interpolation for ' , trim ( source_file_str ( i_source )), ': ' , j , ' of ' , emission_subgrid_dim ( 2 , i_source ) enddo !Distribute EMEP emissions to subgrid emissions if ( subgrid_emission_distribution_flag ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to subgrid emissions within an area weighted EMEP grid' do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * subgrid_count_subgrid (:,:,:) * proxy_emission_subgrid (:,:, i_source ,:) / total_proxy_emission_subgrid (:,:, i_source ,:) where ( total_proxy_emission_subgrid (:,:, i_source ,:). eq . 0. ) emission_subgrid (:,:, t , i_source ,:) = 0. enddo endif endif enddo !source loop endif !Loop through subgrid and carry out a subgrid weighted moving window interpolation if ( EMEP_emission_grid_interpolation_flag . eq . 2. and . local_subgrid_method_flag . ne . 4 ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to proxy subgrids using emission weighting of the EMEP grid' !NOTE: currently does the inteprolation for all time steps which is not ncessary. Only needs to do it for 1. Same with the area interpolation. !Only use time tt for weighting distribution to increase speed. It is possible this can change with time. Replace 'tt' with ':' tt = 1 !tt=dim_length_nc(time_dim_nc_index) allocate ( total_weighting_nc ( dim_length_nc ( x_dim_nc_index ), dim_length_nc ( y_dim_nc_index ), n_pollutant_loop )) !EMEP grid weighting for interpolation allocate ( proxy_weighting_nc ( 5 , 5 , n_pollutant_loop )) !EMEP grid weighting for interpolation !allocate (subgrid_count_nc(dim_length_nc(x_dim_nc_index),dim_length_nc(y_dim_nc_index),tt,n_source_index)) allocate ( subgrid_count_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) i_w_c = 3 j_w_c = 3 total_proxy_emission_subgrid = 0. !emission_subgrid=0. !Set the start and end times of the loop !t_start=1 !t_end=subgrid_dim(t_dim_index) allocate ( weighting_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), n_pollutant_loop )) weighting_subgrid_dim (:,:) = emission_subgrid_dim ( 1 : 2 ,:) !Calculate weighting sum for each EMEP grid. total_weighting_nc = 0. do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then emission_subgrid (:,:,:, i_source ,:) = 0. subgrid_count_subgrid = 0 weighting_subgrid (:,:,:) = proxy_emission_subgrid (:,:, i_source ,:) !Calculate the total weighting (emission) in each emep grid do j = 1 , weighting_subgrid_dim ( y_dim_index , i_source ) do i = 1 , weighting_subgrid_dim ( x_dim_index , i_source ) i_nc = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) total_weighting_nc ( i_nc , j_nc ,:) = total_weighting_nc ( i_nc , j_nc ,:) + weighting_subgrid ( i , j ,:) !write(*,*) i_source,i,j,i_nc,j_nc,weighting_subgrid(i,j,:,i_source) !write(*,*) i,j,i_nc,j_nc,i_nc-crossreference_weighting_to_emep_subgrid(i,j,x_dim_index,i_source),j_nc-crossreference_weighting_to_emep_subgrid(i,j,y_dim_index,i_source) enddo enddo !Calculate the proxy weighting in the nearest emep grids for each subgrid do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) !Only calculate for valid emission subgrids when using the proxy for distribution if (. not . subgrid_emission_distribution_flag . or . sum ( proxy_emission_subgrid ( i , j , i_source ,:)). ne . 0 ) then proxy_weighting_nc = 0. i_cross = i !crossreference_target_to_emission_subgrid(i,j,x_dim_index,i_source) j_cross = j !crossreference_target_to_emission_subgrid(i,j,y_dim_index,i_source) i_nc_c = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , x_dim_index , i_source ) j_nc_c = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , y_dim_index , i_source ) !Limit the loop so that it doesn't go over more than necessary subgrids and does not go outside the domain i_start = max ( 1 , i - emission_subgrid_loop_index ( x_dim_index , i_source )) i_end = min ( emission_subgrid_dim ( x_dim_index , i_source ), i + emission_subgrid_loop_index ( x_dim_index , i_source )) j_start = max ( 1 , j - emission_subgrid_loop_index ( y_dim_index , i_source )) j_end = min ( emission_subgrid_dim ( y_dim_index , i_source ), j + emission_subgrid_loop_index ( y_dim_index , i_source )) !write(*,*) i,j,i_end-i_start,j_end-j_start if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid = lon_emission_subgrid ( i , j , i_source ) ypos_subgrid = lat_emission_subgrid ( i , j , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid,ypos_subgrid,lon_emission_subgrid(i,j,i_source),lat_emission_subgrid(i,j,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid , ypos_subgrid , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) endif do jj = j_start , j_end do ii = i_start , i_end if ( EMEP_projection_type . eq . LL_projection_index ) then xpos_subgrid2 = lon_emission_subgrid ( ii , jj , i_source ) ypos_subgrid2 = lat_emission_subgrid ( ii , jj , i_source ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then if ( use_alternative_LCC_projection_flag ) then call lb2lambert2_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) else call lb2lambert_uEMEP ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), real ( EMEP_projection_attributes ( 3 )), real ( EMEP_projection_attributes ( 4 ))) endif !call lb2lambert_uEMEP(xpos_subgrid2,ypos_subgrid2,lon_emission_subgrid(ii,jj,i_source),lat_emission_subgrid(ii,jj,i_source),real(EMEP_projection_attributes(3)),real(EMEP_projection_attributes(4))) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xpos_subgrid2 , ypos_subgrid2 , lon_emission_subgrid ( ii , jj , i_source ), lat_emission_subgrid ( ii , jj , i_source ), EMEP_projection_attributes ) endif if ( abs ( xpos_subgrid - xpos_subgrid2 ). le . dgrid_nc ( lon_nc_index ) / 2. & . and . abs ( ypos_subgrid - ypos_subgrid2 ). le . dgrid_nc ( lat_nc_index ) / 2. ) then i_nc = crossreference_emission_to_emep_subgrid ( ii , jj , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( ii , jj , y_dim_index , i_source ) !proxy_weighting_nc(i_nc,j_nc,:,i_source)=proxy_weighting_nc(i_nc,j_nc,:,i_source)+weighting_subgrid(ii,jj,:,i_source) proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c ,:) = proxy_weighting_nc ( i_nc - i_nc_c + i_w_c , j_nc - j_nc_c + j_w_c ,:) + weighting_subgrid ( ii , jj ,:) total_proxy_emission_subgrid ( i , j , i_source ,:) = total_proxy_emission_subgrid ( i , j , i_source ,:) + weighting_subgrid ( ii , jj ,:) !Weighting subgrid is the same as the existing proxy subgrid but without the subsource subgrid_count_subgrid ( i , j ,:) = subgrid_count_subgrid ( i , j ,:) + 1 endif enddo enddo i_cross = i !crossreference_target_to_emission_subgrid(i,j,x_dim_index,i_source) j_cross = j !crossreference_target_to_emission_subgrid(i,j,y_dim_index,i_source) i_nc = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , x_dim_index , i_source ) j_nc = crossreference_emission_to_emep_subgrid ( i_cross , j_cross , y_dim_index , i_source ) i_nc_start = max ( 1 , i_nc - 1 ) i_nc_end = min ( dim_length_nc ( x_dim_nc_index ), i_nc + 1 ) j_nc_start = max ( 1 , j_nc - 1 ) j_nc_end = min ( dim_length_nc ( y_dim_nc_index ), j_nc + 1 ) !write(*,*) i,j,i_nc,j_nc,i_nc_end-i_nc_start,j_nc_end-j_nc_start do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c ,:) = proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c ,:) / total_weighting_nc ( ii , jj ,:) !where (total_weighting_nc(ii,jj,tt,i_source).eq.0) proxy_weighting_nc(ii-i_nc+i_w_c,jj-j_nc+j_w_c,:,i_source)=0. where ( total_weighting_nc ( ii , jj ,:). eq . 0 ) proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c ,:) = 0. enddo enddo !Add up the contributing weights !Note that only the subsource_index=1 can be determined since EMEP has no subsources !if (hourly_calculations) then !do i_subsource=1,n_subsource_index(i_source) do jj = j_nc_start , j_nc_end do ii = i_nc_start , i_nc_end do i_pollutant = 1 , n_pollutant_loop emission_subgrid ( i , j ,:, i_source , i_pollutant ) = emission_subgrid ( i , j ,:, i_source , i_pollutant ) & + var3d_nc ( ii , jj ,:, emis_nc_index , i_source , i_pollutant ) * proxy_weighting_nc ( ii - i_nc + i_w_c , jj - j_nc + j_w_c , i_pollutant ) enddo !if (weighting_nc(ii,jj,traffic_index).ne.0) then !    write(*,*) i,j,ii,jj,weighting_nc(ii,jj,traffic_index),subgrid(i,j,traffic_index,emep_local_subgrid_index) !endif enddo enddo !write(*,*) i,j,proxy_weighting_nc(2,:,1,i_source) !write(*,*) i,j,proxy_weighting_nc(2,2,1,i_source),emission_subgrid(i,j,1,i_source,subsource_index) !write(*,*) sum(proxy_weighting_nc) !Converts from mg/subgrid to ug/s/subgrid assuming the original EMEP emissions are in mg/m2/hour if ( hourly_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. if ( annual_calculations ) emission_subgrid ( i , j ,:, i_source ,:) = emission_subgrid ( i , j ,:, i_source ,:) * emission_subgrid_delta ( x_dim_index , i_source ) * emission_subgrid_delta ( y_dim_index , i_source ) * 100 0. / 360 0. / EMEP_emission_aggregation_period endif !If valid emission subgrid enddo if ( mod ( j , 100 ). eq . 0 ) write ( * , '(A,A,A,i4,A,i4)' ) 'Subgrid emission EMEP interpolation for ' , trim ( source_file_str ( i_source )), ': ' , j , ' of ' , emission_subgrid_dim ( 2 , i_source ) enddo !Puts counts into the time array. If emission distributions change in time this needs to be replaced !do t=1,size(subgrid_count_subgrid,3) !    subgrid_count_subgrid(:,:,t,i_source)=subgrid_count_subgrid(:,:,tt,i_source) !enddo !Distribute EMEP emissions to existing subgrid emissions if ( subgrid_emission_distribution_flag ) then write ( unit_logfile , '(A)' ) 'Distributing EMEP emissions to subgrid emissions within an emission weighted EMEP grid' do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * subgrid_count_subgrid (:,:,:) * proxy_emission_subgrid (:,:, i_source ,:) / total_proxy_emission_subgrid (:,:, i_source ,:) where ( total_proxy_emission_subgrid (:,:, i_source ,:). eq . 0. ) emission_subgrid (:,:, t , i_source ,:) = 0. enddo endif endif !End if calculate_source enddo !End source loop endif !Scale the subgrid emissions if GNFR is used do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then if ( scale_GNFR_emission_source ( i_source ). ne . 1. ) then write ( unit_logfile , '(2A,f12.2)' ) 'Scaling EMEP emissions for uEMEP source: ' , trim ( source_file_str ( i_source )), scale_GNFR_emission_source ( i_source ) do t = t_start , t_end emission_subgrid (:,:, t , i_source ,:) = emission_subgrid (:,:, t , i_source ,:) * scale_GNFR_emission_source ( i_source ) enddo endif endif enddo !if (subgrid_emission_distribution_flag) then do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_pollutant = 1 , n_pollutant_loop write ( unit_logfile , '(A,A,A,ES10.2)' ) 'Emission source ' , trim ( source_file_str ( i_source )) // ' ' // trim ( pollutant_file_str ( pollutant_loop_index ( i_pollutant ))), ': Total hourly average emissions after use of EMEP (ug/s)=' , & sum ( emission_subgrid ( 1 : emission_subgrid_dim ( x_dim_index , i_source ), 1 : emission_subgrid_dim ( y_dim_index , i_source ),:, i_source , i_pollutant )) / ( t_end - t_start + 1 ) enddo endif enddo !endif if ( allocated ( weighting_nc )) deallocate ( weighting_nc ) if ( allocated ( total_weighting_nc )) deallocate ( total_weighting_nc ) if ( allocated ( proxy_weighting_nc )) deallocate ( proxy_weighting_nc ) if ( allocated ( weighting_subgrid )) deallocate ( weighting_subgrid ) if ( allocated ( total_proxy_emission_subgrid )) deallocate ( total_proxy_emission_subgrid ) if ( allocated ( total_proxy_subgrid_emission_in_EMEP_grid )) deallocate ( total_proxy_subgrid_emission_in_EMEP_grid ) if ( allocated ( subgrid_count_nc )) deallocate ( subgrid_count_nc ) if ( allocated ( subgrid_count_subgrid )) deallocate ( subgrid_count_subgrid ) end subroutine uEMEP_subgrid_emission_EMEP end module subgrid_emission_emep","tags":"","loc":"sourcefile/uemep_subgrid_emission_emep.f90.html"},{"title":"uEMEP_definitions.f90 – uEMEP","text":"Source Code module uEMEP_definitions !UEMEP_definitions !Defines variables and indexes used in the uEMEP routines !Bruce Rolstad Denby 09.11.2016 implicit none ! Directory seperator for linux (/) or windows ( character ( 1 ) :: slash = '\\' character(256) :: model_version_str = ' uEMEP_vx . x ' logical :: read_EMEP_only_once_flag = .false. ! Note can lead to virtual memory overflow integer :: unit_logfile = 0 integer :: unit_finishedfile = 20 integer :: n_roadlinks = 0 integer :: n_roadlinks_major = 0 integer :: n_roadlinks_major_selected = 0 logical :: calculate_EMEP_additional_grid_flag = .false. ! Single loop time variables integer :: t_loop integer :: start_time_loop_index = 1 integer :: end_time_loop_index = 1 ! Dimensions of the netcdf files that are read integer, parameter :: num_dims_nc = 6 ! (x,y,z,t,xpos,ypos) integer, parameter :: num_dims_meteo_nc = 4 ! (x,y,z,t) integer :: dim_length_nc(num_dims_nc) integer :: dim_start_nc(num_dims_nc) = [1, 1, 1, 1, 1, 1] ! start at first value integer :: dim_length_meteo_nc(num_dims_meteo_nc) integer :: dim_start_meteo_nc(num_dims_meteo_nc) = [1, 1, 1, 1] ! start at first value integer :: dim_length_EMEP_nc(num_dims_nc) integer :: dim_start_EMEP_nc(num_dims_nc) ! Dimensions of the netcdf files that are used integer :: end_dim_nc(num_dims_nc) integer :: start_dim_nc(num_dims_nc) integer, parameter :: lon_nc_index = 1 integer, parameter :: lat_nc_index = 2 integer, parameter :: ugrid_nc_index = 3 integer, parameter :: vgrid_nc_index = 4 integer, parameter :: FF10_nc_index = 5 integer, parameter :: FFgrid_nc_index = 6 integer, parameter :: inv_FFgrid_nc_index = 7 integer, parameter :: inv_FF10_nc_index = 8 integer, parameter :: hmix_nc_index = 9 integer, parameter :: kz_nc_index = 10 integer, parameter :: invL_nc_index = 11 integer, parameter :: ustar_nc_index = 12 integer, parameter :: logz0_nc_index = 13 integer, parameter :: J_nc_index = 14 integer, parameter :: conc_nc_index = 15 ! integer, parameter :: frac_nc_index = 16 ! Set with the loop_index (multiple emep lf grids) ! integer, parameter :: local_nc_index = 17 ! Set with the loop_index (multiple emep lf grids) integer, parameter :: emis_nc_index = 18 integer, parameter :: x_nc_index = 19 integer, parameter :: y_nc_index = 20 integer, parameter :: ZTOP_nc_index = 21 integer, parameter :: u10_nc_index = 22 integer, parameter :: v10_nc_index = 23 integer, parameter :: uw_nc_index = 24 integer, parameter :: vw_nc_index = 25 integer, parameter :: Hflux_nc_index = 26 integer, parameter :: t2m_nc_index = 27 integer, parameter :: precip_nc_index = 28 integer, parameter :: wetdepo_nc_index = 29 integer, parameter :: drydepo_nc_index = 30 integer, parameter :: phi_nc_index = 31 integer :: num_var_nc  !This will be set later when the number local fraction grids is known integer, parameter :: num_var_nc_start = 31 ! number of readable variables integer, parameter :: num_var_nc_name = 51 ! number of possible variable names, add 20 to include any extra local fraction grids integer, parameter :: num_var_meteo_nc = num_var_nc_start integer, parameter :: num_lc_var_nc_start = 2 ! number of readable local contribution variables integer :: frac_nc_index = num_var_nc_start + 1 integer :: local_nc_index = num_var_nc_start + 2 integer :: lc_frac_nc_index = 1 integer :: lc_local_nc_index = 2 integer :: num_lc_var_nc = num_lc_var_nc_start integer :: compound_index integer, parameter :: no2_nc_index = 1 integer, parameter :: nox_nc_index = 2 integer, parameter :: pm25_nc_index = 3 integer, parameter :: pm10_nc_index = 4 integer, parameter :: nh3_nc_index = 5 integer, parameter :: o3_nc_index = 6 integer, parameter :: so2_nc_index = 7 integer, parameter :: pmex_nc_index = 8 ! Additional for nh3 compounds integer, parameter :: nh4_nc_index = 9 ! Additional NORTRIP specific compounds integer, parameter :: pm25_sand_nc_index = 10 integer, parameter :: pm10_sand_nc_index = 11 integer, parameter :: pm25_salt_nc_index = 12 integer, parameter :: pm10_salt_nc_index = 13 ! Additional compounds. Need to change n_compound_index as well integer, parameter :: c6h6_nc_index = 14 integer, parameter :: bap_nc_index = 15 integer, parameter :: co_nc_index = 16 integer, parameter :: somo35_nc_index = 17 integer, parameter :: comax_nc_index = 18 integer, parameter :: o3max_nc_index = 19 integer, parameter :: o3_26th_nc_index = 20 integer, parameter :: n_compound_nc_index = 20 ! These are only used in names but need to change the variable n_pollutant_nc_index to fit these! integer, parameter :: pmco_nc_index = 21 integer, parameter :: all_nc_index = 22 integer, parameter :: pm_nc_index = 23 integer, parameter :: all_sand_nc_index = 24 integer, parameter :: all_salt_nc_index = 25 integer, parameter :: all_sand_salt_nc_index = 26 integer, parameter :: all_totals_nc_index = 27 integer, parameter :: aaqd_totals_nc_index = 28 integer, parameter :: gp_totals_nc_index = 29 integer, parameter :: op_totals_nc_index = 30 ! These must be the same as the subgrid source indexes. Should probably just use the one integer, parameter :: allsource_nc_index = 1 integer, parameter :: traffic_nc_index = 2 integer, parameter :: shipping_nc_index = 3 integer, parameter :: heating_nc_index = 4 integer, parameter :: agriculture_nc_index = 5 integer, parameter :: industry_nc_index = 6 ! All the other GNFR emissions integer, parameter :: publicpower_nc_index = 7 integer, parameter :: fugitive_nc_index = 8 integer, parameter :: solvents_nc_index = 9 integer, parameter :: aviation_nc_index = 10 integer, parameter :: offroad_nc_index = 11 integer, parameter :: waste_nc_index = 12 integer, parameter :: livestock_nc_index = 13 integer, parameter :: other_nc_index = 14 integer, parameter :: traffic_exhaust_nc_index = 15 integer, parameter :: traffic_nonexhaust_nc_index = 16 integer, parameter :: traffic_gasoline_nc_index = 17 integer, parameter :: traffic_diesel_nc_index = 18 integer, parameter :: traffic_gas_nc_index = 19 integer, parameter :: publicpower_point_nc_index = 20 integer, parameter :: publicpower_area_nc_index = 21 integer, parameter :: extrasource_nc_index = 22 integer, parameter :: n_source_nc_index = 22 integer :: convert_GNFR_to_uEMEP_sector_index(n_source_nc_index) ! Loop for all pollutants to be calculated integer :: pollutant_index integer, parameter :: n_pollutant_nc_index = 30 ! Includes the addition naming indexes index integer :: n_pollutant_loop = 1 integer :: n_emep_pollutant_loop = 1 integer :: pollutant_loop_index(n_pollutant_nc_index) integer :: pollutant_loop_back_index(n_pollutant_nc_index) ! Set pollutant compound loop integer :: n_pollutant_compound_loop(n_pollutant_nc_index) = 0 integer :: pollutant_compound_loop_index(n_pollutant_nc_index, n_compound_nc_index) = 0 ! Set the pollutant reference index for meteo data. All meteo data read from EMEP uses this index integer :: meteo_p_loop_index = 1 character(256) :: pollutant_file_str(n_pollutant_nc_index) = '' character(256) :: dim_name_nc(num_dims_nc) character(256) :: var_name_meteo_nc(num_var_meteo_nc) character(256) :: dim_name_meteo_nc(num_dims_meteo_nc) integer, parameter :: num_var_population_nc = 2 integer, parameter :: num_dims_population_nc = 2 integer, parameter :: population_nc_index = 1 ! population_nc_index=1 assumes population files in lat and lon integer, parameter :: dwelling_nc_index = 2 character(256) :: dim_name_population_nc(num_dims_population_nc) integer, parameter :: num_var_shipping_nc = 1 ! assumes shipping files in lat and lon integer, parameter :: num_dims_shipping_nc = 2 character(256) :: var_name_shipping_nc(num_var_shipping_nc) character(256) :: dim_name_shipping_nc(num_dims_shipping_nc) integer, parameter :: num_var_landuse_nc = 1 ! assumes landuse files in lat and lon integer, parameter :: num_dims_landuse_nc = 2 character(256) :: dim_name_landuse_nc(num_dims_landuse_nc) integer :: dim_length_landuse_nc(num_dims_landuse_nc) integer :: dim_start_landuse_nc(num_dims_landuse_nc) = [1, 1] ! start at first value ! Dimension netcdf fields integer, parameter :: x_dim_nc_index = 1 integer, parameter :: y_dim_nc_index = 2 integer, parameter :: z_dim_nc_index = 3 integer, parameter :: time_dim_nc_index = 4 integer, parameter :: xdist_dim_nc_index = 5 integer, parameter :: ydist_dim_nc_index = 6 ! Declare netcdf files real, allocatable :: var1d_nc(:, :) real, allocatable :: var2d_nc(:, :, :) real, allocatable :: var3d_nc(:, :, :, :, :, :) real, allocatable :: var4d_nc(:, :, :, :, :, :, :) real, allocatable :: lc_var3d_nc(:, :, :, :, :, :, :, :) ! Netcdf local contribution array (idist,jdist,i,j,k,t,type,source) real, allocatable :: lc_var4d_nc(:, :, :, :, :, :, :, :, :) ! Netcdf local contribution array (idist,jdist,i,j,k,t,type,source) real, allocatable :: comp_var3d_nc(:, :, :, :) ! Netcdf additional compounds array (i,j,t,compound) real, allocatable :: comp_var4d_nc(:, :, :, :, :) ! Netcdf additional compounds array (i,j,k,t,compound) ! Alternative meteorological input data netcdf files. No source element real, allocatable :: meteo_var1d_nc(:, :) real, allocatable :: meteo_var2d_nc(:, :, :) real, allocatable :: meteo_var3d_nc(:, :, :, :) real, allocatable :: meteo_var4d_nc(:, :, :, :, :) real :: dgrid_nc(2) real :: meteo_dgrid_nc(2) double precision, allocatable :: val_dim_nc(:, :) double precision, allocatable :: val_dim_meteo_nc(:, :) character(256), allocatable :: unit_dim_nc(:) character(256), allocatable :: unit_dim_meteo_nc(:) integer :: surface_level_nc ! Indicates the centre of the EMEP local fraction distance array. Set in uEMEP_read_EMEP and used in uEMEP_subgrid_EMEP ! Source of a significant bug up to febuary 2021 when the EMEP lf grid used in the interpolation were not the same integer :: xdist_centre_nc = 0 integer :: ydist_centre_nc = 0 ! Declare road link data arrays real, allocatable :: inputdata_rl(:, :) integer, allocatable :: inputdata_int_rl(:, :) real, allocatable :: inputdata_rl_emissions(:, :, :) logical, allocatable :: valid_link_flag(:) ! Road link (rl) indexes integer, parameter :: x1_rl_index = 1 integer, parameter :: x2_rl_index = 2 integer, parameter :: y1_rl_index = 3 integer, parameter :: y2_rl_index = 4 integer, parameter :: x0_rl_index = 5 integer, parameter :: y0_rl_index = 6 integer, parameter :: lon1_rl_index = 7 integer, parameter :: lon2_rl_index = 8 integer, parameter :: lat1_rl_index = 9 integer, parameter :: lat2_rl_index = 10 integer, parameter :: lon0_rl_index = 11 integer, parameter :: lat0_rl_index = 12 integer, parameter :: length_rl_index = 13 integer, parameter :: z0_rl_index = 14 integer, parameter :: width_rl_index = 15 integer, parameter :: adt_rl_index = 16 integer, parameter :: speed_rl_index = 17 integer, parameter :: hdv_rl_index = 18 integer, parameter :: tunnel_length_rl_index = 19 integer, parameter :: num_var_rl = 19 integer, parameter :: id_rl_index = 1 integer, parameter :: roadtype_rl_index = 2 integer, parameter :: nlanes_rl_index = 3 integer, parameter :: major_index_rl_index = 4 integer, parameter :: num_int_rl = 4 ! Declare file and path names for input roadlink files character(256) :: pathfilename_rl(2) ! Filenames for multiple road link (mrl) files character(256) :: pathfilename_mrl(50) ! Input shipping (ship) indexes integer, parameter :: lon_ship_index = 1 !! Ship longitude index integer, parameter :: lat_ship_index = 2 !! Ship latitude index integer, parameter :: nox_ship_index = 3 !! Ship total NOx emission index integer, parameter :: tpm_ship_index = 4 !! Ship total particulate matter emission integer, parameter :: num_var_ship = 4 !! Number of ship variables integer, parameter :: idloyds_ship_index = 1 integer, parameter :: idnorwegian_ship_index = 2 integer, parameter :: num_int_ship = 2 integer, parameter :: date_ship_index = 1 integer, parameter :: time_ship_index = 2 integer :: num_char_ship ! TODO: Should this be set? integer, parameter :: num_char_rl = 2 ! TODO: Strange position, move to road links? ! Input agriculture integer, parameter :: lon_agriculture_index = 1 integer, parameter :: lat_agriculture_index = 2 integer, parameter :: nh3_agriculture_index = 3 integer, parameter :: num_var_agriculture = 3 ! Declaration for all filenames used to save gridded data produced by uEMEP. Up to 200 file names but of course can be more integer, parameter :: n_filenames_grid = 500 character(256) :: filename_grid(n_filenames_grid) character(256) :: pathname_grid(n_filenames_grid) character(256) :: pathfilename_grid(n_filenames_grid)  ! Combined path and filename ! Declare subgrid variable indexes for ' subgrid ' array integer, parameter :: proxy_subgrid_index = 1 integer, parameter :: proxy_integral_subgrid_index = 2 integer, parameter :: scaling_factor_subgrid_index = 3 integer, parameter :: local_subgrid_index = 4 integer, parameter :: nonlocal_subgrid_index = 5 integer, parameter :: total_subgrid_index = 6 integer, parameter :: emep_subgrid_index = 7 integer, parameter :: emep_frac_subgrid_index = 8 integer, parameter :: emep_local_subgrid_index = 9 integer, parameter :: emep_nonlocal_subgrid_index = 10 integer, parameter :: emep_additional_local_subgrid_index = 11 integer, parameter :: emep_additional_nonlocal_subgrid_index = 12 integer, parameter :: drydepo_local_subgrid_index = 13 integer, parameter :: wetdepo_local_subgrid_index = 14 integer, parameter :: drydepo_nonlocal_subgrid_index = 15 integer, parameter :: wetdepo_nonlocal_subgrid_index = 16 integer, parameter :: n_subgrid_index = 16 ! Declare meteo subgrid variables. Does nothave to be the same as the nc version integer, parameter :: ugrid_subgrid_index = 1 integer, parameter :: vgrid_subgrid_index = 2 integer, parameter :: FF10_subgrid_index = 3 integer, parameter :: FFgrid_subgrid_index = 4 integer, parameter :: inv_FFgrid_subgrid_index = 5 integer, parameter :: inv_FF10_subgrid_index = 6 integer, parameter :: hmix_subgrid_index = 7 integer, parameter :: kz_subgrid_index = 8 integer, parameter :: invL_subgrid_index = 9 integer, parameter :: ustar_subgrid_index = 10 integer, parameter :: logz0_subgrid_index = 11 integer, parameter :: J_subgrid_index = 12 integer, parameter :: t2m_subgrid_index = 13 integer, parameter :: cos_subgrid_index = 14 integer, parameter :: sin_subgrid_index = 15 integer, parameter :: precip_subgrid_index = 16 integer, parameter :: u10_subgrid_index = 17 integer, parameter :: v10_subgrid_index = 18 integer, parameter :: phi_index = 19 integer, parameter :: n_meteo_subgrid_index = 19 ! Declare compound indexes for the subgrid. Same as nc_index values for compounds. Must be converted when necessary integer, parameter :: no2_index = 1 integer, parameter :: nox_index = 2 integer, parameter :: pm25_index = 3 integer, parameter :: pm10_index = 4 integer, parameter :: nh3_index = 5 integer, parameter :: o3_index = 6 integer, parameter :: so2_index = 7 integer, parameter :: pmex_index = 8 integer :: no_index !! TODO Does not seem to be defined or used anywhere, delete? ! Additional for nh3 compounds integer, parameter :: nh4_index = 9 integer, parameter :: pm25_sand_index = 10 integer, parameter :: pm10_sand_index = 11 integer, parameter :: pm25_salt_index = 12 integer, parameter :: pm10_salt_index = 13 ! Additional compounds integer, parameter :: c6h6_index = 14 integer, parameter :: bap_index = 15 integer, parameter :: co_index = 16 integer, parameter :: somo35_index = 17 integer, parameter :: comax_index = 18 integer, parameter :: o3max_index = 19 integer, parameter :: o3_26th_index = 20 integer, parameter :: n_compound_index = 20 ! Declare source indexes (type_source) must be the same as source_nc_index integer, parameter :: allsource_index = 1 integer, parameter :: traffic_index = 2 integer, parameter :: shipping_index = 3 integer, parameter :: heating_index = 4 integer, parameter :: agriculture_index = 5 integer, parameter :: industry_index = 6 ! All the other GNFR emissions integer, parameter :: publicpower_index = 7 integer, parameter :: fugitive_index = 8 integer, parameter :: solvents_index = 9 integer, parameter :: aviation_index = 10 integer, parameter :: offroad_index = 11 integer, parameter :: waste_index = 12 integer, parameter :: livestock_index = 13 integer, parameter :: other_index = 14 integer, parameter :: traffic_exhaust_index = 15 integer, parameter :: traffic_nonexhaust_index = 16 integer, parameter :: n_source_index = 16 integer, parameter :: n_source_calculate_index = 14 integer :: compound_source_index(n_compound_index, n_source_index) character(256) :: source_file_postfix(n_source_nc_index) logical :: save_EMEP_source(n_source_nc_index) = .false. integer, parameter :: x_dim_index = 1 integer, parameter :: y_dim_index = 2 integer, parameter :: t_dim_index = 3 integer, parameter :: n_dim_index = 3 ! Target redistribution grid, the same for all sources and compounds integer :: subgrid_dim(n_dim_index) real :: subgrid_proj_min(2) real :: subgrid_proj_max(2) integer :: init_subgrid_dim(n_dim_index) real, allocatable :: subgrid(:, :, :, :, :, :) ! subgrid (i,j,t,type_subgrid,type_source,type_subsource) real, allocatable :: meteo_subgrid(:, :, :, :) real, allocatable :: last_meteo_subgrid(:, :, :) real, allocatable :: comp_subgrid(:, :, :, :) real, allocatable :: comp_EMEP_subgrid(:, :, :, :) real, allocatable :: orig_EMEP_subgrid(:, :, :, :) real, allocatable :: x_subgrid(:, :) real, allocatable :: y_subgrid(:, :) real, allocatable :: lon_subgrid(:, :) real, allocatable :: lat_subgrid(:, :) real, allocatable :: xproj_subgrid(:, :) real, allocatable :: yproj_subgrid(:, :) real, allocatable :: traveltime_subgrid(:, :, :, :, :) real, allocatable :: exposure_subgrid(:, :, :, :, :) integer :: subgrid_loop_index(2) ! Number of target subgrids to loop through, limitted by the size of the EMEP grid integer :: integral_subgrid_loop_index(2) ! Number of integral subgrids to loop through, limitted by the size of the EMEP grid integer :: emission_subgrid_loop_index(2, n_source_index) ! Number of emission subgrids to loop through, limitted by the size of the EMEP grid integer :: init_emission_subgrid_loop_index(2, n_source_index) ! Number of emission subgrids to loop through, limitted by the size of the EMEP grid logical, allocatable :: use_subgrid(:, :, :) ! Specifies if calculations are to be made at a particular set of target subgrids or not integer, allocatable :: use_subgrid_val(:, :, :) ! Same as use_subgrid but given a value to indicate if it is in the buffer zone of a region ore not (CURRENTLY DEACTIVATED) integer, allocatable :: use_subgrid_interpolation_index(:, :, :) ! Assigns the resolution level for auto gridding to the target grid integer :: n_use_subgrid_levels(n_source_index) real :: loop_index_scale = 1.5 real :: buffer_index_scale = 1.5 ! Emission subgrid per source and subsource. Can be time dependent ! Each source type has its own x and y and dim ! Each source may be of lesser dimensions than the total array size (which is the same as the target grid) integer, parameter :: n_possible_subsource = 2 character(2) :: subsource_str(n_possible_subsource) integer, parameter :: emission_h_index = 1 integer :: emission ! TODO Does not appear to be defined or used anywhere, delete? integer, parameter :: emission_sigz00_index = 2 integer, parameter :: emission_sigy00_index = 3 integer, parameter :: emission_minFF_index = 4 integer, parameter :: n_emission_index = 4 integer :: emission_subgrid_dim(n_dim_index, n_source_index) integer :: emission_max_subgrid_dim(n_dim_index) real :: emission_subgrid_delta(2, n_source_index) real :: emission_subgrid_min(2, n_source_index) real :: emission_subgrid_max(2, n_source_index) integer :: init_emission_subgrid_dim(n_dim_index, n_source_index) real :: init_emission_subgrid_delta(2, n_source_index) real :: init_emission_subgrid_min(2, n_source_index) real :: init_emission_subgrid_max(2, n_source_index) real, allocatable :: emission_subgrid(:, :, :, :, :) ! emission_subgrid (i,j,t,n_source,n_subsource) real, allocatable :: proxy_emission_subgrid(:, :, :, :) ! No time dependence real, allocatable :: emission_time_profile_subgrid(:, :, :, :, :) real, allocatable :: emission_properties_subgrid(:, :, :, :) ! No time dependence and no pollutant dependence. Would then need to do the gaussian calculation for each pollutant real, allocatable :: x_emission_subgrid(:, :, :) ! x_emission_subgrid (i,j,n_source) real, allocatable :: y_emission_subgrid(:, :, :) real, allocatable :: lon_emission_subgrid(:, :, :) real, allocatable :: lat_emission_subgrid(:, :, :) real, allocatable :: xproj_emission_subgrid(:, :, :) real, allocatable :: yproj_emission_subgrid(:, :, :) logical :: use_buffer_zone = .true. integer :: buffer_index(2) real :: buffer_size(2) integer :: emission_buffer_index(2, n_source_index) real :: emission_buffer_size(2, n_source_index) integer :: init_emission_buffer_index(2, n_source_index) real :: init_emission_buffer_size(2, n_source_index) integer :: integral_buffer_index(2) real :: integral_buffer_size(2) integer, parameter :: hsurf_integral_subgrid_index = 1 integer, parameter :: hmix_integral_subgrid_index = 2 integer, parameter :: hsurf_average_subgrid_index = 3 integer, parameter :: n_integral_subgrid_index = 3 integer :: integral_subgrid_dim(n_dim_index) real :: integral_subgrid_delta(2) = 0. real :: integral_subgrid_min(2) real :: integral_subgrid_max(2) real, allocatable :: integral_subgrid(:, :, :, :, :, :) ! emission_subgrid (i,j,t,n_integral_type,n_source,n_pollutant) real, allocatable :: x_integral_subgrid(:, :) real, allocatable :: y_integral_subgrid(:, :) real, allocatable :: lon_integral_subgrid(:, :) real, allocatable :: lat_integral_subgrid(:, :) real, allocatable :: xproj_integral_subgrid(:, :) real, allocatable :: yproj_integral_subgrid(:, :) real, allocatable :: meteo_nc_xproj_integral_subgrid(:, :) real, allocatable :: meteo_nc_yproj_integral_subgrid(:, :) integer :: population_subgrid_dim(2) real :: population_subgrid_delta(2) real :: population_subgrid_min(2) real :: population_subgrid_max(2) real, allocatable :: population_subgrid(:, :, :) real, allocatable :: x_population_subgrid(:, :) real, allocatable :: y_population_subgrid(:, :) real, allocatable :: lon_population_subgrid(:, :) real, allocatable :: lat_population_subgrid(:, :) real, allocatable :: xproj_population_subgrid(:, :) real, allocatable :: yproj_population_subgrid(:, :) integer, allocatable :: crossreference_target_to_emep_subgrid(:, :, :) ! (i,j,dim) integer, allocatable :: crossreference_target_to_localfraction_subgrid(:, :, :, :) ! (i,j,dim,n_lf_grids) integer, allocatable :: crossreference_integral_to_emep_subgrid(:, :, :) ! (i,j,dim) integer, allocatable :: crossreference_integral_to_meteo_nc_subgrid(:, :, :) ! (i,j,dim) integer, allocatable :: crossreference_target_to_integral_subgrid(:, :, :) ! (i,j,dim) integer, allocatable :: crossreference_target_to_emission_subgrid(:, :, :, :) ! (i,j,dim,n_source) integer, allocatable :: crossreference_integral_to_emission_subgrid(:, :, :, :) ! (i,j,dim,n_source) integer, allocatable :: crossreference_emission_to_emep_subgrid(:, :, :, :) ! (i,j,dim,n_source) integer, allocatable :: crossreference_emission_to_integral_subgrid(:, :, :, :) ! (i,j,dim,n_source) integer, allocatable :: crossreference_target_to_population_subgrid(:, :, :) ! (i,j,dim) integer, allocatable :: crossreference_emission_to_deposition_subgrid(:, :, :, :) ! (i,j,dim,n_source) integer, allocatable :: crossreference_emission_to_landuse_subgrid(:, :, :, :) ! (i,j,dim,n_source) integer, allocatable :: crossreference_target_to_deposition_subgrid(:, :, :) ! (i,j,dim) integer, allocatable :: crossreference_deposition_to_emep_subgrid(:, :, :) ! (i,j,dim) real :: min_link_size = 50.0 real :: min_adt = 1000.0 real :: H_meteo = 45.0 ! Height of the gridded meteo values integer :: start_month_in_annual_calculations = 1 integer :: end_month_in_annual_calculations = 12 ! Pseudo dispersion parameters real :: by(n_source_index, n_possible_subsource) real :: az(n_source_index, n_possible_subsource) real :: bz(n_source_index, n_possible_subsource) real :: sig_y_0(n_source_index, n_possible_subsource) real :: sig_z_0(n_source_index, n_possible_subsource) integer, parameter :: UTM_projection_index = 1 integer, parameter :: RDM_projection_index = 2 integer, parameter :: LCC_projection_index = 3 integer, parameter :: LL_projection_index = 4 integer, parameter :: LAEA_projection_index = 5 integer, parameter :: LTM_projection_index = 6 integer, parameter :: PS_projection_index = 7 double precision :: population_nc_projection_attributes(10) integer :: meteo_nc_projection_type = LCC_projection_index double precision :: meteo_nc_projection_attributes(10) logical :: use_alternative_LCC_projection_flag = .false. ! Filename index for files produced by uEMEP integer :: proxy_emission_file_index(n_source_index) integer :: emission_file_index(n_source_index) integer :: proxy_file_index(n_source_index) integer :: proxy_integral_file_index(n_source_index) integer :: emep_subgrid_file_index(n_source_index) integer :: emep_subgrid_nonlocal_file_index(n_source_index) integer :: emep_subgrid_local_file_index(n_source_index) integer :: emep_subgrid_frac_file_index(n_source_index) integer :: subgrid_local_file_index(n_source_index) integer :: subgrid_total_file_index(n_source_index) integer :: emep_additional_subgrid_nonlocal_file_index(n_source_index) integer :: emep_additional_subgrid_local_file_index(n_source_index) integer :: emep_subgrid_semilocal_file_index(n_source_index) integer :: subgrid_sourcetotal_inregion_file_index(n_source_index) integer :: subgrid_sourcetotal_file_index(n_source_index) ! Filename index for meteorological parameters integer :: subgrid_ugrid_file_index integer :: subgrid_vgrid_file_index integer :: subgrid_u10_file_index integer :: subgrid_v10_file_index integer :: subgrid_hmix_file_index integer :: subgrid_kz_file_index integer :: subgrid_logz0_file_index integer :: subgrid_invL_file_index integer :: subgrid_FF10_file_index integer :: subgrid_FFgrid_file_index integer :: subgrid_invFF10_file_index integer :: subgrid_invFFgrid_file_index integer :: subgrid_ustar_file_index integer :: subgrid_J_file_index integer :: subgrid_meteo_file_index integer :: subgrid_DD10_file_index integer :: subgrid_DDgrid_file_index integer :: subgrid_t2m_file_index ! Filename index for grid auto grid parameters integer :: use_subgrid_file_index(n_source_index) integer :: emep_emission_subgrid_file_index(n_source_index) character(256) :: source_file_str(n_source_nc_index) = '' real :: unit_conversion(n_source_index) = 1.0 real :: emission_factor_conversion(n_compound_nc_index, n_source_index, n_possible_subsource) = 0.0 integer :: weighting_step = 1 integer :: ref_year_EMEP = 1900 integer :: ref_year_meteo = 1970 integer :: n_receptor integer :: n_receptor_in integer, parameter :: n_receptor_max = 20000 integer :: n_valid_receptor integer :: n_valid_receptor_in real :: lon_receptor(n_receptor_max) real :: lat_receptor(n_receptor_max) real :: x_receptor(n_receptor_max) real :: y_receptor(n_receptor_max) real :: height_receptor(n_receptor_max) real :: lon_receptor_in(n_receptor_max) real :: lat_receptor_in(n_receptor_max) real :: x_receptor_in(n_receptor_max) real :: y_receptor_in(n_receptor_max) real :: height_receptor_in(n_receptor_max) integer :: i_receptor_subgrid(n_receptor_max) integer :: j_receptor_subgrid(n_receptor_max) character(256) :: name_receptor(n_receptor_max, 2) character(256) :: name_receptor_in(n_receptor_max, 2) logical :: use_receptor(n_receptor_max) = .true. integer :: valid_receptor_index(n_receptor_max) integer :: valid_receptor_inverse_index(n_receptor_max) ! Indicies for SSB building and population data integer, parameter :: dwelling_index = 1 integer, parameter :: population_index = 2 integer, parameter :: establishment_index = 3 integer, parameter :: school_index = 4 integer, parameter :: kindergaten_index = 5 integer, parameter :: home_index = 6 integer, parameter :: municipality_index = 7 integer, parameter :: RWC_heating_index = 8 integer, parameter :: n_population_index = 8 integer :: population_file_index(n_population_index) ! Is a temporary variable set when reading SSB data integer :: SSB_data_type = dwelling_index integer :: n_receptor_grid integer :: start_grid_loop_index integer :: end_grid_loop_index integer :: g_loop ! Correction output time array converting days 1900 to seconds 2000 integer(kind=4), allocatable :: time_seconds_output(:) ! Residential wood combustion variables integer :: n_RWC_grids real, allocatable :: RWC_grid_emission(:, :) real, allocatable :: RWC_grid_HDD(:, :) integer(kind=8), allocatable :: RWC_grid_id(:) integer, allocatable :: RWC_region_id(:) real, allocatable :: RWC_grid_height(:, :) real, allocatable :: DMT_EMEP_grid_nc(:, :, :) ! Scenario calculator variables real :: aqi_hourly_limits(n_compound_index, 1:3) real :: aqi_daily_limits(n_compound_index, 1:3) real :: aqi_annual_limits(n_compound_index, 1:3) ! Special source allocation for no2 based on leaving out the source in the chemistry calculation real, allocatable :: comp_source_subgrid(:, :, :, :, :) real, allocatable :: comp_source_subgrid_from_in_region(:, :, :, :, :) real, allocatable :: comp_source_additional_subgrid(:, :, :, :, :) real, allocatable :: comp_source_EMEP_subgrid(:, :, :, :, :) real, allocatable :: comp_source_EMEP_additional_subgrid(:, :, :, :, :) ! Semilocal contributions to no2 and o3 based on the background NO2/NOx ratio real, allocatable :: comp_semilocal_source_subgrid_from_in_region(:, :, :, :, :) ! Set the scaling factors for the auto gridding routine integer :: use_subgrid_step_delta(0:10) integer, parameter :: outside_region_index = -1 integer, parameter :: outside_interpolation_region_index = -2 integer, parameter :: inside_region_index = 0 ! Variables for saving averages real, allocatable :: val_array_av(:, :, :) integer(8), allocatable :: time_seconds_output_av(:) integer :: counter_av = 0 ! Species variables integer, parameter :: pm10_sp_index = 1 integer, parameter :: pm25_sp_index = 2 integer, parameter :: pmco_sp_index = 3 ! pmco_sp_index is just for reading integer, parameter :: n_pmxx_sp_index = 3 integer, parameter :: sp_soa_index = 1 integer, parameter :: sp_sia_index = 2 integer, parameter :: sp_dust_index = 3 integer, parameter :: sp_seasalt_index = 4 integer, parameter :: sp_ffire_index = 5 integer, parameter :: sp_ppm_index = 6 integer, parameter :: sp_water_index = 7 integer, parameter :: sp_pm_index = 8 integer, parameter :: sp_asoa_index = 9 integer, parameter :: sp_bsoa_index = 10 integer, parameter :: n_sp_index = 10 ! Additional BBOA species used in the OP calculations integer, parameter :: sp_BBOA_index = 11 integer, parameter :: sp_BBOA_RES_index = 12 integer, parameter :: n_sp_OP_index = 12 ! These are used just for reading integer, parameter :: sp_no3_index = 13 integer, parameter :: sp_so4_index = 14 integer, parameter :: sp_nh4_index = 15 integer, parameter :: sp_dust_sah_index = 16 integer, parameter :: sp_dust_wb_index = 17 integer, parameter :: sp_ffire_bc_index = 18 integer, parameter :: sp_ffire_rem_index = 19 ! Alternative input names so the other names are reserved for otuput integer, parameter :: sp_soa_in_index = 20 integer, parameter :: sp_sia_in_index = 21 integer, parameter :: sp_dust_in_index = 22 integer, parameter :: sp_seasalt_in_index = 23 integer, parameter :: sp_ffire_in_index = 24 integer, parameter :: sp_ppm_in_index = 25 integer, parameter :: sp_water_in_index = 26 integer, parameter :: sp_pm_in_index = 27 ! Alternative input names for OP so the other names are reserved for otuput integer, parameter :: sp_POM_RES_in_index = 28 integer, parameter :: sp_EC_RES_NEW_in_index = 29 integer, parameter :: sp_EC_RES_AGE_in_index = 30 integer, parameter :: sp_REM_RES_in_index = 31 integer, parameter :: sp_FFIRE_OM_in_index = 32 integer, parameter :: sp_FFIRE_BC_in_index = 33 integer, parameter :: sp_FFIRE_REM_in_index = 34 integer, parameter :: sp_EC_RES_in_index = 35 integer, parameter :: sp_asoa_in_index = 36 integer, parameter :: sp_bsoa_in_index = 37 integer, parameter :: n_sp_all_index = 37 real, allocatable :: species_var3d_nc(:, :, :, :, :) ! (x,y,t,n_pmxx_sp_index,n_species_loop_index) real, allocatable :: species_EMEP_subgrid(:, :, :, :, :) ! (x,y,t,n_pmxx_sp_index,n_species_loop_index) integer :: species_loop_index(n_sp_all_index) integer :: n_species_loop_index = n_sp_index ! Variable length of species list, set in uEMEP_set_species_loop ! Dimension with the largest possible, including OP character(256) :: species_name_nc(n_pmxx_sp_index, n_sp_all_index) ! Deposition and land use real, allocatable :: orig_EMEP_deposition_subgrid(:, :, :, :, :) real, allocatable :: depo_var3d_nc(:, :, :, :, :) integer :: deposition_subgrid_dim(n_dim_index) real :: deposition_subgrid_min(2) real :: deposition_subgrid_max(2) integer, parameter :: vd_index = 1 integer, parameter :: drydepo_index = 2 integer, parameter :: wetdepo_index = 3 integer, parameter :: n_deposition_index = 3 real, allocatable :: deposition_subgrid(:, :, :, :, :) ! deposition_subgrid (i,j,t,n_deposition_index,n_pollutant_loop) real, allocatable :: x_deposition_subgrid(:, :) real, allocatable :: y_deposition_subgrid(:, :) real, allocatable :: lon_deposition_subgrid(:, :) real, allocatable :: lat_deposition_subgrid(:, :) real, allocatable :: xproj_deposition_subgrid(:, :) real, allocatable :: yproj_deposition_subgrid(:, :) integer :: deposition_subgrid_loop_index(2) integer :: deposition_buffer_index(2) real :: deposition_buffer_size(2) real :: wetdepo_scavanging_rate(n_compound_index) real :: drydepo_vd_default(n_compound_index) integer :: landuse_subgrid_dim(n_dim_index) real :: landuse_subgrid_min(2) real :: landuse_subgrid_max(2) ! Only x and y integer, parameter :: temp_conif_index = 1 integer, parameter :: temp_decid_index = 2 integer, parameter :: med_needle_index = 3 integer, parameter :: med_broadleaf_index = 4 integer, parameter :: temp_crop_index = 5 integer, parameter :: med_crop_index = 6 integer, parameter :: root_crop_index = 7 integer, parameter :: moorland_index = 8 integer, parameter :: grass_index = 9 integer, parameter :: medscrub_index = 10 integer, parameter :: wetlands_index = 11 integer, parameter :: tundra_index = 12 integer, parameter :: desert_index = 13 ! TODO Same as water below? integer, parameter :: water_index = 13 ! TODO Same as desert above? integer, parameter :: ice_index = 14 integer, parameter :: urban_index = 15 integer, parameter :: grid_index = 16 integer, parameter :: clc_index = 17 integer, parameter :: n_landuse_index = 17 real, allocatable :: landuse_subgrid(:, :, :) ! landuse_subgrid (i,j,n_landuse_index) Fraction of landuse type real, allocatable :: x_landuse_subgrid(:, :) real, allocatable :: y_landuse_subgrid(:, :) real, allocatable :: lon_landuse_subgrid(:, :) real, allocatable :: lat_landuse_subgrid(:, :) real, allocatable :: xproj_landuse_subgrid(:, :) real, allocatable :: yproj_landuse_subgrid(:, :) integer :: landuse_subgrid_loop_index(2) integer :: landuse_buffer_index(2) real :: landuse_buffer_size(2) character(256) :: deposition_name_nc(n_landuse_index, n_compound_nc_index) real :: depo_scale_nc(n_compound_nc_index) logical :: first_g_loop = .true. ! Define the source sector match between uEMEP and EMEP integer :: uEMEP_to_EMEP_sector(n_source_nc_index) = 0 character(2) :: uEMEP_to_EMEP_sector_str(n_source_nc_index) = '' character(2) :: uEMEP_to_EMEP_emis_sector_str(n_source_nc_index) = '' ! Define the aggregation period for EMEP emissions when these are to be used in calculations. Annual is 365*24=8760 or 8784 for leap years integer :: population_nc_projection_type = LL_projection_index ! Additional multiple local fraction variables integer, parameter :: max_n_local_fraction_grids = 3 integer :: frac_nc_loop_index(max_n_local_fraction_grids) integer :: local_nc_loop_index(max_n_local_fraction_grids) integer :: lc_frac_nc_loop_index(max_n_local_fraction_grids) integer :: lc_local_nc_loop_index(max_n_local_fraction_grids) integer :: min_frac_nc_loop_index integer :: max_frac_nc_loop_index integer :: min_lc_frac_nc_loop_index integer :: max_lc_frac_nc_loop_index integer :: convert_frac_to_lc_frac_loop_index(num_var_nc_name) integer :: local_fraction_grid_for_EMEP_grid_interpolation_source(n_source_index) = 1 real :: local_fraction_grid_size_scaling = 1.0 real :: EMEP_grid_interpolation_size_original = 1.0 real :: EMEP_grid_interpolation_size_source(n_source_index) = 1.0 real :: local_fraction_additional_grid_size_scaling = 1.0 real :: EMEP_additional_grid_interpolation_size_original = 0.0 character(256) :: finished_file = '' character(256) :: finished_file_rec = '' ! Landuse proxy integer, parameter :: n_clc_landuse_index = 44 ! Benzene split from VOC logical :: extract_benzene_from_voc_emissions = .false. real :: benzene_split_voc_in_GNFR_sectors(13) = & [0.0449, 0.0212, 0.0668, 0.0084, 0.0, 0.0266, 0.0226, 0.0214, 0.0223, 0.0362, 0.068, 0.0601, 0.068] ! Setting this to true is for diagnostic puroses. Gived the integrated lowest grid average concentration instead of the receptor logical :: wind_vectors_10m_available = .false. ! Arrays needed for tracking the region each grid cell belongs to ! subgrid_region_index will contain the region index of each uEMEP target subgrid (or 0 for cells not in a region) integer, allocatable :: subgrid_region_index(:, :) ! emission_subgrid_region_index will contain the region index of each uEMEP emission subgrid for each source (zero or negative number indicates ' no - region ' ) integer , allocatable :: emission_subgrid_region_index (:, :, :) ! n_regions is the number of regions occurring in the target grid. Will be set after reading region mask file integer :: n_regions = - 1 ! highest allowed value of a region index integer , parameter :: maxvalue_region_index = 1000 ! regionindex_loop_index specifies the region_index along the region dimension in arrays that have the region dimension, and will get length n_regions integer , allocatable :: regionindex_loop_index (:) ! input a region_index to get its positional index in regionindex_loop_index. If the region_index is not in the taret grid, you get 0 integer :: regionindex_loop_back_index ( maxvalue_region_index ) ! Defining an extended EMEP grid on which to define region information ! EMEP_extended_subsample_region_id will contain the region ID of each subsample of each cell of the extended EMEP grid ! number of extra EMEP grids in each direction in the extended array ! initialized to zero, but will be set higher if used integer :: ngrid_extended_margin = 0 ! dimensions of the extended EMEP grid use for region fraction arrays ! (will be set to EMEP grid dimensions + 2*ngrid_extended_margin) integer :: nx_EMEP_extended = 0 integer :: ny_EMEP_extended = 0 ! regionfraction_per_EMEP_extended_grid will give the fraction of each EMEP grid that is within each region (x,y,region) real , allocatable :: regionfraction_per_EMEP_extended_grid (:, :, :) ! Region ID of subsamples of the extended EMEP grid (xsub,ysub,x,y) integer , allocatable :: EMEP_extended_subsample_region_id (:, :, :, :) ! n_subsamples_per_EMEP_grid specifies how many subsamples to use along each spatial dimension of an EMEP grid in EMEP_extended_subsample_region_id integer :: n_subsamples_per_EMEP_grid = 20 ! The following arrays will contain the part of the downscaled contributions that are from within the same region as the receptor real , allocatable :: subgrid_proxy_from_in_region (:, :, :, :, :) real , allocatable :: subgrid_local_from_in_region (:, :, :, :, :) ! The following arrays will contain (non-overlapping) EMEP contributions from within the same region as the target subgrid is in ! The grids are defined for dimensions (x,y,time,source,pollutant) ! They can be added to find the total EMEP contribution from-in-region. ! - In-region contribution from inside the moving window (can be replaced with downscaled in-region contributions) real , allocatable :: subgrid_EMEP_local_from_in_region (:, :, :, :, :) ! - In-region contribution from outside the moving window, out to the very edge of the LF grid domain real , allocatable :: subgrid_EMEP_semilocal_from_in_region (:, :, :, :, :) end module uEMEP_definitions","tags":"","loc":"sourcefile/uemep_definitions.f90.html"},{"title":"read_esri_ascii_file.f90 – uEMEP","text":"Source Code module mod_read_esri_ascii_file use uEMEP_definitions , only : unit_logfile implicit none private public :: write_esri_ascii_file , read_esri_ascii_file , read_esri_ascii_header contains subroutine read_esri_ascii_header ( filename_ascii_sub , ncols_sub , nrows_sub , cellsize_sub , xllcorner , yllcorner , read_nodata_flag ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub real :: cellsize_sub real :: xllcorner real :: yllcorner logical :: read_nodata_flag ! Local variables real :: NODATA_value = - 99 9.0 integer :: unit_in = 20 character ( 256 ) :: temp_str open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'old' , readonly ) rewind ( unit_in ) read ( unit_in , * ) temp_str , ncols_sub read ( unit_in , * ) temp_str , nrows_sub read ( unit_in , * ) temp_str , xllcorner read ( unit_in , * ) temp_str , yllcorner read ( unit_in , * ) temp_str , cellsize_sub if ( read_nodata_flag ) read ( unit_in , * ) temp_str , NODATA_value write ( unit_logfile , '(2a10,4a12)' ) 'ncols' , 'nrows' , 'xllcorner' , 'yllcorner' , 'cellsize' , 'NODATA_val' write ( unit_logfile , '(2i10,4f12.1)' ) ncols_sub , nrows_sub , xllcorner , yllcorner , cellsize_sub , NODATA_value close ( unit_in ) end subroutine read_esri_ascii_header subroutine read_esri_ascii_file ( filename_ascii_sub , ncols_sub , nrows_sub , cellsize_sub , val_array , x_array , y_array , read_nodata_flag ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) logical :: read_nodata_flag ! Local variables character ( 256 ) :: temp_str integer :: i , j , ii , jj integer :: ncols_sub_temp , nrows_sub_temp real :: xllcorner real :: yllcorner real :: NODATA_value integer :: unit_in = 20 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'old' , readonly ) rewind ( unit_in ) read ( unit_in , * ) temp_str , ncols_sub_temp read ( unit_in , * ) temp_str , nrows_sub_temp read ( unit_in , * ) temp_str , xllcorner read ( unit_in , * ) temp_str , yllcorner read ( unit_in , * ) temp_str , cellsize_sub if ( read_nodata_flag ) read ( unit_in , * ) temp_str , NODATA_value if ( ncols_sub . ne . ncols_sub_temp . or . nrows_sub . ne . nrows_sub_temp ) then write ( unit_logfile , * ) 'ERROR: Subgrid columns or rows do not match. Columns: ' , ncols_sub , ncols_sub_temp , 'Rows: ' , nrows_sub , nrows_sub_temp stop 1 end if read ( unit_in , * ) (( val_array ( ii , jj ), ii = 1 , ncols_sub ), jj = nrows_sub , 1 , - 1 ) close ( unit_in ) ! Set position arrays do i = 1 , ncols_sub do j = 1 , nrows_sub x_array ( i , j ) = xllcorner + cellsize_sub / 2.0 + ( i - 1 ) * cellsize_sub y_array ( i , j ) = yllcorner + cellsize_sub / 2.0 + ( j - 1 ) * cellsize_sub end do end do end subroutine read_esri_ascii_file subroutine write_esri_ascii_file ( filename_ascii_sub , ncols_sub , nrows_sub , cellsize_sub , val_array , x_array , y_array ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) ! Local variables integer :: ii , jj real :: xllcorner real :: yllcorner real :: NODATA_value = - 99 9.0 integer :: unit_in = 20 character ( len = :), allocatable :: fmt xllcorner = x_array ( 1 , 1 ) - cellsize_sub / 2.0 yllcorner = y_array ( 1 , 1 ) - cellsize_sub / 2.0 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'unknown' ) write ( unit_in , * ) 'ncols' , ncols_sub write ( unit_in , * ) 'nrows' , nrows_sub write ( unit_in , * ) 'xllcorner' , xllcorner write ( unit_in , * ) 'yllcorner' , yllcorner write ( unit_in , * ) 'cellsize' , cellsize_sub write ( unit_in , * ) 'NODATA_value' , NODATA_value do jj = nrows_sub , 1 , - 1 write ( fmt , '(A,I0,A)' ) '(' , ncols_sub , 'es12.3)' write ( unit_in , fmt ) ( val_array ( ii , jj ), ii = 1 , ncols_sub ) end do close ( unit_in ) end subroutine write_esri_ascii_file subroutine read_esri_ascii_3d_file ( filename_ascii_sub , ncols_sub , nrows_sub , nblocks_sub , cellsize_sub , val_array , x_array , y_array ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub , nblocks_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub , nblocks_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) ! Local variables character ( 256 ) :: temp_str integer :: i , j , ii , jj , tt integer :: ncols_sub_temp , nrows_sub_temp , nblocks_sub_temp real :: nrows_sub_temp_real real :: xllcorner real :: yllcorner real :: NODATA_value integer :: unit_in = 20 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'old' , readonly ) rewind ( unit_in ) read ( unit_in , * ) temp_str , ncols_sub_temp read ( unit_in , * ) temp_str , nrows_sub_temp read ( unit_in , * ) temp_str , nrows_sub_temp_real if ( temp_str . eq . 'xllcorner' ) then nblocks_sub_temp = 1 xllcorner = nrows_sub_temp_real else nrows_sub_temp = int ( nrows_sub_temp_real ) read ( unit_in , * ) temp_str , xllcorner end if read ( unit_in , * ) temp_str , yllcorner read ( unit_in , * ) temp_str , cellsize_sub read ( unit_in , * ) temp_str , NODATA_value if ( ncols_sub . ne . ncols_sub_temp . or . nrows_sub . ne . nrows_sub_temp . or . nblocks_sub . ne . nblocks_sub_temp ) then write ( unit_logfile , '(A,2I,A,2I,A,2I)' ) 'ERROR: Subgrid columns or rows do not match. Columns: ' , ncols_sub , ncols_sub_temp , '  Rows: ' , nrows_sub , nrows_sub_temp , '  Blocks: ' , nblocks_sub , nblocks_sub_temp stop 1 end if read ( unit_in , * ) ((( val_array ( ii , jj , tt ), ii = 1 , ncols_sub ), jj = nrows_sub , 1 , - 1 ), tt = 1 , nblocks_sub ) close ( unit_in ) ! Set position arrays do i = 1 , ncols_sub do j = 1 , nrows_sub x_array ( i , j ) = xllcorner + cellsize_sub / 2.0 + ( i - 1 ) * cellsize_sub y_array ( i , j ) = yllcorner + cellsize_sub / 2.0 + ( j - 1 ) * cellsize_sub end do end do end subroutine read_esri_ascii_3d_file subroutine write_esri_ascii_3d_file ( filename_ascii_sub , ncols_sub , nrows_sub , nblocks_sub , cellsize_sub , val_array , x_array , y_array ) character ( * ) :: filename_ascii_sub integer :: ncols_sub , nrows_sub , nblocks_sub real :: cellsize_sub real :: val_array ( ncols_sub , nrows_sub , nblocks_sub ) real :: x_array ( ncols_sub , nrows_sub ) real :: y_array ( ncols_sub , nrows_sub ) ! Local variables integer :: ii , jj , tt real :: xllcorner real :: yllcorner real :: NODATA_value = - 99 9.0 integer :: unit_in = 20 character ( len = :), allocatable :: fmt xllcorner = x_array ( 1 , 1 ) - cellsize_sub / 2.0 yllcorner = y_array ( 1 , 1 ) - cellsize_sub / 2.0 open ( unit_in , file = filename_ascii_sub , access = 'sequential' , form = 'formatted' , status = 'unknown' ) write ( unit_in , * ) 'ncols' , ncols_sub write ( unit_in , * ) 'nrows' , nrows_sub if ( nblocks_sub . gt . 1 ) write ( unit_in , * ) 'nblocks' , nblocks_sub write ( unit_in , * ) 'xllcorner' , xllcorner write ( unit_in , * ) 'yllcorner' , yllcorner write ( unit_in , * ) 'cellsize' , cellsize_sub write ( unit_in , * ) 'NODATA_val' , NODATA_value do tt = 1 , nblocks_sub do jj = nrows_sub , 1 , - 1 write ( fmt , '(A,I0,A)' ) '(' , ncols_sub , 'es12.3)' write ( unit_in , fmt ) ( val_array ( ii , jj , tt ), ii = 1 , ncols_sub ) end do end do close ( unit_in ) end subroutine write_esri_ascii_3d_file end module mod_read_esri_ascii_file","tags":"","loc":"sourcefile/read_esri_ascii_file.f90.html"},{"title":"uEMEP_grid_roads.f90 – uEMEP","text":"Source Code module grid_roads use uemep_configuration use mod_lambert_projection , only : PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: uEMEP_grid_roads contains !========================================================================== !   NORTRIP_grid_roads.f90 !   Places line source proxy emissions in the traffic subgrid !========================================================================== subroutine uEMEP_grid_roads use uEMEP_definitions implicit none integer i , j integer ro real , allocatable :: f_subgrid (:) real , allocatable :: adt_temp (:,:) real , allocatable :: adt_car_temp (:) real , allocatable :: adt_truck_temp (:) real x_subgrid_in ( 2 ), y_subgrid_in ( 2 ) real x_line_in ( 2 ), y_line_in ( 2 ), lat_line_in ( 2 ), lon_line_in ( 2 ) integer i_traffic_index ( 2 ), j_traffic_index ( 2 ) integer i_start , i_end , j_start , j_end integer source_index , t integer i_roadlink_emission_compound ( n_pollutant_loop ) integer tt , ttt integer major_ro integer t_start_temp , t_end_temp real tunnel_ratio real sigma0_temp integer i_pollutant write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Gridding road link proxy data (uEMEP_grid_roads)' write ( unit_logfile , '(A)' ) '================================================================' allocate ( f_subgrid ( n_roadlinks )) allocate ( adt_temp ( n_roadlinks , n_pollutant_loop )) allocate ( adt_car_temp ( n_roadlinks )) allocate ( adt_truck_temp ( n_roadlinks )) !allocate (traffic_emission_subgrid(subgrid_dim(1),subgrid_dim(2)),n_emission_subgrid_index) source_index = traffic_index t = 1 proxy_emission_subgrid (:,:, source_index ,:) = 0. if ( use_traffic_for_sigma0_flag ) then emission_properties_subgrid (:,:, emission_sigy00_index , source_index ) = 0. emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) = 0. endif !Possible to split the traffic source into different subsources at this point if necessary, e.g. light and heavy traffic !Here we weight the adt by the emission ratio and give an emission factor valid for cars adt_car_temp = inputdata_rl ( 1 : n_roadlinks , adt_rl_index ) * ( 1. - inputdata_rl ( 1 : n_roadlinks , hdv_rl_index ) / 10 0. ) adt_truck_temp = inputdata_rl ( 1 : n_roadlinks , adt_rl_index ) * inputdata_rl ( 1 : n_roadlinks , hdv_rl_index ) / 10 0. do i_pollutant = 1 , n_pollutant_loop adt_temp (:, i_pollutant ) = adt_car_temp + adt_truck_temp * ratio_truck_car_emission ( pollutant_loop_index ( i_pollutant )) enddo !Calculate the pseudo traffic emissions in each grid write ( unit_logfile , * ) 'Gridding traffic emission proxy data' !Convert from uEMEP to NORTRIP if ( use_NORTRIP_emission_data ) then !This links the order of the NORTRIP output to the pollutants !Order is: pm10,pm2.5,pmex,nox,pm10_sand/salt,pm2.5_sand/salt,pm10_salt,pm2.5_salt do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ). eq . pm10_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 1 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 2 elseif ( pollutant_loop_index ( i_pollutant ). eq . pmex_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 3 elseif ( pollutant_loop_index ( i_pollutant ). eq . nox_nc_index ) then i_roadlink_emission_compound ( i_pollutant ) = 4 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm10_sand_nc_index . and .( pollutant_index . eq . all_sand_nc_index . or . pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 5 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm10_salt_nc_index . and .( pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm10_salt_nc_index . and .( pollutant_index . eq . all_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 5 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_nc_index . and .( pollutant_index . eq . all_sand_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_sand_nc_index . and .( pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 7 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_salt_nc_index . and .( pollutant_index . eq . all_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 6 elseif ( pollutant_loop_index ( i_pollutant ). eq . pm25_salt_nc_index . and .( pollutant_index . eq . all_sand_salt_nc_index )) then i_roadlink_emission_compound ( i_pollutant ) = 8 else write ( unit_logfile , '(a,2i)' ) 'STOPPING: No valid compound chosen for NORTRIP. Stopping uEMEP_grid_roads. Pollutant index=' , pollutant_index , pollutant_loop_index ( i_pollutant ) !write(*,*) n_pollutant_loop !write(*,*) pollutant_loop_index(1:n_pollutant_loop) stop endif enddo emission_subgrid (:,:,:, traffic_index ,:) = 0. !Set the time to be used based on the time loop flag if ( use_single_time_loop_flag ) then t_start_temp = t_loop t_end_temp = t_loop else t_start_temp = 1 t_end_temp = subgrid_dim ( t_dim_index ) endif endif do ro = 1 , n_roadlinks x_line_in = inputdata_rl ( ro , x1_rl_index : x2_rl_index ) y_line_in = inputdata_rl ( ro , y1_rl_index : y2_rl_index ) !Convert to EMEP coordinates from specified projection type to lambertCC or latlon. Not certain if the fraction is correctly calculated in lat lon coordinates but otherwise very complicated if ( save_emissions_for_EMEP ( traffic_index )) then do i = 1 , 2 call PROJ2LL ( x_line_in ( i ), y_line_in ( i ), lon_line_in ( i ), lat_line_in ( i ), projection_attributes , projection_type ) !call UTM2LL(utm_zone,y_line_in(i),x_line_in(i),lat_line_in(i),lon_line_in(i)) if ( EMEP_projection_type . eq . LL_projection_index ) then x_line_in ( i ) = lon_line_in ( i ) y_line_in ( i ) = lat_line_in ( i ) elseif ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_line_in ( i ), y_line_in ( i ), lon_line_in ( i ), lat_line_in ( i ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_line_in ( i ), y_line_in ( i ), lon_line_in ( i ), lat_line_in ( i ), EMEP_projection_attributes ) endif enddo !write(*,*) x_line_in(1),y_line_in(1),lon_line_in(1),lat_line_in(1) endif i_traffic_index = 1 + floor (( x_line_in - emission_subgrid_min ( x_dim_index , source_index )) / emission_subgrid_delta ( x_dim_index , source_index )) j_traffic_index = 1 + floor (( y_line_in - emission_subgrid_min ( y_dim_index , source_index )) / emission_subgrid_delta ( y_dim_index , source_index )) if (( i_traffic_index ( 1 ). ge . 1. or . i_traffic_index ( 2 ). ge . 1 ). and .( j_traffic_index ( 1 ). ge . 1. or . j_traffic_index ( 2 ). ge . 1 ). and . & ( i_traffic_index ( 1 ). le . emission_subgrid_dim ( x_dim_index , source_index ). or . i_traffic_index ( 2 ). le . emission_subgrid_dim ( x_dim_index , source_index )). and . & ( j_traffic_index ( 1 ). le . emission_subgrid_dim ( y_dim_index , source_index ). or . j_traffic_index ( 2 ). le . emission_subgrid_dim ( y_dim_index , source_index ))) then !write(*,*) ro,i_traffic_index,j_traffic_index !Limit the loop if it is near the edge i_start = max ( 1 , minval ( i_traffic_index )) i_end = min ( emission_subgrid_dim ( x_dim_index , source_index ), maxval ( i_traffic_index )) j_start = max ( 1 , minval ( j_traffic_index )) j_end = min ( emission_subgrid_dim ( y_dim_index , source_index ), maxval ( j_traffic_index )) !if (i_end-i_start.gt.2.or.j_end-j_start.gt.2) write(*,*) ro,i_start,i_end,j_start,j_end do j = j_start , j_end do i = i_start , i_end x_subgrid_in ( 1 ) = x_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( x_dim_index , source_index ) / 2. x_subgrid_in ( 2 ) = x_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( x_dim_index , source_index ) / 2. y_subgrid_in ( 1 ) = y_emission_subgrid ( i , j , source_index ) - emission_subgrid_delta ( y_dim_index , source_index ) / 2. y_subgrid_in ( 2 ) = y_emission_subgrid ( i , j , source_index ) + emission_subgrid_delta ( y_dim_index , source_index ) / 2. f_subgrid ( ro ) = line_fraction_in_grid_func ( x_subgrid_in , y_subgrid_in , x_line_in , y_line_in ) !do subsource_index=1,n_subsource(source_index) proxy_emission_subgrid ( i , j , source_index ,:) = proxy_emission_subgrid ( i , j , source_index ,:) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * adt_temp ( ro ,:) !Put the temporally changing emissions straight into the emission subgrid !Will not be overwritten in uEMEP_convert_proxy_to_emissions if use_NORTRIP_emission_data=true if ( use_NORTRIP_emission_data ) then major_ro = inputdata_int_rl ( ro , major_index_rl_index ) do tt = t_start_temp , t_end_temp !Convert from g/km/hour to ug/s/subgrid if ( use_single_time_loop_flag ) then ttt = t_loop t = 1 else t = tt ttt = tt endif !write(*,*) 'ro,major_ro,tt,t,ttt',ro,major_ro,tt,t,ttt !write(*,*) 'emission_grid',shape(emission_subgrid) !write(*,*) 'inputdata_rl_emissions',shape(inputdata_rl_emissions) !if (t_loop.eq.2) stop do i_pollutant = 1 , n_pollutant_loop !write(*,*) i_pollutant,major_ro,inputdata_rl(major_ro,tunnel_length_rl_index) if ( use_tunnel_deposition_flag . and . inputdata_rl ( ro , tunnel_length_rl_index ). gt . 0 ) then call tunnel_deposition_factor ( pollutant_loop_index ( i_pollutant ), inputdata_rl ( ro , tunnel_length_rl_index ) & , inputdata_rl ( ro , ADT_rl_index ) * inputdata_rl ( ro , length_rl_index ) / inputdata_rl ( ro , tunnel_length_rl_index ) & , ventilation_factor , min_ADT_ventilation_factor , min_length_ventilation_factor , windspeed_tunnel , tunnel_ratio ) else tunnel_ratio = 1. endif !Turn off tunnel emissions if required if (. not . use_tunnel_emissions_flag . and . inputdata_rl ( ro , tunnel_length_rl_index ). gt . 0 ) then tunnel_ratio = 0 endif !Converts from g/km/hr (NORTRIP) to ug/sec (uEMEP) emission_subgrid ( i , j , t , source_index , i_pollutant ) = emission_subgrid ( i , j , t , source_index , i_pollutant ) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * inputdata_rl_emissions ( major_ro , ttt , i_roadlink_emission_compound ( i_pollutant )) & * 1.e6 / 1.e3 / 360 0. * tunnel_ratio enddo !write(*,*) i,j, emission_subgrid(i,j,t,source_index,pollutant_loop_back_index(pm10_nc_index)),emission_subgrid(i,j,t,source_index,pollutant_loop_back_index(pm25_nc_index)) enddo endif !Set the sigma values according to traffic speed and road width using proxy weighting if ( use_traffic_for_sigma0_flag . and .. not . save_emissions_for_EMEP ( traffic_index )) then sigma0_temp = sigma0_traffic_func ( inputdata_rl ( ro , speed_rl_index )) if ( inputdata_rl ( ro , tunnel_length_rl_index ). gt . 5 0. ) sigma0_temp = tunnel_sig_z_00 emission_properties_subgrid ( i , j , emission_sigy00_index , source_index ) = emission_properties_subgrid ( i , j , emission_sigy00_index , source_index ) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * adt_temp ( ro , 1 ) * sqrt (( inputdata_rl ( ro , width_rl_index ) / 2. ) ** 2 + sigma0_temp ** 2 ) emission_properties_subgrid ( i , j , emission_sigz00_index , source_index ) = emission_properties_subgrid ( i , j , emission_sigz00_index , source_index ) & + inputdata_rl ( ro , length_rl_index ) * f_subgrid ( ro ) * adt_temp ( ro , 1 ) * sigma0_temp endif !enddo !write(*,*) ro,i,j,f_subgrid(ro) !write(*,*) ro,f_subgrid(ro),traffic_emission_subgrid(i,j,x_emission_subgrid_index),traffic_emission_subgrid(i,j,y_emission_subgrid_index),x_line_in,y_line_in enddo enddo !write(*,*) 'Gridding traffic emission',ro,' of ',n_roadlinks endif !if (mod(ro,10000).eq.0) write(*,*) 'Gridding traffic emission',ro,' of ',n_roadlinks enddo !Set the road properties based on ADT weighting if ( use_traffic_for_sigma0_flag ) then emission_properties_subgrid (:,:, emission_sigy00_index , source_index ) = emission_properties_subgrid (:,:, emission_sigy00_index , source_index ) / proxy_emission_subgrid (:,:, source_index , 1 ) emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) = emission_properties_subgrid (:,:, emission_sigz00_index , source_index ) / proxy_emission_subgrid (:,:, source_index , 1 ) endif deallocate ( f_subgrid ) deallocate ( adt_temp ) deallocate ( adt_car_temp ) deallocate ( adt_truck_temp ) !Deallocate road link arrays after gridding but not when the external time step is used !and not when the multiple receptor grids are used !and not when the auto subgridding is used !because gridding roads is called again if ( use_single_time_loop_flag . or . use_multiple_receptor_grids_flag . or . use_emission_positions_for_auto_subgrid_flag ( allsource_index )) then !Do not deallocate because they will be used again else if ( allocated ( inputdata_rl )) deallocate ( inputdata_rl ) if ( allocated ( inputdata_int_rl )) deallocate ( inputdata_int_rl ) if ( allocated ( inputdata_rl_emissions )) deallocate ( inputdata_rl_emissions ) endif end subroutine uEMEP_grid_roads !========================================================================== !   uEMEP model tunnel_deposition_factor !========================================================================== subroutine tunnel_deposition_factor ( tunnel_pollutant_index , tunnel_length , tunnel_ADT , ventilation_fac , min_ADT_ventilation_fac , min_length_ventilation_fac , windspeed_tunnel_in , ratio ) use uEMEP_definitions implicit none integer , intent ( in ) :: tunnel_pollutant_index real , intent ( in ) :: tunnel_length , tunnel_ADT real , intent ( in ) :: ventilation_fac , min_ADT_ventilation_fac , min_length_ventilation_fac real , intent ( in ) :: windspeed_tunnel_in !(m/s) real :: dep_velocity !(cm/s) real :: radius_tunnel = 5. !Radius of the tunnel opening. Fixed real :: B real , intent ( out ) :: ratio dep_velocity = 0. if ( tunnel_pollutant_index . eq . pm10_index ) dep_velocity = 0.1 if ( tunnel_pollutant_index . eq . pm25_index ) dep_velocity = 0.05 if ( tunnel_pollutant_index . eq . pmex_index ) dep_velocity = 0.05 if ( tunnel_pollutant_index . eq . nox_index ) dep_velocity = 0.02 B = 2. / radius_tunnel * dep_velocity / 10 0. / max ( windspeed_tunnel_in , 0.1 ) ratio = 1. if ( B * tunnel_length . lt . 1e-5 ) then ratio = 1 - B * tunnel_length / 2. else ratio = 1 / B * ( 1 - exp ( - B * tunnel_length )) / tunnel_length endif !Adjust for ventilation if ( tunnel_ADT . gt . min_ADT_ventilation_fac . and . tunnel_length . gt . min_length_ventilation_fac ) then !write(*,*) min_ADT_ventilation_fac,min_length_ventilation_fac,ratio,B ratio = ratio * ventilation_fac !write(*,*) tunnel_ADT,tunnel_length,ratio,ventilation_fac endif !write(*,*) tunnel_pollutant_index,tunnel_length,ratio end subroutine tunnel_deposition_factor function sigma0_traffic_func ( speed ) implicit none real :: speed real :: sigma0_traffic_func real :: min_sigma = 0.5 real :: max_sigma = 3. real :: min_speed = 4 0. real :: max_speed = 10 0. real :: gradient gradient = ( max_sigma - min_sigma ) / ( max_speed - min_speed ) sigma0_traffic_func = min ( max ( min_sigma + ( speed - min_speed ) * gradient , min_sigma ), max_sigma ) end function sigma0_traffic_func function minFF_traffic_func ( speed ) implicit none real :: speed real :: minFF_traffic_func real :: min_FF = 0.0 real :: max_FF = 2. real :: min_speed = 4 0. real :: max_speed = 10 0. real :: gradient ! gradient=(max_FF-min_FF)/((max_speed-min_speed)*100000./25.) ! minFF_traffic_func=min(max(speed*adt/width*gradient,min_FF),max_FF) gradient = ( max_FF - min_FF ) / (( max_speed - min_speed )) minFF_traffic_func = min ( max ( speed * gradient , min_FF ), max_FF ) end function minFF_traffic_func !========================================================================== !   NORTRIP model line_fraction_in_grid_func !========================================================================== function line_fraction_in_grid_func ( x_grid , y_grid , x_line , y_line ) implicit none !real, intent(in) :: x_grid_in(2),y_grid_in(2),x_line_in(2),y_line_in(2) real :: line_fraction_in_grid_func real :: x_grid ( 2 ), y_grid ( 2 ), x_line ( 2 ), y_line ( 2 ) real :: x_int ( 2 ), y_int ( 2 ) real :: length_line , length_int real :: dx , dy real :: x_temp , y_temp integer node , anti_node integer node_x_grid , node_y_grid integer :: n_intersection !Set to local variables !x_grid=x_grid_in !y_grid=y_grid_in !x_line=x_line_in !y_line=y_line_in !Set the initial fraction line_fraction_in_grid_func = 0. !return !Check first for lines that cannot have an intersection. Will return 0 if ( x_line ( 1 ). lt . x_grid ( 1 ). and . x_line ( 2 ). lt . x_grid ( 1 )) return if ( x_line ( 1 ). ge . x_grid ( 2 ). and . x_line ( 2 ). ge . x_grid ( 2 )) return if ( y_line ( 1 ). lt . y_grid ( 1 ). and . y_line ( 2 ). lt . y_grid ( 1 )) return if ( y_line ( 1 ). ge . y_grid ( 2 ). and . y_line ( 2 ). ge . y_grid ( 2 )) return !if ((x_line(1).lt.x_grid(1).and.x_line(2).lt.x_grid(1)).or.(x_line(1).ge.x_grid(2).and.x_line(2).ge.x_grid(2)).or.(y_line(1).lt.y_grid(1).and.y_line(2).lt.y_grid(1)).or.(y_line(1).ge.y_grid(2).and.y_line(2).ge.y_grid(2))) return !Set length of road link length_line = sqrt (( x_line ( 1 ) - x_line ( 2 )) ** 2 + ( y_line ( 1 ) - y_line ( 2 )) ** 2 ) !Set the initial intercepts x_int ( 1 : 2 ) = x_line y_int ( 1 : 2 ) = y_line !write(*,*) x_grid(:),y_grid(:),x_line(:),y_line(:),length_line if ( length_line . eq . 0 ) return dx = MAXVAL ( x_grid ) - MINVAL ( x_grid ) dy = MAXVAL ( y_grid ) - MINVAL ( y_grid ) !Check for lines that are completely inside the grid if ( x_line ( 1 ). ge . x_grid ( 1 ). and . x_line ( 2 ). ge . x_grid ( 1 ) & . and . x_line ( 1 ). lt . x_grid ( 2 ). and . x_line ( 2 ). lt . x_grid ( 2 ) & . and . y_line ( 1 ). ge . y_grid ( 1 ). and . y_line ( 2 ). ge . y_grid ( 1 ) & . and . y_line ( 1 ). lt . y_grid ( 2 ). and . y_line ( 2 ). lt . y_grid ( 2 )) then line_fraction_in_grid_func = 1. x_int = x_line y_int = y_line return endif !Check for lines with the one of the nodes within do node = 1 , 2 if ( node . eq . 1 ) anti_node = 2 if ( node . eq . 2 ) anti_node = 1 if ( x_line ( node ). ge . x_grid ( 1 ). and . x_line ( node ). lt . x_grid ( 2 ) & . and . y_line ( node ). ge . y_grid ( 1 ). and . y_line ( node ). lt . y_grid ( 2 )) then !This node is in the grid !write(*,*) 'One node in grid' !Shift parallel and equal lines when they are on the grid edge if ( x_line ( node ). eq . x_line ( anti_node ). and . x_line ( node ). eq . x_grid ( 1 )) then x_line = x_line + dx * 1e-6 endif if ( y_line ( node ). eq . y_line ( anti_node ). and . y_line ( node ). eq . y_grid ( 1 )) then y_line = y_line + dy * 1e-6 endif !Can't intersect since it is parallel to the horizontal grid lines if ( y_line ( node ). ne . y_line ( anti_node )) then !Check intersection with the horizontal grid faces do node_y_grid = 1 , 2 x_temp = x_line ( node ) + ( y_grid ( node_y_grid ) - y_line ( node )) * ( x_line ( anti_node ) - x_line ( node )) / ( y_line ( anti_node ) - y_line ( node )) y_temp = y_grid ( node_y_grid ) !write(*,*) node,x_line(node),y_line(node),x_temp,y_temp,MINVAL(y_line),MAXVAL(y_line) if ( y_temp . ge . MINVAL ( y_line ). and . y_temp . le . MAXVAL ( y_line ). and . y_temp . ne . y_line ( node ). and . x_temp . ge . MINVAL ( x_grid ). and . x_temp . le . MAXVAL ( x_grid )) then y_int ( anti_node ) = y_grid ( node_y_grid ) x_int ( anti_node ) = x_temp x_int ( node ) = x_line ( node ) y_int ( node ) = y_line ( node ) length_int = sqrt (( x_int ( node ) - x_int ( anti_node )) ** 2 + ( y_int ( node ) - y_int ( anti_node )) ** 2 ) line_fraction_in_grid_func = length_int / length_line return endif enddo endif !Can't intersect since it is parallel with the vertical grid lines if ( x_line ( node ). ne . x_line ( anti_node )) then !Check intersection with the vertical grid faces do node_x_grid = 1 , 2 y_temp = y_line ( node ) + ( x_grid ( node_x_grid ) - x_line ( node )) * ( y_line ( anti_node ) - y_line ( node )) / ( x_line ( anti_node ) - x_line ( node )) x_temp = x_grid ( node_x_grid ) !write(*,*) node,x_line(node),y_line(node),x_temp,y_temp,MINVAL(x_line),MAXVAL(x_line) if ( x_temp . ge . MINVAL ( x_line ). and . x_temp . le . MAXVAL ( x_line ). and . x_temp . ne . x_line ( node ). and . y_temp . ge . MINVAL ( y_grid ). and . y_temp . le . MAXVAL ( y_grid )) then x_int ( anti_node ) = x_grid ( node_x_grid ) y_int ( anti_node ) = y_temp y_int ( node ) = y_line ( node ) x_int ( node ) = x_line ( node ) length_int = sqrt (( x_int ( node ) - x_int ( anti_node )) ** 2 + ( y_int ( node ) - y_int ( anti_node )) ** 2 ) line_fraction_in_grid_func = length_int / length_line return endif enddo endif endif enddo !node !Only posibility left is that both nodes are outside the grid !Find 2 intersections then n_intersection = 0 node = 1 anti_node = 2 if ( y_line ( node ). ne . y_line ( anti_node )) then !Can't intersect since it is parallel do node_y_grid = 1 , 2 !Check intersection with the horizontal grid faces x_temp = x_line ( node ) + ( y_grid ( node_y_grid ) - y_line ( node )) * ( x_line ( anti_node ) - x_line ( node )) / ( y_line ( anti_node ) - y_line ( node )) y_temp = y_grid ( node_y_grid ) if ( y_temp . ge . MINVAL ( y_line ). and . y_temp . le . MAXVAL ( y_line ). and . x_temp . ge . MINVAL ( x_grid ). and . x_temp . le . MAXVAL ( x_grid ). and . n_intersection . lt . 2 ) then n_intersection = n_intersection + 1 y_int ( n_intersection ) = y_temp x_int ( n_intersection ) = x_temp endif enddo endif if ( x_line ( node ). ne . x_line ( anti_node )) then !Can't intersect since it is parallel do node_x_grid = 1 , 2 y_temp = y_line ( node ) + ( x_grid ( node_x_grid ) - x_line ( node )) * ( y_line ( anti_node ) - y_line ( node )) / ( x_line ( anti_node ) - x_line ( node )) x_temp = x_grid ( node_x_grid ) !Use y_temp.lt.MAXVAL(y_grid) incase it is in one of the corners if ( x_temp . ge . MINVAL ( x_line ). and . x_temp . le . MAXVAL ( x_line ). and . y_temp . ge . MINVAL ( y_grid ). and . y_temp . lt . MAXVAL ( y_grid ). and . n_intersection . lt . 2 ) then n_intersection = n_intersection + 1 x_int ( n_intersection ) = x_temp y_int ( n_intersection ) = y_temp endif enddo endif if ( n_intersection . eq . 2 ) then length_int = sqrt (( x_int ( node ) - x_int ( anti_node )) ** 2 + ( y_int ( node ) - y_int ( anti_node )) ** 2 ) line_fraction_in_grid_func = length_int / length_line endif end function line_fraction_in_grid_func !========================================================================== !   NORTRIP model save_gridded_lines_test_routine !   THis routine used only for testing of gridding for line source !   Not used in modelling !========================================================================== subroutine save_gridded_lines_test_routine use uEMEP_definitions implicit none real :: x_grid ( 10 , 2 ), y_grid ( 10 , 2 ), x_line ( 50 , 2 ), y_line ( 50 , 2 ) real :: line ( 50 , 4 ), length_line ( 50 ) integer n_grid , n_line integer l , g real :: f ( 50 ) n_grid = 2 x_grid ( 1 ,:) = ( /- 1 , 1 / ) y_grid ( 1 ,:) = ( /- 1 , 1 / ) x_grid ( 2 ,:) = ( / 1 , 3 / ) y_grid ( 2 ,:) = ( / 1 , 3 / ) line ( 1 ,:) = ( / . 5 ,. 5 , 1. , 2. / ) !x1,y1,x2,y2 line ( 2 ,:) = ( / . 5 , 0. , - 2. , - 0. / ) !x1,y1,x2,y2 line ( 3 ,:) = ( / 0. , - 0.2 , - 0. , - 2. / ) !x1,y1,x2,y2 line ( 4 ,:) = ( / 2. , 3. , 0.5 , 2. / ) !x1,y1,x2,y2 line ( 5 ,:) = ( /- 2. , - 3. , 1.5 , 1.5 / ) !x1,y1,x2,y2 line ( 6 ,:) = ( / . 7 , - . 9 ,. 2 ,. 7 / ) !x1,y1,x2,y2 line ( 7 ,:) = ( /- 1. , - 3. , - 1. , + 1. / ) !x1,y1,x2,y2 line ( 8 ,:) = ( /- . 5 , - 1. , 3. , - 1. / ) !x1,y1,x2,y2 line ( 9 ,:) = ( /- . 5 , 1. , 3. , 1. / ) !x1,y1,x2,y2 line ( 10 ,:) = ( / 1. , - 3. , 1. , + 0. / ) !x1,y1,x2,y2 line ( 11 ,:) = ( /- . 7 , - 3. , - . 7 , + 2. / ) !x1,y1,x2,y2 line ( 12 ,:) = ( / . 5 , 1.5 , 1.5 ,. 6 / ) !x1,y1,x2,y2 line ( 13 ,:) = ( /- 1. , 1. , 1. , - 1. / ) !x1,y1,x2,y2 line ( 14 ,:) = ( /- 1. , - 1. , 1. , 1. / ) !x1,y1,x2,y2 line ( 15 ,:) = ( /- 1. , 1. , 1. , 1. / ) !x1,y1,x2,y2 line ( 16 ,:) = ( /- 1.5 ,. 3 , 1.5 ,. 3 / ) !x1,y1,x2,y2 line ( 17 ,:) = ( /- 3. , 2. , 1.5 , - 3. / ) !x1,y1,x2,y2 line ( 18 ,:) = ( /- 3. , - 2. , 1. , 1. / ) !x1,y1,x2,y2 line ( 19 ,:) = ( /+ 3. , - 2. , - 1. , 1. / ) !x1,y1,x2,y2 line ( 20 ,:) = ( /- 3. , 0. , 1. , - 1. / ) !x1,y1,x2,y2 n_line = 20 write ( * , * ) 'input data' g = 1 do l = 1 , n_line x_line ( l , 1 ) = line ( l , 1 ) x_line ( l , 2 ) = line ( l , 3 ) y_line ( l , 1 ) = line ( l , 2 ) y_line ( l , 2 ) = line ( l , 4 ) length_line ( l ) = sqrt (( x_line ( l , 1 ) - x_line ( l , 2 )) ** 2 + ( y_line ( l , 1 ) - y_line ( l , 2 )) ** 2 ) !write(*,*) g,l,x_grid(g,:),y_grid(g,:),x_line(l,:),y_line(l,:),length_line(l) enddo write ( * , * ) 'starting gridding' do g = 1 , n_grid do l = 1 , n_line f ( l ) = line_fraction_in_grid_func ( x_grid ( g ,:), y_grid ( g ,:), x_line ( l ,:), y_line ( l ,:)) write ( * , * ) g , l , f ( l ) enddo enddo stop end subroutine save_gridded_lines_test_routine end module grid_roads","tags":"","loc":"sourcefile/uemep_grid_roads.f90.html"},{"title":"uEMEP_read_landuse_rivm_data.f90 – uEMEP","text":"Source Code module read_landuse_rivm_data use uemep_configuration use uEMEP_definitions use crossreference_grids , only : uEMEP_crossreference_grids use mod_read_esri_ascii_file , only : read_esri_ascii_file , read_esri_ascii_header use mod_lambert_projection , only : PROJ2LL , lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: uEMEP_read_landuse_rivm_data , uEMEP_set_landuse_classes , & uEMEP_read_netcdf_landuse_latlon integer Continuous_urban_fabric_value , Discontinuous_urban_fabric_value , Industrial_or_commercial_units_value , Road_and_rail_networks_and_associated_land_value , Port_areas_value integer Airports_value , Mineral_extraction_sites_value , Dump_sites_value , Construction_sites_value , Green_urban_areas_value integer Sport_and_leisure_facilities_value , Non_irrigated_arable_land_value , Permanently_irrigated_land_value , Rice_fields_value , Vineyards_value integer Fruit_trees_and_berry_plantations_value , Olive_groves_value , Pastures_value , Annual_crops_associated_with_permanent_crops_value , Complex_cultivation_patterns_value integer Land_principally_occupied_by_agriculture_value , Agro_forestry_areas_value , Broad_leaved_forest_value , Coniferous_forest_value , Mixed_forest_value integer Natural_grasslands_value , Moors_and_heathland_value , Sclerophyllous_vegetation_value , Transitional_woodland_shrub_value , Beaches_dunes_sands_value integer Bare_rocks_value , Sparsely_vegetated_areas_value , Burnt_areas_value , Glaciers_and_perpetual_snow_value , Inland_marshes_value integer Peat_bogs_value , Salt_marshes_value , Salines_value , Intertidal_flats_value , Water_courses_value , Water_bodies_value , Coastal_lagoons_value , Estuaries_value , Sea_and_ocean_value integer NODATA_clc_value integer n_corine_landuse_index parameter ( n_corine_landuse_index = 48 ) integer Corine_to_EMEP_landuse ( n_corine_landuse_index ) contains !uEMEP_read_landuse_rivm_data.f90 subroutine uEMEP_read_landuse_rivm_data implicit none integer i , j integer ncols_sub , nrows_sub real cellsize_sub , xll_corner_sub , yll_corner_sub real , allocatable :: landuse_array (:,:) integer depac_index ( 9 ) integer emep_landuse_index logical :: exists !landuse_subgrid=0 !landuse_subgrid(:,:,temp_decid_index)=1. pathfilename_landuse = trim ( pathname_landuse ) // trim ( filename_landuse ) inquire ( file = trim ( pathfilename_landuse ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Landuse file does not exist: ' , trim ( pathfilename_landuse ) stop endif call read_esri_ascii_header ( pathfilename_landuse , ncols_sub , nrows_sub , cellsize_sub , xll_corner_sub , yll_corner_sub ,. false .) landuse_subgrid_dim ( x_dim_index ) = ncols_sub landuse_subgrid_dim ( y_dim_index ) = nrows_sub landuse_subgrid_min ( x_dim_index ) = xll_corner_sub landuse_subgrid_min ( y_dim_index ) = yll_corner_sub landuse_subgrid_delta ( x_dim_index ) = cellsize_sub landuse_subgrid_delta ( y_dim_index ) = cellsize_sub !Deallocate grids if they are already allocated. if ( allocated ( landuse_subgrid )) deallocate ( landuse_subgrid ) if ( allocated ( x_landuse_subgrid )) deallocate ( x_landuse_subgrid ) if ( allocated ( y_landuse_subgrid )) deallocate ( y_landuse_subgrid ) if ( allocated ( lon_landuse_subgrid )) deallocate ( lon_landuse_subgrid ) if ( allocated ( lat_landuse_subgrid )) deallocate ( lat_landuse_subgrid ) if ( allocated ( xproj_landuse_subgrid )) deallocate ( xproj_landuse_subgrid ) if ( allocated ( yproj_landuse_subgrid )) deallocate ( yproj_landuse_subgrid ) !Reefine landuse grid if (. not . allocated ( landuse_subgrid )) allocate ( landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ), n_landuse_index )) if (. not . allocated ( x_landuse_subgrid )) allocate ( x_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_landuse_subgrid )) allocate ( y_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_landuse_subgrid )) allocate ( lon_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_landuse_subgrid )) allocate ( lat_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_landuse_subgrid )) allocate ( xproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_landuse_subgrid )) allocate ( yproj_landuse_subgrid ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) !Set the depsoition grid to be the same dimensions as the landuse grid deposition_subgrid_dim ( x_dim_index ) = ncols_sub deposition_subgrid_dim ( y_dim_index ) = nrows_sub deposition_subgrid_min ( x_dim_index ) = xll_corner_sub deposition_subgrid_min ( y_dim_index ) = yll_corner_sub deposition_subgrid_delta ( x_dim_index ) = cellsize_sub deposition_subgrid_delta ( y_dim_index ) = cellsize_sub !Deallocate grids if they are already allocated. if ( allocated ( deposition_subgrid )) deallocate ( deposition_subgrid ) if ( allocated ( x_deposition_subgrid )) deallocate ( x_deposition_subgrid ) if ( allocated ( y_deposition_subgrid )) deallocate ( y_deposition_subgrid ) if ( allocated ( lon_deposition_subgrid )) deallocate ( lon_deposition_subgrid ) if ( allocated ( lat_deposition_subgrid )) deallocate ( lat_deposition_subgrid ) if ( allocated ( xproj_deposition_subgrid )) deallocate ( xproj_deposition_subgrid ) if ( allocated ( yproj_deposition_subgrid )) deallocate ( yproj_deposition_subgrid ) !Reefine deposition grid if (. not . allocated ( deposition_subgrid )) allocate ( deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), deposition_subgrid_dim ( t_dim_index ), n_deposition_index , n_pollutant_loop )) if (. not . allocated ( x_deposition_subgrid )) allocate ( x_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( y_deposition_subgrid )) allocate ( y_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lon_deposition_subgrid )) allocate ( lon_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( lat_deposition_subgrid )) allocate ( lat_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( xproj_deposition_subgrid )) allocate ( xproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) if (. not . allocated ( yproj_deposition_subgrid )) allocate ( yproj_deposition_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ))) do j = 1 , landuse_subgrid_dim ( y_dim_index ) do i = 1 , landuse_subgrid_dim ( x_dim_index ) x_landuse_subgrid ( i , j ) = landuse_subgrid_min ( x_dim_index ) + landuse_subgrid_delta ( x_dim_index ) * ( i - 0.5 ) y_landuse_subgrid ( i , j ) = landuse_subgrid_min ( y_dim_index ) + landuse_subgrid_delta ( y_dim_index ) * ( j - 0.5 ) !Set the lat-lon coordinates of the landuse call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), projection_attributes , projection_type ) !if (projection_type.eq.RDM_projection_index) then !    call RDM2LL(y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !elseif (projection_type.eq.UTM_projection_index) then !    call UTM2LL(utm_zone,y_landuse_subgrid(i,j),x_landuse_subgrid(i,j),lat_landuse_subgrid(i,j),lon_landuse_subgrid(i,j)) !endif !If the EMEP projection is lambert then set the proj coordinates to lambert, otherwise to lat-lon if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) elseif ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( xproj_landuse_subgrid ( i , j ), yproj_landuse_subgrid ( i , j ), lon_landuse_subgrid ( i , j ), lat_landuse_subgrid ( i , j ), EMEP_projection_attributes ) else xproj_landuse_subgrid ( i , j ) = lon_landuse_subgrid ( i , j ) yproj_landuse_subgrid ( i , j ) = lat_landuse_subgrid ( i , j ) endif enddo enddo !Set the deposition x and y to be the same x_deposition_subgrid = x_landuse_subgrid y_deposition_subgrid = y_landuse_subgrid xproj_deposition_subgrid = xproj_landuse_subgrid yproj_deposition_subgrid = yproj_landuse_subgrid lon_deposition_subgrid = lon_landuse_subgrid lat_deposition_subgrid = lat_landuse_subgrid !Recalculate the cross references again since these could have changed call uEMEP_crossreference_grids !Read the landuse index into the temporary landuse array if (. not . allocated ( landuse_array )) allocate ( landuse_array ( landuse_subgrid_dim ( x_dim_index ), landuse_subgrid_dim ( y_dim_index ))) call read_esri_ascii_file ( pathfilename_landuse , ncols_sub , nrows_sub , cellsize_sub , landuse_array , x_landuse_subgrid , y_landuse_subgrid ,. false .) !set the depac indicies to the matching EMEP ones depac_index = 0 depac_index ( 4 ) = temp_conif_index depac_index ( 5 ) = temp_decid_index depac_index ( 2 ) = temp_crop_index depac_index ( 3 ) = temp_crop_index depac_index ( 8 ) = moorland_index depac_index ( 1 ) = grass_index depac_index ( 9 ) = desert_index depac_index ( 6 ) = water_index depac_index ( 7 ) = urban_index !Distribute to the depac indexes to the EMEP ones landuse_subgrid = 0 do j = 1 , landuse_subgrid_dim ( y_dim_index ) do i = 1 , landuse_subgrid_dim ( x_dim_index ) emep_landuse_index = depac_index ( int ( landuse_array ( i , j ))) landuse_subgrid ( i , j , emep_landuse_index ) = 1. !Put the landuse index in the last array landuse_subgrid ( i , j , grid_index ) = emep_landuse_index !write(*,*) i,j,int(landuse_array(i,j)), emep_landuse_index enddo enddo if ( allocated ( landuse_array )) deallocate ( landuse_array ) end subroutine uEMEP_read_landuse_rivm_data subroutine uEMEP_read_netcdf_landuse_latlon use uEMEP_definitions use netcdf implicit none integer status_nc integer i , j integer i_dim , id_nc character ( 256 ) var_name_nc_temp , dimname_temp integer var_id_nc integer i_landuse_index , j_landuse_index real delta_landuse_nc ( num_dims_landuse_nc ) integer dim_id_nc ( num_dims_landuse_nc ) logical reduce_landuse_region_flag real temp_lon ( 4 ), temp_lat ( 4 ), temp_x ( 4 ), temp_y ( 4 ) real temp_x_min , temp_x_max , temp_y_min , temp_y_max integer i_temp_min , i_temp_max , j_temp_min , j_temp_max real temp_delta ( num_dims_landuse_nc ) real correct_lon ( 2 ) real temp_scale integer i_source , i_landuse real buffer_delta logical :: exists !Temporary reading variables real , allocatable :: landuse_nc_dp (:,:) double precision , allocatable :: var2d_nc_dp (:,:) double precision , allocatable :: temp_var2d_nc_dp (:,:) !Functions !real area_weighted_extended_vectorgrid_interpolation_function write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading landuse data (uEMEP_read_netcdf_landuse_latlon)' write ( unit_logfile , '(A)' ) '================================================================' !Set the filename pathfilename_landuse = trim ( pathname_landuse ) // trim ( filename_landuse ) !Test existence. If does not exist then stop inquire ( file = trim ( pathfilename_landuse ), exist = exists ) if (. not . exists ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Netcdf file does not exist: ' , trim ( pathfilename_landuse ) write ( unit_logfile , '(A)' ) '  STOPPING' stop endif !Open the netcdf file for reading write ( unit_logfile , '(2A)' ) ' Opening netcdf file: ' , trim ( pathfilename_landuse ) status_nc = NF90_OPEN ( pathfilename_landuse , nf90_nowrite , id_nc ) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,I)' ) 'ERROR opening netcdf file. Stopping: ' , status_nc stop endif !Find the (lon,lat) dimensions of the file. Use the meteo id's as these are x and y do i_dim = 1 , num_dims_landuse_nc status_nc = NF90_INQ_DIMID ( id_nc , dim_name_landuse_nc ( i_dim ), dim_id_nc ( i_dim )) status_nc = NF90_INQUIRE_DIMENSION ( id_nc , dim_id_nc ( i_dim ), dimname_temp , dim_length_landuse_nc ( i_dim )) if ( status_nc . NE . NF90_NOERR ) then write ( unit_logfile , '(A,A,A,I)' ) 'No dimension information available for ' , trim ( dim_name_landuse_nc ( i_dim )), ' Setting to 1 with status: ' , status_nc dim_length_landuse_nc ( i_dim ) = 1 endif enddo write ( unit_logfile , '(A,6I)' ) ' Size of landuse dimensions (lon,lat): ' , dim_length_landuse_nc !Reduce the size of the grid to the heating emission grid size reduce_landuse_region_flag = . true . if ( reduce_landuse_region_flag ) then write ( unit_logfile , '(A)' ) 'Reducing landuse domain for reading' !Determine the LL cordinates of the target grid !if (EMEP_projection_type.eq.LCC_projection_index) then !Retrieve the four corners of the target grid in lat and lon buffer_delta = 10 call PROJ2LL ( landuse_subgrid_min ( x_dim_index ) - buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_min ( y_dim_index ) - buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) call PROJ2LL ( landuse_subgrid_max ( x_dim_index ) + buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_max ( y_dim_index ) + buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( landuse_subgrid_min ( x_dim_index ) - buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_max ( y_dim_index ) + buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) call PROJ2LL ( landuse_subgrid_max ( x_dim_index ) + buffer_delta * landuse_subgrid_delta ( x_dim_index ), landuse_subgrid_min ( y_dim_index ) - buffer_delta * landuse_subgrid_delta ( y_dim_index ), temp_lon ( 4 ), temp_lat ( 4 ), projection_attributes , projection_type ) temp_x_min = 1.e32 ; temp_y_min = 1.e32 temp_x_max =- 1.e32 ; temp_y_max =- 1.e32 temp_x = temp_lon ; temp_y = temp_lat do i = 1 , 4 write ( * , * ) i , temp_x ( i ), temp_y ( i ) if ( temp_x ( i ). lt . temp_x_min ) temp_x_min = temp_x ( i ) if ( temp_y ( i ). lt . temp_y_min ) temp_y_min = temp_y ( i ) if ( temp_x ( i ). gt . temp_x_max ) temp_x_max = temp_x ( i ) if ( temp_y ( i ). gt . temp_y_max ) temp_y_max = temp_y ( i ) enddo write ( unit_logfile , '(A,2f12.2)' ) 'Min: ' , temp_x_min , temp_y_min write ( unit_logfile , '(A,2f12.2)' ) 'Max: ' , temp_x_max , temp_y_max !Read the lon and lat values to get the delta and size. Put in temporary array !Allocate the temporary arrays for lat,lon and population if (. not . allocated ( temp_var2d_nc_dp )) allocate ( temp_var2d_nc_dp ( max ( dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index )), num_dims_landuse_nc )) !x and y dim_start_landuse_nc = 1 do i = 1 , num_dims_landuse_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_landuse_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , temp_var2d_nc_dp ( 1 : dim_length_landuse_nc ( i ), i ), start = ( / dim_start_landuse_nc ( i ) / ), count = ( / dim_length_landuse_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_landuse_nc = temp_var2d_nc_dp ( 2 ,:) - temp_var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Landuse grid delta (degrees): ' , delta_landuse_nc !write(*,*) temp_var1d_nc_dp temp_delta ( 1 ) = delta_landuse_nc ( 1 ) temp_delta ( 2 ) = delta_landuse_nc ( 2 ) !write(*,*) temp_delta !Find grid position of the max and min coordinates and add2 grids*EMEP_grid_interpolation_size i_temp_min = 1 + floor (( temp_x_min - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) i_temp_max = 1 + floor (( temp_x_max - temp_var2d_nc_dp ( 1 , 1 )) / temp_delta ( 1 ) + 0.5 ) j_temp_min = 1 + floor (( temp_y_min - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) j_temp_max = 1 + floor (( temp_y_max - temp_var2d_nc_dp ( 1 , 2 )) / temp_delta ( 2 ) + 0.5 ) !write(unit_logfile,'(A,2I)') ' Reading EMEP i grids: ',i_temp_min,i_temp_max !write(unit_logfile,'(A,2I)') ' Reading EMEP j grids: ',j_temp_min,j_temp_max !Increase the region by 5 grids to be certain i_temp_min = max ( 1 , i_temp_min - 10 ) i_temp_max = min ( dim_length_landuse_nc ( x_dim_nc_index ), i_temp_max + 10 ) j_temp_min = max ( 1 , j_temp_min - 10 ) j_temp_max = min ( dim_length_landuse_nc ( y_dim_nc_index ), j_temp_max + 10 ) dim_length_landuse_nc ( x_dim_nc_index ) = i_temp_max - i_temp_min + 1 dim_length_landuse_nc ( y_dim_nc_index ) = j_temp_max - j_temp_min + 1 dim_start_landuse_nc ( x_dim_nc_index ) = i_temp_min dim_start_landuse_nc ( y_dim_nc_index ) = j_temp_min write ( unit_logfile , '(A,3I)' ) ' Reading landuse i grids: ' , i_temp_min , i_temp_max , dim_length_landuse_nc ( x_dim_nc_index ) write ( unit_logfile , '(A,3I)' ) ' Reading landuse j grids: ' , j_temp_min , j_temp_max , dim_length_landuse_nc ( y_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading landuse lon grids (min,max): ' , temp_var2d_nc_dp ( i_temp_min , x_dim_nc_index ), temp_var2d_nc_dp ( i_temp_max , x_dim_nc_index ) write ( unit_logfile , '(A,2f12.2)' ) ' Reading landuse lat grids (min,max): ' , temp_var2d_nc_dp ( j_temp_min , y_dim_nc_index ), temp_var2d_nc_dp ( j_temp_max , y_dim_nc_index ) !endif endif if ( i_temp_min . ge . i_temp_max . or . j_temp_min . ge . j_temp_max ) then !No population data available write ( unit_logfile , '(A)' ) ' WARNING: No landuse data available in this region. Setting to 0' landuse_subgrid (:,:, clc_index ) = 0 else if (. not . allocated ( landuse_nc_dp )) allocate ( landuse_nc_dp ( dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index ))) !Lat and lon if (. not . allocated ( var2d_nc_dp )) allocate ( var2d_nc_dp ( max ( dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index )), num_dims_landuse_nc )) !x and y !Read the lon and lat values to get the delta do i = 1 , num_dims_landuse_nc !Identify the variable name and ID in the nc file and read it var_name_nc_temp = dim_name_landuse_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , var2d_nc_dp ( 1 : dim_length_landuse_nc ( i ), i ), start = ( / dim_start_landuse_nc ( i ) / ), count = ( / dim_length_landuse_nc ( i ) / )) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif enddo delta_landuse_nc = var2d_nc_dp ( 2 ,:) - var2d_nc_dp ( 1 ,:) write ( unit_logfile , '(A,2f12.6)' ) 'Landuse grid delta (degrees): ' , delta_landuse_nc !write(*,*) var2d_nc_dp(1,1),var2d_nc_dp(dim_length_population_nc(x_dim_nc_index),1) !write(*,*) var2d_nc_dp(1,2),var2d_nc_dp(dim_length_population_nc(y_dim_nc_index),2) !Read the landuse data i = 1 !Uses the population_nc_index as index, =1, but not logical !Identify the variable name and ID in the nc file and read it var_name_nc_temp = var_name_landuse_nc ( i ) status_nc = NF90_INQ_VARID ( id_nc , trim ( var_name_nc_temp ), var_id_nc ) if ( status_nc . EQ . NF90_NOERR ) then !status_nc = nf90_get_att(id_nc, var_id_nc, \"units\", unit_dim_meteo_nc(i)) status_nc = NF90_GET_VAR ( id_nc , var_id_nc , landuse_nc_dp (:,:), start = ( / dim_start_landuse_nc ( x_dim_nc_index ), dim_start_landuse_nc ( y_dim_nc_index ) / ), count = ( / dim_length_landuse_nc ( x_dim_nc_index ), dim_length_landuse_nc ( y_dim_nc_index ) / )) write ( unit_logfile , '(2a,2f12.2)' ) 'Landuse variable min and max: ' , trim ( var_name_nc_temp ), minval ( landuse_nc_dp (:,:)), maxval ( landuse_nc_dp (:,:)) else write ( unit_logfile , '(A,A,A,I)' ) 'No information available for ' , trim ( var_name_nc_temp ), ' Status: ' , status_nc endif !enddo !write(*,*) 'Finished reading landuse data' !Loop through the landuse data and put it in the landuse grid !Converting from lat lon to the subgrid coordinates and then finding the nearest neighbour landuse_subgrid (:,:, clc_index ) = 0 where ( landuse_nc_dp . lt . 0 ) landuse_nc_dp = 0. write ( unit_logfile , '(2a,2f12.2)' ) 'Landuse min and max: ' , trim ( var_name_nc_temp ), minval ( landuse_nc_dp (:,:)), maxval ( landuse_nc_dp (:,:)) !stop do j = 1 , landuse_subgrid_dim ( y_dim_nc_index ) do i = 1 , landuse_subgrid_dim ( x_dim_nc_index ) !Project the centre position to lat lon call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ), temp_lon ( 1 ), temp_lat ( 1 ), projection_attributes , projection_type ) !Project both sides to get the delta call PROJ2LL ( x_landuse_subgrid ( i , j ) - landuse_subgrid_delta ( x_dim_index ) / 2. , y_landuse_subgrid ( i , j ), temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_landuse_subgrid ( i , j ) + landuse_subgrid_delta ( x_dim_index ) / 2. , y_landuse_subgrid ( i , j ), temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( x_dim_index ) = temp_lon ( 3 ) - temp_lon ( 2 ) call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ) - landuse_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 2 ), temp_lat ( 2 ), projection_attributes , projection_type ) call PROJ2LL ( x_landuse_subgrid ( i , j ), y_landuse_subgrid ( i , j ) + landuse_subgrid_delta ( y_dim_index ) / 2. , temp_lon ( 3 ), temp_lat ( 3 ), projection_attributes , projection_type ) temp_delta ( y_dim_index ) = temp_lat ( 3 ) - temp_lat ( 2 ) !Make a local correction to lon so it is essentially in the same units as lat so area averaging is correct correct_lon ( 1 ) = cos ( 3.14159 / 18 0. * temp_lat ( 1 )) correct_lon ( 2 ) = 1. !Take the nearest instead i_landuse_index = 1 + floor (( temp_lon ( 1 ) - var2d_nc_dp ( 1 , x_dim_nc_index )) / delta_landuse_nc ( 1 ) + 0.5 ) j_landuse_index = 1 + floor (( temp_lat ( 1 ) - var2d_nc_dp ( 1 , y_dim_nc_index )) / delta_landuse_nc ( 2 ) + 0.5 ) !write(*,*) i,j,temp_lon(1),temp_lat(1) landuse_subgrid ( i , j , clc_index ) = landuse_nc_dp ( i_landuse_index , j_landuse_index ) !Place the clc landuse in the EMEP landuse if ( landuse_subgrid ( i , j , clc_index ). gt . 0 ) then landuse_subgrid ( i , j , Corine_to_EMEP_landuse ( landuse_subgrid ( i , j , clc_index ))) = 1 else landuse_subgrid ( i , j , Corine_to_EMEP_landuse ( NODATA_clc_value )) = 1 endif !Do the interpolation on the same grid then scale afterwards. Equivalent to interpolating density then rescaling with grid size !landuse_subgrid(i,j,clc_index)=area_weighted_extended_vectorgrid_interpolation_function( & !    real(var2d_nc_dp(1:dim_length_landuse_nc(x_dim_nc_index),x_dim_nc_index))*correct_lon(1),real(var2d_nc_dp(1:dim_length_landuse_nc(y_dim_nc_index),y_dim_nc_index)) & !    ,landuse_nc_dp(:,:,landuse_nc_index),dim_length_landuse_nc(x_dim_nc_index),dim_length_landuse_nc(y_dim_nc_index) & !    ,delta_landuse_nc*correct_lon,temp_lon(1)*correct_lon(1),temp_lat(1),delta_landuse_nc*correct_lon) !temp_scale=(temp_delta(1)*correct_lon(1)*temp_delta(2)*correct_lon(2))/(delta_landuse_nc(1)*correct_lon(1)*delta_landuse_nc(2)*correct_lon(2)) !write(*,*) temp_scale !landuse_subgrid(i,j,clc_index)=landuse_subgrid(i,j,clc_index)*temp_scale if ( isnan ( landuse_subgrid ( i , j , clc_index ))) then write ( * , * ) 'Stopping, nan in landuse_subgrid' write ( * , * ) temp_scale , correct_lon , delta_landuse_nc , temp_delta , temp_lon stop endif if ( landuse_subgrid ( i , j , clc_index ). lt . 0. ) then write ( * , * ) 'Stopping, negative value in landuse_subgrid' write ( * , * ) temp_scale , correct_lon , delta_landuse_nc , temp_delta , temp_lon stop endif enddo enddo write ( unit_logfile , '(A,2f12.2)' ) 'Max and min landuse in read domain: ' , maxval ( landuse_nc_dp (:,:)), minval ( landuse_nc_dp (:,:)) write ( unit_logfile , '(A,2f12.2)' ) 'Max and min landuse in subgrid domain: ' , maxval ( landuse_subgrid (:,:, clc_index )), minval ( landuse_subgrid (:,:, clc_index )) if ( use_landuse_as_proxy ) then !Place the landuse as a proxy emission with the appropriate weights !loop through all sources and landuses do i_source = 1 , n_source_index !If source is to be downscaled and at least one landuse is selected then calculate the proxy emission weighting !write(*,*) i_source,calculate_source(i_source),sum(landuse_proxy_weighting(i_source,:)) if ( calculate_source ( i_source ). and . sum ( landuse_proxy_weighting ( i_source ,:)). gt . 0 ) then proxy_emission_subgrid (:,:, i_source ,:) = 0. do i_landuse = 1 , n_clc_landuse_index !write(*,*) i_source,i_landuse,landuse_proxy_weighting(i_source,i_landuse) if ( landuse_proxy_weighting ( i_source , i_landuse ). gt . 0 ) then write ( unit_logfile , '(A,i4,A,A,a,i4)' ) 'Distributing landuse index ' , i_landuse , ' to uEMEP sector \"' , trim ( source_file_str ( i_source )), '\" and GNFR sector ' , uEMEP_to_EMEP_sector ( i_source ) do j = 1 , emission_subgrid_dim ( y_dim_nc_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_nc_index , i_source ) i_landuse_index = crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ) j_landuse_index = crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ) if ( int ( landuse_subgrid ( i_landuse_index , j_landuse_index , clc_index )). eq . i_landuse ) then proxy_emission_subgrid ( i , j , i_source ,:) = proxy_emission_subgrid ( i , j , i_source ,:) + landuse_proxy_weighting ( i_source , i_landuse ) !write(*,'(6i,2f12.2)') i,j,i_landuse_index,j_landuse_index,i_source,i_landuse,landuse_proxy_weighting(i_source,i_landuse),proxy_emission_subgrid(i,j,i_source,1) endif !If there is no data (0 or greater than the maximum number of landuse categories) then distribute emissions evenly on the EMEP grid if ( int ( landuse_subgrid ( i_landuse_index , j_landuse_index , clc_index )). gt . n_clc_landuse_index . or . int ( landuse_subgrid ( i_landuse_index , j_landuse_index , clc_index )). lt . 1 ) then proxy_emission_subgrid ( i , j , i_source ,:) = 1. endif enddo enddo endif enddo endif enddo endif endif !No landuse available if ( allocated ( landuse_nc_dp )) deallocate ( landuse_nc_dp ) if ( allocated ( var2d_nc_dp )) deallocate ( var2d_nc_dp ) if ( allocated ( temp_var2d_nc_dp )) deallocate ( temp_var2d_nc_dp ) end subroutine uEMEP_read_netcdf_landuse_latlon subroutine uEMEP_set_landuse_classes use uEMEP_definitions implicit none !test !landuse_proxy_weighting(heating_index,Continuous_urban_fabric_value)=1. !landuse_proxy_weighting(heating_index,Discontinuous_urban_fabric_value)=0.5 Continuous_urban_fabric_value = 1 Discontinuous_urban_fabric_value = 2 Industrial_or_commercial_units_value = 3 Road_and_rail_networks_and_associated_land_value = 4 Port_areas_value = 5 Airports_value = 6 Mineral_extraction_sites_value = 7 Dump_sites_value = 8 Construction_sites_value = 9 Green_urban_areas_value = 10 Sport_and_leisure_facilities_value = 11 Non_irrigated_arable_land_value = 12 Permanently_irrigated_land_value = 13 Rice_fields_value = 14 Vineyards_value = 15 Fruit_trees_and_berry_plantations_value = 16 Olive_groves_value = 17 Pastures_value = 18 Annual_crops_associated_with_permanent_crops_value = 19 Complex_cultivation_patterns_value = 20 Land_principally_occupied_by_agriculture_value = 21 Agro_forestry_areas_value = 22 Broad_leaved_forest_value = 23 Coniferous_forest_value = 24 Mixed_forest_value = 25 Natural_grasslands_value = 26 Moors_and_heathland_value = 27 Sclerophyllous_vegetation_value = 28 Transitional_woodland_shrub_value = 29 Beaches_dunes_sands_value = 30 Bare_rocks_value = 31 Sparsely_vegetated_areas_value = 32 Burnt_areas_value = 33 Glaciers_and_perpetual_snow_value = 34 Inland_marshes_value = 35 Peat_bogs_value = 36 Salt_marshes_value = 37 Salines_value = 38 Intertidal_flats_value = 39 Water_courses_value = 40 Water_bodies_value = 41 Coastal_lagoons_value = 42 Estuaries_value = 43 Sea_and_ocean_value = 44 NODATA_clc_value = 48 Corine_to_EMEP_landuse ( Continuous_urban_fabric_value ) = urban_index Corine_to_EMEP_landuse ( Discontinuous_urban_fabric_value ) = urban_index Corine_to_EMEP_landuse ( Industrial_or_commercial_units_value ) = urban_index Corine_to_EMEP_landuse ( Road_and_rail_networks_and_associated_land_value ) = urban_index Corine_to_EMEP_landuse ( Port_areas_value ) = urban_index Corine_to_EMEP_landuse ( Airports_value ) = urban_index Corine_to_EMEP_landuse ( Mineral_extraction_sites_value ) = urban_index Corine_to_EMEP_landuse ( Dump_sites_value ) = urban_index Corine_to_EMEP_landuse ( Construction_sites_value ) = urban_index Corine_to_EMEP_landuse ( Green_urban_areas_value ) = grass_index Corine_to_EMEP_landuse ( Sport_and_leisure_facilities_value ) = urban_index Corine_to_EMEP_landuse ( Non_irrigated_arable_land_value ) = grass_index Corine_to_EMEP_landuse ( Permanently_irrigated_land_value ) = grass_index Corine_to_EMEP_landuse ( Rice_fields_value ) = wetlands_index Corine_to_EMEP_landuse ( Vineyards_value ) = med_crop_index Corine_to_EMEP_landuse ( Fruit_trees_and_berry_plantations_value ) = med_crop_index Corine_to_EMEP_landuse ( Olive_groves_value ) = med_crop_index Corine_to_EMEP_landuse ( Pastures_value ) = grass_index Corine_to_EMEP_landuse ( Annual_crops_associated_with_permanent_crops_value ) = temp_crop_index Corine_to_EMEP_landuse ( Complex_cultivation_patterns_value ) = temp_crop_index Corine_to_EMEP_landuse ( Land_principally_occupied_by_agriculture_value ) = temp_crop_index Corine_to_EMEP_landuse ( Agro_forestry_areas_value ) = temp_decid_index Corine_to_EMEP_landuse ( Broad_leaved_forest_value ) = temp_decid_index Corine_to_EMEP_landuse ( Coniferous_forest_value ) = med_needle_index Corine_to_EMEP_landuse ( Mixed_forest_value ) = med_broadleaf_index Corine_to_EMEP_landuse ( Natural_grasslands_value ) = grass_index Corine_to_EMEP_landuse ( Moors_and_heathland_value ) = moorland_index Corine_to_EMEP_landuse ( Sclerophyllous_vegetation_value ) = medscrub_index Corine_to_EMEP_landuse ( Transitional_woodland_shrub_value ) = moorland_index Corine_to_EMEP_landuse ( Beaches_dunes_sands_value ) = desert_index Corine_to_EMEP_landuse ( Bare_rocks_value ) = urban_index Corine_to_EMEP_landuse ( Sparsely_vegetated_areas_value ) = medscrub_index Corine_to_EMEP_landuse ( Burnt_areas_value ) = medscrub_index Corine_to_EMEP_landuse ( Glaciers_and_perpetual_snow_value ) = ice_index Corine_to_EMEP_landuse ( Inland_marshes_value ) = wetlands_index Corine_to_EMEP_landuse ( Peat_bogs_value ) = wetlands_index Corine_to_EMEP_landuse ( Salt_marshes_value ) = wetlands_index Corine_to_EMEP_landuse ( Salines_value ) = wetlands_index Corine_to_EMEP_landuse ( Intertidal_flats_value ) = wetlands_index Corine_to_EMEP_landuse ( Water_courses_value ) = wetlands_index Corine_to_EMEP_landuse ( Water_bodies_value ) = water_index Corine_to_EMEP_landuse ( Coastal_lagoons_value ) = water_index Corine_to_EMEP_landuse ( Estuaries_value ) = water_index Corine_to_EMEP_landuse ( Sea_and_ocean_value ) = water_index Corine_to_EMEP_landuse ( NODATA_clc_value ) = grid_index end subroutine uEMEP_set_landuse_classes end module read_landuse_rivm_data","tags":"","loc":"sourcefile/uemep_read_landuse_rivm_data.f90.html"},{"title":"uemep_configuration.f90 – uEMEP","text":"Source Code module uemep_configuration use uEMEP_definitions , only : n_population_index , num_var_nc_name , n_pollutant_nc_index , n_source_nc_index , & n_compound_nc_index , num_var_population_nc , num_var_landuse_nc , n_source_index , UTM_projection_index , & LCC_projection_index , population_index , max_n_local_fraction_grids , n_dim_index , n_possible_subsource , & n_clc_landuse_index use uemep_constants , only : NODATA_value use uemep_logger implicit none ! Configuration file name entered in command line integer , parameter :: n_max_config_files = 10 character ( 256 ) :: name_config_file ( n_max_config_files ) = '' character ( 256 ) :: emission_date_str = '' integer :: n_config_files = 0 character ( 256 ) :: config_date_str = '' character ( 256 ) :: filename_log_file = 'uEMEP_log.txt' character ( 256 ) :: pathname_log_file = '' character ( 256 ) :: file_tag character ( 256 ) :: replacement_date_str = '<>' character ( 256 ) :: replacement_yesterday_date_str = '[]' character ( 256 ) :: replacement_hour_str = '<>' character ( 256 ) :: NORTRIP_replacement_hour_str = '<>' character ( 256 ) :: input_comp_name character ( 256 ) :: pathname_output_grid character ( 256 ) :: filename_date_output_grid = '<replace_date>_<replace_hour>' character ( 256 ) :: pathname_rl ( 2 ) ! Path name for input roadlink files character ( 256 ) :: filename_rl ( 2 ) ! File name for input roadlink files character ( 256 ) :: pathname_mrl ( 50 ) ! Path name for multiple road link (mrl) files character ( 256 ) :: filename_mrl ( 50 ) ! File name for multiple road link (mrl) files character ( 256 ) :: pathname_EMEP ( 4 ) ! Path name for input EMEP files character ( 256 ) :: filename_EMEP ( 4 ) ! File name for input EMEP files character ( 256 ) :: pathfilename_EMEP ( 4 ) ! Combined path and file name for input EMEP files character ( 256 ) :: original_filename_EMEP ( 4 ) character ( 256 ) :: original_pathname_EMEP ( 4 ) character ( 256 ) :: filename_ship ( 2 ) ! File name for shipping ais files character ( 256 ) :: pathname_ship ( 2 ) ! Path name for shipping ais files character ( 256 ) :: pathfilename_ship ( 2 ) ! Combined path and file name for shipping ais files character ( 256 ) :: filename_agriculture ( 2 ) ! File name for input agriculture rivm files character ( 256 ) :: pathname_agriculture ( 2 ) ! Path name for input agriculture rivm files character ( 256 ) :: pathfilename_agriculture ( 2 ) ! Combined path and file name for input agriculture rivm files character ( 256 ) :: filename_emission_rivm ( 2 ) ! File name for input emission rivm files character ( 256 ) :: pathname_emission_rivm ( 2 ) ! Path name for input emission rivm files character ( 256 ) :: pathfilename_emission_rivm ( 2 ) ! Combined path and file name for input emission rivm files character ( 256 ) :: filename_industry ( 10 ) ! File name for input industry files character ( 256 ) :: pathname_industry ( 10 ) ! Path name for input industry files character ( 256 ) :: pathfilename_industry ( 10 ) ! Combined path and file name for input industry files character ( 256 ) :: filename_heating ( 10 ) ! File name for input heating files character ( 256 ) :: pathname_heating ( 10 ) ! Path name for input heating files character ( 256 ) :: pathfilename_heating ( 10 ) ! Combined path and file name for input heating files character ( 256 ) :: filename_population ( n_population_index ) ! File name for input population files character ( 256 ) :: pathname_population ( n_population_index ) ! Path name for input population files character ( 256 ) :: pathfilename_population ( n_population_index ) ! Combined path and file name for input population files character ( 256 ) :: filename_receptor ! File name for the receptor file character ( 256 ) :: pathname_receptor ! Path name for the receptor file character ( 256 ) :: pathfilename_receptor ! Combined path and file name for the receptor file character ( 256 ) :: filename_timeprofile ! File name for the time profile file character ( 256 ) :: pathname_timeprofile ! Path name for the time profile file character ( 256 ) :: pathfilename_timeprofile ! Combined path and file name for the time profile file character ( 256 ) :: alternative_meteorology_type = 'meps' character ( 256 ) :: pathname_region_id = '' character ( 256 ) :: filename_region_id = '' character ( 256 ) :: region_name = '' character ( 256 ) :: pathfilename_region_id = '' character ( 256 ) :: pathname_tiles = '' character ( 256 ) :: filename_tiles = '' character ( 256 ) :: tile_tag = '' character ( 256 ) :: save_tile_tag = '' character ( 256 ) :: inpath_region_heating_scaling = '' character ( 256 ) :: infile_region_heating_scaling = '' character ( 256 ) :: pathfilename_region_heating_scaling = '' character ( 256 ) :: pathname_rl_change = '' character ( 256 ) :: filename_rl_change = '' character ( 256 ) :: forecast_hour_str = '00' ! Forecast hour string for writing to files character ( 256 ) :: NORTRIP_hour_str = '01' ! NORTRIP hour string for writing to files character ( 256 ) :: pathname_emissions_for_EMEP = '' character ( 256 ) :: save_emissions_for_EMEP_projection = 'lambert' character ( 256 ) :: save_emissions_for_EMEP_region = 'NO' character ( 256 ) :: var_name_nc ( num_var_nc_name , n_pollutant_nc_index , n_source_nc_index ) character ( 256 ) :: filename_landuse = '' character ( 256 ) :: pathname_landuse = '' character ( 256 ) :: pathfilename_landuse = '' ! Combined path and filename character ( 256 ) :: emission_naming_template_str = 'Sec<n>_Emis_mgm2_' character ( 256 ) :: pathname_boundingbox = '' character ( 256 ) :: filename_boundingbox = '' character ( 256 ) :: pathfilename_boundingbox = '' character ( 256 ) :: select_country_by_name = '' character ( 256 ) :: comp_name_nc ( n_compound_nc_index ) character ( 256 ) :: var_name_population_nc ( num_var_population_nc ) character ( 256 ) :: local_fraction_naming_template_str = 'sec<n>_local_fraction' character ( 256 ) :: finished_filename = '' character ( 256 ) :: finished_subpath = 'finished/' character ( 256 ) :: var_name_landuse_nc ( num_var_landuse_nc ) ! Configurations needed for new way to read region mask character ( 256 ) :: pathname_region_mask = '' character ( 256 ) :: filename_region_mask = '' character ( 256 ) :: varname_region_mask = 'region_index' logical :: hourly_calculations = . false . logical :: annual_calculations = . false . logical :: use_single_time_loop_flag = . false . logical :: reduce_EMEP_region_flag = . false . logical :: use_multiple_receptor_grids_flag = . false . logical :: reduce_roadlink_region_flag = . true . logical :: calculate_source ( n_source_nc_index ) = . false . logical :: calculate_EMEP_source ( n_source_nc_index ) = . false . logical :: make_EMEP_grid_emission_data ( n_source_nc_index ) = . false . logical :: replace_EMEP_local_with_subgrid_local ( n_source_nc_index ) = . false . logical :: subgrid_emission_distribution_flag = . false . ! If true then distributes the EMEP emissions to the existing emission subgrid logical :: EMEP_grid_interpolation_simple_flag = . false . ! not used? logical :: use_downwind_position_flag = . false . ! If true then searches the upwind EMEP grid position for emissions logical :: average_zc_h_in_Kz_flag = . true . logical :: use_emission_positions_for_auto_subgrid_flag ( n_source_index ) = . false . logical :: use_receptor_positions_for_auto_subgrid_flag = . false . logical :: use_population_positions_for_auto_subgrid_flag = . false . logical :: interpolate_subgrids_flag = . false . logical :: use_trajectory_flag ( n_source_index ) = . false . logical :: calculate_aggregated_shipping_emissions_flag = . false . logical :: use_aggregated_shipping_emissions_flag = . true . logical :: calculate_population_exposure_flag = . false . logical :: use_last_meteo_in_dispersion = . false . logical :: use_meandering_in_dispersion = . false . logical :: use_traffic_for_sigma0_flag = . false . logical :: use_alternative_meteorology_flag = . false . logical :: use_alternative_z0_flag = . false . logical :: save_netcdf_file_flag = . false . logical :: save_netcdf_receptor_flag = . false . logical :: save_netcdf_fraction_as_contribution_flag = . false . logical :: calculate_tiling_flag = . false . logical :: calculate_region_tiling_flag = . false . logical :: use_region_select_and_mask_flag = . false . logical :: use_NORTRIP_emission_data = . false . logical :: use_NORTRIP_emission_pollutant ( n_pollutant_nc_index ) = . true . logical :: use_RWC_emission_data = . false . logical :: include_o3_in_aqi_index = . false . logical :: read_weekly_shipping_data_flag = . false . logical :: read_monthly_and_daily_shipping_data_flag = . false . logical :: use_tunnel_emissions_flag = . true . logical :: use_tunnel_deposition_flag = . false . logical :: save_emissions_for_EMEP ( n_source_index ) = . false . logical :: save_compounds = . true . ! Output data saving flags logical :: save_source_contributions = . true . ! Output data saving flags logical :: save_emep_source_contributions = . false . ! Output data saving flags logical :: save_emep_additional_source_contributions = . false . logical :: save_total_source_contributions = . false . logical :: save_local_source_contributions_from_in_region = . false . logical :: save_semilocal_source_contributions_from_in_region = . false . logical :: save_total_source_contributions_from_in_region = . false . logical :: save_no2_source_contributions = . true . ! Output data saving flags logical :: save_o3_source_contributions = . true . ! Output data saving flags logical :: save_wind_vectors = . false . ! Output data saving flags logical :: save_other_meteo = . false . ! Output data saving flags logical :: save_emep_original = . true . ! Output data saving flags logical :: save_emissions = . false . ! Output data saving flags logical :: save_for_chemistry = . false . ! Output data saving flags logical :: save_population = . false . ! Output data saving flags logical :: save_aqi = . true . ! Output data saving flags logical :: save_emep_species = . false . ! Output data saving flags logical :: save_deposition = . false . ! Output data saving flags logical :: save_seasalt = . false . ! Output data saving flags logical :: save_netcdf_average_flag = . false . logical :: use_traffic_nox_emission_temperature_dependency = . false . logical :: calculate_deposition_flag = . false . logical :: calculate_source_depletion_flag = . false . logical :: read_landuse_flag = . false . logical :: use_plume_dispersion_deposition_flag = . false . logical :: adjust_wetdepo_integral_to_lowest_layer_flag = . false . logical :: auto_adjustment_for_summertime = . true . logical :: use_EMEP_surface_ozone_flag = . false . logical :: use_EMEP_surface_compounds_flag = . false . logical :: use_water_in_EMEP_surface_pm_flag = . false . logical :: save_compounds_as_ascii = . false . logical :: use_GNFR_emissions_from_EMEP_flag = . false . logical :: use_GNFR19_emissions_from_EMEP_flag = . false . logical :: use_alphabetic_GNFR_emissions_from_EMEP_flag = . false . logical :: use_emission_naming_template_flag = . false . logical :: read_OSM_roadlink_data_flag = . false . logical :: no_header_roadlink_data_flag = . false . logical :: use_user_specified_sectors_flag = . false . logical :: read_population_from_netcdf_flag = . false . logical :: read_population_from_netcdf_local_flag = . false . logical :: auto_select_OSM_country_flag = . false . logical :: select_latlon_centre_domain_position_flag = . false . logical :: read_shipping_from_netcdf_flag = . false . logical :: read_RWC_file_with_extra_HDD = . false . logical :: read_RWC_file_with_extra_HDD_and_height = . false . logical :: use_alternative_traveltime_weighting = . false . logical :: use_straightline_traveltime_distance = . false . logical :: limit_emep_grid_interpolation_region_to_calculation_region = . false . logical :: use_local_fraction_naming_template_flag = . false . logical :: use_local_fraction_grid_size_in_template_flag = . false . logical :: save_traffic_emissions_for_EMEP_as_exhaust_nonexhaust_flag = . false . logical :: use_annual_mean_pdf_chemistry_correction = . false . logical :: quick_annual_mean_pdf_chemistry_correction = . true . logical :: use_landuse_as_proxy = . false . logical :: read_rivm_landuse_flag = . false . logical :: use_rivm_agricuture_emission_data = . false . logical :: read_subgrid_emission_data = . false . logical :: use_rivm_subgrid_emission_format = . false . logical :: save_EMEP_somo35 = . false . logical :: save_EMEP_comax = . false . logical :: save_EMEP_o3max = . false . logical :: save_EMEP_o3_26th = . false . logical :: save_EMEP_so2 = . false . logical :: derive_SOA_from_other_species = . false . logical :: use_phi_for_invL = . false . logical :: trace_emissions_from_in_region = . false . logical :: calc_grid_vertical_average_concentration_annual_flag = . false . logical :: wind_level_zc_flag = . false . ! This will use the centre of mass wind no matter what type of wind_level_flag is used logical :: use_alternative_ppm_variable_for_lf = . false . logical :: save_emep_OP_species = . false . integer :: start_time_nc_index = 1 integer :: end_time_nc_index = 1 integer :: start_time_meteo_nc_index = 1 integer :: end_time_meteo_nc_index = 1 integer :: use_receptor_region = 1 ! Surrounding grid region when just running for receptors integer :: projection_type = UTM_projection_index integer :: EMEP_projection_type = LCC_projection_index integer :: utm_zone = 33 integer :: EMEP_grid_interpolation_flag = 0 integer :: EMEP_meteo_grid_interpolation_flag = 1 integer :: EMEP_emission_grid_interpolation_flag = 0 integer :: local_subgrid_method_flag = 1 integer :: stability_scheme_flag integer :: wind_level_flag = 3 integer :: wind_level_integral_flag = 3 integer :: no2_chemistry_scheme_flag = 1 integer :: no2_background_chemistry_scheme_flag = 0 integer :: integral_subgrid_step = 1 integer :: n_subsource ( n_source_index ) = 1 !Initialise the number of actual emission subsources to 1 for all subsources integer :: num_multiple_roadlink_files = 0 ! Number of multiple road link files integer :: population_data_type = population_index integer :: emission_timeprofile_hour_shift = 1 ! Winter European time integer :: region_id = 0 integer :: region_index = 0 integer :: HDD_threshold_value = 15 integer :: n_kz_iterations = 2 integer :: save_emissions_start_index = 1 integer :: save_emissions_end_index = 24 integer :: EMEP_surface_level_nc = 1 integer :: EMEP_surface_level_nc_2 = 1 integer :: uEMEP_to_EMEP_replace_sector ( n_source_nc_index ) = 0 integer :: local_fraction_grid_size ( max_n_local_fraction_grids ) = 1 integer :: n_local_fraction_grids = 1 integer :: local_fraction_grid_for_EMEP_grid_interpolation = 1 integer :: local_fraction_grid_for_EMEP_additional_grid_interpolation = 1 integer :: n_var_av = 100 ! Maximum number of variables to be saved as averages integer :: convert_uEMEP_to_GNFR_sector_index ( n_source_nc_index ) integer :: Kz_scheme = 2 ! 1 is O'Brian, 2 is Troen integer :: save_emission_subgrid_dim ( n_dim_index ) integer :: alternative_ppm_variable_for_lf_dim = 4 real :: utm_lon0 = 1 5. real :: ltm_lon0 = 0. real :: EMEP_grid_interpolation_size = 1. real :: EMEP_additional_grid_interpolation_size = 0. real :: traj_step_scale = 2.0 real :: subgrid_delta ( 2 ) real :: subgrid_min ( 2 ) real :: subgrid_max ( 2 ) real :: init_subgrid_delta ( 2 ) real :: init_subgrid_min ( 2 ) real :: init_subgrid_max ( 2 ) real :: deposition_subgrid_delta ( 2 ) = 0.0 real :: landuse_subgrid_delta ( 2 ) = 0.0 real :: h_emis ( n_source_index , n_possible_subsource ) real :: sig_y_00 ( n_source_index , n_possible_subsource ) real :: sigy_0_subgid_width_scale = 0.25 real :: sig_z_00 ( n_source_index , n_possible_subsource ) real :: FF_min_dispersion = 0.1 real :: ustar_min = 0.001 real :: hmix_min = 2 5.0 real :: hmix_max = 200 0.0 real :: emission_factor ( n_compound_nc_index , n_source_index , n_possible_subsource ) = 1.0 real :: ratio_truck_car_emission ( n_compound_nc_index ) = 1 0.0 real :: z_rec ( n_source_index , n_possible_subsource ) ! Pseudo dispersion parameters real :: ay ( n_source_index , n_possible_subsource ) ! Pseudo dispersion parameters real :: replace_invL = NODATA_value ! Will not replace invL when it has a NODATA value real :: replace_hmix = NODATA_value ! Will not replace mix when it has a NODATA value real :: FF_scale = NODATA_value real :: FF10_offset = NODATA_value real :: DD_offset = NODATA_value real :: J_scale = NODATA_value real :: replace_z0 = NODATA_value ! Will not replace z0 when it has a NODATA value real :: region_subgrid_delta = 5 0.0 real :: max_interpolation_subgrid_size = 100 0.0 real :: DMT_min_value = - 2 0.0 !Minimum allowable daily mean temperature for heating degree day calculation real :: integral_subgrid_delta_ref = 0. real :: ventilation_factor = 1.0 real :: min_ADT_ventilation_factor = 0.0 real :: min_length_ventilation_factor = 0.0 real :: windspeed_tunnel = 1.0 real :: lowest_stable_L = 1.0e6 real :: lowest_unstable_L = - 1 0.0 real :: tunnel_sig_z_00 = 5.0 real :: bridge_h_emis = 1 0.0 ! Bridge height not in use yet real :: traffic_nox_emission_temperature_ref_temperature ( 2 ) real :: traffic_nox_emission_temperature_ref_scaling ( 2 ) real :: limit_industry_delta = 25 0.0 real :: limit_shipping_delta = 25 0.0 real :: limit_heating_delta = 25 0.0 real :: limit_population_delta = 25 0.0 real :: EMEP_emission_aggregation_period = 1.0 real :: select_lat_centre_position = 6 0.0 real :: select_lon_centre_position = 1 1.0 real :: select_domain_width_EW_km = 2 0.0 real :: select_domain_height_NS_km = 2 0.0 real :: osm_adt_power_scale = 1.0 real :: romberg_parameters ( 3 ) = 0.0 real :: SRM_parameters ( 3 ) = 0.0 real :: sig_y_scaling_factor = 2.0 real :: min_proxy_emission_shipping_value = 0.0 real :: population_power_scale = 1.0 real :: H_emep = 9 0.0 ! Height of lowest level in EMEP real :: comp_scale_nc ( n_compound_nc_index ) real :: traveltime_power = 1. real :: traveltime_scaling = 1.0 real :: f_no2_emep = 0.1 real :: ox_sigma_ratio_pdf = 0.0 real :: nox_sigma_ratio_pdf = 0.0 real :: max_bin_pdf = 100 0.0 real :: min_bin_pdf = 0.0001 real :: log10_step_bin_pdf = 0.05 real :: landuse_proxy_weighting ( n_source_index , n_clc_landuse_index ) = 0.0 real :: scale_GNFR_emission_source ( n_source_index ) = 1.0 real :: subgrid_receptor_offset ( 2 ) = 0.0 real :: z_invL = 1 0.0 real :: save_emission_subgrid_min ( 2 ) !Only x and y real :: save_emission_subgrid_delta ( 2 ) double precision :: projection_attributes ( 10 ) double precision :: EMEP_projection_attributes ( 10 ) end module uemep_configuration","tags":"","loc":"sourcefile/uemep_configuration.f90.html"},{"title":"rdm2ll.f90 – uEMEP","text":"Source Code module mod_rdm2ll implicit none private public :: RDM2LL contains subroutine RDM2LL ( y , x , lat , lon ) implicit none real x , y , lat , lon real referenceRdX , referenceRdY , referenceWgs84X , referenceWgs84Y real dX , dY real sumN , sumE !SOURCE:   https://www.roelvanlisdonk.nl/2012/11/21/simple-way-for-converting-rijksdriehoek-coordinates-to-lat-and-long-wgs84-in-c/ !referentie coordinated RDM referenceRdX = 155000 referenceRdY = 463000 !The city \"Amsterfoort\" is used as reference \"WGS84\" coordinate. referenceWgs84X = 5 2.15517 referenceWgs84Y = 5.387206 dX = ( x - referenceRdX ) * 10 ** ( - 5.0 ) dY = ( y - referenceRdY ) * 10 ** ( - 5.0 ) sumN = ( 323 5.65389 * dY ) + ( - 3 2.58297 * ( dX ** 2 )) + ( - 0.2475 * ( dY ** 2 )) + ( - 0.84978 * ( dX ** 2 ) * dY ) + ( - 0.0655 * ( dY ** 3 )) + ( - 0.01709 * ( dX ** 2 ) * ( dY ** 2 )) + ( - 0.00738 * dX ) + ( 0.0053 * ( dX ** 4 )) + ( - 0.00039 * ( dX ** 2 ) * ( dY ** 3 )) + ( 0.00033 * ( dX ** 4 ) * dY ) + ( - 0.00012 * dX * dY ) sumE = ( 526 0.52916 * dX ) + ( 10 5.94684 * dX * dY ) + ( 2.45656 * dX * ( dY ** 2 )) + ( - 0.81885 * ( dX ** 3 )) + ( 0.05594 * dX * ( dY ** 3 )) + ( - 0.05607 * ( dX ** 3 ) * dY ) + ( 0.01199 * dY ) + ( - 0.00256 * ( dX ** 3 ) * ( dY ** 2 )) + ( 0.00128 * dX * ( dY ** 4 )) + ( 0.00022 * ( dY ** 2 )) + ( - 0.00022 * ( dX ** 2 )) + ( 0.00026 * ( dX ** 5 )) lat = referenceWgs84X + ( sumN / 360 0. ) lon = referenceWgs84Y + ( sumE / 360 0. ) end subroutine RDM2LL end module mod_rdm2ll","tags":"","loc":"sourcefile/rdm2ll.f90.html"},{"title":"uEMEP_crossreference_grids.f90 – uEMEP","text":"Source Code module crossreference_grids use uemep_configuration use uEMEP_definitions use mod_lambert_projection , only : lb2lambert2_uEMEP , LL2PS_spherical implicit none private public :: uEMEP_crossreference_grids contains subroutine uEMEP_crossreference_grids () integer :: i , j , k integer :: ii , jj integer :: i_source real :: x_temp , y_temp ! Cross referencing must be done for each new grid when using multiple grids if ( allocated ( crossreference_target_to_emep_subgrid )) then deallocate ( crossreference_target_to_emep_subgrid ) end if if ( allocated ( crossreference_target_to_localfraction_subgrid )) then deallocate ( crossreference_target_to_localfraction_subgrid ) end if if ( allocated ( crossreference_integral_to_emep_subgrid )) then deallocate ( crossreference_integral_to_emep_subgrid ) end if if ( allocated ( crossreference_target_to_integral_subgrid )) then deallocate ( crossreference_target_to_integral_subgrid ) end if if ( allocated ( crossreference_target_to_emission_subgrid )) then deallocate ( crossreference_target_to_emission_subgrid ) end if if ( allocated ( crossreference_emission_to_EMEP_subgrid )) then deallocate ( crossreference_emission_to_EMEP_subgrid ) end if if ( allocated ( crossreference_integral_to_emission_subgrid )) then deallocate ( crossreference_integral_to_emission_subgrid ) end if if ( allocated ( crossreference_emission_to_integral_subgrid )) then deallocate ( crossreference_emission_to_integral_subgrid ) end if if ( allocated ( crossreference_target_to_population_subgrid )) then deallocate ( crossreference_target_to_population_subgrid ) end if if ( use_alternative_meteorology_flag ) then if ( allocated ( crossreference_integral_to_meteo_nc_subgrid )) then deallocate ( crossreference_integral_to_meteo_nc_subgrid ) end if end if if ( calculate_deposition_flag ) then if ( allocated ( crossreference_emission_to_deposition_subgrid )) then deallocate ( crossreference_emission_to_deposition_subgrid ) end if if ( allocated ( crossreference_target_to_deposition_subgrid )) then deallocate ( crossreference_target_to_deposition_subgrid ) end if if ( allocated ( crossreference_deposition_to_emep_subgrid )) then deallocate ( crossreference_deposition_to_emep_subgrid ) end if end if if ( read_landuse_flag ) then if ( allocated ( crossreference_emission_to_landuse_subgrid )) then deallocate ( crossreference_emission_to_landuse_subgrid ) end if end if ! Allocate arrays allocate ( crossreference_target_to_emep_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_target_to_localfraction_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 , n_local_fraction_grids )) allocate ( crossreference_integral_to_emep_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_target_to_integral_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_target_to_emission_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_emission_to_EMEP_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_integral_to_emission_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_emission_to_integral_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_target_to_population_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) if ( use_alternative_meteorology_flag ) then allocate ( crossreference_integral_to_meteo_nc_subgrid ( integral_subgrid_dim ( x_dim_index ), integral_subgrid_dim ( y_dim_index ), 2 )) end if if ( calculate_deposition_flag ) then allocate ( crossreference_emission_to_deposition_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) allocate ( crossreference_target_to_deposition_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), 2 )) allocate ( crossreference_deposition_to_emep_subgrid ( deposition_subgrid_dim ( x_dim_index ), deposition_subgrid_dim ( y_dim_index ), 2 )) end if if ( read_landuse_flag ) then allocate ( crossreference_emission_to_landuse_subgrid ( emission_max_subgrid_dim ( x_dim_index ), emission_max_subgrid_dim ( y_dim_index ), 2 , n_source_index )) end if write ( unit_logfile , '(A)' ) 'Allocating EMEP grid index to subgrid index' ! Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then ! When EMEP is read as x,y projection then var1d_nc(:,lon/lat_nc_index) are the x, y projection indexes, actually call lb2lambert2_uEMEP ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) = ii crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) = jj end do end do write ( unit_logfile , '(A)' ) 'Allocating EMEP local fraction grid index to subgrid index' ! Loop through subgrid and find those subgrids within EMEP grids and allocate concentrations directly from EMEP grids. do k = 1 , n_local_fraction_grids do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) jj = 1 + floor (( lat_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then !When EMEP is read as x,y projection then var1d_nc(:,lon/lat_nc_index) are the x, y projection indexes, actually call lb2lambert2_uEMEP ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_subgrid ( i , j ), lat_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) / local_fraction_grid_size ( k ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_target_to_localfraction_subgrid ( i , j , x_dim_index , k ) = ii crossreference_target_to_localfraction_subgrid ( i , j , y_dim_index , k ) = jj end do end do end do write ( unit_logfile , '(A)' ) 'Allocating integral grid index to subgrid index' do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_subgrid ( i , j ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_subgrid ( i , j ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) end do end do write ( unit_logfile , '(A)' ) 'Allocating population grid index to subgrid index' do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_population_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_subgrid ( i , j ) - population_subgrid_min ( x_dim_index )) / population_subgrid_delta ( x_dim_index )) crossreference_target_to_population_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_subgrid ( i , j ) - population_subgrid_min ( y_dim_index )) / population_subgrid_delta ( y_dim_index )) end do end do write ( unit_logfile , '(A)' ) 'Allocating EMEP grid index to integral subgrid index' do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_integral_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_integral_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_integral_to_emep_subgrid ( i , j , x_dim_index ) = ii crossreference_integral_to_emep_subgrid ( i , j , y_dim_index ) = jj end do end do if ( use_alternative_meteorology_flag ) then write ( unit_logfile , '(A)' ) 'Allocating alternative meteo nc grid index to integral subgrid index' do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) if ( meteo_nc_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_integral_subgrid ( i , j ) - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_integral_subgrid ( i , j ) - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( meteo_nc_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) ii = 1 + floor (( x_temp - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( meteo_nc_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_integral_subgrid ( i , j ), lat_integral_subgrid ( i , j ), meteo_nc_projection_attributes ) ii = 1 + floor (( x_temp - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_integral_to_meteo_nc_subgrid ( i , j , x_dim_index ) = ii crossreference_integral_to_meteo_nc_subgrid ( i , j , y_dim_index ) = jj end do end do end if do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_emission_subgrid ( i , j , i_source ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_emission_subgrid ( i , j , i_source ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_emission_subgrid ( i , j , i_source ), lat_emission_subgrid ( i , j , i_source ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , i_source ) = ii crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , i_source ) = jj end do end do do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_emission_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_subgrid ( i , j ) - emission_subgrid_min ( x_dim_index , i_source )) / emission_subgrid_delta ( x_dim_index , i_source )) crossreference_target_to_emission_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_subgrid ( i , j ) - emission_subgrid_min ( y_dim_index , i_source )) / emission_subgrid_delta ( y_dim_index , i_source )) end do end do do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index )) crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) = max ( min ( crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ), integral_subgrid_dim ( x_dim_index )), 1 ) crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) = max ( min ( crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ), integral_subgrid_dim ( y_dim_index )), 1 ) if ( crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) . lt . 1 . or . crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ) . gt . integral_subgrid_dim ( x_dim_index ) & . or . crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) . lt . 1 . or . crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ) . gt . integral_subgrid_dim ( y_dim_index )) then write ( unit_logfile , '(A,4i,4f)' ) 'WARNING: crossreference_emission_to_integral_subgrid is out of bounds (i_emis,j_emis,i_integral,j_integral,x_emis,y_emis)' , i , j , & crossreference_emission_to_integral_subgrid ( i , j , x_dim_index , i_source ), crossreference_emission_to_integral_subgrid ( i , j , y_dim_index , i_source ), & x_emission_subgrid ( i , j , i_source ) / 1000 , y_emission_subgrid ( i , j , i_source ) / 1000 , ( x_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( x_dim_index )) / integral_subgrid_delta ( x_dim_index ) + 0.5 , & ( y_emission_subgrid ( i , j , i_source ) - integral_subgrid_min ( y_dim_index )) / integral_subgrid_delta ( y_dim_index ) + 0.5 end if end do end do do j = 1 , integral_subgrid_dim ( y_dim_index ) do i = 1 , integral_subgrid_dim ( x_dim_index ) crossreference_integral_to_emission_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_integral_subgrid ( i , j ) - emission_subgrid_min ( x_dim_index , i_source )) / emission_subgrid_delta ( x_dim_index , i_source )) crossreference_integral_to_emission_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_integral_subgrid ( i , j ) - emission_subgrid_min ( y_dim_index , i_source )) / emission_subgrid_delta ( y_dim_index , i_source )) end do end do if ( calculate_deposition_flag ) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_deposition_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - deposition_subgrid_min ( x_dim_index )) / deposition_subgrid_delta ( x_dim_index )) crossreference_emission_to_deposition_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - deposition_subgrid_min ( y_dim_index )) / deposition_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_emission_to_deposition_subgrid ( i , j , x_dim_index , i_source ) = max ( min ( crossreference_emission_to_deposition_subgrid ( i , j , x_dim_index , i_source ), deposition_subgrid_dim ( x_dim_index )), 1 ) crossreference_emission_to_deposition_subgrid ( i , j , y_dim_index , i_source ) = max ( min ( crossreference_emission_to_deposition_subgrid ( i , j , y_dim_index , i_source ), deposition_subgrid_dim ( y_dim_index )), 1 ) end do end do end if if ( read_landuse_flag ) then do j = 1 , emission_subgrid_dim ( y_dim_index , i_source ) do i = 1 , emission_subgrid_dim ( x_dim_index , i_source ) crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ) = 1 + floor (( x_emission_subgrid ( i , j , i_source ) - landuse_subgrid_min ( x_dim_index )) / landuse_subgrid_delta ( x_dim_index )) crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ) = 1 + floor (( y_emission_subgrid ( i , j , i_source ) - landuse_subgrid_min ( y_dim_index )) / landuse_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ) = max ( min ( crossreference_emission_to_landuse_subgrid ( i , j , x_dim_index , i_source ), landuse_subgrid_dim ( x_dim_index )), 1 ) crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ) = max ( min ( crossreference_emission_to_landuse_subgrid ( i , j , y_dim_index , i_source ), landuse_subgrid_dim ( y_dim_index )), 1 ) end do end do end if end if end do if ( calculate_deposition_flag ) then do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ) = 1 + floor (( x_subgrid ( i , j ) - deposition_subgrid_min ( x_dim_index )) / deposition_subgrid_delta ( x_dim_index )) crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) = 1 + floor (( y_subgrid ( i , j ) - deposition_subgrid_min ( y_dim_index )) / deposition_subgrid_delta ( y_dim_index )) ! At edge this can return negative distances due to the different sizes of emission and integral grids and buffer zones. Set the limits here. Should not be a problem crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ) = max ( min ( crossreference_target_to_deposition_subgrid ( i , j , x_dim_index ), deposition_subgrid_dim ( x_dim_index )), 1 ) crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ) = max ( min ( crossreference_target_to_deposition_subgrid ( i , j , y_dim_index ), deposition_subgrid_dim ( y_dim_index )), 1 ) end do end do write ( unit_logfile , '(A)' ) 'Allocating EMEP grid index to deposition subgrid index' do j = 1 , deposition_subgrid_dim ( y_dim_index ) do i = 1 , deposition_subgrid_dim ( x_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then ii = 1 + floor (( lon_deposition_subgrid ( i , j ) - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( lat_deposition_subgrid ( i , j ) - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_temp , y_temp , lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else if ( EMEP_projection_type . eq . PS_projection_index ) then call LL2PS_spherical ( x_temp , y_temp , lon_deposition_subgrid ( i , j ), lat_deposition_subgrid ( i , j ), EMEP_projection_attributes ) ii = 1 + floor (( x_temp - var1d_nc ( 1 , lon_nc_index )) / dgrid_nc ( lon_nc_index ) + 0.5 ) jj = 1 + floor (( y_temp - var1d_nc ( 1 , lat_nc_index )) / dgrid_nc ( lat_nc_index ) + 0.5 ) else write ( unit_logfile , '(A)' ) 'No valid projection in use. Stopping' stop 1 end if crossreference_deposition_to_emep_subgrid ( i , j , x_dim_index ) = ii crossreference_deposition_to_emep_subgrid ( i , j , y_dim_index ) = jj end do end do end if end subroutine uEMEP_crossreference_grids end module crossreference_grids","tags":"","loc":"sourcefile/uemep_crossreference_grids.f90.html"},{"title":"uEMEP_chemistry_NO2.f90 – uEMEP","text":"Source Code module chemistry_no2 use uemep_constants , only : pi , epsilon0 use uemep_configuration use uEMEP_definitions use time_functions , only : get_sun_angles implicit none private public :: uEMEP_chemistry , correct_annual_mean_chemistry , & uEMEP_source_fraction_chemistry contains subroutine uEMEP_chemistry () ! Routine for doing the chemistry calculations in uEMEP integer :: i , j real :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature real :: nox_out , no2_out , o3_out , p_bg_out , p_out integer :: t , t_start , t_end integer :: i_source , i_subsource , emep_subsource integer :: i_pollutant logical :: nox_available = . false . integer :: i_integral , j_integral real :: FF_loc , distance_grid integer :: i_cross_integral , j_cross_integral , i_nc , j_nc real :: sum_p_bg_out , sum_p_out , count_p_out real :: max_p_bg_out , max_p_out , min_p_bg_out , min_p_out ! NB. Additional is calculated but not necessarily saved! real :: nox_bg_additional , no2_bg_additional , o3_bg_additional ! These are calculated in the Chemistry routine. Fist declared here. Are global variables if ( . not . allocated ( comp_source_subgrid )) then allocate ( comp_source_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( . not . allocated ( comp_source_EMEP_subgrid )) then allocate ( comp_source_EMEP_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( . not . allocated ( comp_source_EMEP_additional_subgrid )) then allocate ( comp_source_EMEP_additional_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if ! Search for nox in the pollutants do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ) . eq . nox_nc_index ) nox_available = . true . end do ! Leave the chemistry routine if nox is not available if ( . not . nox_available ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Calculating chemistry for NO2 (uEMEP_chemistry)' write ( unit_logfile , '(A)' ) '================================================================' if ( no2_chemistry_scheme_flag . eq . 0 ) then write ( unit_logfile , '(A)' ) 'No chemistry used' else if ( no2_chemistry_scheme_flag . eq . 1 ) then write ( unit_logfile , '(A)' ) 'Photostationary state used' else if ( no2_chemistry_scheme_flag . eq . 2 ) then write ( unit_logfile , '(A)' ) 'Photochemistry with time scale used' else if ( no2_chemistry_scheme_flag . eq . 3 ) then write ( unit_logfile , '(A)' ) 'Romberg parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 4 ) then write ( unit_logfile , '(A)' ) 'SRM parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'During parameterisation used' end if t_start = 1 t_end = subgrid_dim ( t_dim_index ) i_subsource = 1 emep_subsource = 1 comp_subgrid (:,:,:, no2_index ) = 0 comp_subgrid (:,:,:, nox_index ) = 0 comp_subgrid (:,:,:, o3_index ) = 0 nox_bg = 0.0 ; no2_bg = 0.0 ; o3_bg = 0.0 ; nox_loc = 0.0 ; f_no2_loc = 0.0 ; J_photo = 0.0 ; temperature = 0.0 ! Before calculating travel time then include the other EMEP sources not downscaled ! Travel time is set to EMEP Grid_width/FFgrid do t = t_start , t_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) i_cross_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_cross_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) FF_loc = 1.0 if ( hourly_calculations ) then FF_loc = max ( FF_min_dispersion , meteo_subgrid ( i_cross_integral , j_cross_integral , t , FFgrid_subgrid_index )) else if ( annual_calculations ) then FF_loc = max ( FF_min_dispersion , 1.0 / meteo_subgrid ( i_cross_integral , j_cross_integral , t , inv_FFgrid_subgrid_index )) end if i_nc = crossreference_target_to_emep_subgrid ( i , j , x_dim_index ) j_nc = crossreference_target_to_emep_subgrid ( i , j , y_dim_index ) if ( EMEP_projection_type . eq . LL_projection_index ) then distance_grid = 11100 0.0 * sqrt ( dgrid_nc ( lon_nc_index ) * cos ( var1d_nc ( j_nc , lat_nc_index ) * pi / 18 0.0 ) * dgrid_nc ( lat_nc_index )) else ! Assumed LCC or PS distance_grid = sqrt ( dgrid_nc ( lon_nc_index ) * dgrid_nc ( lat_nc_index )) end if end do end do end do sum_p_bg_out = 0.0 sum_p_out = 0.0 count_p_out = 0 max_p_bg_out = - 100 0.0 ; min_p_bg_out = 100 0.0 ; max_p_out = - 100 0.0 ; min_p_out = 100 0.0 do t = t_start , t_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) nox_bg = subgrid ( i , j , t , emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then nox_bg_additional = subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) end if o3_bg = comp_EMEP_subgrid ( i , j , t , o3_index ) f_no2_loc = 0.0 nox_loc = 0.0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) * subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if if ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source )) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end do if ( abs ( nox_loc ) > epsilon0 ) then f_no2_loc = f_no2_loc / nox_loc else f_no2_loc = 0.0 end if no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) ! Conserve Ox when removing NO2 in the background. Cannot be less than 0 ! Assume stationary state to derive no2 and o3 background if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg , o3_bg ) end if if ( EMEP_additional_grid_interpolation_size . gt . 0 ) then no2_bg_additional = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg_additional / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg_additional , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg_additional , o3_bg_additional ) else o3_bg_additional = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg_additional )) ! Conserve Ox when removing NO2 in the background end if comp_source_EMEP_additional_subgrid ( i , j , t , o3_index , allsource_index ) = o3_bg_additional comp_source_EMEP_additional_subgrid ( i , j , t , no2_index , allsource_index ) = no2_bg_additional end if ! Set the background O3 level. use all_source for the nonlocal. comp_source_EMEP_subgrid ( i , j , t , o3_index , allsource_index ) = o3_bg comp_source_EMEP_subgrid ( i , j , t , no2_index , allsource_index ) = no2_bg if ( no2_chemistry_scheme_flag . eq . 0 ) then nox_out = nox_bg + nox_loc no2_out = no2_bg + nox_loc * f_no2_loc o3_out = o3_bg else if ( no2_chemistry_scheme_flag . eq . 1 ) then call uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 2 ) then call uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , traveltime_subgrid ( i , j , t , 3 , pollutant_loop_back_index ( nox_nc_index )) * traveltime_scaling , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 3 ) then call uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_parameters ) else if ( no2_chemistry_scheme_flag . eq . 4 ) then call uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_parameters ) else if ( no2_chemistry_scheme_flag . eq . 5 ) then call uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) end if sum_p_bg_out = sum_p_bg_out + p_bg_out sum_p_out = sum_p_out + p_out count_p_out = count_p_out + 1 max_p_bg_out = max ( max_p_bg_out , p_bg_out ); min_p_bg_out = min ( min_p_bg_out , p_bg_out ) max_p_out = max ( max_p_out , p_out ); min_p_out = min ( min_p_out , p_out ) comp_subgrid ( i , j , t , o3_index ) = o3_out comp_subgrid ( i , j , t , no2_index ) = no2_out comp_subgrid ( i , j , t , nox_index ) = nox_out else comp_subgrid ( i , j , t , o3_index ) = NODATA_value comp_subgrid ( i , j , t , no2_index ) = NODATA_value comp_subgrid ( i , j , t , nox_index ) = NODATA_value end if end do end do end do write ( * , '(A,2f12.3)' ) 'P value (nonlocal,local): ' , sum_p_bg_out / count_p_out , sum_p_out / count_p_out write ( * , '(A,2f12.3)' ) 'P max (nonlocal,local): ' , max_p_bg_out , max_p_out write ( * , '(A,2f12.3)' ) 'P min (nonlocal,local): ' , min_p_bg_out , min_p_out end subroutine uEMEP_chemistry subroutine uEMEP_source_fraction_chemistry () ! Special source allocation for no2 based on leaving out one source at a time in the chemistry calculation ! This will always give a sum less, but not much less than, the total no2 ! This is normalised in order for it to be used ! Vhemistry scheme must have been run prior to implementing this integer :: i , j real :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature real :: nox_out , no2_out , o3_out , p_bg_out , p_out integer :: t , t_start , t_end integer :: i_source , i_subsource , emep_subsource integer :: i_pollutant logical :: nox_available = . false . integer :: i_integral , j_integral integer :: remove_source real :: sum_no2_source_subgrid , sum_o3_source_subgrid real , allocatable :: comp_source_temp_subgrid (:,:,:,:,:) real , allocatable :: comp_source_EMEP_temp_subgrid (:,:,:,:,:) ! additional delarations needed for the in-region calculations integer , parameter :: inregion_index = 1 integer , parameter :: outregion_index = 2 integer :: k real :: f_no2_isource , nox_loc_isource_total , nox_loc_isource_from_in_region , nox_loc_isource real :: no2_inandout_region ( 2 ) real :: o3_inandout_region ( 2 ) real :: sum_no2_inregion_outregion , sum_o3_inregion_outregion real :: nox_semiloc_isource , f_no2_bg if ( trace_emissions_from_in_region . and . . not . calculate_EMEP_additional_grid_flag ) then if (. not . allocated ( comp_source_subgrid_from_in_region )) allocate ( comp_source_subgrid_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) comp_source_subgrid_from_in_region = 0.0 if (. not . allocated ( comp_semilocal_source_subgrid_from_in_region )) allocate ( comp_semilocal_source_subgrid_from_in_region ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) comp_semilocal_source_subgrid_from_in_region = 0.0 end if ! Search for nox in the pollutants do i_pollutant = 1 , n_pollutant_loop if ( pollutant_loop_index ( i_pollutant ) . eq . nox_nc_index ) nox_available = . true . end do ! Leave the chemistry routine if nox is not available if ( . not . nox_available ) return if ( . not . allocated ( comp_source_subgrid )) then allocate ( comp_source_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( calculate_EMEP_additional_grid_flag ) then if ( . not . allocated ( comp_source_additional_subgrid )) then allocate ( comp_source_additional_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if ! Temporary array for storing the comp_source_subgrid to avoid rewriting large parts of the routine when running the additional version if ( . not . allocated ( comp_source_temp_subgrid )) then allocate ( comp_source_temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if if ( . not . allocated ( comp_source_EMEP_temp_subgrid )) then allocate ( comp_source_EMEP_temp_subgrid ( subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ), subgrid_dim ( t_dim_index ), n_compound_index , n_source_index )) end if comp_source_temp_subgrid = comp_source_subgrid comp_source_EMEP_temp_subgrid = comp_source_EMEP_subgrid comp_source_EMEP_subgrid = comp_source_EMEP_additional_subgrid end if write ( unit_logfile , '(A)' ) '--------------------------------------------------------' if (. not . calculate_EMEP_additional_grid_flag ) write ( unit_logfile , '(A)' ) 'Calculating chemistry source contributions for NO2 and O3 (uEMEP_source_fraction_chemistry)' if ( calculate_EMEP_additional_grid_flag ) write ( unit_logfile , '(A)' ) 'Calculating additional nonlocal for NO2 and O3 (uEMEP_source_fraction_chemistry)' write ( unit_logfile , '(A)' ) '--------------------------------------------------------' if ( no2_chemistry_scheme_flag . eq . 0 ) then write ( unit_logfile , '(A)' ) 'No chemistry used' else if ( no2_chemistry_scheme_flag . eq . 1 ) then write ( unit_logfile , '(A)' ) 'Photostationary state used' else if ( no2_chemistry_scheme_flag . eq . 2 ) then write ( unit_logfile , '(A)' ) 'Photochemistry with time scale used' else if ( no2_chemistry_scheme_flag . eq . 3 ) then write ( unit_logfile , '(A)' ) 'Romberg parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 4 ) then write ( unit_logfile , '(A)' ) 'SRM parameterisation used' else if ( no2_chemistry_scheme_flag . eq . 5 ) then write ( unit_logfile , '(A)' ) 'During parameterisation used' end if t_start = 1 t_end = subgrid_dim ( t_dim_index ) i_subsource = 1 emep_subsource = 1 nox_bg = 0.0 ; no2_bg = 0.0 ; o3_bg = 0.0 ; nox_loc = 0.0 ; f_no2_loc = 0.0 ; J_photo = 0.0 ; temperature = 0.0 ! Weighted travel time already calculated do t = t_start , t_end do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) then i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) if ( calculate_EMEP_additional_grid_flag ) then nox_bg = subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) else nox_bg = subgrid ( i , j , t , emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) end if o3_bg = comp_EMEP_subgrid ( i , j , t , o3_index ) do remove_source = 1 , n_source_index if ( calculate_source ( remove_source ) . or . remove_source . eq . allsource_index . or . ( calculate_emep_source ( remove_source ) . and . . not . calculate_source ( remove_source ))) then f_no2_loc = 0.0 nox_loc = 0.0 do i_source = 1 , n_source_index if ( calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) * subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if ! Include the local EMEP that are not being downscaled if ( . not . calculate_EMEP_additional_grid_flag ) then if ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if end if if ( calculate_EMEP_additional_grid_flag ) then ! If calculating the additional region then use the additional local EMEP not being downscaled if ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * subgrid ( i , j , t , emep_additional_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc = nox_loc + subgrid ( i , j , t , emep_additional_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if !If calculating the additional region then include the difference BG-BG_additional to the local EMEP that is being downscaled if ( calculate_source ( i_source )) then if ( remove_source . ne . i_source ) then do i_subsource = 1 , n_subsource ( i_source ) f_no2_loc = f_no2_loc + f_no2_emep * & ( subgrid ( i , j , t , emep_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) & - subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index ))) nox_loc = nox_loc + subgrid ( i , j , t , emep_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) & - subgrid ( i , j , t , emep_additional_nonlocal_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) end do end if end if end if end do if ( abs ( nox_loc ) > epsilon0 ) then f_no2_loc = f_no2_loc / nox_loc else f_no2_loc = 0.0 end if ! Use the all source index to calculate the contribution from the background ! This is done by removing all the sources, rather than the difference as done for the local sources ! This is because the chemistry is disturbed when removing background nox and no2 if ( remove_source . ne . allsource_index ) then no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) ! Conserve Ox when removing NO2 in the background. Cannot be less than 0 else no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) !Conserve Ox when removing NO2 in the background. Cannot be less than 0 nox_loc = 0.0 f_no2_loc = 0.0 end if ! Assume stationary state to derive no2 and o3 background. Overwrites the previous setting if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg , o3_bg ) end if if ( no2_chemistry_scheme_flag . eq . 0 ) then nox_out = nox_bg + nox_loc no2_out = no2_bg + nox_loc * f_no2_loc o3_out = o3_bg else if ( no2_chemistry_scheme_flag . eq . 1 ) then call uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 2 ) then call uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , traveltime_subgrid ( i , j , t , 3 , pollutant_loop_back_index ( nox_nc_index )) * traveltime_scaling , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 3 ) then call uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_parameters ) else if ( no2_chemistry_scheme_flag . eq . 4 ) then call uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_parameters ) else if ( no2_chemistry_scheme_flag . eq . 5 ) then call uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) end if ! For background just use the result without any sources. ! There is a problem disturbing the chemistry by removing the background nox and no2 but not changing the o3 if ( remove_source . eq . allsource_index ) then comp_source_subgrid ( i , j , t , no2_index , remove_source ) = no2_bg comp_source_subgrid ( i , j , t , o3_index , remove_source ) = o3_bg else !Avoid round off errors which can occur with small numbers comp_source_subgrid ( i , j , t , no2_index , remove_source ) = max ( 0.0 , comp_subgrid ( i , j , t , no2_index ) - no2_out ) !Can be negative and can be greater than 1 so do not limit comp_source_subgrid ( i , j , t , o3_index , remove_source ) = comp_subgrid ( i , j , t , o3_index ) - o3_out end if end if end do !Normalise the contributions !Calculate the sum sum_no2_source_subgrid = 0.0 sum_o3_source_subgrid = 0.0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source ))) then sum_no2_source_subgrid = sum_no2_source_subgrid + comp_source_subgrid ( i , j , t , no2_index , i_source ) sum_o3_source_subgrid = sum_o3_source_subgrid + comp_source_subgrid ( i , j , t , o3_index , i_source ) end if end do ! Set the background fractions so they will not be adjusted with normalisation do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . ( calculate_emep_source ( i_source ) . and . . not . calculate_source ( i_source ))) then ! Adjust for the background and normalise if ( abs ( sum_no2_source_subgrid ) > epsilon0 ) then comp_source_subgrid ( i , j , t , no2_index , i_source ) = comp_source_subgrid ( i , j , t , no2_index , i_source ) / sum_no2_source_subgrid & * ( comp_subgrid ( i , j , t , no2_index ) - comp_source_EMEP_subgrid ( i , j , t , no2_index , allsource_index )) else comp_source_subgrid ( i , j , t , no2_index , i_source ) = 0 end if if ( abs ( sum_o3_source_subgrid ) > epsilon0 ) then comp_source_subgrid ( i , j , t , o3_index , i_source ) = comp_source_subgrid ( i , j , t , o3_index , i_source ) / sum_o3_source_subgrid & * ( comp_subgrid ( i , j , t , o3_index ) - comp_source_EMEP_subgrid ( i , j , t , o3_index , allsource_index )) else comp_source_subgrid ( i , j , t , o3_index , i_source ) = 0 end if ! Setting local sources to 0 if total concentration is zero: No longer do this, because nonlocal might be non-zero even if total is zero !if (comp_subgrid(i,j,t,no2_index) .le. 0) comp_source_subgrid(i,j,t,no2_index,i_source) = 0 !if (comp_subgrid(i,j,t,o3_index) .le. 0) comp_source_subgrid(i,j,t,o3_index,i_source) = 0 end if end do ! Calculate NO2 and O3 source contributions from-in-region ! ******************************************************** if ( trace_emissions_from_in_region . and . . not . calculate_EMEP_additional_grid_flag ) then ! Calculate downscaled contributions from-in-region do remove_source = 1 , n_source_index if ( calculate_source ( remove_source ) . or . calculate_EMEP_source ( remove_source )) then do k = 1 , 2 ! inregion and outregion ! add up all local sources to NOx, except 'remove_source' from either inregion or outregion f_no2_loc = 0 nox_loc = 0 do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . calculate_EMEP_source ( i_source )) then ! NB: loop over n_subsource is not logical, since we in practice weigh contributions from sources with 2 subsources more than sources with only 1, but I do it to follow Bruce's method above... do i_subsource = 1 , n_subsource ( i_source ) ! check whether to use downscaled or non-downscaled local contribution for this source if ( calculate_source ( i_source )) then ! downscaled contribution f_no2_isource = emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) nox_loc_isource_total = subgrid ( i , j , t , local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc_isource_from_in_region = subgrid_local_from_in_region ( i , j , t , i_source , pollutant_loop_back_index ( nox_nc_index )) else ! i.e. calculate_EMEP_source(i_source) .and. .not. calculate_source(i_source) ! EMEP contribution f_no2_isource = f_no2_emep nox_loc_isource_total = subgrid ( i , j , t , emep_local_subgrid_index , i_source , pollutant_loop_back_index ( nox_nc_index )) nox_loc_isource_from_in_region = subgrid_EMEP_local_from_in_region ( i , j , t , i_source , pollutant_loop_back_index ( nox_nc_index )) end if ! check if this source is the one we remove or not, to determine how to add it if ( i_source == remove_source ) then ! for the source to remove: We should then treat the inregion and outregion differently if ( k == inregion_index ) then ! in region: add only the local contribution from outside region nox_loc_isource = nox_loc_isource_total - nox_loc_isource_from_in_region else if ( k == outregion_index ) then ! out region: add only the local contribution from inside region nox_loc_isource = nox_loc_isource_from_in_region else write ( unit_logfile , '(A)' ) 'ERROR: value of k is not inregion_index or outregion_index' stop end if else ! for other sources, just add all the local contribution in both cases nox_loc_isource = nox_loc_isource_total end if f_no2_loc = f_no2_loc + f_no2_isource * nox_loc_isource nox_loc = nox_loc + nox_loc_isource end do end if end do ! divide f_no2_loc by total NOx contribution, in both cases if ( abs ( nox_loc ) > epsilon0 ) then f_no2_loc = f_no2_loc / nox_loc else f_no2_loc = 0.0 end if ! Calculate background concentrations (following Bruce's approach above) no2_bg = comp_EMEP_subgrid ( i , j , t , no2_index ) * nox_bg / subgrid ( i , j , t , emep_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) o3_bg = max ( 0.0 , comp_EMEP_subgrid ( i , j , t , o3_index ) + 4 8.0 / 4 6.0 * ( comp_EMEP_subgrid ( i , j , t , no2_index ) - no2_bg )) !Conserve Ox when removing NO2 in the background. Cannot be less than 0 ! Assume stationary state to derive no2 and o3 background. Overwrites the previous setting if ( no2_background_chemistry_scheme_flag . eq . 1 ) then call uEMEP_nonlocal_NO2_O3 ( nox_bg , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , f_no2_emep , no2_bg , o3_bg ) end if ! Calculate NO2 and O3 with the chemistry scheme if ( no2_chemistry_scheme_flag . eq . 0 ) then nox_out = nox_bg + nox_loc no2_out = no2_bg + nox_loc * f_no2_loc o3_out = o3_bg else if ( no2_chemistry_scheme_flag . eq . 1 ) then call uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 2 ) then call uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , traveltime_subgrid ( i , j , t , 3 , pollutant_loop_back_index ( nox_nc_index )) * traveltime_scaling , nox_out , no2_out , o3_out , p_bg_out , p_out ) else if ( no2_chemistry_scheme_flag . eq . 3 ) then call uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_parameters ) else if ( no2_chemistry_scheme_flag . eq . 4 ) then call uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_parameters ) else if ( no2_chemistry_scheme_flag . eq . 5 ) then call uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , comp_EMEP_subgrid ( i , j , t , nox_index ), comp_EMEP_subgrid ( i , j , t , no2_index ), comp_EMEP_subgrid ( i , j , t , o3_index ), J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) end if !Avoid round off errors which can occur with small numbers no2_inandout_region ( k ) = max ( 0.0 , comp_subgrid ( i , j , t , no2_index ) - no2_out ) !Can be negative and can be greater than 1 so do not limit o3_inandout_region ( k ) = comp_subgrid ( i , j , t , o3_index ) - o3_out end do ! k=1,2 ! scale the contributions so the sum equals the total contribution from the source sum_no2_inregion_outregion = no2_inandout_region ( inregion_index ) + no2_inandout_region ( outregion_index ) sum_o3_inregion_outregion = o3_inandout_region ( inregion_index ) + o3_inandout_region ( outregion_index ) if ( abs ( sum_no2_inregion_outregion ) > epsilon0 ) then comp_source_subgrid_from_in_region ( i , j , t , no2_index , remove_source ) = comp_source_subgrid ( i , j , t , no2_index , remove_source ) * no2_inandout_region ( inregion_index ) / sum_no2_inregion_outregion else comp_source_subgrid_from_in_region ( i , j , t , no2_index , remove_source ) = 0 end if if ( abs ( sum_o3_inregion_outregion ) > epsilon0 ) then comp_source_subgrid_from_in_region ( i , j , t , o3_index , remove_source ) = comp_source_subgrid ( i , j , t , o3_index , remove_source ) * o3_inandout_region ( inregion_index ) / sum_o3_inregion_outregion else comp_source_subgrid_from_in_region ( i , j , t , o3_index , remove_source ) = 0 end if end if end do ! remove_source = 1, n_source_index ! Calculate semilocal contributions to NO2 and O3 ! This is approximated by assuming the same NO2/NOx ratio as for background as a whole nox_bg = subgrid ( i , j , t , emep_nonlocal_subgrid_index , allsource_index , pollutant_loop_back_index ( nox_nc_index )) no2_bg = comp_source_EMEP_subgrid ( i , j , t , no2_index , allsource_index ) do i_source = 1 , n_source_index if ( calculate_source ( i_source ) . or . calculate_EMEP_source ( i_source )) then ! get initial NO2/NOx ratio of this source if ( calculate_source ( i_source )) then i_subsource = 1 !!!!! for now, just use no2/nox ratio of the first subsource f_no2_isource = emission_factor ( no2_index , i_source , i_subsource ) / emission_factor ( nox_index , i_source , i_subsource ) else f_no2_isource = f_no2_emep end if ! calculate NO2/NOx ratio in the background f_no2_bg = no2_bg / nox_bg ! get semilocal contribution to NOx from this source nox_semiloc_isource = subgrid_EMEP_semilocal_from_in_region ( i , j , t , i_source , pollutant_loop_back_index ( nox_index )) ! calculate NO2 and O3 semilocal contribution from the source, assuming the NO2/NOx ratio is the same as in background comp_semilocal_source_subgrid_from_in_region ( i , j , t , no2_index , i_source ) = f_no2_bg * nox_semiloc_isource comp_semilocal_source_subgrid_from_in_region ( i , j , t , o3_index , i_source ) = - 4 8. / 4 6. * ( f_no2_bg - f_no2_isource ) * nox_semiloc_isource end if end do end if !(trace_emissions_from_in_region .and. .not. calculate_EMEP_additional_grid_flag) ! *************************************************************** ! done calculating NO2 and O3 source contributions from-in-region else ! i.e. if (.not. (use_subgrid(i,j,allsource_index))) comp_source_subgrid ( i , j , t ,:,:) = NODATA_value if ( trace_emissions_from_in_region . and . . not . calculate_EMEP_additional_grid_flag ) then comp_source_subgrid_from_in_region ( i , j , t ,:,:) = NODATA_value end if end if end do end do end do ! Transfer the arrays to the right outputs if ( calculate_EMEP_additional_grid_flag ) then comp_source_additional_subgrid = comp_source_subgrid comp_source_subgrid = comp_source_temp_subgrid comp_source_EMEP_subgrid = comp_source_EMEP_temp_subgrid ! EMEP_additional is unchanged if ( allocated ( comp_source_temp_subgrid )) deallocate ( comp_source_temp_subgrid ) if ( allocated ( comp_source_EMEP_temp_subgrid )) deallocate ( comp_source_EMEP_temp_subgrid ) end if end subroutine uEMEP_source_fraction_chemistry subroutine uEMEP_photostationary_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) real , intent ( in ) :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature real , intent ( out ) :: nox_out , no2_out , o3_out , p_bg_out , p_out integer no2_i , no_i , nox_i , o3_i , ox_i , nox_bg_i , no2_bg_i integer , parameter :: n_i = 7 real :: Na , Na_fac , k1 real :: mass ( n_i ) real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 , 4 6.0 , 4 6.0 ] real :: mol ( n_i ) real :: f_no2 , f_ox , Jd , fac_sqrt real :: min_nox = 1.0e-6 no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 ; nox_bg_i = 6 ; no2_bg_i = 7 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 !Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ); !(cm&#94;3/s) and temperature in Kelvin mass ( 1 : n_i ) = 0.0 mol ( 1 : n_i ) = 0.0 ! Test for 0 NOx. If so leave the routine mass ( nox_i ) = nox_loc + nox_bg if ( mass ( nox_i ) . le . min_nox ) then nox_out = 0.0 no2_out = 0.0 o3_out = o3_bg return end if ! Check the photostationary assumption for the input data mass ( nox_i ) = nox_bg mass ( no2_i ) = no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) ! Test the photostationary state for the bg input data if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_bg_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_bg_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if ! Add the local contribution for calculation mass ( nox_i ) = nox_loc + nox_bg mass ( no2_i ) = f_no2_loc * nox_loc + no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) f_no2 = mol ( no2_i ) / mol ( nox_i ) f_ox = mol ( ox_i ) / mol ( nox_i ) ! Test the photostationary state for the input data. Will not be in equilibrium if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if ! Set the photolysis rate Jd = J_photo / k1 / mol ( nox_i ) ! Calculate fraction of NO2 in photostationary state fac_sqrt = max ( 0.0 , ( 1.0 + f_ox + Jd ) ** 2 - 4.0 * f_ox ) f_no2 = 0.5 * (( 1.0 + f_ox + Jd ) - sqrt ( fac_sqrt )) ! Convert back to mass mol ( no2_i ) = f_no2 * mol ( nox_i ); mol ( o3_i ) = max ( 0.0 , mol ( ox_i ) - mol ( no2_i )) ! Rounding errors possible mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) !Rounding errors possible mass = mol * mmass / Na_fac ! (ug/m3) no2_out = mass ( no2_i ) nox_out = mass ( nox_i ) o3_out = mass ( o3_i ) ! Check output if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if end subroutine uEMEP_photostationary_NO2 subroutine uEMEP_phototimescale_NO2 ( nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , time_scale , nox_out , no2_out , o3_out , p_bg_out , p_out ) real , intent ( in ) :: nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , time_scale real , intent ( out ) :: nox_out , no2_out , o3_out , p_bg_out , p_out ! Local variables integer :: no2_i , no_i , nox_i , o3_i , ox_i , nox_bg_i , no2_bg_i integer , parameter :: n_i = 7 double precision :: Na , Na_fac , k1 double precision :: mass ( n_i ) double precision :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 , 4 6.0 , 4 6.0 ] double precision :: mol ( n_i ) double precision :: fac_sqrt double precision :: f_no2 , f_ox , Jd , Jd_bg double precision :: min_nox = 1.0e-6 double precision :: c , b , BB , td , f_no2_0 , f_no2_ps complex ( 8 ) :: AA double precision :: p_tot_out , f_ox_bg , f_no2_bg_ps , f_no2_bg no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 ; nox_bg_i = 6 ; no2_bg_i = 7 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ) ! (cm&#94;3/s) and temperature in Kelvin mass ( 1 : n_i ) = 0.0 mol ( 1 : n_i ) = 0.0 ! Test for 0 NOx. If so leave the routine mass ( nox_i ) = nox_loc + nox_bg if ( mass ( nox_i ) . le . min_nox ) then nox_out = 0.0 no2_out = 0.0 o3_out = o3_bg return end if ! Check the photostationary assumption for the input data mass ( nox_i ) = nox_bg mass ( no2_i ) = no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) f_ox_bg = mol ( ox_i ) / mol ( nox_i ) Jd_bg = J_photo / k1 / mol ( nox_i ) f_no2_bg_ps = 0.5 * (( 1 + f_ox_bg + Jd_bg ) - sqrt (( 1 + f_ox_bg + Jd_bg ) ** 2 - 4.0 * f_ox_bg )) f_no2_bg = mol ( no2_i ) / mol ( nox_i ) p_bg_out = f_no2_bg / f_no2_bg_ps ! Check input if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_bg_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_bg_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if ! Add the local contribution for calculation mass ( nox_i ) = nox_loc + nox_bg mass ( no2_i ) = f_no2_loc * nox_loc + no2_bg mass ( o3_i ) = o3_bg mol = mass / mmass * Na_fac ! (molecules per cm3) mol ( ox_i ) = mol ( o3_i ) + mol ( no2_i ) mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) f_no2 = mol ( no2_i ) / mol ( nox_i ) f_ox = mol ( ox_i ) / mol ( nox_i ) ! Set the photolysis rate Jd = J_photo / k1 / mol ( nox_i ) ! Calculate photostationary for total nox, ox fac_sqrt = max ( 0.0 , ( 1 + f_ox + Jd ) ** 2 - 4.0 * f_ox ) f_no2_ps = 0.5 * (( 1 + f_ox + Jd ) - sqrt ( fac_sqrt )) p_tot_out = f_no2 / f_no2_ps ! Calculate fraction of NO2 based on the time scale c = f_ox b = 1 + f_ox + Jd BB = sqrt ( max ( 0.0 , b ** 2 - 4.0 * c )) ! max avoids roundoff errors td = time_scale * k1 * mol ( nox_i ) f_no2_0 = f_no2 AA = clog ( cmplx (( BB + b - 2.0 * f_no2_0 ) / ( BB - b + 2.0 * f_no2_0 ))) f_no2 = real ( - BB / 2.0 * (( exp ( AA + BB * td ) - 1.0 ) / ( exp ( AA + BB * td ) + 1.0 )) + b / 2.0 ) if ( isnan ( f_no2 )) f_no2 = - BB / 2.0 + b / 2.0 fac_sqrt = max ( 0.0 , ( 1 + f_ox + Jd ) ** 2 - 4.0 * f_ox ) f_no2_ps = 0.5 * (( 1.0 + f_ox + Jd ) - sqrt ( fac_sqrt )) p_out = f_no2 / f_no2_ps ! Convert back to mass mol ( no2_i ) = max ( 0.0 , f_no2 * mol ( nox_i )) mol ( o3_i ) = max ( 0.0 , mol ( ox_i ) - mol ( no2_i )) ! Rounding errors possible mol ( no_i ) = max ( 0.0 , mol ( nox_i ) - mol ( no2_i )) ! Rounding errors possible mass = mol * mmass / Na_fac ! (ug/m3) no2_out = mass ( no2_i ) nox_out = mass ( nox_i ) o3_out = mass ( o3_i ) if ( isnan ( no2_out )) then write ( * , '(8a12)' ) 'nox_bg' , 'no2_bg' , 'o3_bg' , 'nox_loc' , 'f_no2_loc' , 'J_photo' , 'temperature' , 'time_scale' write ( * , '(8es12.2)' ) nox_bg , no2_bg , o3_bg , nox_loc , f_no2_loc , J_photo , temperature , time_scale write ( * , '(4a12)' ) 'f_no2' , 'BB' , 'b' , 'b**2-4.*c' write ( * , '(4es12.2)' ) f_no2 , BB , b , b ** 2 - 4.0 * c stop 1 end if ! Check output if ( abs ( J_photo ) > epsilon0 . and . abs ( mol ( no_i )) > epsilon0 . and . abs ( mol ( o3_i )) > epsilon0 ) then p_out = J_photo * mol ( no2_i ) / k1 / mol ( o3_i ) / mol ( no_i ) else p_out = mol ( no2_i ) / ( mol ( ox_i ) + mol ( nox_i ) - abs ( mol ( ox_i ) - mol ( nox_i ))) * 2.0 end if end subroutine uEMEP_phototimescale_NO2 subroutine uEMEP_Romberg_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , romberg_params ) ! From Norwegian obs fit ! real :: a_rom=20 ! real :: b_rom=30 ! From model fit ! real :: a_rom=30 ! real :: b_rom=35 ! real :: c_rom=0.20 ! Gral values 30 35 0.18 ! B�chlin and B�singer (2008) 29 35 0.217 real , intent ( in ) :: nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc real , intent ( in ) :: romberg_params ( 3 ) real , intent ( out ) :: nox_out , no2_out , o3_out ! Local variables real :: a_rom = 3 0.0 real :: b_rom = 3 5.0 real :: c_rom = 0.20 real :: ox_init , no2_init , no2_equ ! If available, use custom parameter values if ( abs ( romberg_params ( 1 )) > epsilon0 ) then a_rom = romberg_params ( 1 ) b_rom = romberg_params ( 2 ) c_rom = romberg_params ( 3 ) end if nox_out = nox_bg + nox_loc no2_equ = a_rom * nox_bg / ( nox_bg + b_rom ) + nox_bg * c_rom no2_out = a_rom * nox_out / ( nox_out + b_rom ) + nox_out * c_rom no2_out = no2_out - no2_equ + no2_bg no2_out = max ( no2_bg , no2_out ) no2_init = no2_bg + f_no2_loc * nox_loc ! Small adjustments for molecular weights ox_init = no2_init * 4 7.0 / 4 6.0 + o3_bg * 4 7.0 / 4 8.0 o3_out = ox_init * 4 8.0 / 4 7.0 - no2_out * 4 8.0 / 4 6.0 end subroutine uEMEP_Romberg_NO2 subroutine uEMEP_SRM_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_out , no2_out , o3_out , SRM_params ) ! From model fit ! real :: beta = 0.45 ! real :: K = 30.0 ! real :: F = 0.2 ! From RIVM Briefrapport 2014-0109 ! beta=1 ! K=100 ! F=0.2 ! ! Reference ! https://core.ac.uk/download/pdf/58774365.pdf real , intent ( in ) :: nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc real , intent ( in ) :: SRM_params ( 3 ) real , intent ( out ) :: nox_out , no2_out , o3_out ! Local variables real :: beta = 0.45 real :: K = 3 0.0 real :: F = 0.2 real :: ox_init , no2_init ! If available, use custom parameter values if ( abs ( SRM_params ( 1 )) > epsilon0 ) then beta = SRM_params ( 1 ) K = SRM_params ( 2 ) F = SRM_params ( 3 ) end if nox_out = nox_bg + nox_loc no2_out = no2_bg + beta * o3_bg * nox_loc / ( nox_loc + K / ( 1 - F )) + F * nox_loc no2_init = no2_bg + f_no2_loc * nox_loc ! Small adjustments for molecular weights ox_init = no2_init * 4 7.0 / 4 6.0 + o3_bg * 4 7.0 / 4 8.0 o3_out = ox_init * 4 8.0 / 4 7.0 - no2_out * 4 8.0 / 4 6.0 end subroutine uEMEP_SRM_NO2 subroutine uEMEP_During_NO2 ( nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , nox_emep , no2_emep , o3_emep , J_photo , temperature , nox_out , no2_out , o3_out , p_bg_out , p_out ) ! Reference ! D�ring, I., B�chlin, W., Ketzel, M., Baum, A., Friedrich, U., Wurzler, S., 2011. ! A new simplified NO/NO2 conversion model under consideration of direct NO2-emissions. ! Meteorol. Zeitschrift 20, 67�73. doi:10.1127/0941-2948/2011/0491 ! ! Improved Methodologies for NO2 Exposure Assessment in the EU, page 53 ! https://ec.europa.eu/environment/air/pdf/NO2_Exposure_Final_Report.pdf real , intent ( in ) :: nox_bg , no2_bg , nox_loc , o3_bg , f_no2_loc , J_photo , temperature real , intent ( in ) :: nox_emep , no2_emep , o3_emep real , intent ( out ) :: nox_out , no2_out , o3_out real , intent ( out ) :: p_bg_out , p_out ! Local variables real :: mol_nox_bg , mol_no2_bg , mol_nox_loc , mol_o3_bg , mol_no2_loc , mol_ox_loc , mol_no_bg , mol_ox_bg real :: mol_no2_out , mol_o3_out , mol_no_out real :: mol_nox_emep , mol_no2_emep , mol_o3_emep , mol_no_emep , mol_ox_emep , p_emep_out real :: b , d , r , c , k1 real :: Na , Na_fac integer :: no2_i , no_i , nox_i , o3_i , ox_i integer , parameter :: n_i = 5 real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 ] no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ) ! (cm&#94;3/s) and temperature in Kelvin Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included ! Normally multiplied by *Na_fac but not necessary as it is just a scaling mol_no2_bg = no2_bg / mmass ( no2_i ) mol_no2_loc = f_no2_loc * nox_loc / mmass ( no2_i ) mol_nox_bg = nox_bg / mmass ( nox_i ) mol_nox_loc = nox_loc / mmass ( nox_i ) mol_o3_bg = o3_bg / mmass ( o3_i ) mol_no_bg = ( nox_bg - no2_bg ) / mmass ( nox_i ) mol_ox_bg = mol_o3_bg + mol_no2_bg mol_o3_emep = o3_emep / mmass ( o3_i ) mol_nox_emep = nox_emep / mmass ( nox_i ) mol_no2_emep = no2_emep / mmass ( no2_i ) mol_no_emep = max ( 0.0 , mol_nox_emep - mol_no2_emep ) mol_ox_emep = mol_o3_emep + mol_no2_emep mol_ox_loc = mol_o3_bg + mol_no2_bg + mol_no2_loc if ( mol_no2_emep . gt . 0 ) then r = mol_o3_emep * mol_no_emep / mol_no2_emep else r = 0.0 end if b = mol_ox_loc + mol_nox_bg + mol_nox_loc + r c = max ( 0.0 , b ** 2 - 4.0 * mol_ox_loc * ( mol_nox_bg + mol_nox_loc )) ! Should never be less than 0 but can be -0 d = sqrt ( c ) mol_no2_out = ( b - d ) / 2.0 mol_o3_out = mol_ox_loc - mol_no2_out mol_no_out = mol_nox_bg + mol_nox_loc - mol_no2_out nox_out = nox_bg + nox_loc no2_out = mol_no2_out * mmass ( no2_i ) o3_out = mol_o3_out * mmass ( o3_i ) ! Not correct as it does not calculate the actual photostationary equation p_out = r p_bg_out = mol_o3_bg * mol_no_bg / mol_no2_bg ! Check output if ( abs ( J_photo ) > epsilon0 . and . abs ( mol_no_out ) > epsilon0 . and . abs ( mol_o3_out ) > epsilon0 ) then p_out = J_photo * mol_no2_out / k1 / mol_o3_out / mol_no_out / Na_fac p_emep_out = J_photo * mol_no2_emep / k1 / mol_o3_emep / mol_no_emep / Na_fac p_bg_out = J_photo * mol_no2_bg / k1 / mol_o3_bg / mol_no_bg / Na_fac else p_out = mol_no2_out / ( mol_ox_loc + mol_nox_bg + mol_nox_loc - abs ( mol_ox_loc - mol_nox_bg - mol_nox_loc )) * 2.0 p_emep_out = mol_no2_emep / ( mol_ox_emep + mol_nox_emep - abs ( mol_ox_emep - mol_nox_emep )) * 2.0 p_bg_out = mol_no2_bg / ( mol_ox_bg + mol_nox_bg - abs ( mol_ox_bg - mol_nox_bg )) * 2.0 end if end subroutine uEMEP_During_NO2 subroutine uEMEP_nonlocal_NO2_O3 ( nox_bg , nox_emep , no2_emep , o3_emep , J_photo , temperature , f_no2 , no2_out , o3_out ) real , intent ( in ) :: J_photo , temperature , f_no2 real , intent ( in ) :: nox_bg real , intent ( in ) :: nox_emep , no2_emep , o3_emep real , intent ( out ) :: no2_out , o3_out ! Local variables real :: mol_nox_bg real :: mol_no2_out , mol_o3_out real :: mol_nox_emep , mol_no2_emep , mol_o3_emep , mol_ox_emep , mol_no_emep real :: b , d , r , c real :: Na , Na_fac , k1 real :: p_phot , r_phot integer no2_i , no_i , nox_i , o3_i , ox_i integer , parameter :: n_i = 5 real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 ] no2_i = 1 ; no_i = 2 ; nox_i = 3 ; o3_i = 4 ; ox_i = 5 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature ) ! (cm&#94;3/s) and temperature in Kelvin ! Normally multiplied by *Na_fac but not necessary as it is just a scaling mol_o3_emep = o3_emep / mmass ( o3_i ) * Na_fac mol_no2_emep = no2_emep / mmass ( no2_i ) * Na_fac mol_nox_emep = nox_emep / mmass ( nox_i ) * Na_fac mol_ox_emep = mol_o3_emep + mol_no2_emep - f_no2 * mol_nox_emep mol_nox_bg = nox_bg / mmass ( nox_i ) * Na_fac mol_no_emep = max ( 0.0 , mol_nox_emep - mol_no2_emep ) if ( mol_no2_emep . gt . 0 ) then r = mol_o3_emep * mol_no_emep / mol_no2_emep p_phot = J_photo / k1 * mol_no2_emep / mol_o3_emep / mol_no_emep r_phot = J_photo / k1 / Na_fac r = r_phot * Na_fac b = mol_ox_emep + mol_nox_bg + r c = max ( 0.0 , b ** 2 - 4.0 * mol_ox_emep * mol_nox_bg ) ! Should never be less than 0 but can be -0.0 d = sqrt ( c ) mol_no2_out = ( b - d ) / 2.0 mol_o3_out = mol_ox_emep - mol_no2_out no2_out = max ( 0.0 , mol_no2_out * mmass ( no2_i ) / Na_fac ) o3_out = max ( 0.0 , mol_o3_out * mmass ( o3_i ) / Na_fac ) else no2_out = 0.0 o3_out = o3_emep end if end subroutine uEMEP_nonlocal_NO2_O3 subroutine correct_annual_mean_chemistry () integer :: i , j , t integer :: t_start , t_end integer :: i_integral , j_integral real :: o3_in , nox_in , no2_in , J_photo_in , temperature_in , lon_in , lat_in real :: ox_sigma_ratio_in , nox_sigma_ratio_in real :: o3_out , no2_out real :: sum_no2_in , sum_no2_out integer :: no2_count logical :: run_all_flag write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Correcting annual mean NO2 and O3 (correct_annual_mean_chemistry)' write ( unit_logfile , '(A)' ) '================================================================' t_start = 1 t_end = subgrid_dim ( t_dim_index ) sum_no2_in = 0.0 sum_no2_out = 0.0 no2_count = 0 do t = t_start , t_end !Run the conversion routine once to get the Jd distribution which is saved. This is to save time as this is slow. Done in the centre of the grid if ( quick_annual_mean_pdf_chemistry_correction ) then run_all_flag = . false . i = subgrid_dim ( x_dim_index ) / 2 j = subgrid_dim ( y_dim_index ) / 2 o3_in = comp_subgrid ( i , j , t , o3_index ) no2_in = comp_subgrid ( i , j , t , no2_index ) nox_in = comp_subgrid ( i , j , t , nox_index ) i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo_in = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature_in = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) lon_in = lon_subgrid ( i , j ) lat_in = lat_subgrid ( i , j ) ox_sigma_ratio_in = ox_sigma_ratio_pdf nox_sigma_ratio_in = nox_sigma_ratio_pdf call uEMEP_annual_mean_pdf_correction_NO2_O3 ( min_bin_pdf , max_bin_pdf , log10_step_bin_pdf , . true ., no2_in , nox_in , o3_in , J_photo_in , & temperature_in , ox_sigma_ratio_in , nox_sigma_ratio_in , lon_in , lat_in , no2_out , o3_out ) else run_all_flag = . true . end if do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) o3_in = comp_subgrid ( i , j , t , o3_index ) no2_in = comp_subgrid ( i , j , t , no2_index ) nox_in = comp_subgrid ( i , j , t , nox_index ) i_integral = crossreference_target_to_integral_subgrid ( i , j , x_dim_index ) j_integral = crossreference_target_to_integral_subgrid ( i , j , y_dim_index ) J_photo_in = meteo_subgrid ( i_integral , j_integral , t , J_subgrid_index ) temperature_in = meteo_subgrid ( i_integral , j_integral , t , t2m_subgrid_index ) lon_in = lon_subgrid ( i , j ) lat_in = lat_subgrid ( i , j ) ox_sigma_ratio_in = ox_sigma_ratio_pdf nox_sigma_ratio_in = nox_sigma_ratio_pdf if ( o3_in . le . 0 . or . nox_in . le . 0 . or . no2_in . le . 0 ) then o3_out = o3_in no2_out = no2_in else call uEMEP_annual_mean_pdf_correction_NO2_O3 ( min_bin_pdf , max_bin_pdf , log10_step_bin_pdf , run_all_flag , no2_in , nox_in , o3_in , J_photo_in , & temperature_in , ox_sigma_ratio_in , nox_sigma_ratio_in , lon_in , lat_in , no2_out , o3_out ) end if comp_subgrid ( i , j , t , o3_index ) = o3_out comp_subgrid ( i , j , t , no2_index ) = no2_out sum_no2_in = sum_no2_in + no2_in sum_no2_out = sum_no2_out + no2_out no2_count = no2_count + 1 if ( isnan ( no2_out )) then write ( unit_logfile , '(a,2i5,4f12.4)' ) 'NaN in pdf output. Stopping ' , i , j , no2_in , no2_out , o3_in , o3_out stop 1 end if end do end do end do write ( unit_logfile , '(a,f12.4)' ) 'Average NO2 scaling with pdf correction = ' , sum_no2_out / sum_no2_in end subroutine correct_annual_mean_chemistry subroutine uEMEP_annual_mean_pdf_correction_NO2_O3 ( bin_min , bin_max , delta_log10_bin , run_all , no2_in , nox_in , o3_in , J_photo_in , temperature_in , ox_sigma_ratio_in , nox_sigma_ratio_in , lon_in , lat_in , no2_out , o3_out ) real , intent ( in ) :: bin_min , bin_max , delta_log10_bin logical , intent ( in ) :: run_all real , intent ( in ) :: J_photo_in , temperature_in real , intent ( in ) :: no2_in , nox_in , o3_in real , intent ( in ) :: ox_sigma_ratio_in , nox_sigma_ratio_in real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: no2_out , o3_out ! Loca variables real :: mol_no2_out , mol_o3_out real :: Na , Na_fac , k1 integer , parameter :: no2_i = 1 !integer, parameter :: no_i = 2 integer , parameter :: nox_i = 3 integer , parameter :: o3_i = 4 !integer, parameter :: ox_i = 5 integer , parameter :: n_i = 5 real :: mmass ( n_i ) = [ 4 6.0 , 3 0.0 , 4 6.0 , 4 8.0 , 4 7.0 ] real :: log10_bin_max , log10_bin_min real , allocatable :: log10_bin (:), bin (:), delta_bin (:) integer :: n_bin real :: nox_sigma_ratio , ox_sigma_ratio real :: ox_sigma , ox_sig_sqr , ox_mu , nox_sigma , nox_sig_sqr , nox_mu real , allocatable :: y_nox (:), y_ox (:), y_Jd (:) integer , parameter :: nbin_Jd = 8760 ! Hours in a year integer :: bin_temp real , save :: y_Jd_acc ( nbin_Jd ) real :: mean_y_Jd_acc , y_Jd_acc_temp , y_Jd_acc_temp_log10 real :: y_all_val , y_all_prob , y_all_sum , y_all_prob_sum , y_all , y_annual , y_scale real :: azimuth_ang , zenith_ang real :: mol_nox , mol_no2 , mol_ox , mol_o3 , Jd double precision :: date_num integer :: i , j , k , l integer :: date_array ( 6 ) real :: min_sigma_ratio = 0.01 real :: bin_temp2 Na = 6.022e23 ! (molecules/mol) Na_fac = Na / 1.0e12 ! Conversion from ug/m3 to molecules/cm3 included k1 = 1.4e-12 * exp ( - 131 0.0 / temperature_in ) ! (cm&#94;3/s) and temperature in Kelvin mol_nox = nox_in * Na_fac / mmass ( nox_i ) mol_no2 = no2_in * Na_fac / mmass ( no2_i ) mol_o3 = o3_in * Na_fac / mmass ( o3_i ) mol_ox = mol_no2 + mol_o3 Jd = J_photo_in / k1 no2_out = no2_in o3_out = o3_in !Create the bins for the pdf in (mol/cm3). ox, nox and J log10_bin_max = log10 ( bin_max ) log10_bin_min = log10 ( bin_min ) n_bin = int (( log10_bin_max - log10_bin_min ) / delta_log10_bin ) + 1 ! Creates 80 bins with these settings allocate ( log10_bin ( n_bin )) allocate ( bin ( n_bin )) allocate ( delta_bin ( n_bin )) do i = 1 , n_bin log10_bin ( i ) = log10_bin_min + ( i - 1 ) * delta_log10_bin end do do i = 1 , n_bin bin ( i ) = ( 1 0.0 ** log10_bin ( i )) * Na_fac / mmass ( nox_i ) delta_bin ( i ) = ( 1 0.0 ** ( log10_bin ( i ) + delta_log10_bin / 2.0 ) - 1 0.0 ** ( log10_bin ( i ) - delta_log10_bin / 2.0 )) * Na_fac / mmass ( nox_i ) end do ! Distribute concentrations into the pdf bins ! Minimum needed to avoid NaNs in the calculation nox_sigma_ratio = 1.14 ox_sigma_ratio = 0.21 if ( abs ( nox_sigma_ratio_in ) > epsilon0 ) nox_sigma_ratio = max ( nox_sigma_ratio_in , min_sigma_ratio ) if ( abs ( ox_sigma_ratio_in ) > epsilon0 ) ox_sigma_ratio = max ( ox_sigma_ratio_in , min_sigma_ratio ) ox_sigma = mol_ox * ox_sigma_ratio ox_sig_sqr = log ( 1.0 + ox_sigma ** 2.0 / mol_ox ** 2.0 ) ox_mu = log ( mol_ox ** 2.0 / sqrt ( mol_ox ** 2.0 + ox_sigma ** 2.0 )) nox_sigma = mol_nox * nox_sigma_ratio nox_sig_sqr = log ( 1.0 + nox_sigma ** 2.0 / mol_nox ** 2.0 ) nox_mu = log ( mol_nox ** 2.0 / sqrt ( mol_nox ** 2.0 + nox_sigma ** 2.0 )) allocate ( y_ox ( n_bin )) allocate ( y_nox ( n_bin )) if ( . not . allocated ( y_Jd )) allocate ( y_Jd ( n_bin )) y_Jd = 0.0 y_ox = 0.0 y_nox = 0.0 do i = 1 , n_bin y_ox ( i ) = 1.0 / bin ( i ) / sqrt ( ox_sig_sqr ) / sqrt ( 2.0 * pi ) * exp ( - (( log ( bin ( i )) - ox_mu ) ** 2 ) / 2.0 / ox_sig_sqr ) * delta_bin ( i ) y_nox ( i ) = 1.0 / bin ( i ) / sqrt ( nox_sig_sqr ) / sqrt ( 2.0 * pi ) * exp ( - (( log ( bin ( i )) - nox_mu ) ** 2 ) / 2.0 / nox_sig_sqr ) * delta_bin ( i ) end do ! Create the Jd_acc distribution by looping through every hour in the year and extracting the zenith angle ! Only do this if requested for the first time if ( run_all ) then y_Jd_acc = 0 do i = 1 , nbin_Jd date_num = 1.0 + i / 2 4.0 date_array = 0 zenith_ang = 0.0 call get_sun_angles ( lat_in , lon_in , date_array , date_num , 0.0 , azimuth_ang , zenith_ang ) if ( zenith_ang . ge . 9 0.0 ) then y_Jd_acc ( i ) = 0 else y_Jd_acc ( i ) = (( cosd ( zenith_ang )) ** 0.28 ) end if end do end if mean_y_Jd_acc = sum ( y_Jd_acc ) / nbin_Jd do i = 1 , nbin_Jd y_Jd_acc_temp = Jd * y_Jd_acc ( i ) / mean_y_Jd_acc if ( y_Jd_acc_temp / Na_fac * mmass ( nox_i ) < bin_min ) then bin_temp = 1 else y_Jd_acc_temp_log10 = log10 ( y_Jd_acc_temp / Na_fac * mmass ( nox_i )) bin_temp = floor (( y_Jd_acc_temp_log10 - log10_bin_min ) / delta_log10_bin + 0.5 ) + 1 bin_temp = min ( max ( bin_temp , 1 ), n_bin ) end if y_Jd ( bin_temp ) = y_Jd ( bin_temp ) + 1 end do ! Normalise all distributions y_Jd = y_Jd / sum ( y_Jd ) y_ox = y_ox / sum ( y_ox ) y_nox = y_nox / sum ( y_nox ) !Calculate scaling based on photostationary assumption y_all_sum = 0 y_all_prob_sum = 0 do j = 1 , n_bin do k = 1 , n_bin do l = 1 , n_bin ! Calculate weighting y_all_prob = y_nox ( j ) * y_Jd ( k ) * y_ox ( l ) if ( y_all_prob . gt . 0.0 ) then ! Calculate NO2 value bin_temp2 = bin ( j ) + bin ( k ) + bin ( l ) y_all_val = ( bin_temp2 - sqrt ( bin_temp2 * bin_temp2 - 4.0 * bin ( j ) * bin ( l ))) / 2.0 ! Add weighted value y_all_sum = y_all_sum + y_all_val * y_all_prob ! Calculate sum of weights for normalisation later y_all_prob_sum = y_all_prob_sum + y_all_prob end if end do end do end do y_all = y_all_sum / y_all_prob_sum ! Calculate the mean value y_annual = (( mol_nox + Jd + mol_ox ) - sqrt (( mol_nox + Jd + mol_ox ) ** 2 - 4.0 * mol_nox * mol_ox )) / 2.0 y_scale = y_all / y_annual mol_no2_out = y_scale * mol_no2 mol_o3_out = mol_ox - mol_no2_out no2_out = mol_no2_out / Na_fac * mmass ( no2_i ) o3_out = mol_o3_out / Na_fac * mmass ( o3_i ) deallocate ( log10_bin ) deallocate ( bin ) deallocate ( delta_bin ) deallocate ( y_ox ) deallocate ( y_nox ) deallocate ( y_Jd ) end subroutine uEMEP_annual_mean_pdf_correction_NO2_O3 end module chemistry_no2","tags":"","loc":"sourcefile/uemep_chemistry_no2.f90.html"},{"title":"uEMEP_read_time_profiles.f90 – uEMEP","text":"Source Code module read_time_profiles use uemep_configuration use time_functions , only : day_of_week , summer_time_europe , number_to_date implicit none private public :: uEMEP_read_time_profiles contains !uEMEP_read_time_profiles.f90 subroutine uEMEP_read_time_profiles use uEMEP_definitions implicit none integer i , j character ( 256 ) temp_str integer unit_in logical :: exists integer week_day_temp double precision date_num_temp integer n_col !parameter (n_col=5) character ( 256 ), allocatable :: header_str (:) integer , allocatable :: source_index_in (:) integer temp_region_id integer n_hours_in_week , n_months_in_year integer , allocatable :: time_month_of_year_input (:), time_hour_of_week_input (:) real , allocatable :: val_month_of_year_input (:,:), val_hour_of_week_input (:,:) integer date_array ( 6 ) integer i_source , t , hour_of_week_index integer t_profile_loop integer emission_time_shift_temp integer i_cross , j_cross real hdd_temp integer col_val , index_val logical do_not_calculate_RWC_emissions !double precision date_to_number !emission_time_profile_subgrid=1. !Only read data if flag is correct if ( local_subgrid_method_flag . ne . 2 ) return write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading time profiles (uEMEP_read_time_profiles)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_timeprofile = trim ( pathname_timeprofile ) // trim ( filename_timeprofile ) !Test existence of the filename. If does not exist then use default inquire ( file = trim ( pathfilename_timeprofile ), exist = exists ) if (. not . exists ) then write ( * , '(A,A)' ) ' ERROR: Time profile data file does not exist: ' , trim ( pathfilename_timeprofile ) stop endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_timeprofile , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening time profile file: ' // trim ( pathfilename_timeprofile ) !Find the number of commas in the header to determine columns read ( unit_in , '(a)' ) temp_str !write(*,*) trim(temp_str),index(temp_str,',') col_val = 0 do while ( index ( temp_str , ',' ). ne . 0 ) index_val = index ( temp_str , ',' ) temp_str = temp_str ( index_val + 1 :) col_val = col_val + 1 !write(*,*) col_val,trim(temp_str) enddo n_col = col_val + 1 allocate ( header_str ( n_col )) allocate ( source_index_in ( n_col - 1 )) write ( unit_logfile , '(a,i)' ) ' Number of columns read: ' , n_col !stop rewind ( unit_in ) !Read source header string read ( unit_in , * ) header_str !write(unit_logfile,*) header_str !Read source index, correpsonding to uEMEP source indexes (change to SNAP or NFR later) read ( unit_in , * ) temp_str , source_index_in write ( unit_logfile , * ) trim ( temp_str ), source_index_in !Read region read ( unit_in , * ) temp_str , temp_region_id write ( unit_logfile , '(a,i)' ) trim ( temp_str ), temp_region_id !Read Hour_of_week read ( unit_in , * ) temp_str , n_hours_in_week write ( unit_logfile , '(a,i)' ) trim ( temp_str ), n_hours_in_week !write(*,*) num_week_traffic,days_in_week,hours_in_day,n_roadlinks if (. not . allocated ( time_hour_of_week_input )) allocate ( time_hour_of_week_input ( n_hours_in_week )) if (. not . allocated ( val_hour_of_week_input )) allocate ( val_hour_of_week_input ( n_hours_in_week , n_col - 1 )) do i = 1 , n_hours_in_week read ( unit_in , * ) time_hour_of_week_input ( i ), val_hour_of_week_input ( i , 1 : n_col - 1 ) !write(*,*) time_hour_of_week_input(i),val_hour_of_week_input(i,1:n_col-1) enddo !Read Hour_of_week read ( unit_in , * ) temp_str , n_months_in_year write ( unit_logfile , '(a,i)' ) trim ( temp_str ), n_months_in_year !write(*,*) num_week_traffic,days_in_week,hours_in_day,n_roadlinks if (. not . allocated ( time_month_of_year_input )) allocate ( time_month_of_year_input ( n_months_in_year )) if (. not . allocated ( val_month_of_year_input )) allocate ( val_month_of_year_input ( n_months_in_year , n_col - 1 )) do i = 1 , n_months_in_year read ( unit_in , * ) time_month_of_year_input ( i ), val_month_of_year_input ( i , 1 : n_col - 1 ) !write(*,*) time_month_of_year_input(i),val_month_of_year_input(i,1:n_col-1) enddo close ( unit_in , status = 'keep' ) !close(unit_in) !Normalise the data to be used with average emmissions to give an hourly average value and a monthly average value do i_source = 1 , n_col - 1 val_hour_of_week_input (:, i_source ) = val_hour_of_week_input (:, i_source ) / sum ( val_hour_of_week_input (:, i_source )) * n_hours_in_week val_month_of_year_input (:, i_source ) = val_month_of_year_input (:, i_source ) / sum ( val_month_of_year_input (:, i_source )) * n_months_in_year enddo !do i=1,n_hours_in_week !    write(*,*) time_hour_of_week_input(i),val_hour_of_week_input(i,1:n_col-1) !enddo !stop !Get time information for the current calculation !    if (use_single_time_loop_flag) then !        t_profile_loop=end_time_loop_index !    else !        t_profile_loop=dim_length_nc(time_dim_nc_index) !    endif t_profile_loop = dim_length_nc ( time_dim_nc_index ) do t = 1 , t_profile_loop !if (t.eq.t_loop) then !EMEP date is days since 1900 !write(*,*) val_dim_nc(t,time_dim_nc_index) !Round up the hour. Not here, is done earlier now !date_num_temp=dble(ceiling(val_dim_nc(t,time_dim_nc_index)*24.))/24. date_num_temp = val_dim_nc ( t , time_dim_nc_index ) !write(*,*) real(ceiling(val_dim_nc(t,time_dim_nc_index)*24.)),date_num_temp call number_to_date ( date_num_temp , date_array , ref_year_EMEP ) if ( t . eq . 1 ) write ( unit_logfile , '(a,6i6)' ) 'Date array start = ' , date_array if ( t . eq . t_profile_loop ) write ( unit_logfile , '(a,6i6)' ) 'Date array end = ' , date_array week_day_temp = day_of_week ( date_array ) !write(unit_logfile,*) 'Day of week = ',week_day_temp !write(*,*) t,date_array if ( summer_time_europe ( date_array )) then if ( auto_adjustment_for_summertime ) then emission_time_shift_temp = emission_timeprofile_hour_shift + 1 if ( t . eq . 1 ) write ( unit_logfile , '(a)' ) ' Emission profiles set to summer time. ' else emission_time_shift_temp = emission_timeprofile_hour_shift if ( t . eq . 1 ) write ( unit_logfile , '(a)' ) ' Emission profiles not adjusted for summer time. ' endif else emission_time_shift_temp = emission_timeprofile_hour_shift if ( t . eq . 1 ) write ( unit_logfile , '(a)' ) ' Emission profiles set to winter time. ' endif hour_of_week_index = ( week_day_temp - 1 ) * 24 + date_array ( 4 ) + emission_time_shift_temp if ( hour_of_week_index . gt . n_hours_in_week ) hour_of_week_index = hour_of_week_index - n_hours_in_week if ( hour_of_week_index . lt . 1 ) hour_of_week_index = hour_of_week_index + n_hours_in_week do i_source = 1 , n_col - 1 if ( calculate_source ( source_index_in ( i_source ))) then if ( source_index_in ( i_source ). eq . shipping_index . and . read_monthly_and_daily_shipping_data_flag ) then !Do nothing as the time profile has already been set in uEMEP_read_monthly_and_daily_shipping_asi_data subroutine !write(unit_logfile,'(a,i,es16.6)') 'Not resetting shipping time profiles: ',t,sum(emission_time_profile_subgrid(:,:,t,source_index_in(i_source),1)) else !Set the time profile emission_time_profile_subgrid (:,:, t , source_index_in ( i_source ),:) = val_hour_of_week_input ( hour_of_week_index , i_source ) * val_month_of_year_input ( date_array ( 2 ), i_source ) !if (source_index_in(i_source).eq.industry_index) write(*,*) 'TIME PROFILE: ',val_hour_of_week_input(hour_of_week_index,i_source),val_month_of_year_input(date_array(2),i_source) endif !write(*,*) hour_of_week_index,val_hour_of_week_input(hour_of_week_index,i_source),val_month_of_year_input(date_array(2),i_source) !write(*,*) emission_time_profile_subgrid(1,1,t,source_index_in(i_source),1) !Will  only do this calculation if for heat and only if meteorology exists !This is poorly poisitioned here because it can be called even when no meteorology is available, hence the allocation check do_not_calculate_RWC_emissions = . false . if ( source_index_in ( i_source ). eq . heating_index . and . use_RWC_emission_data ) then do j = 1 , emission_subgrid_dim ( y_dim_index , source_index_in ( i_source )) do i = 1 , emission_subgrid_dim ( x_dim_index , source_index_in ( i_source )) if ( save_emissions_for_EMEP ( allsource_index )) then if ( allocated ( meteo_var1d_nc )) then !Need to cross reference the meteo grid to the emission grid as this is not done normally !Tricky using the two different emep grids? !Not certain if this 0.5 is correct. Not used else where i_cross = 1 + floor (( x_emission_subgrid ( i , j , source_index_in ( i_source )) - meteo_var1d_nc ( 1 , lon_nc_index )) / meteo_dgrid_nc ( lon_nc_index ) + 0.5 ) j_cross = 1 + floor (( y_emission_subgrid ( i , j , source_index_in ( i_source )) - meteo_var1d_nc ( 1 , lat_nc_index )) / meteo_dgrid_nc ( lat_nc_index ) + 0.5 ) !Because the meteo grid can be smaller than the EMEP grid then need to limit it !write(*,'(6i12)') i,j,i_cross,j_cross,dim_length_meteo_nc(x_dim_nc_index),dim_length_meteo_nc(y_dim_nc_index) i_cross = min ( max ( 1 , i_cross ), dim_length_meteo_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_meteo_nc ( y_dim_nc_index )) else !Do not do this calculation until the meteo data is available !write(unit_logfile,'(a)') ' No meteo data available for RWC heating emission calculations. Stopping' !stop !i_cross=1 !j_cross=1 do_not_calculate_RWC_emissions = . true . endif else !Use the EMEP meteorology i_cross = crossreference_emission_to_emep_subgrid ( i , j , x_dim_index , source_index_in ( i_source )) j_cross = crossreference_emission_to_emep_subgrid ( i , j , y_dim_index , source_index_in ( i_source )) i_cross = min ( max ( 1 , i_cross ), dim_length_nc ( x_dim_nc_index )) j_cross = min ( max ( 1 , j_cross ), dim_length_nc ( y_dim_nc_index )) endif if (. not . do_not_calculate_RWC_emissions ) then hdd_temp = max ( 0. , HDD_threshold_value - max ( DMT_min_value , DMT_EMEP_grid_nc ( i_cross , j_cross , 1 ))) !write (*,*) hdd_temp,DMT_EMEP_grid_nc(i_cross,j_cross,1),max(DMT_min_value,DMT_EMEP_grid_nc(i_cross,j_cross,1)),HDD_threshold_value-max(DMT_min_value,DMT_EMEP_grid_nc(i_cross,j_cross,1)) !the heating emissions have already been normalised with RWC_grid_HDD in uEMEP_read_RWC_heating_data emission_time_profile_subgrid ( i , j , t , source_index_in ( i_source ),:) = val_hour_of_week_input ( hour_of_week_index , i_source ) / 2 4. * hdd_temp !if (i.eq.1.and.j.eq.1) write(*,*) t,hour_of_week_index,val_hour_of_week_input(hour_of_week_index,i_source)/24.,hdd_temp,HDD_threshold_value,DMT_EMEP_grid_nc(i_cross,j_cross,1) !if (i.eq.1.and.j.eq.1) write(*,*) t,hour_of_week_index,emission_time_profile_subgrid(i,j,t,source_index_in(i_source),1) endif enddo enddo endif endif enddo if ( annual_calculations ) then emission_time_profile_subgrid (:,:, t ,:,:) = 1. endif enddo deallocate ( time_hour_of_week_input ) deallocate ( val_hour_of_week_input ) deallocate ( time_month_of_year_input ) deallocate ( val_month_of_year_input ) end subroutine uEMEP_read_time_profiles end module read_time_profiles","tags":"","loc":"sourcefile/uemep_read_time_profiles.f90.html"},{"title":"rargsort.f90 – uEMEP","text":"Source Code module mod_rargsort implicit none private public :: rargsort contains ! https://github.com/certik/fortran-utils/blob/master/src/sorting.f90 subroutine rargsort ( a , b , n_a ) ! Returns the indices that would sort an array. ! ! Arguments ! --------- ! integer n_a real , intent ( in ) :: a ( n_a ) ! array of numbers integer , intent ( out ) :: b ( n_a ) ! indices into the array 'a' that sort it !integer :: rargsort(size(a)) ! ! Example ! ------- ! ! rargsort([4.1_dp, 2.1_dp, 2.05_dp, -1.5_dp, 4.2_dp]) ! Returns [4, 3, 2, 1, 5] integer :: N ! number of numbers/vectors integer :: i , imin ! indices: i, i of smallest integer :: temp1 ! temporary real :: temp2 real :: a2 ( n_a ) !write(*,*) a a2 = a N = size ( a ) do i = 1 , N b ( i ) = i end do do i = 1 , N - 1 ! find ith smallest in 'a' imin = minloc ( a2 ( i :), 1 ) + i - 1 ! swap to position i in 'a' and 'b', if not already there if ( imin /= i ) then temp2 = a2 ( i ); a2 ( i ) = a2 ( imin ); a2 ( imin ) = temp2 temp1 = b ( i ); b ( i ) = b ( imin ); b ( imin ) = temp1 end if end do !rargsort=b end subroutine function rargsort_original ( a ) result ( b ) ! Returns the indices that would sort an array. ! ! Arguments ! --------- ! real , intent ( in ) :: a (:) ! array of numbers integer :: b ( size ( a )) ! indices into the array 'a' that sort it ! ! Example ! ------- ! ! rargsort([4.1_dp, 2.1_dp, 2.05_dp, -1.5_dp, 4.2_dp]) ! Returns [4, 3, 2, 1, 5] integer :: N ! number of numbers/vectors integer :: i , imin ! indices: i, i of smallest integer :: temp1 ! temporary real :: temp2 real :: a2 ( size ( a )) a2 = a N = size ( a ) do i = 1 , N b ( i ) = i end do do i = 1 , N - 1 ! find ith smallest in 'a' imin = minloc ( a2 ( i :), 1 ) + i - 1 ! swap to position i in 'a' and 'b', if not already there if ( imin /= i ) then temp2 = a2 ( i ); a2 ( i ) = a2 ( imin ); a2 ( imin ) = temp2 temp1 = b ( i ); b ( i ) = b ( imin ); b ( imin ) = temp1 end if end do end function end module mod_rargsort","tags":"","loc":"sourcefile/rargsort.f90.html"},{"title":"uEMEP_set_filenames.f90 – uEMEP","text":"Source Code module set_filenames use uEMEP_definitions !, only: pathname_grid, filename_grid, source_file_str use uemep_configuration !, only: pathname_output_grid, save_netcdf_fraction_as_contribution_flag implicit none private public :: uEMEP_set_filenames contains subroutine uEMEP_set_filenames () !! Set filenames for all gridded data to be saved !! These are the names now given in the netcdf files ! Local variables integer :: i ! Set pathname for all gridded data to be saved pathname_grid (:) = pathname_output_grid do i = 1 , n_source_index filename_grid ( proxy_emission_file_index ( i )) = trim ( 'proxy_emission_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emission_file_index ( i )) = trim ( 'emission_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_file_index ( i )) = trim ( 'proxy_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_integral_file_index ( i )) = trim ( 'proxy_integral_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_file_index ( i )) = trim ( 'EMEP_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_nonlocal_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_local_file_index ( i )) = trim ( 'EMEP_local_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_additional_nonlocal_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_local_file_index ( i )) = trim ( 'EMEP_additional_local_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_frac_file_index ( i )) = trim ( 'EMEP_frac_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_local_file_index ( i )) = trim ( 'local_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_total_file_index ( i )) = trim ( 'total_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( use_subgrid_file_index ( i )) = trim ( 'use_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_emission_subgrid_file_index ( i )) = trim ( 'EMEP_emission_subgrid' ) // '_' // trim ( source_file_str ( i )) end do ! Alternative set of names for outputs to netcdf do i = 1 , n_source_index filename_grid ( proxy_emission_file_index ( i )) = trim ( 'proxy_emission' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emission_file_index ( i )) = trim ( 'emission' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_file_index ( i )) = trim ( 'proxy' ) // '_' // trim ( source_file_str ( i )) filename_grid ( proxy_integral_file_index ( i )) = trim ( 'proxy_integral' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_file_index ( i )) = trim ( 'EMEP' ) // '_' // trim ( source_file_str ( i )) if ( save_netcdf_fraction_as_contribution_flag ) then filename_grid ( emep_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_nonlocal_contribution' ) filename_grid ( emep_subgrid_local_file_index ( i )) = trim ( 'EMEP_local_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_additional_nonlocal_contribution' ) filename_grid ( emep_additional_subgrid_local_file_index ( i )) = trim ( 'EMEP_additional_local_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_frac_file_index ( i )) = trim ( 'EMEP_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_local_file_index ( i )) = trim ( 'local_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_semilocal_file_index ( i )) = trim ( 'EMEP_semilocal_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_inregion_file_index ( i )) = trim ( 'total_contribution' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_file_index ( i )) = trim ( 'total_contribution' ) // '_' // trim ( source_file_str ( i )) else filename_grid ( emep_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_nonlocal_fraction' ) filename_grid ( emep_subgrid_local_file_index ( i )) = trim ( 'EMEP_local_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_additional_subgrid_nonlocal_file_index ( i )) = trim ( 'EMEP_additional_nonlocal_fraction' ) filename_grid ( emep_additional_subgrid_local_file_index ( i )) = trim ( 'EMEP_additional_local_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_frac_file_index ( i )) = trim ( 'EMEP_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_local_file_index ( i )) = trim ( 'local_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_subgrid_semilocal_file_index ( i )) = trim ( 'EMEP_semilocal_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_inregion_file_index ( i )) = trim ( 'total_fraction' ) // '_' // trim ( source_file_str ( i )) filename_grid ( subgrid_sourcetotal_file_index ( i )) = trim ( 'total_fraction' ) // '_' // trim ( source_file_str ( i )) end if filename_grid ( subgrid_total_file_index ( i )) = trim ( 'total' ) // '_' // trim ( source_file_str ( i )) filename_grid ( use_subgrid_file_index ( i )) = trim ( 'use_subgrid' ) // '_' // trim ( source_file_str ( i )) filename_grid ( emep_emission_subgrid_file_index ( i )) = trim ( 'EMEP_emission' ) // '_' // trim ( source_file_str ( i )) end do filename_grid ( population_file_index ( dwelling_index )) = trim ( 'dwelling' ) filename_grid ( population_file_index ( population_index )) = trim ( 'population' ) filename_grid ( population_file_index ( school_index )) = trim ( 'school' ) filename_grid ( population_file_index ( establishment_index )) = trim ( 'establishment' ) filename_grid ( population_file_index ( kindergaten_index )) = trim ( 'kindergaten' ) filename_grid ( population_file_index ( home_index )) = trim ( 'home' ) ! Meteo file names filename_grid ( subgrid_ugrid_file_index ) = 'xgrid_wind' filename_grid ( subgrid_vgrid_file_index ) = 'ygrid_wind' filename_grid ( subgrid_u10_file_index ) = 'x10_wind' filename_grid ( subgrid_v10_file_index ) = 'y10_wind' filename_grid ( subgrid_hmix_file_index ) = 'hmix' filename_grid ( subgrid_kz_file_index ) = 'kz' filename_grid ( subgrid_logz0_file_index ) = 'logz0' filename_grid ( subgrid_invL_file_index ) = 'inv_L' filename_grid ( subgrid_FFgrid_file_index ) = 'wind_speed_grid' filename_grid ( subgrid_DDgrid_file_index ) = 'wind_direction_grid' filename_grid ( subgrid_FF10_file_index ) = 'wind_speed_10m' filename_grid ( subgrid_DD10_file_index ) = 'wind_direction_10m' filename_grid ( subgrid_invFFgrid_file_index ) = 'inv_FFgrid' filename_grid ( subgrid_invFF10_file_index ) = 'inv_FF10' filename_grid ( subgrid_ustar_file_index ) = 'ustar' filename_grid ( subgrid_J_file_index ) = 'J_photo' filename_grid ( subgrid_t2m_file_index ) = 'air_temperature_2m' end subroutine uEMEP_set_filenames end module set_filenames","tags":"","loc":"sourcefile/uemep_set_filenames.f90.html"},{"title":"uEMEP_read_receptor_data.f90 – uEMEP","text":"Source Code module read_receptor_data use uemep_configuration use utility_functions , only : ll2utm , ll2ltm use mod_lambert_projection , only : LL2LAEA implicit none private public :: uEMEP_read_receptor_data , uEMEP_set_loop_receptor_grid , uEMEP_grid_receptor_data contains !uEMEP_read_receptor_data !Reads in receptor positions and names subroutine uEMEP_read_receptor_data use uEMEP_definitions implicit none integer k logical exists character ( 256 ) temp_str integer unit_in integer count logical unique_receptor ( n_receptor_max ) integer kk integer :: io use_receptor = . true . if ( use_receptor_positions_for_auto_subgrid_flag . or . use_multiple_receptor_grids_flag . or . save_netcdf_receptor_flag ) then else return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Reading receptor positions (uEMEP_read_receptor_data)' write ( unit_logfile , '(A)' ) '================================================================' pathfilename_receptor = trim ( pathname_receptor ) // trim ( filename_receptor ) !write(*,*) pathname_rl(2),filename_rl(2),pathfilename_rl(2) !Test existence of the road link filename (2). If does not exist then use default inquire ( file = trim ( pathfilename_receptor ), exist = exists ) if (. not . exists ) then if ( use_multiple_receptor_grids_flag ) then write ( unit_logfile , '(A,A)' ) ' ERROR: Receptor file does not exist. Cannot calculate: ' , trim ( pathfilename_receptor ) stop else write ( unit_logfile , '(A,A)' ) ' WARNING: Receptor file does not exist. Will not provide receptor output: ' , trim ( pathfilename_receptor ) n_receptor = 0 n_receptor_in = n_receptor n_valid_receptor = 0 n_valid_receptor_in = n_valid_receptor return endif endif !Open the file for reading unit_in = 20 open ( unit_in , file = pathfilename_receptor , access = 'sequential' , status = 'old' , readonly ) write ( unit_logfile , '(a)' ) ' Opening receptor file ' // trim ( pathfilename_receptor ) rewind ( unit_in ) !call NXTDAT(unit_in,nxtdat_flag) !read the header to find out how many links there are read ( unit_in , '(a)' , iostat = io ) temp_str if ( io == 0 ) then k = 0 do while ( k . lt . n_receptor_max ) k = k + 1 read ( unit_in , * , iostat = io ) name_receptor ( k , 1 ), lon_receptor ( k ), lat_receptor ( k ), height_receptor ( k ) !,name_receptor(k,2) if ( io /= 0 ) exit !write(*,*) trim(name_receptor(k,1)),lon_receptor(k),lat_receptor(k),trim(name_receptor(k,2)) enddo end if close ( unit_in ) n_receptor = k write ( unit_logfile , '(a,2i)' ) ' Number of receptor points and max allowable = ' , n_receptor , n_receptor_max !Convert to x,y positions do k = 1 , n_receptor if ( projection_type . eq . RDM_projection_index ) then !No conversion exists for RDM elseif ( projection_type . eq . UTM_projection_index ) then call ll2utm ( 1 , utm_zone , lat_receptor ( k ), lon_receptor ( k ), y_receptor ( k ), x_receptor ( k )) elseif ( projection_type . eq . LTM_projection_index ) then call ll2ltm ( 1 , ltm_lon0 , lat_receptor ( k ), lon_receptor ( k ), y_receptor ( k ), x_receptor ( k )) elseif ( projection_type . eq . LAEA_projection_index ) then call LL2LAEA ( x_receptor ( k ), y_receptor ( k ), lon_receptor ( k ), lat_receptor ( k ), projection_attributes ) endif enddo !Save the receptor data in the 'in' array as the other arrays can be changed n_receptor_in = n_receptor if ( use_multiple_receptor_grids_flag ) then n_receptor_in = n_receptor name_receptor_in = name_receptor lon_receptor_in = lon_receptor lat_receptor_in = lat_receptor x_receptor_in = x_receptor y_receptor_in = y_receptor height_receptor_in = height_receptor endif !Identify receptors within the initial subgrid region and only calculate these init_subgrid_dim ( x_dim_index ) = floor (( init_subgrid_max ( x_dim_index ) - init_subgrid_min ( x_dim_index )) / init_subgrid_delta ( x_dim_index )) + 1 init_subgrid_dim ( y_dim_index ) = floor (( init_subgrid_max ( y_dim_index ) - init_subgrid_min ( y_dim_index )) / init_subgrid_delta ( y_dim_index )) + 1 write ( unit_logfile , '(a,2i)' ) ' Number of initial subgrid = ' , init_subgrid_dim ( x_dim_index ), init_subgrid_dim ( y_dim_index ) write ( unit_logfile , '(a,2f12.1)' ) ' Size of initial subgrid = ' , init_subgrid_max ( x_dim_index ) - init_subgrid_min ( x_dim_index ), init_subgrid_max ( y_dim_index ) - init_subgrid_min ( y_dim_index ) !Remove identically named receptors count = 0 unique_receptor = . true . do k = 1 , n_receptor do kk = 1 , n_receptor if ( trim ( name_receptor ( k , 1 )). eq . trim ( name_receptor ( kk , 1 )). and . unique_receptor ( k ). and . k . ne . kk ) then unique_receptor ( kk ) = . false . endif enddo enddo !Select receptors within the initial grid and with unique names do k = 1 , n_receptor i_receptor_subgrid ( k ) = 1 + floor (( x_receptor ( k ) - init_subgrid_min ( x_dim_index )) / init_subgrid_delta ( x_dim_index )) j_receptor_subgrid ( k ) = 1 + floor (( y_receptor ( k ) - init_subgrid_min ( y_dim_index )) / init_subgrid_delta ( y_dim_index )) !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) !Set subgrid use or not. At grid and surrounding grids in case of interpolation later if ( i_receptor_subgrid ( k ). gt . 1. and . i_receptor_subgrid ( k ). lt . init_subgrid_dim ( x_dim_index ). and . j_receptor_subgrid ( k ). gt . 1. and . j_receptor_subgrid ( k ). lt . init_subgrid_dim ( y_dim_index ). and . unique_receptor ( k )) then use_receptor ( k ) = . true . !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) count = count + 1 valid_receptor_index ( count ) = k valid_receptor_inverse_index ( k ) = count write ( unit_logfile , '(a,a12,3f12.1)' ) ' Receptor and grid positions (x,y,h) = ' , trim ( name_receptor ( k , 1 )), x_receptor ( k ) - init_subgrid_min ( x_dim_index ), y_receptor ( k ) - init_subgrid_min ( y_dim_index ), height_receptor ( k ) else use_receptor ( k ) = . false . valid_receptor_inverse_index ( k ) = 0 endif enddo n_valid_receptor = count n_valid_receptor_in = n_valid_receptor write ( unit_logfile , '(a,i)' ) ' Total number of receptors to be calculated = ' , n_valid_receptor end subroutine uEMEP_read_receptor_data subroutine uEMEP_grid_receptor_data use uEMEP_definitions implicit none integer i , j , k integer count logical use_receptor_temp !integer :: use_region=2 ! +/- number of grids to loop around so that receptor positions can be interpolated linearly if ( use_receptor_positions_for_auto_subgrid_flag . or . use_multiple_receptor_grids_flag ) then else return endif write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Gridding receptor positions (uEMEP_grid_receptor_data)' write ( unit_logfile , '(A)' ) '================================================================' !Find the target grid positions of the receptor points use_subgrid = . false . count = 0 do k = 1 , n_receptor !Always true when using use_multiple_receptor_grids_flag as this is inside the use_receptor loop if ( use_multiple_receptor_grids_flag ) then use_receptor_temp = . true . else use_receptor_temp = use_receptor ( k ) endif if ( use_receptor_temp ) then i_receptor_subgrid ( k ) = 1 + floor (( x_receptor ( k ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) j_receptor_subgrid ( k ) = 1 + floor (( y_receptor ( k ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) !write(*,*) 'HERE2: ',i_receptor_subgrid(k),j_receptor_subgrid(k) !Set subgrid use or not. At grid and surrounding grids in case of interpolation later if ( i_receptor_subgrid ( k ). gt . use_receptor_region . and . i_receptor_subgrid ( k ). lt . subgrid_dim ( x_dim_index ) - use_receptor_region + 1. and . j_receptor_subgrid ( k ). gt . use_receptor_region . and . j_receptor_subgrid ( k ). lt . subgrid_dim ( y_dim_index ) - use_receptor_region + 1 ) then use_subgrid ( i_receptor_subgrid ( k ) - use_receptor_region : i_receptor_subgrid ( k ) + use_receptor_region , j_receptor_subgrid ( k ) - use_receptor_region : j_receptor_subgrid ( k ) + use_receptor_region ,:) = . true . !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) count = count + 1 endif endif enddo write ( unit_logfile , '(a,i)' ) ' Number of receptor points available in region = ' , count count = 0 do j = 1 , subgrid_dim ( y_dim_index ) do i = 1 , subgrid_dim ( x_dim_index ) if ( use_subgrid ( i , j , allsource_index )) count = count + 1 enddo enddo write ( unit_logfile , '(a,i)' ) ' Number of subgrids to be calculated = ' , count end subroutine uEMEP_grid_receptor_data subroutine uEMEP_set_loop_receptor_grid use uEMEP_definitions implicit none integer k integer count !integer :: use_region=2 ! +/- number of grids to loop around so that receptor positions can be interpolated linearly real x_ref , y_ref if (. not . use_multiple_receptor_grids_flag ) then return endif !if (g_loop.eq.start_grid_loop_index) then write ( unit_logfile , '(A)' ) '' write ( unit_logfile , '(A)' ) '================================================================' write ( unit_logfile , '(A)' ) 'Starting receptor loop (uEMEP_set_loop_receptor_grid)' write ( unit_logfile , '(A)' ) '================================================================' ! endif k = 1 if ( use_multiple_receptor_grids_flag ) then name_receptor ( k ,:) = name_receptor_in ( g_loop ,:) lon_receptor ( k ) = lon_receptor_in ( g_loop ) lat_receptor ( k ) = lat_receptor_in ( g_loop ) x_receptor ( k ) = x_receptor_in ( g_loop ) y_receptor ( k ) = y_receptor_in ( g_loop ) height_receptor ( k ) = height_receptor_in ( g_loop ) endif !Set lowest left edge of subgrid receptor position would be in x_ref = ( floor (( x_receptor ( k ) - subgrid_receptor_offset ( x_dim_index )) / subgrid_delta ( x_dim_index ) + 0.0 )) * subgrid_delta ( x_dim_index ) + subgrid_receptor_offset ( x_dim_index ) y_ref = ( floor (( y_receptor ( k ) - subgrid_receptor_offset ( y_dim_index )) / subgrid_delta ( y_dim_index ) + 0.0 )) * subgrid_delta ( y_dim_index ) + subgrid_receptor_offset ( y_dim_index ) !Set limits subgrid_min ( x_dim_index ) = x_ref - subgrid_delta ( x_dim_index ) * ( use_receptor_region ) * 1.0 subgrid_min ( y_dim_index ) = y_ref - subgrid_delta ( y_dim_index ) * ( use_receptor_region ) * 1.0 subgrid_max ( x_dim_index ) = x_ref + subgrid_delta ( x_dim_index ) * ( use_receptor_region + 1 ) * 1.0 subgrid_max ( y_dim_index ) = y_ref + subgrid_delta ( y_dim_index ) * ( use_receptor_region + 1 ) * 1.0 subgrid_dim ( x_dim_index ) = floor (( subgrid_max ( x_dim_index ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) + 1 subgrid_dim ( y_dim_index ) = floor (( subgrid_max ( y_dim_index ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) + 1 z_rec = height_receptor ( k ) write ( unit_logfile , '(a,i12,a)' ) ' Receptor loop number = ' , g_loop , ' ' // trim ( name_receptor ( k , 1 )) write ( unit_logfile , '(a,4f12.1)' ) ' Receptor and grid positions (x,y) = ' , x_receptor ( k ), x_ref , y_receptor ( k ), y_ref write ( unit_logfile , '(a,2i)' ) ' Number of receptor subgrids = ' , subgrid_dim ( x_dim_index ), subgrid_dim ( y_dim_index ) write ( unit_logfile , '(a,f12.1)' ) ' Receptor height (m) = ' , z_rec ( allsource_index , 1 ) !Find the target grid positions of the receptor points count = 0 !do k=1,n_receptor i_receptor_subgrid ( k ) = 1 + floor (( x_receptor ( k ) - subgrid_min ( x_dim_index )) / subgrid_delta ( x_dim_index )) j_receptor_subgrid ( k ) = 1 + floor (( y_receptor ( k ) - subgrid_min ( y_dim_index )) / subgrid_delta ( y_dim_index )) write ( unit_logfile , '(a,2i)' ) ' Receptor subgrid index = ' , i_receptor_subgrid ( k ), j_receptor_subgrid ( k ) !Set subgrid use or not. At grid and surrounding grids in case of interpolation later if ( i_receptor_subgrid ( k ). gt . use_receptor_region . and . i_receptor_subgrid ( k ). lt . subgrid_dim ( x_dim_index ) - use_receptor_region + 1. and . j_receptor_subgrid ( k ). gt . use_receptor_region . and . j_receptor_subgrid ( k ). lt . subgrid_dim ( y_dim_index ) - use_receptor_region + 1 ) then use_subgrid ( i_receptor_subgrid ( k ) - use_receptor_region : i_receptor_subgrid ( k ) + use_receptor_region , j_receptor_subgrid ( k ) - use_receptor_region : j_receptor_subgrid ( k ) + use_receptor_region ,:) = . true . !write(*,*) trim(name_receptor(k,1)),i_receptor_subgrid(k),j_receptor_subgrid(k) count = count + 1 endif !enddo write ( unit_logfile , '(a,i)' ) ' Number of receptor points available in region = ' , count !count=0 !do j=1,subgrid_dim(y_dim_index) !do i=1,subgrid_dim(x_dim_index) !    if (use_subgrid(i,j,allsource_index)) count=count+1 !enddo !enddo !write(unit_logfile,'(a,i)') ' Number of subgrids to be calculated = ', count end subroutine uEMEP_set_loop_receptor_grid end module read_receptor_data","tags":"","loc":"sourcefile/uemep_read_receptor_data.f90.html"},{"title":"uEMEP_set_dispersion_params.f90 – uEMEP","text":"Source Code module set_dispersion_parameters use uemep_configuration implicit none private public :: uEMEP_set_dispersion_sigma_simple , delta_wind_direction , & uEMEP_set_dispersion_sigma_PG , uEMEP_set_dispersion_sigma_Kz_emulator , & uEMEP_set_dispersion_params_simple , uEMEP_set_dispersion_params_PG contains !uEMEP_set_dispersion_params.f90 !Routines for calculating dispersion parameters when sig_z and sig_y are defined as sig=sig0+a*x&#94;b subroutine uEMEP_set_dispersion_params_simple ( source_index , subsource_index ) use uEMEP_definitions implicit none integer source_index , subsource_index !Set the psedo dispersion parameters here. ay ( source_index , subsource_index ) = 0.32 by ( source_index , subsource_index ) = 0.78 az ( source_index , subsource_index ) = 0.22 bz ( source_index , subsource_index ) = 0.78 !ay(source_index,subsource_index)=0.64!From Liu !by(source_index,subsource_index)=0.46!From Liu !az(source_index,subsource_index)=0.088!From Liu !bz(source_index,subsource_index)=0.72!From Liu 0.72 !ay(source_index,subsource_index)=0.32 !by(source_index,subsource_index)=0.78 az ( source_index , subsource_index ) = 0.2 bz ( source_index , subsource_index ) = 0.75 !Alternative to ASME !ay(source_index,subsource_index)=0.14 !by(source_index,subsource_index)=0.9 !az(source_index,subsource_index)=0.22 !bz(source_index,subsource_index)=0.85 !sig_y_0(source_index,subsource_index)=sig_y_00(source_index,subsource_index) !sig_z_0(source_index,subsource_index)=sig_z_00(source_index,subsource_index) !sig_y_0(source_index,subsource_index)=sig_y_00(source_index,subsource_index)+sqrt(emission_subgrid_delta(x_dim_index,source_index)*emission_subgrid_delta(y_dim_index,source_index))/2. !sig_z_0(source_index,subsource_index)=sig_z_00(source_index,subsource_index)+az(source_index,subsource_index)*exp(bz(source_index,subsource_index)*log(sig_y_0(source_index,subsource_index))) !h_emis(source_index,subsource_index)=1. !z_rec(source_index,subsource_index)=2. !Exceptions !ay=ay*3. !az=az*5. !bz=0.95 end subroutine uEMEP_set_dispersion_params_simple subroutine uEMEP_set_dispersion_params_PG ( invL , source_index , subsource_index ) use uEMEP_definitions implicit none integer source_index , subsource_index real invL integer class_index real min_xy real ay_pg ( 6 ), by_pg ( 6 ), az_pg ( 6 ), bz_pg ( 6 ) real L_class ( 5 ), invL_class ( 5 ) data ay_pg / 0.469 , 0.306 , 0.230 , 0.219 , 0.237 , 0.237 / data by_pg / 0.903 , 0.855 , 0.855 , 0.764 , 0.691 , 0.594 / data az_pg / 0.017 , 0.072 , 0.076 , 0.140 , 0.217 , 0.262 / data bz_pg / 1.38 , 1.021 , 0.879 , 0.727 , 0.610 , 0.500 / !data L_class /-10.,-25.,-200.,200.,25./ data L_class /- 1 0. , - 2 5. , - 10 0. , 5 0. , 5. / invL_class = 1. / L_class if ( invL . le . invL_class ( 1 )) then class_index = 1 elseif ( invL . gt . invL_class ( 1 ). and . invL . le . invL_class ( 2 )) then class_index = 2 elseif ( invL . gt . invL_class ( 2 ). and . invL . le . invL_class ( 3 )) then class_index = 3 elseif ( invL . gt . invL_class ( 3 ). and . invL . le . invL_class ( 4 )) then class_index = 4 elseif ( invL . gt . invL_class ( 4 ). and . invL . le . invL_class ( 5 )) then class_index = 5 elseif ( invL . gt . invL_class ( 5 )) then class_index = 6 else class_index = 0 write ( * , * ) 'No stability class found. Stopping' , invL write ( * , * ) 'No stability class found. Stopping' , 1. / invL stop endif !if (class_index.ne.4) write(*,*) invL,class_index !Set the dispersion parameters here. ay ( source_index , subsource_index ) = ay_pg ( class_index ) by ( source_index , subsource_index ) = by_pg ( class_index ) az ( source_index , subsource_index ) = az_pg ( class_index ) bz ( source_index , subsource_index ) = bz_pg ( class_index ) !if (bz(source_index,subsource_index).ne.0.727) write(*,*) invL,class_index,bz(source_index,subsource_index) !ay(source_index,subsource_index)=0.219 !by(source_index,subsource_index)=0.764 !az(source_index,subsource_index)=0.114 !bz(source_index,subsource_index)=0.727 !Changed this to use the min_xy value as in all other routines using sigy_0_subgid_width_scale (13.12.2019) !Not important because this is set properly in uEMEP_set_dispersion_sigma_PG which is called afterwards min_xy = ( emission_subgrid_delta ( x_dim_index , source_index ) + emission_subgrid_delta ( y_dim_index , source_index )) / 4. !sig_y_0(source_index,subsource_index)=sig_y_00(source_index,subsource_index)+sqrt(emission_subgrid_delta(x_dim_index,source_index)*emission_subgrid_delta(y_dim_index,source_index))/4.*sigy_0_subgid_width_scale sig_y_0 ( source_index , subsource_index ) = sig_y_00 ( source_index , subsource_index ) + min_xy * sigy_0_subgid_width_scale sig_z_0 ( source_index , subsource_index ) = sig_z_00 ( source_index , subsource_index ) + az ( source_index , subsource_index ) * exp ( bz ( source_index , subsource_index ) * log ( sig_y_0 ( source_index , subsource_index ))) end subroutine uEMEP_set_dispersion_params_PG subroutine delta_wind_direction ( i_cross , j_cross , tt , temp_FF_subgrid , angle_diff ) use uEMEP_definitions implicit none integer , intent ( in ) :: i_cross , j_cross , tt real , intent ( in ) :: temp_FF_subgrid real , intent ( out ) :: angle_diff real :: meandering_degree_max = 2 0. real cos_subgrid_loc , sin_subgrid_loc if ( use_last_meteo_in_dispersion ) then cos_subgrid_loc = meteo_subgrid ( i_cross , j_cross , tt , cos_subgrid_index ) sin_subgrid_loc = meteo_subgrid ( i_cross , j_cross , tt , sin_subgrid_index ) angle_diff = abs ( asin ( meteo_subgrid ( i_cross , j_cross , tt , sin_subgrid_index ) * last_meteo_subgrid ( i_cross , j_cross , cos_subgrid_index ) & - meteo_subgrid ( i_cross , j_cross , tt , cos_subgrid_index ) * last_meteo_subgrid ( i_cross , j_cross , sin_subgrid_index ) )) / 2. angle_diff = min ( angle_diff , 3.14159 / 4. ) !Less than 45 degrees !write(*,*) i_cross,j_cross,angle_diff(i_cross,j_cross)*180/3.14159 else angle_diff = 0. endif if ( use_meandering_in_dispersion ) then angle_diff = angle_diff + ( meandering_degree_max * 3.14159 / 18 0. ) * exp ( - ( temp_FF_subgrid - FF_min_dispersion ) / ( FF_min_dispersion * 2. )) endif end subroutine delta_wind_direction subroutine uEMEP_set_dispersion_sigma_simple ( sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta , delta_wind , x , sig_z , sig_y , sig_z_0 , sig_y_0 ) implicit none real , intent ( in ) :: sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta ( 2 ), delta_wind , x real , intent ( out ) :: sig_z , sig_y , sig_z_0 , sig_y_0 real ay , by , az , bz real min_xy !Set the psedo dispersion parameters for neutral conditions !From Klug !ay=0.32 !by=0.78 !az=0.22 !bz=0.78 !From Liu !ay=0.64 !by=0.46!From Liu !az=0.088!From Liu !bz=0.72!From Liu 0.72 !Alternative ASME !ay=0.14 !by=0.9 !az=0.22 !bz=0.85 !Update from K_z fitting ay = 0.32 by = 0.78 !az=0.19 !bz=0.77 az = 0.125 bz = 0.85 !For z0=0.1, corresponding to the same as K_z for wind height at emission source of 1 m az = 0.245 bz = 0.711 !For z0=0.3, corresponding to the same as K_z for wind height at average of emission source of 1 m and zc az = 0.21 bz = 0.79 !For z0=0.3, corresponding to the same as K_z for wind height at emission source of 1 m !Consistant with uEMEP_set_dispersion_params_PG needs to be fixed. Just one call to the parameters, one calle to the sigma calculation az = 0.2 bz = 0.75 min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. !Set sig_y_0 to be half of the average x,y grid size !Add this here ay*exp(by*log(min_xy)) to be the same as sig_z and the same as the  Kz calculation !Does not mean it is correct, just closer to the Kz which is perhaps not so correct sig_y_0 = sig_y_00 + min_xy * sigy_0_subgid_width_scale + ay * exp ( by * log ( min_xy )) !Set sig_z_0 to be the size of the plume after travelling half of the grid size sig_z_0 = sig_z_00 + az * exp ( bz * log ( min_xy )) !Set sig_y and sig_z = sig_0 + a*x&#94;b +x*delata_wind sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta_wind ) sig_z = sig_z_0 + az * exp ( bz * log ( x )) end subroutine uEMEP_set_dispersion_sigma_simple subroutine uEMEP_set_dispersion_sigma_PG ( invL_in , logz0 , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta , delta_wind , x , sig_z , sig_y , sig_z_0 , sig_y_0 ) implicit none real , intent ( in ) :: invL_in , logz0 , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta ( 2 ), delta_wind , x real , intent ( out ) :: sig_z , sig_y , sig_z_0 , sig_y_0 integer i_bot , i_top , i real weight real ay , by , az , bz real min_xy real ay_pg ( 6 ), by_pg ( 6 ), az_pg ( 6 ), bz_pg ( 6 ) real a_invL ( 6 ), b_invL ( 6 ), invL ( 6 ) !Use ASME parameters data ay_pg / 0.40 , 0.36 , 0.34 , 0.32 , 0.315 , 0.31 / data by_pg / 0.91 , 0.86 , 0.82 , 0.78 , 0.75 , 0.71 / data az_pg / 0.40 , 0.33 , 0.27 , 0.22 , 0.14 , 0.06 / data bz_pg / 0.91 , 0.86 , 0.82 , 0.78 , 0.75 , 0.71 / !Conversion of classes to L data a_invL /- 0.096 , - 0.037 , - 0.002 , 0.0 , 0.004 , 0.035 / data b_invL / 0.029 , 0.029 , 0.018 , 0.0 , - 0.018 , - 0.036 / invL = a_invL + b_invL * logz0 min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. !Find and interpolate the stability class based on input invL if ( invL_in . le . invL ( 1 )) then i_bot = 1 i_top = 1 weight = 0. elseif ( invL_in . gt . invL ( 6 )) then i_bot = 6 i_top = 6 weight = 1. else do i = 1 , 5 if ( invL_in . gt . invL ( i ). and . invL_in . le . invL ( i + 1 )) then i_bot = i i_top = i + 1 weight = ( invL_in - invL ( i )) / ( invL ( i + 1 ) - invL ( i )) exit endif enddo endif ay = ay_pg ( i_bot ) * ( 1. - weight ) + ay_pg ( i_top ) * weight by = by_pg ( i_bot ) * ( 1. - weight ) + by_pg ( i_top ) * weight az = az_pg ( i_bot ) * ( 1. - weight ) + az_pg ( i_top ) * weight bz = bz_pg ( i_bot ) * ( 1. - weight ) + bz_pg ( i_top ) * weight !Set sig_y_0 to be half of the average x,y grid size !Add this here ay*exp(by*log(min_xy)) to be the same as sig_z and the same as the  Kz calculation !Does not mean it is correct, just closer to the Kz which is perhaps not so correct sig_y_0 = sig_y_00 + min_xy * sigy_0_subgid_width_scale + ay * exp ( by * log ( min_xy )) !Set sig_z_0 to be the size of the plume after travelling half of the grid size sig_z_0 = sig_z_00 + az * exp ( bz * log ( min_xy )) !Set sig_y and sig_z = sig_0 + a*x&#94;b +x*delata_wind !Changed this because of error when x=0, check the other similar routines if ( x . le . 0 ) then sig_y = sig_y_0 sig_z = sig_z_0 else sig_y = sig_y_0 + ay * exp ( by * log ( x )) + x * abs ( delta_wind ) sig_z = sig_z_0 + az * exp ( bz * log ( x )) endif !write(*,'(i,6f)') i,weight,sig_y,sig_z,az,bz,x end subroutine uEMEP_set_dispersion_sigma_PG subroutine uEMEP_set_dispersion_sigma_Kz_emulator ( z_emis , invL , logz0 , z_pbl , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta , delta_wind , x , sig_z , sig_y , sig_z_0 , sig_y_0 ) implicit none real , intent ( in ) :: z_emis , invL , logz0 , z_pbl , sig_z_00 , sig_y_00 , sigy_0_subgid_width_scale , subgrid_delta ( 2 ), delta_wind , x real , intent ( out ) :: sig_z , sig_y , sig_z_0 , sig_y_0 real invL_in , zz_pbl , z0 real ay , by , az , bz real min_xy real z0_ref , zz_pbl_ref , zz_pbl_L , logz real x_val !invL_in=1./L min_xy = ( subgrid_delta ( 1 ) + subgrid_delta ( 2 )) / 4. x_val = max ( x , min_xy ) !Remove the stable cases as these are not normally done in the full K_z formulation !invL_in=min(invL_in,1./100.) invL_in = min ( invL , 0. ) !invL_in=0. zz_pbl = min (. 95 , z_emis / z_pbl ) !Cannot be greater than 0.95 as it is outside the emulator region zz_pbl_L = z_pbl * invL_in ; logz = log ( z_emis ) z0 = exp ( logz0 ) !Original !az=0.15+0.52*(z0-0.02)-0.15*(1.-EXP(-zz_pbl/0.03))+0.16*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/5.)) !bz=0.77-0.15*(1.-EXP(-z0/0.3))+0.2*(1.-EXP(-zz_pbl/0.03))-0.4*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/8.)) !Alternative form z0_ref = 0.1 zz_pbl_ref = 0.001 !az=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))+0.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !bz=0.76-0.17*(1.-exp(-(z0-z0_ref)*.3))+0.2*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))-0.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !ay=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl)*10.))+.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !by=0.76-0.17*(1.-exp(-(z0-z0_ref)*3))+0.70*(1.-exp(-(zz_pbl)*1.))-.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) az = ( - tanh (( logz - 1.2 ) * 3. ) * 0.08 + 0.1 + ( 1 - exp ( - zz_pbl / 0.05 )) * 0.06 ) * ( 1 + ( z0 - z0_ref ) / ( z0 + 0.6 ) * 3. ) - . 02 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( zz_pbl_L ) * 1 0. )) bz = tanh (( logz - 1.2 ) * 3 ) * 0.14 + 0.88 - ( 1 - exp ( - zz_pbl / 0.05 )) * 0.11 - log ( z0 / z0_ref ) * 0.04 - . 20 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( invL_in ) * 1 0. )) if ( z_emis / z_pbl . gt . 1 ) then az = 0.001 bz = 1.0 endif !Limit to the values explored by the emulator, just in case az = min ( max ( az , 0.001 ), 0.7 ) bz = min ( max ( bz , 0.4 ), 1.2 ) !Calculate y values, taken as close to the maximum K height of z/z_pbl=0.25 zz_pbl = 0.25 zz_pbl = ( z_pbl * 0.25 + z_emis ) / 2. / z_pbl logz = log ( zz_pbl * z_pbl ) !ay=0.15+0.52*(z0-0.02)-0.15*(1.-EXP(-zz_pbl/0.03))+0.16*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/5.)) !by=0.77-0.15*(1.-EXP(-z0/0.3))+0.2*(1.-EXP(-zz_pbl/0.03))-0.4*SIGN(1.0,invL_in)*(1.-EXP(-ABS(invL_in)/zz_pbl/8.)) !az=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))+0.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !bz=0.76-0.17*(1.-exp(-(z0-z0_ref)*.3))+0.2*(1.-exp(-(zz_pbl-zz_pbl_ref)*30.))-0.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !ay=0.15+.70*(z0-z0_ref)-0.1*(1.-exp(-(zz_pbl)*10.))+.01*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) !by=0.76-0.17*(1.-exp(-(z0-z0_ref)*3))+0.70*(1.-exp(-(zz_pbl)*1.))-.4*sign(1.,invL_in)*(1.-exp(-abs(invL_in)*10.)) ay = ( - tanh (( logz - 1.2 ) * 3. ) * 0.08 + 0.1 + ( 1 - exp ( - zz_pbl / 0.05 )) * 0.06 ) * ( 1 + ( z0 - z0_ref ) / ( z0 + 0.6 ) * 3. ) - . 02 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( zz_pbl_L ) * 1 0. )) by = tanh (( logz - 1.2 ) * 3 ) * 0.14 + 0.88 - ( 1 - exp ( - zz_pbl / 0.05 )) * 0.11 - log ( z0 / z0_ref ) * 0.04 - . 20 * sign ( 1. , invL_in ) * ( 1. - exp ( - abs ( invL_in ) * 1 0. )) if ( z_emis / z_pbl . ge . 1. ) then ay = 0.001 by = 1.0 endif ay = min ( max ( ay , 0.001 ), 0.7 ) by = min ( max ( by , 0.4 ), 1.2 ) !Set sig_y_0 to be half of the average x,y grid size !Mulitiply by the scale sig_y_0 = sig_y_00 + min_xy * sigy_0_subgid_width_scale !Set sig_z_0 to be the size of the plume after travelling half of the grid size !sig_z_0=sig_z_00+az*exp(bz*log(min_xy)) !Set sig_y and sig_z = sig_0 + a*x&#94;b +x*delata_wind sig_y = sig_y_0 + ay * exp ( by * log ( x + min_xy )) + ( x + min_xy ) * abs ( delta_wind ) !sig_z=sig_z_0+az*exp(bz*log(x)) !if (x.lt.10.) write(*,*) x,sig_z_00,sig_z sig_z_0 = sig_z_00 + az * exp ( bz * log ( min_xy )) sig_z = sig_z_00 + az * exp ( bz * log ( x + min_xy )) !if (x.lt.10.) write(*,*) x+min_xy,sig_z_00,sig_z !if (x.lt.10.) write(*,*) !if (zz_pbl.le.0.or.sig_z.le.0.or.sig_y.le.0) then !    write(*,'(7f)') az,bz,ay,by,sig_z,sig_y,x !    stop !endif end subroutine uEMEP_set_dispersion_sigma_Kz_emulator end module set_dispersion_parameters","tags":"","loc":"sourcefile/uemep_set_dispersion_params.f90.html"},{"title":"lambert_projection.f90 – uEMEP","text":"Source Code module mod_lambert_projection ! Routines for calling the various possible projections for the uEMEP sub-grid to lat lon use uemep_constants , only : pi use uEMEP_definitions use utility_functions , only : ltm2ll , utm2ll , ll2utm , ll2ltm use mod_rdm2ll , only : RDM2LL implicit none private public :: lb2lambert2_uEMEP , LL2PS_spherical , PROJ2LL , LL2LAEA , lambert2lb2_uEMEP , & lb2lambert_uEMEP , LL2PROJ contains subroutine testlambert () real :: gl , gb , x , y , lon0 , lat0 , y0 , k , F , earth_radius , lat_stand1 , GRIDWIDTH_M real :: deg2rad GRIDWIDTH_M = 250 0.0 lon0 = 1 5.0 lat0 = 6 3.0 deg2rad = PI / 18 0.0 earth_radius = 637100 0.0 lat_stand1 = lat0 k = sin ( PI / 18 0.0 * lat0 ) F = earth_radius * cos ( PI / 18 0.0 * lat_stand1 ) * tan ( PI / 4 + PI / 36 0.0 * lat_stand1 ) ** k / k y0 = F * tan ( PI / 4 - PI / 36 0.0 * lat0 ) ** k gl = 1 5.0 gb = 6 3.0 call lb2lambert ( x , y , gl , gb , lon0 , y0 , k , F ) write ( * , * ) 'lon = ' , gl , 'lat =' , gb write ( * , * ) 'give lambert x = ' , x , 'y =' , y write ( * , * ) 'lambert i = ' , ( x ) / GRIDWIDTH_M , 'j =' , y / GRIDWIDTH_M write ( * , * ) x = - 89244 2.2 y = 122067 8.0 call lambert2lb ( x , y , gl , gb , lon0 , y0 , k , F ) write ( * , * ) 'Lambert x = ' , x , 'y =' , y write ( * , * ) 'gives lon = ' , gl , 'lat =' , gb call lb2lambert ( x , y , gl , gb , lon0 , y0 , k , F ) write ( * , * ) 'and back to Lambert x = ' , x , 'y =' , y end subroutine testlambert subroutine lambert2lb ( x , y , gl , gb , lon0 , y0 , k , F ) real , intent ( in ) :: x , y , lon0 , y0 , k , F real , intent ( out ) :: gl , gb real :: r , t r = sqrt ( x * x + ( y0 - y ) * ( y0 - y )) t = atan ( x / ( y0 - y )) gb = 2.0 * 18 0.0 / PI * atan (( F / r ) ** ( 1.0 / k )) - 9 0.0 gl = lon0 + 18 0.0 / PI * t / k end subroutine lambert2lb subroutine lb2lambert ( x , y , gl , gb , lon0 , y0 , k , F ) real , intent ( in ) :: gl , gb , lon0 , y0 , k , F real , intent ( out ) :: x , y real :: r , dr2 , dr dr = PI / 18 0.0 dr2 = PI / 36 0.0 r = F * tan ( PI / 4 - dr2 * gb ) ** k x = r * sin ( dr * k * ( gl - lon0 )) y = y0 - r * cos ( dr * k * ( gl - lon0 )) end subroutine lb2lambert subroutine lambert2lb_uEMEP ( x , y , gl , gb , lon0 , lat0 ) real , intent ( in ) :: x , y , lon0 , lat0 real , intent ( out ) :: gl , gb real :: r , t real :: earth_radius , k , F , y0 earth_radius = 637100 0.0 k = sin ( PI / 18 0.0 * lat0 ) F = earth_radius * cos ( PI / 18 0.0 * lat0 ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat0 ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = sqrt ( x * x + ( y0 - y ) * ( y0 - y )) t = atan ( x / ( y0 - y )) gb = 2.0 * 18 0.0 / PI * atan (( F / r ) ** ( 1.0 / k )) - 9 0.0 gl = lon0 + 18 0.0 / PI * t / k end subroutine lambert2lb_uEMEP subroutine lambert2lb2_uEMEP ( x , y , gl , gb , projection_attr ) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: x , y real , intent ( out ) :: gl , gb real :: r , t real :: earth_radius , k , F , y0 real :: deg2rad , rad2deg , k_lambert , lat0_lambert real :: lat0 real :: lat_stand1_lambert , lat_stand2_lambert , lon0 , lat0_in lat_stand1_lambert = projection_attr ( 1 ) lat_stand2_lambert = projection_attr ( 2 ) lon0 = projection_attr ( 3 ) lat0_in = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI if ( lat_stand1_lambert . eq . lat_stand2_lambert ) then k_lambert = sin ( PI / 18 0.0 * lat0_in ) else k_lambert = log ( cos ( deg2rad * lat_stand1_lambert ) / cos ( deg2rad * lat_stand2_lambert )) / & ( log ( tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand2_lambert ) / tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand1_lambert ))) end if lat0_lambert = rad2deg * asin ( k_lambert ) lat0 = lat0_in k = k_lambert F = earth_radius * cos ( PI / 18 0.0 * lat_stand1_lambert ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat_stand1_lambert ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = sqrt ( x * x + ( y0 - y ) * ( y0 - y )) t = atan ( x / ( y0 - y )) gb = 2 * 18 0.0 / PI * atan (( F / r ) ** ( 1.0 / k )) - 9 0.0 gl = lon0 + 18 0.0 / PI * t / k end subroutine lambert2lb2_uEMEP subroutine lb2lambert_uEMEP ( x , y , gl , gb , lon0 , lat0 ) real , intent ( in ) :: gl , gb , lon0 , lat0 real , intent ( out ) :: x , y real :: r real :: earth_radius , k , F , y0 real :: rad2deg earth_radius = 637100 0.0 rad2deg = PI / 18 0.0 k = sin ( PI / 18 0.0 * lat0 ) F = earth_radius * cos ( PI / 18 0.0 * lat0 ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat0 ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = F * tan ( PI / 4.0 - PI / 36 0.0 * gb ) ** k x = r * sin ( PI / 18 0.0 * k * ( gl - lon0 )) y = y0 - r * cos ( PI / 18 0.0 * k * ( gl - lon0 )) end subroutine lb2lambert_uEMEP subroutine lb2lambert2_uEMEP ( x , y , gl , gb , projection_attr ) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: gl , gb real , intent ( out ) :: x , y real :: r real :: earth_radius , k , F , y0 real :: deg2rad , rad2deg , k_lambert , lat0_lambert real :: lat0 real :: lat_stand1_lambert , lat_stand2_lambert , lon0 , lat0_in lat_stand1_lambert = projection_attr ( 1 ) lat_stand2_lambert = projection_attr ( 2 ) lon0 = projection_attr ( 3 ) lat0_in = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI if ( lat_stand1_lambert . eq . lat_stand2_lambert ) then k_lambert = sin ( PI / 18 0.0 * lat0_in ) else k_lambert = log ( cos ( deg2rad * lat_stand1_lambert ) / cos ( deg2rad * lat_stand2_lambert )) / & ( log ( tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand2_lambert ) / tan ( 0.25 * PI + 0.5 * deg2rad * lat_stand1_lambert ))) end if lat0_lambert = rad2deg * asin ( k_lambert ) lat0 = lat0_in k = k_lambert F = earth_radius * cos ( PI / 18 0.0 * lat_stand1_lambert ) * ( tan ( PI / 4.0 + PI / 36 0.0 * lat_stand1_lambert ) ** k ) / k y0 = F * tan ( PI / 4.0 - PI / 36 0.0 * lat0 ) ** k r = F * tan ( PI / 4.0 - PI / 36 0.0 * gb ) ** k x = r * sin ( PI / 18 0.0 * k * ( gl - lon0 )) y = y0 - r * cos ( PI / 18 0.0 * k * ( gl - lon0 )) end subroutine lb2lambert2_uEMEP subroutine LL2LAEA_spherical ( x , y , lon_in , lat_in , projection_attr ) ! https://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: x , y ! Local variables real :: r real :: earth_radius real :: deg2rad , rad2deg , k_lambert real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: lon , lat lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad lon = lon_in * deg2rad lat = lat_in * deg2rad k_lambert = sqrt ( 2.0 / ( 1.0 + sin ( lat0 ) * sin ( lat ) + cos ( lat0 ) * cos ( lat ) * cos ( lon - lon0 ))) x = false_easting + r * k_lambert * cos ( lat ) * sin ( lon - lon0 ) y = false_northing + r * k_lambert * ( cos ( lat0 ) * sin ( lat ) - sin ( lat0 ) * cos ( lat ) * cos ( lon - lon0 )) end subroutine LL2LAEA_spherical subroutine LAEA2LL_spherical ( x , y , lon , lat , projection_attr ) ! https://mathworld.wolfram.com/LambertAzimuthalEqual-AreaProjection.html ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( out ) :: lon , lat real , intent ( in ) :: x , y ! Local variables real :: r , rho , c real :: earth_radius real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad rho = sqrt (( x - false_easting ) * ( x - false_easting ) + ( y - false_northing ) * ( y - false_northing )) c = 2.0 * asin ( rho * 0.5 / r ) lat = asin ( cos ( c ) * sin ( lat0 ) + ( y - false_northing ) / rho * sin ( c ) * cos ( lat0 )) lon = lon0 + atan (( x - false_easting ) * sin ( c ) / ( rho * cos ( lat0 ) * cos ( c ) - ( y - false_northing ) * sin ( lat0 ) * sin ( c ))) lat = lat * rad2deg lon = lon * rad2deg end subroutine LAEA2LL_spherical subroutine LL2LAEA ( x , y , lon_in , lat_in , projection_attr ) ! https://epsg.io/3035 ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: x , y ! Local variables real :: semi_major_axis real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: lon , lat real :: inv_f , f , a , e , q_p , q_0 , q , beta , beta_0 , R_q , D , B lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) semi_major_axis = projection_attr ( 5 ) inv_f = projection_attr ( 6 ) !flattening deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI a = semi_major_axis f = 1.0 / inv_f e = sqrt ( 2.0 * f - f * f ) lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad lon = lon_in * deg2rad lat = lat_in * deg2rad q_p = ( 1.0 - e * e ) * ( 1.0 / ( 1.0 - e * e ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e ) / ( 1.0 + e ))) q_0 = ( 1.0 - e * e ) * ( sin ( lat0 ) / ( 1.0 - e * e * sin ( lat0 ) ** 2 ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e * sin ( lat0 )) / ( 1.0 + e * sin ( lat0 )))) q = ( 1.0 - e * e ) * ( sin ( lat ) / ( 1.0 - e * e * sin ( lat ) ** 2 ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e * sin ( lat )) / ( 1.0 + e * sin ( lat )))) beta_0 = asin ( q_0 / q_p ) beta = asin ( q / q_p ) R_q = a * sqrt ( q_p / 2.0 ) D = a * ( cos ( lat0 ) / sqrt ( 1.0 - e * e * sin ( lat0 ) ** 2 ) / ( R_q * cos ( beta_0 ))) B = R_q * sqrt ( 2.0 / ( 1.0 + sin ( beta_0 ) * sin ( beta ) + cos ( beta_0 ) * cos ( beta ) * cos ( lon - lon0 ))) x = false_easting + B * D * cos ( beta ) * sin ( lon - lon0 ) y = false_northing + B / D * ( cos ( beta_0 ) * sin ( beta ) - sin ( beta_0 ) * cos ( beta ) * cos ( lon - lon0 )) end subroutine LL2LAEA subroutine LAEA2LL ( x , y , lon , lat , projection_attr ) ! www.epsg.org ! grid_mapping_name = lambert_azimuthal_equal_area ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( out ) :: lon , lat real , intent ( in ) :: x , y real :: rho real :: semi_major_axis real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: inv_f , f , a , e , q_p , q_0 , beta_0 , R_q , D real :: C , beta_d lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) semi_major_axis = projection_attr ( 5 ) inv_f = projection_attr ( 6 ) ! flattening deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI a = semi_major_axis f = 1.0 / inv_f e = sqrt ( 2.0 * f - f * f ) lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad q_p = ( 1.0 - e * e ) * ( 1.0 / ( 1.0 - e * e ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e ) / ( 1.0 + e ))) q_0 = ( 1.0 - e * e ) * ( sin ( lat0 ) / ( 1.0 - e * e * sin ( lat0 ) ** 2 ) - 1.0 / ( 2.0 * e ) * log (( 1.0 - e * sin ( lat0 )) / ( 1.0 + e * sin ( lat0 )))) beta_0 = asin ( q_0 / q_p ) R_q = a * sqrt ( q_p / 2.0 ) D = a * ( cos ( lat0 ) / sqrt ( 1.0 - e * e * sin ( lat0 ) ** 2 ) / ( R_q * cos ( beta_0 ))) rho = sqrt (( x - false_easting ) * ( x - false_easting ) / D / D + D * D * ( y - false_northing ) * ( y - false_northing )) C = 2.0 * asin ( rho / 2.0 / R_q ) beta_d = asin ( cos ( C ) * sin ( beta_0 ) + D * ( y - false_northing ) * sin ( C ) * cos ( beta_0 ) / rho ) lon = lon0 + atan2 (( x - false_easting ) * sin ( C ), & ( D * rho * cos ( beta_0 ) * cos ( C ) - D * D * ( y - false_northing ) * sin ( beta_0 ) * sin ( C ))) lat = beta_d + e ** 2 * ( 1.0 / 3.0 + 3 1.0 / 18 0.0 * e ** 2.0 + 51 7.0 / 504 0.0 * e ** 4 ) * sin ( 2.0 * beta_d ) & + e ** 4.0 * ( 2 3.0 / 36 0.0 + 25 1.0 / 378 0.0 * e ** 2 ) * sin ( 4.0 * beta_d ) + ( 76 1.0 / 4536 0.0 * e ** 6 ) * sin ( 6.0 * beta_d ) lat = lat * rad2deg lon = lon * rad2deg end subroutine LAEA2LL subroutine PROJ2LL ( x_in , y_in , lon_out , lat_out , projection_attributes_in , projection_type_in ) ! Definitions only needed for the identification indexes double precision , intent ( in ) :: projection_attributes_in ( 10 ) real , intent ( in ) :: x_in , y_in integer , intent ( in ) :: projection_type_in real , intent ( out ) :: lon_out , lat_out integer :: utm_zone_in real :: ltm_lon0_in if ( projection_type_in . eq . RDM_projection_index ) then call RDM2LL ( y_in , x_in , lat_out , lon_out ) else if ( projection_type_in . eq . UTM_projection_index ) then utm_zone_in = floor ( projection_attributes_in ( 1 ) + 0.5 ) call utm2ll ( 1 , utm_zone_in , y_in , x_in , lat_out , lon_out ) else if ( projection_type_in . eq . LTM_projection_index ) then utm_zone_in = floor ( projection_attributes_in ( 1 ) + 0.5 ) ltm_lon0_in = projection_attributes_in ( 2 ) call ltm2ll ( 1 , utm_zone_in , ltm_lon0_in , y_in , x_in , lat_out , lon_out ) else if ( projection_type_in . eq . LAEA_projection_index ) then call LAEA2LL ( x_in , y_in , lon_out , lat_out , projection_attributes_in ) else if ( projection_type_in . eq . LCC_projection_index ) then call lambert2lb2_uEMEP ( x_in , y_in , lon_out , lat_out , projection_attributes_in ) else if ( projection_type_in . eq . PS_projection_index ) then call PS2LL_spherical ( x_in , y_in , lon_out , lat_out , projection_attributes_in ) else if ( projection_type_in . eq . LL_projection_index ) then lon_out = x_in lat_out = y_in else write ( unit_logfile , '(A,I0)' ) 'ERROR: This projection type index is not implemented:' , projection_type_in stop end if end subroutine PROJ2LL subroutine LL2PROJ ( lon_in , lat_in , x_out , y_out , projection_attributes_out , projection_type_out ) ! Definitions only needed for the identification indexes double precision , intent ( in ) :: projection_attributes_out ( 10 ) real , intent ( out ) :: x_out , y_out integer , intent ( in ) :: projection_type_out real , intent ( in ) :: lon_in , lat_in integer :: utm_zone_out real :: ltm_lon0_out if ( projection_type_out . eq . RDM_projection_index ) then write ( unit_logfile , '(A)' ) ' ERROR: Conversion from lon-lat to RDM projection is not implemented\"' stop else if ( projection_type_out . eq . UTM_projection_index ) then utm_zone_out = floor ( projection_attributes_out ( 1 ) + 0.5 ) call ll2utm ( 1 , utm_zone_out , lat_in , lon_in , y_out , x_out ) else if ( projection_type_out . eq . LTM_projection_index ) then utm_zone_out = floor ( projection_attributes_out ( 1 ) + 0.5 ) ltm_lon0_out = projection_attributes_out ( 2 ) call ll2ltm ( 1 , ltm_lon0_out , lat_in , lon_in , y_out , x_out ) !????????? else if ( projection_type_out . eq . LAEA_projection_index ) then call LL2LAEA ( x_out , y_out , lon_in , lat_in , projection_attributes_out ) else if ( projection_type_out . eq . LCC_projection_index ) then call lb2lambert2_uEMEP ( x_out , y_out , lon_in , lat_in , projection_attributes_out ) else if ( projection_type_out . eq . PS_projection_index ) then call LL2PS_spherical ( x_out , y_out , lon_in , lat_in , projection_attributes_out ) else if ( projection_type_out . eq . LL_projection_index ) then x_out = lon_in y_out = lat_in else write ( unit_logfile , '(A,I0)' ) 'ERROR: This projection type index is not implemented:' , projection_type_out stop end if end subroutine LL2PROJ subroutine LL2PS_spherical ( x , y , lon_in , lat_in , projection_attr ) ! https://mathworld.wolfram.com/StereographicProjection.html ! grid_mapping_name = Polar_Stereographic ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0)lat_stand1_lambert=projection_attributes(1) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( in ) :: lon_in , lat_in real , intent ( out ) :: x , y real :: r real :: earth_radius real deg2rad , rad2deg , k_ps real lat0 , lat0_in , lon0 , lon0_in real false_easting , false_northing real scaling real lon , lat lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) scaling = projection_attr ( 6 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad lon = lon_in * deg2rad lat = lat_in * deg2rad k_ps = 2.0 * r * scaling / ( 1.0 + sin ( lat0 ) * sin ( lat ) + cos ( lat0 ) * cos ( lat ) * cos ( lon - lon0 )) x = false_easting + k_ps * cos ( lat ) * sin ( lon - lon0 ) y = false_northing + k_ps * ( cos ( lat0 ) * sin ( lat ) - sin ( lat0 ) * cos ( lat ) * cos ( lon - lon0 )) end subroutine LL2PS_spherical subroutine PS2LL_spherical ( x , y , lon , lat , projection_attr ) ! https://mathworld.wolfram.com/StereographicProjection.html ! grid_mapping_name = Polar_Stereographic ! Map parameters: ! longitude_of_projection_origin ! latitude_of_projection_origin ! false_easting - This parameter is optional (default is 0) ! false_northing - This parameter is optional (default is 0) ! NOTE scale_factor_at_projection_origin =0.5(1+sin(Standard Parallel)) double precision , intent ( in ) :: projection_attr ( 10 ) real , intent ( out ) :: lon , lat real , intent ( in ) :: x , y real :: r , rho , c real :: earth_radius real :: deg2rad , rad2deg real :: lat0 , lat0_in , lon0 , lon0_in real :: false_easting , false_northing real :: scaling lon0_in = projection_attr ( 1 ) lat0_in = projection_attr ( 2 ) false_easting = projection_attr ( 3 ) false_northing = projection_attr ( 4 ) earth_radius = projection_attr ( 5 ) scaling = projection_attr ( 6 ) deg2rad = PI / 18 0.0 rad2deg = 18 0.0 / PI r = earth_radius lat0 = lat0_in * deg2rad lon0 = lon0_in * deg2rad rho = sqrt (( x - false_easting ) * ( x - false_easting ) + ( y - false_northing ) * ( y - false_northing )) c = 2.0 * atan ( rho * 0.5 / r / scaling ) lat = asin ( cos ( c ) * sin ( lat0 ) + ( y - false_northing ) / rho * sin ( c ) * cos ( lat0 )) lon = lon0 + atan (( x - false_easting ) * sin ( c ) / ( rho * cos ( lat0 ) * cos ( c ) - ( y - false_northing ) * sin ( lat0 ) * sin ( c ))) lat = lat * rad2deg lon = lon * rad2deg end subroutine PS2LL_spherical end module mod_lambert_projection","tags":"","loc":"sourcefile/lambert_projection.f90.html"},{"title":"Model Documentation – uEMEP","text":"","tags":"","loc":"page/index.html"}]}